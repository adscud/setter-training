var e9=Object.defineProperty;var t9=(t,e,n)=>e in t?e9(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var bt=(t,e,n)=>(t9(t,typeof e!="symbol"?e+"":e,n),n);function n9(t,e){for(var n=0;n<e.length;n++){const s=e[n];if(typeof s!="string"&&!Array.isArray(s)){for(const r in s)if(r!=="default"&&!(r in t)){const o=Object.getOwnPropertyDescriptor(s,r);o&&Object.defineProperty(t,r,o.get?o:{enumerable:!0,get:()=>s[r]})}}}return Object.freeze(Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const o of r)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function n(r){const o={};return r.integrity&&(o.integrity=r.integrity),r.referrerPolicy&&(o.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?o.credentials="include":r.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(r){if(r.ep)return;r.ep=!0;const o=n(r);fetch(r.href,o)}})();var Rr=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function RO(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function s9(t){if(t.__esModule)return t;var e=t.default;if(typeof e=="function"){var n=function s(){return this instanceof s?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};n.prototype=e.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(t).forEach(function(s){var r=Object.getOwnPropertyDescriptor(t,s);Object.defineProperty(n,s,r.get?r:{enumerable:!0,get:function(){return t[s]}})}),n}var AO={exports:{}},bw={},_O={exports:{}},Ut={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hy=Symbol.for("react.element"),r9=Symbol.for("react.portal"),o9=Symbol.for("react.fragment"),i9=Symbol.for("react.strict_mode"),a9=Symbol.for("react.profiler"),u9=Symbol.for("react.provider"),l9=Symbol.for("react.context"),c9=Symbol.for("react.forward_ref"),h9=Symbol.for("react.suspense"),d9=Symbol.for("react.memo"),p9=Symbol.for("react.lazy"),C_=Symbol.iterator;function f9(t){return t===null||typeof t!="object"?null:(t=C_&&t[C_]||t["@@iterator"],typeof t=="function"?t:null)}var DO={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},PO=Object.assign,FO={};function Cp(t,e,n){this.props=t,this.context=e,this.refs=FO,this.updater=n||DO}Cp.prototype.isReactComponent={};Cp.prototype.setState=function(t,e){if(typeof t!="object"&&typeof t!="function"&&t!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,t,e,"setState")};Cp.prototype.forceUpdate=function(t){this.updater.enqueueForceUpdate(this,t,"forceUpdate")};function OO(){}OO.prototype=Cp.prototype;function nN(t,e,n){this.props=t,this.context=e,this.refs=FO,this.updater=n||DO}var sN=nN.prototype=new OO;sN.constructor=nN;PO(sN,Cp.prototype);sN.isPureReactComponent=!0;var k_=Array.isArray,LO=Object.prototype.hasOwnProperty,rN={current:null},MO={key:!0,ref:!0,__self:!0,__source:!0};function zO(t,e,n){var s,r={},o=null,i=null;if(e!=null)for(s in e.ref!==void 0&&(i=e.ref),e.key!==void 0&&(o=""+e.key),e)LO.call(e,s)&&!MO.hasOwnProperty(s)&&(r[s]=e[s]);var a=arguments.length-2;if(a===1)r.children=n;else if(1<a){for(var u=Array(a),l=0;l<a;l++)u[l]=arguments[l+2];r.children=u}if(t&&t.defaultProps)for(s in a=t.defaultProps,a)r[s]===void 0&&(r[s]=a[s]);return{$$typeof:hy,type:t,key:o,ref:i,props:r,_owner:rN.current}}function m9(t,e){return{$$typeof:hy,type:t.type,key:e,ref:t.ref,props:t.props,_owner:t._owner}}function oN(t){return typeof t=="object"&&t!==null&&t.$$typeof===hy}function g9(t){var e={"=":"=0",":":"=2"};return"$"+t.replace(/[=:]/g,function(n){return e[n]})}var I_=/\/+/g;function v2(t,e){return typeof t=="object"&&t!==null&&t.key!=null?g9(""+t.key):e.toString(36)}function M1(t,e,n,s,r){var o=typeof t;(o==="undefined"||o==="boolean")&&(t=null);var i=!1;if(t===null)i=!0;else switch(o){case"string":case"number":i=!0;break;case"object":switch(t.$$typeof){case hy:case r9:i=!0}}if(i)return i=t,r=r(i),t=s===""?"."+v2(i,0):s,k_(r)?(n="",t!=null&&(n=t.replace(I_,"$&/")+"/"),M1(r,e,n,"",function(l){return l})):r!=null&&(oN(r)&&(r=m9(r,n+(!r.key||i&&i.key===r.key?"":(""+r.key).replace(I_,"$&/")+"/")+t)),e.push(r)),1;if(i=0,s=s===""?".":s+":",k_(t))for(var a=0;a<t.length;a++){o=t[a];var u=s+v2(o,a);i+=M1(o,e,n,u,r)}else if(u=f9(t),typeof u=="function")for(t=u.call(t),a=0;!(o=t.next()).done;)o=o.value,u=s+v2(o,a++),i+=M1(o,e,n,u,r);else if(o==="object")throw e=String(t),Error("Objects are not valid as a React child (found: "+(e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e)+"). If you meant to render a collection of children, use an array instead.");return i}function e1(t,e,n){if(t==null)return t;var s=[],r=0;return M1(t,s,"","",function(o){return e.call(n,o,r++)}),s}function y9(t){if(t._status===-1){var e=t._result;e=e(),e.then(function(n){(t._status===0||t._status===-1)&&(t._status=1,t._result=n)},function(n){(t._status===0||t._status===-1)&&(t._status=2,t._result=n)}),t._status===-1&&(t._status=0,t._result=e)}if(t._status===1)return t._result.default;throw t._result}var Mr={current:null},z1={transition:null},x9={ReactCurrentDispatcher:Mr,ReactCurrentBatchConfig:z1,ReactCurrentOwner:rN};Ut.Children={map:e1,forEach:function(t,e,n){e1(t,function(){e.apply(this,arguments)},n)},count:function(t){var e=0;return e1(t,function(){e++}),e},toArray:function(t){return e1(t,function(e){return e})||[]},only:function(t){if(!oN(t))throw Error("React.Children.only expected to receive a single React element child.");return t}};Ut.Component=Cp;Ut.Fragment=o9;Ut.Profiler=a9;Ut.PureComponent=nN;Ut.StrictMode=i9;Ut.Suspense=h9;Ut.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=x9;Ut.cloneElement=function(t,e,n){if(t==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+t+".");var s=PO({},t.props),r=t.key,o=t.ref,i=t._owner;if(e!=null){if(e.ref!==void 0&&(o=e.ref,i=rN.current),e.key!==void 0&&(r=""+e.key),t.type&&t.type.defaultProps)var a=t.type.defaultProps;for(u in e)LO.call(e,u)&&!MO.hasOwnProperty(u)&&(s[u]=e[u]===void 0&&a!==void 0?a[u]:e[u])}var u=arguments.length-2;if(u===1)s.children=n;else if(1<u){a=Array(u);for(var l=0;l<u;l++)a[l]=arguments[l+2];s.children=a}return{$$typeof:hy,type:t.type,key:r,ref:o,props:s,_owner:i}};Ut.createContext=function(t){return t={$$typeof:l9,_currentValue:t,_currentValue2:t,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},t.Provider={$$typeof:u9,_context:t},t.Consumer=t};Ut.createElement=zO;Ut.createFactory=function(t){var e=zO.bind(null,t);return e.type=t,e};Ut.createRef=function(){return{current:null}};Ut.forwardRef=function(t){return{$$typeof:c9,render:t}};Ut.isValidElement=oN;Ut.lazy=function(t){return{$$typeof:p9,_payload:{_status:-1,_result:t},_init:y9}};Ut.memo=function(t,e){return{$$typeof:d9,type:t,compare:e===void 0?null:e}};Ut.startTransition=function(t){var e=z1.transition;z1.transition={};try{t()}finally{z1.transition=e}};Ut.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")};Ut.useCallback=function(t,e){return Mr.current.useCallback(t,e)};Ut.useContext=function(t){return Mr.current.useContext(t)};Ut.useDebugValue=function(){};Ut.useDeferredValue=function(t){return Mr.current.useDeferredValue(t)};Ut.useEffect=function(t,e){return Mr.current.useEffect(t,e)};Ut.useId=function(){return Mr.current.useId()};Ut.useImperativeHandle=function(t,e,n){return Mr.current.useImperativeHandle(t,e,n)};Ut.useInsertionEffect=function(t,e){return Mr.current.useInsertionEffect(t,e)};Ut.useLayoutEffect=function(t,e){return Mr.current.useLayoutEffect(t,e)};Ut.useMemo=function(t,e){return Mr.current.useMemo(t,e)};Ut.useReducer=function(t,e,n){return Mr.current.useReducer(t,e,n)};Ut.useRef=function(t){return Mr.current.useRef(t)};Ut.useState=function(t){return Mr.current.useState(t)};Ut.useSyncExternalStore=function(t,e,n){return Mr.current.useSyncExternalStore(t,e,n)};Ut.useTransition=function(){return Mr.current.useTransition()};Ut.version="18.2.0";_O.exports=Ut;var fe=_O.exports;const iN=RO(fe);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var v9=fe,w9=Symbol.for("react.element"),b9=Symbol.for("react.fragment"),S9=Object.prototype.hasOwnProperty,C9=v9.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,k9={key:!0,ref:!0,__self:!0,__source:!0};function BO(t,e,n){var s,r={},o=null,i=null;n!==void 0&&(o=""+n),e.key!==void 0&&(o=""+e.key),e.ref!==void 0&&(i=e.ref);for(s in e)S9.call(e,s)&&!k9.hasOwnProperty(s)&&(r[s]=e[s]);if(t&&t.defaultProps)for(s in e=t.defaultProps,e)r[s]===void 0&&(r[s]=e[s]);return{$$typeof:w9,type:t,key:o,ref:i,props:r,_owner:C9.current}}bw.Fragment=b9;bw.jsx=BO;bw.jsxs=BO;AO.exports=bw;var Pt=AO.exports,Bk={},VO={exports:{}},Po={},WO={exports:{}},UO={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(t){function e(K,re){var pe=K.length;K.push(re);e:for(;0<pe;){var he=pe-1>>>1,xe=K[he];if(0<r(xe,re))K[he]=re,K[pe]=xe,pe=he;else break e}}function n(K){return K.length===0?null:K[0]}function s(K){if(K.length===0)return null;var re=K[0],pe=K.pop();if(pe!==re){K[0]=pe;e:for(var he=0,xe=K.length,Ce=xe>>>1;he<Ce;){var Ee=2*(he+1)-1,Ie=K[Ee],ke=Ee+1,Ae=K[ke];if(0>r(Ie,pe))ke<xe&&0>r(Ae,Ie)?(K[he]=Ae,K[ke]=pe,he=ke):(K[he]=Ie,K[Ee]=pe,he=Ee);else if(ke<xe&&0>r(Ae,pe))K[he]=Ae,K[ke]=pe,he=ke;else break e}}return re}function r(K,re){var pe=K.sortIndex-re.sortIndex;return pe!==0?pe:K.id-re.id}if(typeof performance=="object"&&typeof performance.now=="function"){var o=performance;t.unstable_now=function(){return o.now()}}else{var i=Date,a=i.now();t.unstable_now=function(){return i.now()-a}}var u=[],l=[],c=1,h=null,d=3,f=!1,m=!1,y=!1,x=typeof setTimeout=="function"?setTimeout:null,v=typeof clearTimeout=="function"?clearTimeout:null,w=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function S(K){for(var re=n(l);re!==null;){if(re.callback===null)s(l);else if(re.startTime<=K)s(l),re.sortIndex=re.expirationTime,e(u,re);else break;re=n(l)}}function k(K){if(y=!1,S(K),!m)if(n(u)!==null)m=!0,te(I);else{var re=n(l);re!==null&&le(k,re.startTime-K)}}function I(K,re){m=!1,y&&(y=!1,v(_),_=-1),f=!0;var pe=d;try{for(S(re),h=n(u);h!==null&&(!(h.expirationTime>re)||K&&!V());){var he=h.callback;if(typeof he=="function"){h.callback=null,d=h.priorityLevel;var xe=he(h.expirationTime<=re);re=t.unstable_now(),typeof xe=="function"?h.callback=xe:h===n(u)&&s(u),S(re)}else s(u);h=n(u)}if(h!==null)var Ce=!0;else{var Ee=n(l);Ee!==null&&le(k,Ee.startTime-re),Ce=!1}return Ce}finally{h=null,d=pe,f=!1}}var T=!1,R=null,_=-1,D=5,L=-1;function V(){return!(t.unstable_now()-L<D)}function U(){if(R!==null){var K=t.unstable_now();L=K;var re=!0;try{re=R(!0,K)}finally{re?j():(T=!1,R=null)}}else T=!1}var j;if(typeof w=="function")j=function(){w(U)};else if(typeof MessageChannel<"u"){var q=new MessageChannel,J=q.port2;q.port1.onmessage=U,j=function(){J.postMessage(null)}}else j=function(){x(U,0)};function te(K){R=K,T||(T=!0,j())}function le(K,re){_=x(function(){K(t.unstable_now())},re)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(K){K.callback=null},t.unstable_continueExecution=function(){m||f||(m=!0,te(I))},t.unstable_forceFrameRate=function(K){0>K||125<K?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):D=0<K?Math.floor(1e3/K):5},t.unstable_getCurrentPriorityLevel=function(){return d},t.unstable_getFirstCallbackNode=function(){return n(u)},t.unstable_next=function(K){switch(d){case 1:case 2:case 3:var re=3;break;default:re=d}var pe=d;d=re;try{return K()}finally{d=pe}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(K,re){switch(K){case 1:case 2:case 3:case 4:case 5:break;default:K=3}var pe=d;d=K;try{return re()}finally{d=pe}},t.unstable_scheduleCallback=function(K,re,pe){var he=t.unstable_now();switch(typeof pe=="object"&&pe!==null?(pe=pe.delay,pe=typeof pe=="number"&&0<pe?he+pe:he):pe=he,K){case 1:var xe=-1;break;case 2:xe=250;break;case 5:xe=1073741823;break;case 4:xe=1e4;break;default:xe=5e3}return xe=pe+xe,K={id:c++,callback:re,priorityLevel:K,startTime:pe,expirationTime:xe,sortIndex:-1},pe>he?(K.sortIndex=pe,e(l,K),n(u)===null&&K===n(l)&&(y?(v(_),_=-1):y=!0,le(k,pe-he))):(K.sortIndex=xe,e(u,K),m||f||(m=!0,te(I))),K},t.unstable_shouldYield=V,t.unstable_wrapCallback=function(K){var re=d;return function(){var pe=d;d=re;try{return K.apply(this,arguments)}finally{d=pe}}}})(UO);WO.exports=UO;var I9=WO.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var GO=fe,Ro=I9;function Re(t){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+t,n=1;n<arguments.length;n++)e+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+t+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var HO=new Set,Sg={};function dh(t,e){Yd(t,e),Yd(t+"Capture",e)}function Yd(t,e){for(Sg[t]=e,t=0;t<e.length;t++)HO.add(e[t])}var du=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Vk=Object.prototype.hasOwnProperty,$9=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,$_={},N_={};function N9(t){return Vk.call(N_,t)?!0:Vk.call($_,t)?!1:$9.test(t)?N_[t]=!0:($_[t]=!0,!1)}function T9(t,e,n,s){if(n!==null&&n.type===0)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return s?!1:n!==null?!n.acceptsBooleans:(t=t.toLowerCase().slice(0,5),t!=="data-"&&t!=="aria-");default:return!1}}function E9(t,e,n,s){if(e===null||typeof e>"u"||T9(t,e,n,s))return!0;if(s)return!1;if(n!==null)switch(n.type){case 3:return!e;case 4:return e===!1;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}function zr(t,e,n,s,r,o,i){this.acceptsBooleans=e===2||e===3||e===4,this.attributeName=s,this.attributeNamespace=r,this.mustUseProperty=n,this.propertyName=t,this.type=e,this.sanitizeURL=o,this.removeEmptyString=i}var Qs={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t){Qs[t]=new zr(t,0,!1,t,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(t){var e=t[0];Qs[e]=new zr(e,1,!1,t[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(t){Qs[t]=new zr(t,2,!1,t.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(t){Qs[t]=new zr(t,2,!1,t,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t){Qs[t]=new zr(t,3,!1,t.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(t){Qs[t]=new zr(t,3,!0,t,null,!1,!1)});["capture","download"].forEach(function(t){Qs[t]=new zr(t,4,!1,t,null,!1,!1)});["cols","rows","size","span"].forEach(function(t){Qs[t]=new zr(t,6,!1,t,null,!1,!1)});["rowSpan","start"].forEach(function(t){Qs[t]=new zr(t,5,!1,t.toLowerCase(),null,!1,!1)});var aN=/[\-:]([a-z])/g;function uN(t){return t[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t){var e=t.replace(aN,uN);Qs[e]=new zr(e,1,!1,t,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t){var e=t.replace(aN,uN);Qs[e]=new zr(e,1,!1,t,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(t){var e=t.replace(aN,uN);Qs[e]=new zr(e,1,!1,t,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(t){Qs[t]=new zr(t,1,!1,t.toLowerCase(),null,!1,!1)});Qs.xlinkHref=new zr("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(t){Qs[t]=new zr(t,1,!1,t.toLowerCase(),null,!0,!0)});function lN(t,e,n,s){var r=Qs.hasOwnProperty(e)?Qs[e]:null;(r!==null?r.type!==0:s||!(2<e.length)||e[0]!=="o"&&e[0]!=="O"||e[1]!=="n"&&e[1]!=="N")&&(E9(e,n,r,s)&&(n=null),s||r===null?N9(e)&&(n===null?t.removeAttribute(e):t.setAttribute(e,""+n)):r.mustUseProperty?t[r.propertyName]=n===null?r.type===3?!1:"":n:(e=r.attributeName,s=r.attributeNamespace,n===null?t.removeAttribute(e):(r=r.type,n=r===3||r===4&&n===!0?"":""+n,s?t.setAttributeNS(s,e,n):t.setAttribute(e,n))))}var bu=GO.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,t1=Symbol.for("react.element"),bd=Symbol.for("react.portal"),Sd=Symbol.for("react.fragment"),cN=Symbol.for("react.strict_mode"),Wk=Symbol.for("react.profiler"),jO=Symbol.for("react.provider"),KO=Symbol.for("react.context"),hN=Symbol.for("react.forward_ref"),Uk=Symbol.for("react.suspense"),Gk=Symbol.for("react.suspense_list"),dN=Symbol.for("react.memo"),Gu=Symbol.for("react.lazy"),XO=Symbol.for("react.offscreen"),T_=Symbol.iterator;function Am(t){return t===null||typeof t!="object"?null:(t=T_&&t[T_]||t["@@iterator"],typeof t=="function"?t:null)}var Kn=Object.assign,w2;function Xm(t){if(w2===void 0)try{throw Error()}catch(n){var e=n.stack.trim().match(/\n( *(at )?)/);w2=e&&e[1]||""}return`
`+w2+t}var b2=!1;function S2(t,e){if(!t||b2)return"";b2=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(e,[])}catch(l){var s=l}Reflect.construct(t,[],e)}else{try{e.call()}catch(l){s=l}t.call(e.prototype)}else{try{throw Error()}catch(l){s=l}t()}}catch(l){if(l&&s&&typeof l.stack=="string"){for(var r=l.stack.split(`
`),o=s.stack.split(`
`),i=r.length-1,a=o.length-1;1<=i&&0<=a&&r[i]!==o[a];)a--;for(;1<=i&&0<=a;i--,a--)if(r[i]!==o[a]){if(i!==1||a!==1)do if(i--,a--,0>a||r[i]!==o[a]){var u=`
`+r[i].replace(" at new "," at ");return t.displayName&&u.includes("<anonymous>")&&(u=u.replace("<anonymous>",t.displayName)),u}while(1<=i&&0<=a);break}}}finally{b2=!1,Error.prepareStackTrace=n}return(t=t?t.displayName||t.name:"")?Xm(t):""}function R9(t){switch(t.tag){case 5:return Xm(t.type);case 16:return Xm("Lazy");case 13:return Xm("Suspense");case 19:return Xm("SuspenseList");case 0:case 2:case 15:return t=S2(t.type,!1),t;case 11:return t=S2(t.type.render,!1),t;case 1:return t=S2(t.type,!0),t;default:return""}}function Hk(t){if(t==null)return null;if(typeof t=="function")return t.displayName||t.name||null;if(typeof t=="string")return t;switch(t){case Sd:return"Fragment";case bd:return"Portal";case Wk:return"Profiler";case cN:return"StrictMode";case Uk:return"Suspense";case Gk:return"SuspenseList"}if(typeof t=="object")switch(t.$$typeof){case KO:return(t.displayName||"Context")+".Consumer";case jO:return(t._context.displayName||"Context")+".Provider";case hN:var e=t.render;return t=t.displayName,t||(t=e.displayName||e.name||"",t=t!==""?"ForwardRef("+t+")":"ForwardRef"),t;case dN:return e=t.displayName||null,e!==null?e:Hk(t.type)||"Memo";case Gu:e=t._payload,t=t._init;try{return Hk(t(e))}catch{}}return null}function A9(t){var e=t.type;switch(t.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return t=e.render,t=t.displayName||t.name||"",e.displayName||(t!==""?"ForwardRef("+t+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Hk(e);case 8:return e===cN?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e}return null}function gl(t){switch(typeof t){case"boolean":case"number":case"string":case"undefined":return t;case"object":return t;default:return""}}function qO(t){var e=t.type;return(t=t.nodeName)&&t.toLowerCase()==="input"&&(e==="checkbox"||e==="radio")}function _9(t){var e=qO(t)?"checked":"value",n=Object.getOwnPropertyDescriptor(t.constructor.prototype,e),s=""+t[e];if(!t.hasOwnProperty(e)&&typeof n<"u"&&typeof n.get=="function"&&typeof n.set=="function"){var r=n.get,o=n.set;return Object.defineProperty(t,e,{configurable:!0,get:function(){return r.call(this)},set:function(i){s=""+i,o.call(this,i)}}),Object.defineProperty(t,e,{enumerable:n.enumerable}),{getValue:function(){return s},setValue:function(i){s=""+i},stopTracking:function(){t._valueTracker=null,delete t[e]}}}}function n1(t){t._valueTracker||(t._valueTracker=_9(t))}function YO(t){if(!t)return!1;var e=t._valueTracker;if(!e)return!0;var n=e.getValue(),s="";return t&&(s=qO(t)?t.checked?"true":"false":t.value),t=s,t!==n?(e.setValue(t),!0):!1}function ov(t){if(t=t||(typeof document<"u"?document:void 0),typeof t>"u")return null;try{return t.activeElement||t.body}catch{return t.body}}function jk(t,e){var n=e.checked;return Kn({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:n??t._wrapperState.initialChecked})}function E_(t,e){var n=e.defaultValue==null?"":e.defaultValue,s=e.checked!=null?e.checked:e.defaultChecked;n=gl(e.value!=null?e.value:n),t._wrapperState={initialChecked:s,initialValue:n,controlled:e.type==="checkbox"||e.type==="radio"?e.checked!=null:e.value!=null}}function QO(t,e){e=e.checked,e!=null&&lN(t,"checked",e,!1)}function Kk(t,e){QO(t,e);var n=gl(e.value),s=e.type;if(n!=null)s==="number"?(n===0&&t.value===""||t.value!=n)&&(t.value=""+n):t.value!==""+n&&(t.value=""+n);else if(s==="submit"||s==="reset"){t.removeAttribute("value");return}e.hasOwnProperty("value")?Xk(t,e.type,n):e.hasOwnProperty("defaultValue")&&Xk(t,e.type,gl(e.defaultValue)),e.checked==null&&e.defaultChecked!=null&&(t.defaultChecked=!!e.defaultChecked)}function R_(t,e,n){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var s=e.type;if(!(s!=="submit"&&s!=="reset"||e.value!==void 0&&e.value!==null))return;e=""+t._wrapperState.initialValue,n||e===t.value||(t.value=e),t.defaultValue=e}n=t.name,n!==""&&(t.name=""),t.defaultChecked=!!t._wrapperState.initialChecked,n!==""&&(t.name=n)}function Xk(t,e,n){(e!=="number"||ov(t.ownerDocument)!==t)&&(n==null?t.defaultValue=""+t._wrapperState.initialValue:t.defaultValue!==""+n&&(t.defaultValue=""+n))}var qm=Array.isArray;function Md(t,e,n,s){if(t=t.options,e){e={};for(var r=0;r<n.length;r++)e["$"+n[r]]=!0;for(n=0;n<t.length;n++)r=e.hasOwnProperty("$"+t[n].value),t[n].selected!==r&&(t[n].selected=r),r&&s&&(t[n].defaultSelected=!0)}else{for(n=""+gl(n),e=null,r=0;r<t.length;r++){if(t[r].value===n){t[r].selected=!0,s&&(t[r].defaultSelected=!0);return}e!==null||t[r].disabled||(e=t[r])}e!==null&&(e.selected=!0)}}function qk(t,e){if(e.dangerouslySetInnerHTML!=null)throw Error(Re(91));return Kn({},e,{value:void 0,defaultValue:void 0,children:""+t._wrapperState.initialValue})}function A_(t,e){var n=e.value;if(n==null){if(n=e.children,e=e.defaultValue,n!=null){if(e!=null)throw Error(Re(92));if(qm(n)){if(1<n.length)throw Error(Re(93));n=n[0]}e=n}e==null&&(e=""),n=e}t._wrapperState={initialValue:gl(n)}}function ZO(t,e){var n=gl(e.value),s=gl(e.defaultValue);n!=null&&(n=""+n,n!==t.value&&(t.value=n),e.defaultValue==null&&t.defaultValue!==n&&(t.defaultValue=n)),s!=null&&(t.defaultValue=""+s)}function __(t){var e=t.textContent;e===t._wrapperState.initialValue&&e!==""&&e!==null&&(t.value=e)}function JO(t){switch(t){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Yk(t,e){return t==null||t==="http://www.w3.org/1999/xhtml"?JO(e):t==="http://www.w3.org/2000/svg"&&e==="foreignObject"?"http://www.w3.org/1999/xhtml":t}var s1,eL=function(t){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(e,n,s,r){MSApp.execUnsafeLocalFunction(function(){return t(e,n,s,r)})}:t}(function(t,e){if(t.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in t)t.innerHTML=e;else{for(s1=s1||document.createElement("div"),s1.innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=s1.firstChild;t.firstChild;)t.removeChild(t.firstChild);for(;e.firstChild;)t.appendChild(e.firstChild)}});function Cg(t,e){if(e){var n=t.firstChild;if(n&&n===t.lastChild&&n.nodeType===3){n.nodeValue=e;return}}t.textContent=e}var ig={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},D9=["Webkit","ms","Moz","O"];Object.keys(ig).forEach(function(t){D9.forEach(function(e){e=e+t.charAt(0).toUpperCase()+t.substring(1),ig[e]=ig[t]})});function tL(t,e,n){return e==null||typeof e=="boolean"||e===""?"":n||typeof e!="number"||e===0||ig.hasOwnProperty(t)&&ig[t]?(""+e).trim():e+"px"}function nL(t,e){t=t.style;for(var n in e)if(e.hasOwnProperty(n)){var s=n.indexOf("--")===0,r=tL(n,e[n],s);n==="float"&&(n="cssFloat"),s?t.setProperty(n,r):t[n]=r}}var P9=Kn({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function Qk(t,e){if(e){if(P9[t]&&(e.children!=null||e.dangerouslySetInnerHTML!=null))throw Error(Re(137,t));if(e.dangerouslySetInnerHTML!=null){if(e.children!=null)throw Error(Re(60));if(typeof e.dangerouslySetInnerHTML!="object"||!("__html"in e.dangerouslySetInnerHTML))throw Error(Re(61))}if(e.style!=null&&typeof e.style!="object")throw Error(Re(62))}}function Zk(t,e){if(t.indexOf("-")===-1)return typeof e.is=="string";switch(t){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Jk=null;function pN(t){return t=t.target||t.srcElement||window,t.correspondingUseElement&&(t=t.correspondingUseElement),t.nodeType===3?t.parentNode:t}var eI=null,zd=null,Bd=null;function D_(t){if(t=fy(t)){if(typeof eI!="function")throw Error(Re(280));var e=t.stateNode;e&&(e=$w(e),eI(t.stateNode,t.type,e))}}function sL(t){zd?Bd?Bd.push(t):Bd=[t]:zd=t}function rL(){if(zd){var t=zd,e=Bd;if(Bd=zd=null,D_(t),e)for(t=0;t<e.length;t++)D_(e[t])}}function oL(t,e){return t(e)}function iL(){}var C2=!1;function aL(t,e,n){if(C2)return t(e,n);C2=!0;try{return oL(t,e,n)}finally{C2=!1,(zd!==null||Bd!==null)&&(iL(),rL())}}function kg(t,e){var n=t.stateNode;if(n===null)return null;var s=$w(n);if(s===null)return null;n=s[e];e:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(s=!s.disabled)||(t=t.type,s=!(t==="button"||t==="input"||t==="select"||t==="textarea")),t=!s;break e;default:t=!1}if(t)return null;if(n&&typeof n!="function")throw Error(Re(231,e,typeof n));return n}var tI=!1;if(du)try{var _m={};Object.defineProperty(_m,"passive",{get:function(){tI=!0}}),window.addEventListener("test",_m,_m),window.removeEventListener("test",_m,_m)}catch{tI=!1}function F9(t,e,n,s,r,o,i,a,u){var l=Array.prototype.slice.call(arguments,3);try{e.apply(n,l)}catch(c){this.onError(c)}}var ag=!1,iv=null,av=!1,nI=null,O9={onError:function(t){ag=!0,iv=t}};function L9(t,e,n,s,r,o,i,a,u){ag=!1,iv=null,F9.apply(O9,arguments)}function M9(t,e,n,s,r,o,i,a,u){if(L9.apply(this,arguments),ag){if(ag){var l=iv;ag=!1,iv=null}else throw Error(Re(198));av||(av=!0,nI=l)}}function ph(t){var e=t,n=t;if(t.alternate)for(;e.return;)e=e.return;else{t=e;do e=t,e.flags&4098&&(n=e.return),t=e.return;while(t)}return e.tag===3?n:null}function uL(t){if(t.tag===13){var e=t.memoizedState;if(e===null&&(t=t.alternate,t!==null&&(e=t.memoizedState)),e!==null)return e.dehydrated}return null}function P_(t){if(ph(t)!==t)throw Error(Re(188))}function z9(t){var e=t.alternate;if(!e){if(e=ph(t),e===null)throw Error(Re(188));return e!==t?null:t}for(var n=t,s=e;;){var r=n.return;if(r===null)break;var o=r.alternate;if(o===null){if(s=r.return,s!==null){n=s;continue}break}if(r.child===o.child){for(o=r.child;o;){if(o===n)return P_(r),t;if(o===s)return P_(r),e;o=o.sibling}throw Error(Re(188))}if(n.return!==s.return)n=r,s=o;else{for(var i=!1,a=r.child;a;){if(a===n){i=!0,n=r,s=o;break}if(a===s){i=!0,s=r,n=o;break}a=a.sibling}if(!i){for(a=o.child;a;){if(a===n){i=!0,n=o,s=r;break}if(a===s){i=!0,s=o,n=r;break}a=a.sibling}if(!i)throw Error(Re(189))}}if(n.alternate!==s)throw Error(Re(190))}if(n.tag!==3)throw Error(Re(188));return n.stateNode.current===n?t:e}function lL(t){return t=z9(t),t!==null?cL(t):null}function cL(t){if(t.tag===5||t.tag===6)return t;for(t=t.child;t!==null;){var e=cL(t);if(e!==null)return e;t=t.sibling}return null}var hL=Ro.unstable_scheduleCallback,F_=Ro.unstable_cancelCallback,B9=Ro.unstable_shouldYield,V9=Ro.unstable_requestPaint,as=Ro.unstable_now,W9=Ro.unstable_getCurrentPriorityLevel,fN=Ro.unstable_ImmediatePriority,dL=Ro.unstable_UserBlockingPriority,uv=Ro.unstable_NormalPriority,U9=Ro.unstable_LowPriority,pL=Ro.unstable_IdlePriority,Sw=null,ga=null;function G9(t){if(ga&&typeof ga.onCommitFiberRoot=="function")try{ga.onCommitFiberRoot(Sw,t,void 0,(t.current.flags&128)===128)}catch{}}var Oi=Math.clz32?Math.clz32:K9,H9=Math.log,j9=Math.LN2;function K9(t){return t>>>=0,t===0?32:31-(H9(t)/j9|0)|0}var r1=64,o1=4194304;function Ym(t){switch(t&-t){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return t&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return t}}function lv(t,e){var n=t.pendingLanes;if(n===0)return 0;var s=0,r=t.suspendedLanes,o=t.pingedLanes,i=n&268435455;if(i!==0){var a=i&~r;a!==0?s=Ym(a):(o&=i,o!==0&&(s=Ym(o)))}else i=n&~r,i!==0?s=Ym(i):o!==0&&(s=Ym(o));if(s===0)return 0;if(e!==0&&e!==s&&!(e&r)&&(r=s&-s,o=e&-e,r>=o||r===16&&(o&4194240)!==0))return e;if(s&4&&(s|=n&16),e=t.entangledLanes,e!==0)for(t=t.entanglements,e&=s;0<e;)n=31-Oi(e),r=1<<n,s|=t[n],e&=~r;return s}function X9(t,e){switch(t){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function q9(t,e){for(var n=t.suspendedLanes,s=t.pingedLanes,r=t.expirationTimes,o=t.pendingLanes;0<o;){var i=31-Oi(o),a=1<<i,u=r[i];u===-1?(!(a&n)||a&s)&&(r[i]=X9(a,e)):u<=e&&(t.expiredLanes|=a),o&=~a}}function sI(t){return t=t.pendingLanes&-1073741825,t!==0?t:t&1073741824?1073741824:0}function fL(){var t=r1;return r1<<=1,!(r1&4194240)&&(r1=64),t}function k2(t){for(var e=[],n=0;31>n;n++)e.push(t);return e}function dy(t,e,n){t.pendingLanes|=e,e!==536870912&&(t.suspendedLanes=0,t.pingedLanes=0),t=t.eventTimes,e=31-Oi(e),t[e]=n}function Y9(t,e){var n=t.pendingLanes&~e;t.pendingLanes=e,t.suspendedLanes=0,t.pingedLanes=0,t.expiredLanes&=e,t.mutableReadLanes&=e,t.entangledLanes&=e,e=t.entanglements;var s=t.eventTimes;for(t=t.expirationTimes;0<n;){var r=31-Oi(n),o=1<<r;e[r]=0,s[r]=-1,t[r]=-1,n&=~o}}function mN(t,e){var n=t.entangledLanes|=e;for(t=t.entanglements;n;){var s=31-Oi(n),r=1<<s;r&e|t[s]&e&&(t[s]|=e),n&=~r}}var un=0;function mL(t){return t&=-t,1<t?4<t?t&268435455?16:536870912:4:1}var gL,gN,yL,xL,vL,rI=!1,i1=[],nl=null,sl=null,rl=null,Ig=new Map,$g=new Map,Xu=[],Q9="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function O_(t,e){switch(t){case"focusin":case"focusout":nl=null;break;case"dragenter":case"dragleave":sl=null;break;case"mouseover":case"mouseout":rl=null;break;case"pointerover":case"pointerout":Ig.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":$g.delete(e.pointerId)}}function Dm(t,e,n,s,r,o){return t===null||t.nativeEvent!==o?(t={blockedOn:e,domEventName:n,eventSystemFlags:s,nativeEvent:o,targetContainers:[r]},e!==null&&(e=fy(e),e!==null&&gN(e)),t):(t.eventSystemFlags|=s,e=t.targetContainers,r!==null&&e.indexOf(r)===-1&&e.push(r),t)}function Z9(t,e,n,s,r){switch(e){case"focusin":return nl=Dm(nl,t,e,n,s,r),!0;case"dragenter":return sl=Dm(sl,t,e,n,s,r),!0;case"mouseover":return rl=Dm(rl,t,e,n,s,r),!0;case"pointerover":var o=r.pointerId;return Ig.set(o,Dm(Ig.get(o)||null,t,e,n,s,r)),!0;case"gotpointercapture":return o=r.pointerId,$g.set(o,Dm($g.get(o)||null,t,e,n,s,r)),!0}return!1}function wL(t){var e=Ec(t.target);if(e!==null){var n=ph(e);if(n!==null){if(e=n.tag,e===13){if(e=uL(n),e!==null){t.blockedOn=e,vL(t.priority,function(){yL(n)});return}}else if(e===3&&n.stateNode.current.memoizedState.isDehydrated){t.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}t.blockedOn=null}function B1(t){if(t.blockedOn!==null)return!1;for(var e=t.targetContainers;0<e.length;){var n=oI(t.domEventName,t.eventSystemFlags,e[0],t.nativeEvent);if(n===null){n=t.nativeEvent;var s=new n.constructor(n.type,n);Jk=s,n.target.dispatchEvent(s),Jk=null}else return e=fy(n),e!==null&&gN(e),t.blockedOn=n,!1;e.shift()}return!0}function L_(t,e,n){B1(t)&&n.delete(e)}function J9(){rI=!1,nl!==null&&B1(nl)&&(nl=null),sl!==null&&B1(sl)&&(sl=null),rl!==null&&B1(rl)&&(rl=null),Ig.forEach(L_),$g.forEach(L_)}function Pm(t,e){t.blockedOn===e&&(t.blockedOn=null,rI||(rI=!0,Ro.unstable_scheduleCallback(Ro.unstable_NormalPriority,J9)))}function Ng(t){function e(r){return Pm(r,t)}if(0<i1.length){Pm(i1[0],t);for(var n=1;n<i1.length;n++){var s=i1[n];s.blockedOn===t&&(s.blockedOn=null)}}for(nl!==null&&Pm(nl,t),sl!==null&&Pm(sl,t),rl!==null&&Pm(rl,t),Ig.forEach(e),$g.forEach(e),n=0;n<Xu.length;n++)s=Xu[n],s.blockedOn===t&&(s.blockedOn=null);for(;0<Xu.length&&(n=Xu[0],n.blockedOn===null);)wL(n),n.blockedOn===null&&Xu.shift()}var Vd=bu.ReactCurrentBatchConfig,cv=!0;function eY(t,e,n,s){var r=un,o=Vd.transition;Vd.transition=null;try{un=1,yN(t,e,n,s)}finally{un=r,Vd.transition=o}}function tY(t,e,n,s){var r=un,o=Vd.transition;Vd.transition=null;try{un=4,yN(t,e,n,s)}finally{un=r,Vd.transition=o}}function yN(t,e,n,s){if(cv){var r=oI(t,e,n,s);if(r===null)P2(t,e,s,hv,n),O_(t,s);else if(Z9(r,t,e,n,s))s.stopPropagation();else if(O_(t,s),e&4&&-1<Q9.indexOf(t)){for(;r!==null;){var o=fy(r);if(o!==null&&gL(o),o=oI(t,e,n,s),o===null&&P2(t,e,s,hv,n),o===r)break;r=o}r!==null&&s.stopPropagation()}else P2(t,e,s,null,n)}}var hv=null;function oI(t,e,n,s){if(hv=null,t=pN(s),t=Ec(t),t!==null)if(e=ph(t),e===null)t=null;else if(n=e.tag,n===13){if(t=uL(e),t!==null)return t;t=null}else if(n===3){if(e.stateNode.current.memoizedState.isDehydrated)return e.tag===3?e.stateNode.containerInfo:null;t=null}else e!==t&&(t=null);return hv=t,null}function bL(t){switch(t){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(W9()){case fN:return 1;case dL:return 4;case uv:case U9:return 16;case pL:return 536870912;default:return 16}default:return 16}}var Yu=null,xN=null,V1=null;function SL(){if(V1)return V1;var t,e=xN,n=e.length,s,r="value"in Yu?Yu.value:Yu.textContent,o=r.length;for(t=0;t<n&&e[t]===r[t];t++);var i=n-t;for(s=1;s<=i&&e[n-s]===r[o-s];s++);return V1=r.slice(t,1<s?1-s:void 0)}function W1(t){var e=t.keyCode;return"charCode"in t?(t=t.charCode,t===0&&e===13&&(t=13)):t=e,t===10&&(t=13),32<=t||t===13?t:0}function a1(){return!0}function M_(){return!1}function Fo(t){function e(n,s,r,o,i){this._reactName=n,this._targetInst=r,this.type=s,this.nativeEvent=o,this.target=i,this.currentTarget=null;for(var a in t)t.hasOwnProperty(a)&&(n=t[a],this[a]=n?n(o):o[a]);return this.isDefaultPrevented=(o.defaultPrevented!=null?o.defaultPrevented:o.returnValue===!1)?a1:M_,this.isPropagationStopped=M_,this}return Kn(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():typeof n.returnValue!="unknown"&&(n.returnValue=!1),this.isDefaultPrevented=a1)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():typeof n.cancelBubble!="unknown"&&(n.cancelBubble=!0),this.isPropagationStopped=a1)},persist:function(){},isPersistent:a1}),e}var kp={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(t){return t.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},vN=Fo(kp),py=Kn({},kp,{view:0,detail:0}),nY=Fo(py),I2,$2,Fm,Cw=Kn({},py,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:wN,button:0,buttons:0,relatedTarget:function(t){return t.relatedTarget===void 0?t.fromElement===t.srcElement?t.toElement:t.fromElement:t.relatedTarget},movementX:function(t){return"movementX"in t?t.movementX:(t!==Fm&&(Fm&&t.type==="mousemove"?(I2=t.screenX-Fm.screenX,$2=t.screenY-Fm.screenY):$2=I2=0,Fm=t),I2)},movementY:function(t){return"movementY"in t?t.movementY:$2}}),z_=Fo(Cw),sY=Kn({},Cw,{dataTransfer:0}),rY=Fo(sY),oY=Kn({},py,{relatedTarget:0}),N2=Fo(oY),iY=Kn({},kp,{animationName:0,elapsedTime:0,pseudoElement:0}),aY=Fo(iY),uY=Kn({},kp,{clipboardData:function(t){return"clipboardData"in t?t.clipboardData:window.clipboardData}}),lY=Fo(uY),cY=Kn({},kp,{data:0}),B_=Fo(cY),hY={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},dY={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},pY={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function fY(t){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(t):(t=pY[t])?!!e[t]:!1}function wN(){return fY}var mY=Kn({},py,{key:function(t){if(t.key){var e=hY[t.key]||t.key;if(e!=="Unidentified")return e}return t.type==="keypress"?(t=W1(t),t===13?"Enter":String.fromCharCode(t)):t.type==="keydown"||t.type==="keyup"?dY[t.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:wN,charCode:function(t){return t.type==="keypress"?W1(t):0},keyCode:function(t){return t.type==="keydown"||t.type==="keyup"?t.keyCode:0},which:function(t){return t.type==="keypress"?W1(t):t.type==="keydown"||t.type==="keyup"?t.keyCode:0}}),gY=Fo(mY),yY=Kn({},Cw,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),V_=Fo(yY),xY=Kn({},py,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:wN}),vY=Fo(xY),wY=Kn({},kp,{propertyName:0,elapsedTime:0,pseudoElement:0}),bY=Fo(wY),SY=Kn({},Cw,{deltaX:function(t){return"deltaX"in t?t.deltaX:"wheelDeltaX"in t?-t.wheelDeltaX:0},deltaY:function(t){return"deltaY"in t?t.deltaY:"wheelDeltaY"in t?-t.wheelDeltaY:"wheelDelta"in t?-t.wheelDelta:0},deltaZ:0,deltaMode:0}),CY=Fo(SY),kY=[9,13,27,32],bN=du&&"CompositionEvent"in window,ug=null;du&&"documentMode"in document&&(ug=document.documentMode);var IY=du&&"TextEvent"in window&&!ug,CL=du&&(!bN||ug&&8<ug&&11>=ug),W_=" ",U_=!1;function kL(t,e){switch(t){case"keyup":return kY.indexOf(e.keyCode)!==-1;case"keydown":return e.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function IL(t){return t=t.detail,typeof t=="object"&&"data"in t?t.data:null}var Cd=!1;function $Y(t,e){switch(t){case"compositionend":return IL(e);case"keypress":return e.which!==32?null:(U_=!0,W_);case"textInput":return t=e.data,t===W_&&U_?null:t;default:return null}}function NY(t,e){if(Cd)return t==="compositionend"||!bN&&kL(t,e)?(t=SL(),V1=xN=Yu=null,Cd=!1,t):null;switch(t){case"paste":return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return CL&&e.locale!=="ko"?null:e.data;default:return null}}var TY={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function G_(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return e==="input"?!!TY[t.type]:e==="textarea"}function $L(t,e,n,s){sL(s),e=dv(e,"onChange"),0<e.length&&(n=new vN("onChange","change",null,n,s),t.push({event:n,listeners:e}))}var lg=null,Tg=null;function EY(t){LL(t,0)}function kw(t){var e=$d(t);if(YO(e))return t}function RY(t,e){if(t==="change")return e}var NL=!1;if(du){var T2;if(du){var E2="oninput"in document;if(!E2){var H_=document.createElement("div");H_.setAttribute("oninput","return;"),E2=typeof H_.oninput=="function"}T2=E2}else T2=!1;NL=T2&&(!document.documentMode||9<document.documentMode)}function j_(){lg&&(lg.detachEvent("onpropertychange",TL),Tg=lg=null)}function TL(t){if(t.propertyName==="value"&&kw(Tg)){var e=[];$L(e,Tg,t,pN(t)),aL(EY,e)}}function AY(t,e,n){t==="focusin"?(j_(),lg=e,Tg=n,lg.attachEvent("onpropertychange",TL)):t==="focusout"&&j_()}function _Y(t){if(t==="selectionchange"||t==="keyup"||t==="keydown")return kw(Tg)}function DY(t,e){if(t==="click")return kw(e)}function PY(t,e){if(t==="input"||t==="change")return kw(e)}function FY(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}var Bi=typeof Object.is=="function"?Object.is:FY;function Eg(t,e){if(Bi(t,e))return!0;if(typeof t!="object"||t===null||typeof e!="object"||e===null)return!1;var n=Object.keys(t),s=Object.keys(e);if(n.length!==s.length)return!1;for(s=0;s<n.length;s++){var r=n[s];if(!Vk.call(e,r)||!Bi(t[r],e[r]))return!1}return!0}function K_(t){for(;t&&t.firstChild;)t=t.firstChild;return t}function X_(t,e){var n=K_(t);t=0;for(var s;n;){if(n.nodeType===3){if(s=t+n.textContent.length,t<=e&&s>=e)return{node:n,offset:e-t};t=s}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=K_(n)}}function EL(t,e){return t&&e?t===e?!0:t&&t.nodeType===3?!1:e&&e.nodeType===3?EL(t,e.parentNode):"contains"in t?t.contains(e):t.compareDocumentPosition?!!(t.compareDocumentPosition(e)&16):!1:!1}function RL(){for(var t=window,e=ov();e instanceof t.HTMLIFrameElement;){try{var n=typeof e.contentWindow.location.href=="string"}catch{n=!1}if(n)t=e.contentWindow;else break;e=ov(t.document)}return e}function SN(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return e&&(e==="input"&&(t.type==="text"||t.type==="search"||t.type==="tel"||t.type==="url"||t.type==="password")||e==="textarea"||t.contentEditable==="true")}function OY(t){var e=RL(),n=t.focusedElem,s=t.selectionRange;if(e!==n&&n&&n.ownerDocument&&EL(n.ownerDocument.documentElement,n)){if(s!==null&&SN(n)){if(e=s.start,t=s.end,t===void 0&&(t=e),"selectionStart"in n)n.selectionStart=e,n.selectionEnd=Math.min(t,n.value.length);else if(t=(e=n.ownerDocument||document)&&e.defaultView||window,t.getSelection){t=t.getSelection();var r=n.textContent.length,o=Math.min(s.start,r);s=s.end===void 0?o:Math.min(s.end,r),!t.extend&&o>s&&(r=s,s=o,o=r),r=X_(n,o);var i=X_(n,s);r&&i&&(t.rangeCount!==1||t.anchorNode!==r.node||t.anchorOffset!==r.offset||t.focusNode!==i.node||t.focusOffset!==i.offset)&&(e=e.createRange(),e.setStart(r.node,r.offset),t.removeAllRanges(),o>s?(t.addRange(e),t.extend(i.node,i.offset)):(e.setEnd(i.node,i.offset),t.addRange(e)))}}for(e=[],t=n;t=t.parentNode;)t.nodeType===1&&e.push({element:t,left:t.scrollLeft,top:t.scrollTop});for(typeof n.focus=="function"&&n.focus(),n=0;n<e.length;n++)t=e[n],t.element.scrollLeft=t.left,t.element.scrollTop=t.top}}var LY=du&&"documentMode"in document&&11>=document.documentMode,kd=null,iI=null,cg=null,aI=!1;function q_(t,e,n){var s=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;aI||kd==null||kd!==ov(s)||(s=kd,"selectionStart"in s&&SN(s)?s={start:s.selectionStart,end:s.selectionEnd}:(s=(s.ownerDocument&&s.ownerDocument.defaultView||window).getSelection(),s={anchorNode:s.anchorNode,anchorOffset:s.anchorOffset,focusNode:s.focusNode,focusOffset:s.focusOffset}),cg&&Eg(cg,s)||(cg=s,s=dv(iI,"onSelect"),0<s.length&&(e=new vN("onSelect","select",null,e,n),t.push({event:e,listeners:s}),e.target=kd)))}function u1(t,e){var n={};return n[t.toLowerCase()]=e.toLowerCase(),n["Webkit"+t]="webkit"+e,n["Moz"+t]="moz"+e,n}var Id={animationend:u1("Animation","AnimationEnd"),animationiteration:u1("Animation","AnimationIteration"),animationstart:u1("Animation","AnimationStart"),transitionend:u1("Transition","TransitionEnd")},R2={},AL={};du&&(AL=document.createElement("div").style,"AnimationEvent"in window||(delete Id.animationend.animation,delete Id.animationiteration.animation,delete Id.animationstart.animation),"TransitionEvent"in window||delete Id.transitionend.transition);function Iw(t){if(R2[t])return R2[t];if(!Id[t])return t;var e=Id[t],n;for(n in e)if(e.hasOwnProperty(n)&&n in AL)return R2[t]=e[n];return t}var _L=Iw("animationend"),DL=Iw("animationiteration"),PL=Iw("animationstart"),FL=Iw("transitionend"),OL=new Map,Y_="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function _l(t,e){OL.set(t,e),dh(e,[t])}for(var A2=0;A2<Y_.length;A2++){var _2=Y_[A2],MY=_2.toLowerCase(),zY=_2[0].toUpperCase()+_2.slice(1);_l(MY,"on"+zY)}_l(_L,"onAnimationEnd");_l(DL,"onAnimationIteration");_l(PL,"onAnimationStart");_l("dblclick","onDoubleClick");_l("focusin","onFocus");_l("focusout","onBlur");_l(FL,"onTransitionEnd");Yd("onMouseEnter",["mouseout","mouseover"]);Yd("onMouseLeave",["mouseout","mouseover"]);Yd("onPointerEnter",["pointerout","pointerover"]);Yd("onPointerLeave",["pointerout","pointerover"]);dh("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));dh("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));dh("onBeforeInput",["compositionend","keypress","textInput","paste"]);dh("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));dh("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));dh("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Qm="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),BY=new Set("cancel close invalid load scroll toggle".split(" ").concat(Qm));function Q_(t,e,n){var s=t.type||"unknown-event";t.currentTarget=n,M9(s,e,void 0,t),t.currentTarget=null}function LL(t,e){e=(e&4)!==0;for(var n=0;n<t.length;n++){var s=t[n],r=s.event;s=s.listeners;e:{var o=void 0;if(e)for(var i=s.length-1;0<=i;i--){var a=s[i],u=a.instance,l=a.currentTarget;if(a=a.listener,u!==o&&r.isPropagationStopped())break e;Q_(r,a,l),o=u}else for(i=0;i<s.length;i++){if(a=s[i],u=a.instance,l=a.currentTarget,a=a.listener,u!==o&&r.isPropagationStopped())break e;Q_(r,a,l),o=u}}}if(av)throw t=nI,av=!1,nI=null,t}function Tn(t,e){var n=e[dI];n===void 0&&(n=e[dI]=new Set);var s=t+"__bubble";n.has(s)||(ML(e,t,2,!1),n.add(s))}function D2(t,e,n){var s=0;e&&(s|=4),ML(n,t,s,e)}var l1="_reactListening"+Math.random().toString(36).slice(2);function Rg(t){if(!t[l1]){t[l1]=!0,HO.forEach(function(n){n!=="selectionchange"&&(BY.has(n)||D2(n,!1,t),D2(n,!0,t))});var e=t.nodeType===9?t:t.ownerDocument;e===null||e[l1]||(e[l1]=!0,D2("selectionchange",!1,e))}}function ML(t,e,n,s){switch(bL(e)){case 1:var r=eY;break;case 4:r=tY;break;default:r=yN}n=r.bind(null,e,n,t),r=void 0,!tI||e!=="touchstart"&&e!=="touchmove"&&e!=="wheel"||(r=!0),s?r!==void 0?t.addEventListener(e,n,{capture:!0,passive:r}):t.addEventListener(e,n,!0):r!==void 0?t.addEventListener(e,n,{passive:r}):t.addEventListener(e,n,!1)}function P2(t,e,n,s,r){var o=s;if(!(e&1)&&!(e&2)&&s!==null)e:for(;;){if(s===null)return;var i=s.tag;if(i===3||i===4){var a=s.stateNode.containerInfo;if(a===r||a.nodeType===8&&a.parentNode===r)break;if(i===4)for(i=s.return;i!==null;){var u=i.tag;if((u===3||u===4)&&(u=i.stateNode.containerInfo,u===r||u.nodeType===8&&u.parentNode===r))return;i=i.return}for(;a!==null;){if(i=Ec(a),i===null)return;if(u=i.tag,u===5||u===6){s=o=i;continue e}a=a.parentNode}}s=s.return}aL(function(){var l=o,c=pN(n),h=[];e:{var d=OL.get(t);if(d!==void 0){var f=vN,m=t;switch(t){case"keypress":if(W1(n)===0)break e;case"keydown":case"keyup":f=gY;break;case"focusin":m="focus",f=N2;break;case"focusout":m="blur",f=N2;break;case"beforeblur":case"afterblur":f=N2;break;case"click":if(n.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":f=z_;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":f=rY;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":f=vY;break;case _L:case DL:case PL:f=aY;break;case FL:f=bY;break;case"scroll":f=nY;break;case"wheel":f=CY;break;case"copy":case"cut":case"paste":f=lY;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":f=V_}var y=(e&4)!==0,x=!y&&t==="scroll",v=y?d!==null?d+"Capture":null:d;y=[];for(var w=l,S;w!==null;){S=w;var k=S.stateNode;if(S.tag===5&&k!==null&&(S=k,v!==null&&(k=kg(w,v),k!=null&&y.push(Ag(w,k,S)))),x)break;w=w.return}0<y.length&&(d=new f(d,m,null,n,c),h.push({event:d,listeners:y}))}}if(!(e&7)){e:{if(d=t==="mouseover"||t==="pointerover",f=t==="mouseout"||t==="pointerout",d&&n!==Jk&&(m=n.relatedTarget||n.fromElement)&&(Ec(m)||m[pu]))break e;if((f||d)&&(d=c.window===c?c:(d=c.ownerDocument)?d.defaultView||d.parentWindow:window,f?(m=n.relatedTarget||n.toElement,f=l,m=m?Ec(m):null,m!==null&&(x=ph(m),m!==x||m.tag!==5&&m.tag!==6)&&(m=null)):(f=null,m=l),f!==m)){if(y=z_,k="onMouseLeave",v="onMouseEnter",w="mouse",(t==="pointerout"||t==="pointerover")&&(y=V_,k="onPointerLeave",v="onPointerEnter",w="pointer"),x=f==null?d:$d(f),S=m==null?d:$d(m),d=new y(k,w+"leave",f,n,c),d.target=x,d.relatedTarget=S,k=null,Ec(c)===l&&(y=new y(v,w+"enter",m,n,c),y.target=S,y.relatedTarget=x,k=y),x=k,f&&m)t:{for(y=f,v=m,w=0,S=y;S;S=ld(S))w++;for(S=0,k=v;k;k=ld(k))S++;for(;0<w-S;)y=ld(y),w--;for(;0<S-w;)v=ld(v),S--;for(;w--;){if(y===v||v!==null&&y===v.alternate)break t;y=ld(y),v=ld(v)}y=null}else y=null;f!==null&&Z_(h,d,f,y,!1),m!==null&&x!==null&&Z_(h,x,m,y,!0)}}e:{if(d=l?$d(l):window,f=d.nodeName&&d.nodeName.toLowerCase(),f==="select"||f==="input"&&d.type==="file")var I=RY;else if(G_(d))if(NL)I=PY;else{I=_Y;var T=AY}else(f=d.nodeName)&&f.toLowerCase()==="input"&&(d.type==="checkbox"||d.type==="radio")&&(I=DY);if(I&&(I=I(t,l))){$L(h,I,n,c);break e}T&&T(t,d,l),t==="focusout"&&(T=d._wrapperState)&&T.controlled&&d.type==="number"&&Xk(d,"number",d.value)}switch(T=l?$d(l):window,t){case"focusin":(G_(T)||T.contentEditable==="true")&&(kd=T,iI=l,cg=null);break;case"focusout":cg=iI=kd=null;break;case"mousedown":aI=!0;break;case"contextmenu":case"mouseup":case"dragend":aI=!1,q_(h,n,c);break;case"selectionchange":if(LY)break;case"keydown":case"keyup":q_(h,n,c)}var R;if(bN)e:{switch(t){case"compositionstart":var _="onCompositionStart";break e;case"compositionend":_="onCompositionEnd";break e;case"compositionupdate":_="onCompositionUpdate";break e}_=void 0}else Cd?kL(t,n)&&(_="onCompositionEnd"):t==="keydown"&&n.keyCode===229&&(_="onCompositionStart");_&&(CL&&n.locale!=="ko"&&(Cd||_!=="onCompositionStart"?_==="onCompositionEnd"&&Cd&&(R=SL()):(Yu=c,xN="value"in Yu?Yu.value:Yu.textContent,Cd=!0)),T=dv(l,_),0<T.length&&(_=new B_(_,t,null,n,c),h.push({event:_,listeners:T}),R?_.data=R:(R=IL(n),R!==null&&(_.data=R)))),(R=IY?$Y(t,n):NY(t,n))&&(l=dv(l,"onBeforeInput"),0<l.length&&(c=new B_("onBeforeInput","beforeinput",null,n,c),h.push({event:c,listeners:l}),c.data=R))}LL(h,e)})}function Ag(t,e,n){return{instance:t,listener:e,currentTarget:n}}function dv(t,e){for(var n=e+"Capture",s=[];t!==null;){var r=t,o=r.stateNode;r.tag===5&&o!==null&&(r=o,o=kg(t,n),o!=null&&s.unshift(Ag(t,o,r)),o=kg(t,e),o!=null&&s.push(Ag(t,o,r))),t=t.return}return s}function ld(t){if(t===null)return null;do t=t.return;while(t&&t.tag!==5);return t||null}function Z_(t,e,n,s,r){for(var o=e._reactName,i=[];n!==null&&n!==s;){var a=n,u=a.alternate,l=a.stateNode;if(u!==null&&u===s)break;a.tag===5&&l!==null&&(a=l,r?(u=kg(n,o),u!=null&&i.unshift(Ag(n,u,a))):r||(u=kg(n,o),u!=null&&i.push(Ag(n,u,a)))),n=n.return}i.length!==0&&t.push({event:e,listeners:i})}var VY=/\r\n?/g,WY=/\u0000|\uFFFD/g;function J_(t){return(typeof t=="string"?t:""+t).replace(VY,`
`).replace(WY,"")}function c1(t,e,n){if(e=J_(e),J_(t)!==e&&n)throw Error(Re(425))}function pv(){}var uI=null,lI=null;function cI(t,e){return t==="textarea"||t==="noscript"||typeof e.children=="string"||typeof e.children=="number"||typeof e.dangerouslySetInnerHTML=="object"&&e.dangerouslySetInnerHTML!==null&&e.dangerouslySetInnerHTML.__html!=null}var hI=typeof setTimeout=="function"?setTimeout:void 0,UY=typeof clearTimeout=="function"?clearTimeout:void 0,eD=typeof Promise=="function"?Promise:void 0,GY=typeof queueMicrotask=="function"?queueMicrotask:typeof eD<"u"?function(t){return eD.resolve(null).then(t).catch(HY)}:hI;function HY(t){setTimeout(function(){throw t})}function F2(t,e){var n=e,s=0;do{var r=n.nextSibling;if(t.removeChild(n),r&&r.nodeType===8)if(n=r.data,n==="/$"){if(s===0){t.removeChild(r),Ng(e);return}s--}else n!=="$"&&n!=="$?"&&n!=="$!"||s++;n=r}while(n);Ng(e)}function ol(t){for(;t!=null;t=t.nextSibling){var e=t.nodeType;if(e===1||e===3)break;if(e===8){if(e=t.data,e==="$"||e==="$!"||e==="$?")break;if(e==="/$")return null}}return t}function tD(t){t=t.previousSibling;for(var e=0;t;){if(t.nodeType===8){var n=t.data;if(n==="$"||n==="$!"||n==="$?"){if(e===0)return t;e--}else n==="/$"&&e++}t=t.previousSibling}return null}var Ip=Math.random().toString(36).slice(2),pa="__reactFiber$"+Ip,_g="__reactProps$"+Ip,pu="__reactContainer$"+Ip,dI="__reactEvents$"+Ip,jY="__reactListeners$"+Ip,KY="__reactHandles$"+Ip;function Ec(t){var e=t[pa];if(e)return e;for(var n=t.parentNode;n;){if(e=n[pu]||n[pa]){if(n=e.alternate,e.child!==null||n!==null&&n.child!==null)for(t=tD(t);t!==null;){if(n=t[pa])return n;t=tD(t)}return e}t=n,n=t.parentNode}return null}function fy(t){return t=t[pa]||t[pu],!t||t.tag!==5&&t.tag!==6&&t.tag!==13&&t.tag!==3?null:t}function $d(t){if(t.tag===5||t.tag===6)return t.stateNode;throw Error(Re(33))}function $w(t){return t[_g]||null}var pI=[],Nd=-1;function Dl(t){return{current:t}}function En(t){0>Nd||(t.current=pI[Nd],pI[Nd]=null,Nd--)}function Cn(t,e){Nd++,pI[Nd]=t.current,t.current=e}var yl={},fr=Dl(yl),so=Dl(!1),Kc=yl;function Qd(t,e){var n=t.type.contextTypes;if(!n)return yl;var s=t.stateNode;if(s&&s.__reactInternalMemoizedUnmaskedChildContext===e)return s.__reactInternalMemoizedMaskedChildContext;var r={},o;for(o in n)r[o]=e[o];return s&&(t=t.stateNode,t.__reactInternalMemoizedUnmaskedChildContext=e,t.__reactInternalMemoizedMaskedChildContext=r),r}function ro(t){return t=t.childContextTypes,t!=null}function fv(){En(so),En(fr)}function nD(t,e,n){if(fr.current!==yl)throw Error(Re(168));Cn(fr,e),Cn(so,n)}function zL(t,e,n){var s=t.stateNode;if(e=e.childContextTypes,typeof s.getChildContext!="function")return n;s=s.getChildContext();for(var r in s)if(!(r in e))throw Error(Re(108,A9(t)||"Unknown",r));return Kn({},n,s)}function mv(t){return t=(t=t.stateNode)&&t.__reactInternalMemoizedMergedChildContext||yl,Kc=fr.current,Cn(fr,t),Cn(so,so.current),!0}function sD(t,e,n){var s=t.stateNode;if(!s)throw Error(Re(169));n?(t=zL(t,e,Kc),s.__reactInternalMemoizedMergedChildContext=t,En(so),En(fr),Cn(fr,t)):En(so),Cn(so,n)}var Ya=null,Nw=!1,O2=!1;function BL(t){Ya===null?Ya=[t]:Ya.push(t)}function XY(t){Nw=!0,BL(t)}function Pl(){if(!O2&&Ya!==null){O2=!0;var t=0,e=un;try{var n=Ya;for(un=1;t<n.length;t++){var s=n[t];do s=s(!0);while(s!==null)}Ya=null,Nw=!1}catch(r){throw Ya!==null&&(Ya=Ya.slice(t+1)),hL(fN,Pl),r}finally{un=e,O2=!1}}return null}var Td=[],Ed=0,gv=null,yv=0,ni=[],si=0,Xc=null,tu=1,nu="";function xc(t,e){Td[Ed++]=yv,Td[Ed++]=gv,gv=t,yv=e}function VL(t,e,n){ni[si++]=tu,ni[si++]=nu,ni[si++]=Xc,Xc=t;var s=tu;t=nu;var r=32-Oi(s)-1;s&=~(1<<r),n+=1;var o=32-Oi(e)+r;if(30<o){var i=r-r%5;o=(s&(1<<i)-1).toString(32),s>>=i,r-=i,tu=1<<32-Oi(e)+r|n<<r|s,nu=o+t}else tu=1<<o|n<<r|s,nu=t}function CN(t){t.return!==null&&(xc(t,1),VL(t,1,0))}function kN(t){for(;t===gv;)gv=Td[--Ed],Td[Ed]=null,yv=Td[--Ed],Td[Ed]=null;for(;t===Xc;)Xc=ni[--si],ni[si]=null,nu=ni[--si],ni[si]=null,tu=ni[--si],ni[si]=null}var To=null,$o=null,Fn=!1,Di=null;function WL(t,e){var n=oi(5,null,null,0);n.elementType="DELETED",n.stateNode=e,n.return=t,e=t.deletions,e===null?(t.deletions=[n],t.flags|=16):e.push(n)}function rD(t,e){switch(t.tag){case 5:var n=t.type;return e=e.nodeType!==1||n.toLowerCase()!==e.nodeName.toLowerCase()?null:e,e!==null?(t.stateNode=e,To=t,$o=ol(e.firstChild),!0):!1;case 6:return e=t.pendingProps===""||e.nodeType!==3?null:e,e!==null?(t.stateNode=e,To=t,$o=null,!0):!1;case 13:return e=e.nodeType!==8?null:e,e!==null?(n=Xc!==null?{id:tu,overflow:nu}:null,t.memoizedState={dehydrated:e,treeContext:n,retryLane:1073741824},n=oi(18,null,null,0),n.stateNode=e,n.return=t,t.child=n,To=t,$o=null,!0):!1;default:return!1}}function fI(t){return(t.mode&1)!==0&&(t.flags&128)===0}function mI(t){if(Fn){var e=$o;if(e){var n=e;if(!rD(t,e)){if(fI(t))throw Error(Re(418));e=ol(n.nextSibling);var s=To;e&&rD(t,e)?WL(s,n):(t.flags=t.flags&-4097|2,Fn=!1,To=t)}}else{if(fI(t))throw Error(Re(418));t.flags=t.flags&-4097|2,Fn=!1,To=t}}}function oD(t){for(t=t.return;t!==null&&t.tag!==5&&t.tag!==3&&t.tag!==13;)t=t.return;To=t}function h1(t){if(t!==To)return!1;if(!Fn)return oD(t),Fn=!0,!1;var e;if((e=t.tag!==3)&&!(e=t.tag!==5)&&(e=t.type,e=e!=="head"&&e!=="body"&&!cI(t.type,t.memoizedProps)),e&&(e=$o)){if(fI(t))throw UL(),Error(Re(418));for(;e;)WL(t,e),e=ol(e.nextSibling)}if(oD(t),t.tag===13){if(t=t.memoizedState,t=t!==null?t.dehydrated:null,!t)throw Error(Re(317));e:{for(t=t.nextSibling,e=0;t;){if(t.nodeType===8){var n=t.data;if(n==="/$"){if(e===0){$o=ol(t.nextSibling);break e}e--}else n!=="$"&&n!=="$!"&&n!=="$?"||e++}t=t.nextSibling}$o=null}}else $o=To?ol(t.stateNode.nextSibling):null;return!0}function UL(){for(var t=$o;t;)t=ol(t.nextSibling)}function Zd(){$o=To=null,Fn=!1}function IN(t){Di===null?Di=[t]:Di.push(t)}var qY=bu.ReactCurrentBatchConfig;function Ai(t,e){if(t&&t.defaultProps){e=Kn({},e),t=t.defaultProps;for(var n in t)e[n]===void 0&&(e[n]=t[n]);return e}return e}var xv=Dl(null),vv=null,Rd=null,$N=null;function NN(){$N=Rd=vv=null}function TN(t){var e=xv.current;En(xv),t._currentValue=e}function gI(t,e,n){for(;t!==null;){var s=t.alternate;if((t.childLanes&e)!==e?(t.childLanes|=e,s!==null&&(s.childLanes|=e)):s!==null&&(s.childLanes&e)!==e&&(s.childLanes|=e),t===n)break;t=t.return}}function Wd(t,e){vv=t,$N=Rd=null,t=t.dependencies,t!==null&&t.firstContext!==null&&(t.lanes&e&&(eo=!0),t.firstContext=null)}function gi(t){var e=t._currentValue;if($N!==t)if(t={context:t,memoizedValue:e,next:null},Rd===null){if(vv===null)throw Error(Re(308));Rd=t,vv.dependencies={lanes:0,firstContext:t}}else Rd=Rd.next=t;return e}var Rc=null;function EN(t){Rc===null?Rc=[t]:Rc.push(t)}function GL(t,e,n,s){var r=e.interleaved;return r===null?(n.next=n,EN(e)):(n.next=r.next,r.next=n),e.interleaved=n,fu(t,s)}function fu(t,e){t.lanes|=e;var n=t.alternate;for(n!==null&&(n.lanes|=e),n=t,t=t.return;t!==null;)t.childLanes|=e,n=t.alternate,n!==null&&(n.childLanes|=e),n=t,t=t.return;return n.tag===3?n.stateNode:null}var Hu=!1;function RN(t){t.updateQueue={baseState:t.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function HL(t,e){t=t.updateQueue,e.updateQueue===t&&(e.updateQueue={baseState:t.baseState,firstBaseUpdate:t.firstBaseUpdate,lastBaseUpdate:t.lastBaseUpdate,shared:t.shared,effects:t.effects})}function ru(t,e){return{eventTime:t,lane:e,tag:0,payload:null,callback:null,next:null}}function il(t,e,n){var s=t.updateQueue;if(s===null)return null;if(s=s.shared,Qt&2){var r=s.pending;return r===null?e.next=e:(e.next=r.next,r.next=e),s.pending=e,fu(t,n)}return r=s.interleaved,r===null?(e.next=e,EN(s)):(e.next=r.next,r.next=e),s.interleaved=e,fu(t,n)}function U1(t,e,n){if(e=e.updateQueue,e!==null&&(e=e.shared,(n&4194240)!==0)){var s=e.lanes;s&=t.pendingLanes,n|=s,e.lanes=n,mN(t,n)}}function iD(t,e){var n=t.updateQueue,s=t.alternate;if(s!==null&&(s=s.updateQueue,n===s)){var r=null,o=null;if(n=n.firstBaseUpdate,n!==null){do{var i={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};o===null?r=o=i:o=o.next=i,n=n.next}while(n!==null);o===null?r=o=e:o=o.next=e}else r=o=e;n={baseState:s.baseState,firstBaseUpdate:r,lastBaseUpdate:o,shared:s.shared,effects:s.effects},t.updateQueue=n;return}t=n.lastBaseUpdate,t===null?n.firstBaseUpdate=e:t.next=e,n.lastBaseUpdate=e}function wv(t,e,n,s){var r=t.updateQueue;Hu=!1;var o=r.firstBaseUpdate,i=r.lastBaseUpdate,a=r.shared.pending;if(a!==null){r.shared.pending=null;var u=a,l=u.next;u.next=null,i===null?o=l:i.next=l,i=u;var c=t.alternate;c!==null&&(c=c.updateQueue,a=c.lastBaseUpdate,a!==i&&(a===null?c.firstBaseUpdate=l:a.next=l,c.lastBaseUpdate=u))}if(o!==null){var h=r.baseState;i=0,c=l=u=null,a=o;do{var d=a.lane,f=a.eventTime;if((s&d)===d){c!==null&&(c=c.next={eventTime:f,lane:0,tag:a.tag,payload:a.payload,callback:a.callback,next:null});e:{var m=t,y=a;switch(d=e,f=n,y.tag){case 1:if(m=y.payload,typeof m=="function"){h=m.call(f,h,d);break e}h=m;break e;case 3:m.flags=m.flags&-65537|128;case 0:if(m=y.payload,d=typeof m=="function"?m.call(f,h,d):m,d==null)break e;h=Kn({},h,d);break e;case 2:Hu=!0}}a.callback!==null&&a.lane!==0&&(t.flags|=64,d=r.effects,d===null?r.effects=[a]:d.push(a))}else f={eventTime:f,lane:d,tag:a.tag,payload:a.payload,callback:a.callback,next:null},c===null?(l=c=f,u=h):c=c.next=f,i|=d;if(a=a.next,a===null){if(a=r.shared.pending,a===null)break;d=a,a=d.next,d.next=null,r.lastBaseUpdate=d,r.shared.pending=null}}while(!0);if(c===null&&(u=h),r.baseState=u,r.firstBaseUpdate=l,r.lastBaseUpdate=c,e=r.shared.interleaved,e!==null){r=e;do i|=r.lane,r=r.next;while(r!==e)}else o===null&&(r.shared.lanes=0);Yc|=i,t.lanes=i,t.memoizedState=h}}function aD(t,e,n){if(t=e.effects,e.effects=null,t!==null)for(e=0;e<t.length;e++){var s=t[e],r=s.callback;if(r!==null){if(s.callback=null,s=n,typeof r!="function")throw Error(Re(191,r));r.call(s)}}}var jL=new GO.Component().refs;function yI(t,e,n,s){e=t.memoizedState,n=n(s,e),n=n==null?e:Kn({},e,n),t.memoizedState=n,t.lanes===0&&(t.updateQueue.baseState=n)}var Tw={isMounted:function(t){return(t=t._reactInternals)?ph(t)===t:!1},enqueueSetState:function(t,e,n){t=t._reactInternals;var s=_r(),r=ul(t),o=ru(s,r);o.payload=e,n!=null&&(o.callback=n),e=il(t,o,r),e!==null&&(Li(e,t,r,s),U1(e,t,r))},enqueueReplaceState:function(t,e,n){t=t._reactInternals;var s=_r(),r=ul(t),o=ru(s,r);o.tag=1,o.payload=e,n!=null&&(o.callback=n),e=il(t,o,r),e!==null&&(Li(e,t,r,s),U1(e,t,r))},enqueueForceUpdate:function(t,e){t=t._reactInternals;var n=_r(),s=ul(t),r=ru(n,s);r.tag=2,e!=null&&(r.callback=e),e=il(t,r,s),e!==null&&(Li(e,t,s,n),U1(e,t,s))}};function uD(t,e,n,s,r,o,i){return t=t.stateNode,typeof t.shouldComponentUpdate=="function"?t.shouldComponentUpdate(s,o,i):e.prototype&&e.prototype.isPureReactComponent?!Eg(n,s)||!Eg(r,o):!0}function KL(t,e,n){var s=!1,r=yl,o=e.contextType;return typeof o=="object"&&o!==null?o=gi(o):(r=ro(e)?Kc:fr.current,s=e.contextTypes,o=(s=s!=null)?Qd(t,r):yl),e=new e(n,o),t.memoizedState=e.state!==null&&e.state!==void 0?e.state:null,e.updater=Tw,t.stateNode=e,e._reactInternals=t,s&&(t=t.stateNode,t.__reactInternalMemoizedUnmaskedChildContext=r,t.__reactInternalMemoizedMaskedChildContext=o),e}function lD(t,e,n,s){t=e.state,typeof e.componentWillReceiveProps=="function"&&e.componentWillReceiveProps(n,s),typeof e.UNSAFE_componentWillReceiveProps=="function"&&e.UNSAFE_componentWillReceiveProps(n,s),e.state!==t&&Tw.enqueueReplaceState(e,e.state,null)}function xI(t,e,n,s){var r=t.stateNode;r.props=n,r.state=t.memoizedState,r.refs=jL,RN(t);var o=e.contextType;typeof o=="object"&&o!==null?r.context=gi(o):(o=ro(e)?Kc:fr.current,r.context=Qd(t,o)),r.state=t.memoizedState,o=e.getDerivedStateFromProps,typeof o=="function"&&(yI(t,e,o,n),r.state=t.memoizedState),typeof e.getDerivedStateFromProps=="function"||typeof r.getSnapshotBeforeUpdate=="function"||typeof r.UNSAFE_componentWillMount!="function"&&typeof r.componentWillMount!="function"||(e=r.state,typeof r.componentWillMount=="function"&&r.componentWillMount(),typeof r.UNSAFE_componentWillMount=="function"&&r.UNSAFE_componentWillMount(),e!==r.state&&Tw.enqueueReplaceState(r,r.state,null),wv(t,n,r,s),r.state=t.memoizedState),typeof r.componentDidMount=="function"&&(t.flags|=4194308)}function Om(t,e,n){if(t=n.ref,t!==null&&typeof t!="function"&&typeof t!="object"){if(n._owner){if(n=n._owner,n){if(n.tag!==1)throw Error(Re(309));var s=n.stateNode}if(!s)throw Error(Re(147,t));var r=s,o=""+t;return e!==null&&e.ref!==null&&typeof e.ref=="function"&&e.ref._stringRef===o?e.ref:(e=function(i){var a=r.refs;a===jL&&(a=r.refs={}),i===null?delete a[o]:a[o]=i},e._stringRef=o,e)}if(typeof t!="string")throw Error(Re(284));if(!n._owner)throw Error(Re(290,t))}return t}function d1(t,e){throw t=Object.prototype.toString.call(e),Error(Re(31,t==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":t))}function cD(t){var e=t._init;return e(t._payload)}function XL(t){function e(v,w){if(t){var S=v.deletions;S===null?(v.deletions=[w],v.flags|=16):S.push(w)}}function n(v,w){if(!t)return null;for(;w!==null;)e(v,w),w=w.sibling;return null}function s(v,w){for(v=new Map;w!==null;)w.key!==null?v.set(w.key,w):v.set(w.index,w),w=w.sibling;return v}function r(v,w){return v=ll(v,w),v.index=0,v.sibling=null,v}function o(v,w,S){return v.index=S,t?(S=v.alternate,S!==null?(S=S.index,S<w?(v.flags|=2,w):S):(v.flags|=2,w)):(v.flags|=1048576,w)}function i(v){return t&&v.alternate===null&&(v.flags|=2),v}function a(v,w,S,k){return w===null||w.tag!==6?(w=U2(S,v.mode,k),w.return=v,w):(w=r(w,S),w.return=v,w)}function u(v,w,S,k){var I=S.type;return I===Sd?c(v,w,S.props.children,k,S.key):w!==null&&(w.elementType===I||typeof I=="object"&&I!==null&&I.$$typeof===Gu&&cD(I)===w.type)?(k=r(w,S.props),k.ref=Om(v,w,S),k.return=v,k):(k=q1(S.type,S.key,S.props,null,v.mode,k),k.ref=Om(v,w,S),k.return=v,k)}function l(v,w,S,k){return w===null||w.tag!==4||w.stateNode.containerInfo!==S.containerInfo||w.stateNode.implementation!==S.implementation?(w=G2(S,v.mode,k),w.return=v,w):(w=r(w,S.children||[]),w.return=v,w)}function c(v,w,S,k,I){return w===null||w.tag!==7?(w=Bc(S,v.mode,k,I),w.return=v,w):(w=r(w,S),w.return=v,w)}function h(v,w,S){if(typeof w=="string"&&w!==""||typeof w=="number")return w=U2(""+w,v.mode,S),w.return=v,w;if(typeof w=="object"&&w!==null){switch(w.$$typeof){case t1:return S=q1(w.type,w.key,w.props,null,v.mode,S),S.ref=Om(v,null,w),S.return=v,S;case bd:return w=G2(w,v.mode,S),w.return=v,w;case Gu:var k=w._init;return h(v,k(w._payload),S)}if(qm(w)||Am(w))return w=Bc(w,v.mode,S,null),w.return=v,w;d1(v,w)}return null}function d(v,w,S,k){var I=w!==null?w.key:null;if(typeof S=="string"&&S!==""||typeof S=="number")return I!==null?null:a(v,w,""+S,k);if(typeof S=="object"&&S!==null){switch(S.$$typeof){case t1:return S.key===I?u(v,w,S,k):null;case bd:return S.key===I?l(v,w,S,k):null;case Gu:return I=S._init,d(v,w,I(S._payload),k)}if(qm(S)||Am(S))return I!==null?null:c(v,w,S,k,null);d1(v,S)}return null}function f(v,w,S,k,I){if(typeof k=="string"&&k!==""||typeof k=="number")return v=v.get(S)||null,a(w,v,""+k,I);if(typeof k=="object"&&k!==null){switch(k.$$typeof){case t1:return v=v.get(k.key===null?S:k.key)||null,u(w,v,k,I);case bd:return v=v.get(k.key===null?S:k.key)||null,l(w,v,k,I);case Gu:var T=k._init;return f(v,w,S,T(k._payload),I)}if(qm(k)||Am(k))return v=v.get(S)||null,c(w,v,k,I,null);d1(w,k)}return null}function m(v,w,S,k){for(var I=null,T=null,R=w,_=w=0,D=null;R!==null&&_<S.length;_++){R.index>_?(D=R,R=null):D=R.sibling;var L=d(v,R,S[_],k);if(L===null){R===null&&(R=D);break}t&&R&&L.alternate===null&&e(v,R),w=o(L,w,_),T===null?I=L:T.sibling=L,T=L,R=D}if(_===S.length)return n(v,R),Fn&&xc(v,_),I;if(R===null){for(;_<S.length;_++)R=h(v,S[_],k),R!==null&&(w=o(R,w,_),T===null?I=R:T.sibling=R,T=R);return Fn&&xc(v,_),I}for(R=s(v,R);_<S.length;_++)D=f(R,v,_,S[_],k),D!==null&&(t&&D.alternate!==null&&R.delete(D.key===null?_:D.key),w=o(D,w,_),T===null?I=D:T.sibling=D,T=D);return t&&R.forEach(function(V){return e(v,V)}),Fn&&xc(v,_),I}function y(v,w,S,k){var I=Am(S);if(typeof I!="function")throw Error(Re(150));if(S=I.call(S),S==null)throw Error(Re(151));for(var T=I=null,R=w,_=w=0,D=null,L=S.next();R!==null&&!L.done;_++,L=S.next()){R.index>_?(D=R,R=null):D=R.sibling;var V=d(v,R,L.value,k);if(V===null){R===null&&(R=D);break}t&&R&&V.alternate===null&&e(v,R),w=o(V,w,_),T===null?I=V:T.sibling=V,T=V,R=D}if(L.done)return n(v,R),Fn&&xc(v,_),I;if(R===null){for(;!L.done;_++,L=S.next())L=h(v,L.value,k),L!==null&&(w=o(L,w,_),T===null?I=L:T.sibling=L,T=L);return Fn&&xc(v,_),I}for(R=s(v,R);!L.done;_++,L=S.next())L=f(R,v,_,L.value,k),L!==null&&(t&&L.alternate!==null&&R.delete(L.key===null?_:L.key),w=o(L,w,_),T===null?I=L:T.sibling=L,T=L);return t&&R.forEach(function(U){return e(v,U)}),Fn&&xc(v,_),I}function x(v,w,S,k){if(typeof S=="object"&&S!==null&&S.type===Sd&&S.key===null&&(S=S.props.children),typeof S=="object"&&S!==null){switch(S.$$typeof){case t1:e:{for(var I=S.key,T=w;T!==null;){if(T.key===I){if(I=S.type,I===Sd){if(T.tag===7){n(v,T.sibling),w=r(T,S.props.children),w.return=v,v=w;break e}}else if(T.elementType===I||typeof I=="object"&&I!==null&&I.$$typeof===Gu&&cD(I)===T.type){n(v,T.sibling),w=r(T,S.props),w.ref=Om(v,T,S),w.return=v,v=w;break e}n(v,T);break}else e(v,T);T=T.sibling}S.type===Sd?(w=Bc(S.props.children,v.mode,k,S.key),w.return=v,v=w):(k=q1(S.type,S.key,S.props,null,v.mode,k),k.ref=Om(v,w,S),k.return=v,v=k)}return i(v);case bd:e:{for(T=S.key;w!==null;){if(w.key===T)if(w.tag===4&&w.stateNode.containerInfo===S.containerInfo&&w.stateNode.implementation===S.implementation){n(v,w.sibling),w=r(w,S.children||[]),w.return=v,v=w;break e}else{n(v,w);break}else e(v,w);w=w.sibling}w=G2(S,v.mode,k),w.return=v,v=w}return i(v);case Gu:return T=S._init,x(v,w,T(S._payload),k)}if(qm(S))return m(v,w,S,k);if(Am(S))return y(v,w,S,k);d1(v,S)}return typeof S=="string"&&S!==""||typeof S=="number"?(S=""+S,w!==null&&w.tag===6?(n(v,w.sibling),w=r(w,S),w.return=v,v=w):(n(v,w),w=U2(S,v.mode,k),w.return=v,v=w),i(v)):n(v,w)}return x}var Jd=XL(!0),qL=XL(!1),my={},ya=Dl(my),Dg=Dl(my),Pg=Dl(my);function Ac(t){if(t===my)throw Error(Re(174));return t}function AN(t,e){switch(Cn(Pg,e),Cn(Dg,t),Cn(ya,my),t=e.nodeType,t){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:Yk(null,"");break;default:t=t===8?e.parentNode:e,e=t.namespaceURI||null,t=t.tagName,e=Yk(e,t)}En(ya),Cn(ya,e)}function ep(){En(ya),En(Dg),En(Pg)}function YL(t){Ac(Pg.current);var e=Ac(ya.current),n=Yk(e,t.type);e!==n&&(Cn(Dg,t),Cn(ya,n))}function _N(t){Dg.current===t&&(En(ya),En(Dg))}var Wn=Dl(0);function bv(t){for(var e=t;e!==null;){if(e.tag===13){var n=e.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||n.data==="$?"||n.data==="$!"))return e}else if(e.tag===19&&e.memoizedProps.revealOrder!==void 0){if(e.flags&128)return e}else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break;for(;e.sibling===null;){if(e.return===null||e.return===t)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var L2=[];function DN(){for(var t=0;t<L2.length;t++)L2[t]._workInProgressVersionPrimary=null;L2.length=0}var G1=bu.ReactCurrentDispatcher,M2=bu.ReactCurrentBatchConfig,qc=0,jn=null,Ns=null,Ls=null,Sv=!1,hg=!1,Fg=0,YY=0;function or(){throw Error(Re(321))}function PN(t,e){if(e===null)return!1;for(var n=0;n<e.length&&n<t.length;n++)if(!Bi(t[n],e[n]))return!1;return!0}function FN(t,e,n,s,r,o){if(qc=o,jn=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,G1.current=t===null||t.memoizedState===null?eQ:tQ,t=n(s,r),hg){o=0;do{if(hg=!1,Fg=0,25<=o)throw Error(Re(301));o+=1,Ls=Ns=null,e.updateQueue=null,G1.current=nQ,t=n(s,r)}while(hg)}if(G1.current=Cv,e=Ns!==null&&Ns.next!==null,qc=0,Ls=Ns=jn=null,Sv=!1,e)throw Error(Re(300));return t}function ON(){var t=Fg!==0;return Fg=0,t}function ua(){var t={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Ls===null?jn.memoizedState=Ls=t:Ls=Ls.next=t,Ls}function yi(){if(Ns===null){var t=jn.alternate;t=t!==null?t.memoizedState:null}else t=Ns.next;var e=Ls===null?jn.memoizedState:Ls.next;if(e!==null)Ls=e,Ns=t;else{if(t===null)throw Error(Re(310));Ns=t,t={memoizedState:Ns.memoizedState,baseState:Ns.baseState,baseQueue:Ns.baseQueue,queue:Ns.queue,next:null},Ls===null?jn.memoizedState=Ls=t:Ls=Ls.next=t}return Ls}function Og(t,e){return typeof e=="function"?e(t):e}function z2(t){var e=yi(),n=e.queue;if(n===null)throw Error(Re(311));n.lastRenderedReducer=t;var s=Ns,r=s.baseQueue,o=n.pending;if(o!==null){if(r!==null){var i=r.next;r.next=o.next,o.next=i}s.baseQueue=r=o,n.pending=null}if(r!==null){o=r.next,s=s.baseState;var a=i=null,u=null,l=o;do{var c=l.lane;if((qc&c)===c)u!==null&&(u=u.next={lane:0,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null}),s=l.hasEagerState?l.eagerState:t(s,l.action);else{var h={lane:c,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null};u===null?(a=u=h,i=s):u=u.next=h,jn.lanes|=c,Yc|=c}l=l.next}while(l!==null&&l!==o);u===null?i=s:u.next=a,Bi(s,e.memoizedState)||(eo=!0),e.memoizedState=s,e.baseState=i,e.baseQueue=u,n.lastRenderedState=s}if(t=n.interleaved,t!==null){r=t;do o=r.lane,jn.lanes|=o,Yc|=o,r=r.next;while(r!==t)}else r===null&&(n.lanes=0);return[e.memoizedState,n.dispatch]}function B2(t){var e=yi(),n=e.queue;if(n===null)throw Error(Re(311));n.lastRenderedReducer=t;var s=n.dispatch,r=n.pending,o=e.memoizedState;if(r!==null){n.pending=null;var i=r=r.next;do o=t(o,i.action),i=i.next;while(i!==r);Bi(o,e.memoizedState)||(eo=!0),e.memoizedState=o,e.baseQueue===null&&(e.baseState=o),n.lastRenderedState=o}return[o,s]}function QL(){}function ZL(t,e){var n=jn,s=yi(),r=e(),o=!Bi(s.memoizedState,r);if(o&&(s.memoizedState=r,eo=!0),s=s.queue,LN(tM.bind(null,n,s,t),[t]),s.getSnapshot!==e||o||Ls!==null&&Ls.memoizedState.tag&1){if(n.flags|=2048,Lg(9,eM.bind(null,n,s,r,e),void 0,null),Bs===null)throw Error(Re(349));qc&30||JL(n,e,r)}return r}function JL(t,e,n){t.flags|=16384,t={getSnapshot:e,value:n},e=jn.updateQueue,e===null?(e={lastEffect:null,stores:null},jn.updateQueue=e,e.stores=[t]):(n=e.stores,n===null?e.stores=[t]:n.push(t))}function eM(t,e,n,s){e.value=n,e.getSnapshot=s,nM(e)&&sM(t)}function tM(t,e,n){return n(function(){nM(e)&&sM(t)})}function nM(t){var e=t.getSnapshot;t=t.value;try{var n=e();return!Bi(t,n)}catch{return!0}}function sM(t){var e=fu(t,1);e!==null&&Li(e,t,1,-1)}function hD(t){var e=ua();return typeof t=="function"&&(t=t()),e.memoizedState=e.baseState=t,t={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Og,lastRenderedState:t},e.queue=t,t=t.dispatch=JY.bind(null,jn,t),[e.memoizedState,t]}function Lg(t,e,n,s){return t={tag:t,create:e,destroy:n,deps:s,next:null},e=jn.updateQueue,e===null?(e={lastEffect:null,stores:null},jn.updateQueue=e,e.lastEffect=t.next=t):(n=e.lastEffect,n===null?e.lastEffect=t.next=t:(s=n.next,n.next=t,t.next=s,e.lastEffect=t)),t}function rM(){return yi().memoizedState}function H1(t,e,n,s){var r=ua();jn.flags|=t,r.memoizedState=Lg(1|e,n,void 0,s===void 0?null:s)}function Ew(t,e,n,s){var r=yi();s=s===void 0?null:s;var o=void 0;if(Ns!==null){var i=Ns.memoizedState;if(o=i.destroy,s!==null&&PN(s,i.deps)){r.memoizedState=Lg(e,n,o,s);return}}jn.flags|=t,r.memoizedState=Lg(1|e,n,o,s)}function dD(t,e){return H1(8390656,8,t,e)}function LN(t,e){return Ew(2048,8,t,e)}function oM(t,e){return Ew(4,2,t,e)}function iM(t,e){return Ew(4,4,t,e)}function aM(t,e){if(typeof e=="function")return t=t(),e(t),function(){e(null)};if(e!=null)return t=t(),e.current=t,function(){e.current=null}}function uM(t,e,n){return n=n!=null?n.concat([t]):null,Ew(4,4,aM.bind(null,e,t),n)}function MN(){}function lM(t,e){var n=yi();e=e===void 0?null:e;var s=n.memoizedState;return s!==null&&e!==null&&PN(e,s[1])?s[0]:(n.memoizedState=[t,e],t)}function cM(t,e){var n=yi();e=e===void 0?null:e;var s=n.memoizedState;return s!==null&&e!==null&&PN(e,s[1])?s[0]:(t=t(),n.memoizedState=[t,e],t)}function hM(t,e,n){return qc&21?(Bi(n,e)||(n=fL(),jn.lanes|=n,Yc|=n,t.baseState=!0),e):(t.baseState&&(t.baseState=!1,eo=!0),t.memoizedState=n)}function QY(t,e){var n=un;un=n!==0&&4>n?n:4,t(!0);var s=M2.transition;M2.transition={};try{t(!1),e()}finally{un=n,M2.transition=s}}function dM(){return yi().memoizedState}function ZY(t,e,n){var s=ul(t);if(n={lane:s,action:n,hasEagerState:!1,eagerState:null,next:null},pM(t))fM(e,n);else if(n=GL(t,e,n,s),n!==null){var r=_r();Li(n,t,s,r),mM(n,e,s)}}function JY(t,e,n){var s=ul(t),r={lane:s,action:n,hasEagerState:!1,eagerState:null,next:null};if(pM(t))fM(e,r);else{var o=t.alternate;if(t.lanes===0&&(o===null||o.lanes===0)&&(o=e.lastRenderedReducer,o!==null))try{var i=e.lastRenderedState,a=o(i,n);if(r.hasEagerState=!0,r.eagerState=a,Bi(a,i)){var u=e.interleaved;u===null?(r.next=r,EN(e)):(r.next=u.next,u.next=r),e.interleaved=r;return}}catch{}finally{}n=GL(t,e,r,s),n!==null&&(r=_r(),Li(n,t,s,r),mM(n,e,s))}}function pM(t){var e=t.alternate;return t===jn||e!==null&&e===jn}function fM(t,e){hg=Sv=!0;var n=t.pending;n===null?e.next=e:(e.next=n.next,n.next=e),t.pending=e}function mM(t,e,n){if(n&4194240){var s=e.lanes;s&=t.pendingLanes,n|=s,e.lanes=n,mN(t,n)}}var Cv={readContext:gi,useCallback:or,useContext:or,useEffect:or,useImperativeHandle:or,useInsertionEffect:or,useLayoutEffect:or,useMemo:or,useReducer:or,useRef:or,useState:or,useDebugValue:or,useDeferredValue:or,useTransition:or,useMutableSource:or,useSyncExternalStore:or,useId:or,unstable_isNewReconciler:!1},eQ={readContext:gi,useCallback:function(t,e){return ua().memoizedState=[t,e===void 0?null:e],t},useContext:gi,useEffect:dD,useImperativeHandle:function(t,e,n){return n=n!=null?n.concat([t]):null,H1(4194308,4,aM.bind(null,e,t),n)},useLayoutEffect:function(t,e){return H1(4194308,4,t,e)},useInsertionEffect:function(t,e){return H1(4,2,t,e)},useMemo:function(t,e){var n=ua();return e=e===void 0?null:e,t=t(),n.memoizedState=[t,e],t},useReducer:function(t,e,n){var s=ua();return e=n!==void 0?n(e):e,s.memoizedState=s.baseState=e,t={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:t,lastRenderedState:e},s.queue=t,t=t.dispatch=ZY.bind(null,jn,t),[s.memoizedState,t]},useRef:function(t){var e=ua();return t={current:t},e.memoizedState=t},useState:hD,useDebugValue:MN,useDeferredValue:function(t){return ua().memoizedState=t},useTransition:function(){var t=hD(!1),e=t[0];return t=QY.bind(null,t[1]),ua().memoizedState=t,[e,t]},useMutableSource:function(){},useSyncExternalStore:function(t,e,n){var s=jn,r=ua();if(Fn){if(n===void 0)throw Error(Re(407));n=n()}else{if(n=e(),Bs===null)throw Error(Re(349));qc&30||JL(s,e,n)}r.memoizedState=n;var o={value:n,getSnapshot:e};return r.queue=o,dD(tM.bind(null,s,o,t),[t]),s.flags|=2048,Lg(9,eM.bind(null,s,o,n,e),void 0,null),n},useId:function(){var t=ua(),e=Bs.identifierPrefix;if(Fn){var n=nu,s=tu;n=(s&~(1<<32-Oi(s)-1)).toString(32)+n,e=":"+e+"R"+n,n=Fg++,0<n&&(e+="H"+n.toString(32)),e+=":"}else n=YY++,e=":"+e+"r"+n.toString(32)+":";return t.memoizedState=e},unstable_isNewReconciler:!1},tQ={readContext:gi,useCallback:lM,useContext:gi,useEffect:LN,useImperativeHandle:uM,useInsertionEffect:oM,useLayoutEffect:iM,useMemo:cM,useReducer:z2,useRef:rM,useState:function(){return z2(Og)},useDebugValue:MN,useDeferredValue:function(t){var e=yi();return hM(e,Ns.memoizedState,t)},useTransition:function(){var t=z2(Og)[0],e=yi().memoizedState;return[t,e]},useMutableSource:QL,useSyncExternalStore:ZL,useId:dM,unstable_isNewReconciler:!1},nQ={readContext:gi,useCallback:lM,useContext:gi,useEffect:LN,useImperativeHandle:uM,useInsertionEffect:oM,useLayoutEffect:iM,useMemo:cM,useReducer:B2,useRef:rM,useState:function(){return B2(Og)},useDebugValue:MN,useDeferredValue:function(t){var e=yi();return Ns===null?e.memoizedState=t:hM(e,Ns.memoizedState,t)},useTransition:function(){var t=B2(Og)[0],e=yi().memoizedState;return[t,e]},useMutableSource:QL,useSyncExternalStore:ZL,useId:dM,unstable_isNewReconciler:!1};function tp(t,e){try{var n="",s=e;do n+=R9(s),s=s.return;while(s);var r=n}catch(o){r=`
Error generating stack: `+o.message+`
`+o.stack}return{value:t,source:e,stack:r,digest:null}}function V2(t,e,n){return{value:t,source:null,stack:n??null,digest:e??null}}function vI(t,e){try{console.error(e.value)}catch(n){setTimeout(function(){throw n})}}var sQ=typeof WeakMap=="function"?WeakMap:Map;function gM(t,e,n){n=ru(-1,n),n.tag=3,n.payload={element:null};var s=e.value;return n.callback=function(){Iv||(Iv=!0,EI=s),vI(t,e)},n}function yM(t,e,n){n=ru(-1,n),n.tag=3;var s=t.type.getDerivedStateFromError;if(typeof s=="function"){var r=e.value;n.payload=function(){return s(r)},n.callback=function(){vI(t,e)}}var o=t.stateNode;return o!==null&&typeof o.componentDidCatch=="function"&&(n.callback=function(){vI(t,e),typeof s!="function"&&(al===null?al=new Set([this]):al.add(this));var i=e.stack;this.componentDidCatch(e.value,{componentStack:i!==null?i:""})}),n}function pD(t,e,n){var s=t.pingCache;if(s===null){s=t.pingCache=new sQ;var r=new Set;s.set(e,r)}else r=s.get(e),r===void 0&&(r=new Set,s.set(e,r));r.has(n)||(r.add(n),t=yQ.bind(null,t,e,n),e.then(t,t))}function fD(t){do{var e;if((e=t.tag===13)&&(e=t.memoizedState,e=e!==null?e.dehydrated!==null:!0),e)return t;t=t.return}while(t!==null);return null}function mD(t,e,n,s,r){return t.mode&1?(t.flags|=65536,t.lanes=r,t):(t===e?t.flags|=65536:(t.flags|=128,n.flags|=131072,n.flags&=-52805,n.tag===1&&(n.alternate===null?n.tag=17:(e=ru(-1,1),e.tag=2,il(n,e,1))),n.lanes|=1),t)}var rQ=bu.ReactCurrentOwner,eo=!1;function Nr(t,e,n,s){e.child=t===null?qL(e,null,n,s):Jd(e,t.child,n,s)}function gD(t,e,n,s,r){n=n.render;var o=e.ref;return Wd(e,r),s=FN(t,e,n,s,o,r),n=ON(),t!==null&&!eo?(e.updateQueue=t.updateQueue,e.flags&=-2053,t.lanes&=~r,mu(t,e,r)):(Fn&&n&&CN(e),e.flags|=1,Nr(t,e,s,r),e.child)}function yD(t,e,n,s,r){if(t===null){var o=n.type;return typeof o=="function"&&!jN(o)&&o.defaultProps===void 0&&n.compare===null&&n.defaultProps===void 0?(e.tag=15,e.type=o,xM(t,e,o,s,r)):(t=q1(n.type,null,s,e,e.mode,r),t.ref=e.ref,t.return=e,e.child=t)}if(o=t.child,!(t.lanes&r)){var i=o.memoizedProps;if(n=n.compare,n=n!==null?n:Eg,n(i,s)&&t.ref===e.ref)return mu(t,e,r)}return e.flags|=1,t=ll(o,s),t.ref=e.ref,t.return=e,e.child=t}function xM(t,e,n,s,r){if(t!==null){var o=t.memoizedProps;if(Eg(o,s)&&t.ref===e.ref)if(eo=!1,e.pendingProps=s=o,(t.lanes&r)!==0)t.flags&131072&&(eo=!0);else return e.lanes=t.lanes,mu(t,e,r)}return wI(t,e,n,s,r)}function vM(t,e,n){var s=e.pendingProps,r=s.children,o=t!==null?t.memoizedState:null;if(s.mode==="hidden")if(!(e.mode&1))e.memoizedState={baseLanes:0,cachePool:null,transitions:null},Cn(_d,ko),ko|=n;else{if(!(n&1073741824))return t=o!==null?o.baseLanes|n:n,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:t,cachePool:null,transitions:null},e.updateQueue=null,Cn(_d,ko),ko|=t,null;e.memoizedState={baseLanes:0,cachePool:null,transitions:null},s=o!==null?o.baseLanes:n,Cn(_d,ko),ko|=s}else o!==null?(s=o.baseLanes|n,e.memoizedState=null):s=n,Cn(_d,ko),ko|=s;return Nr(t,e,r,n),e.child}function wM(t,e){var n=e.ref;(t===null&&n!==null||t!==null&&t.ref!==n)&&(e.flags|=512,e.flags|=2097152)}function wI(t,e,n,s,r){var o=ro(n)?Kc:fr.current;return o=Qd(e,o),Wd(e,r),n=FN(t,e,n,s,o,r),s=ON(),t!==null&&!eo?(e.updateQueue=t.updateQueue,e.flags&=-2053,t.lanes&=~r,mu(t,e,r)):(Fn&&s&&CN(e),e.flags|=1,Nr(t,e,n,r),e.child)}function xD(t,e,n,s,r){if(ro(n)){var o=!0;mv(e)}else o=!1;if(Wd(e,r),e.stateNode===null)j1(t,e),KL(e,n,s),xI(e,n,s,r),s=!0;else if(t===null){var i=e.stateNode,a=e.memoizedProps;i.props=a;var u=i.context,l=n.contextType;typeof l=="object"&&l!==null?l=gi(l):(l=ro(n)?Kc:fr.current,l=Qd(e,l));var c=n.getDerivedStateFromProps,h=typeof c=="function"||typeof i.getSnapshotBeforeUpdate=="function";h||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(a!==s||u!==l)&&lD(e,i,s,l),Hu=!1;var d=e.memoizedState;i.state=d,wv(e,s,i,r),u=e.memoizedState,a!==s||d!==u||so.current||Hu?(typeof c=="function"&&(yI(e,n,c,s),u=e.memoizedState),(a=Hu||uD(e,n,a,s,d,u,l))?(h||typeof i.UNSAFE_componentWillMount!="function"&&typeof i.componentWillMount!="function"||(typeof i.componentWillMount=="function"&&i.componentWillMount(),typeof i.UNSAFE_componentWillMount=="function"&&i.UNSAFE_componentWillMount()),typeof i.componentDidMount=="function"&&(e.flags|=4194308)):(typeof i.componentDidMount=="function"&&(e.flags|=4194308),e.memoizedProps=s,e.memoizedState=u),i.props=s,i.state=u,i.context=l,s=a):(typeof i.componentDidMount=="function"&&(e.flags|=4194308),s=!1)}else{i=e.stateNode,HL(t,e),a=e.memoizedProps,l=e.type===e.elementType?a:Ai(e.type,a),i.props=l,h=e.pendingProps,d=i.context,u=n.contextType,typeof u=="object"&&u!==null?u=gi(u):(u=ro(n)?Kc:fr.current,u=Qd(e,u));var f=n.getDerivedStateFromProps;(c=typeof f=="function"||typeof i.getSnapshotBeforeUpdate=="function")||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(a!==h||d!==u)&&lD(e,i,s,u),Hu=!1,d=e.memoizedState,i.state=d,wv(e,s,i,r);var m=e.memoizedState;a!==h||d!==m||so.current||Hu?(typeof f=="function"&&(yI(e,n,f,s),m=e.memoizedState),(l=Hu||uD(e,n,l,s,d,m,u)||!1)?(c||typeof i.UNSAFE_componentWillUpdate!="function"&&typeof i.componentWillUpdate!="function"||(typeof i.componentWillUpdate=="function"&&i.componentWillUpdate(s,m,u),typeof i.UNSAFE_componentWillUpdate=="function"&&i.UNSAFE_componentWillUpdate(s,m,u)),typeof i.componentDidUpdate=="function"&&(e.flags|=4),typeof i.getSnapshotBeforeUpdate=="function"&&(e.flags|=1024)):(typeof i.componentDidUpdate!="function"||a===t.memoizedProps&&d===t.memoizedState||(e.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||a===t.memoizedProps&&d===t.memoizedState||(e.flags|=1024),e.memoizedProps=s,e.memoizedState=m),i.props=s,i.state=m,i.context=u,s=l):(typeof i.componentDidUpdate!="function"||a===t.memoizedProps&&d===t.memoizedState||(e.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||a===t.memoizedProps&&d===t.memoizedState||(e.flags|=1024),s=!1)}return bI(t,e,n,s,o,r)}function bI(t,e,n,s,r,o){wM(t,e);var i=(e.flags&128)!==0;if(!s&&!i)return r&&sD(e,n,!1),mu(t,e,o);s=e.stateNode,rQ.current=e;var a=i&&typeof n.getDerivedStateFromError!="function"?null:s.render();return e.flags|=1,t!==null&&i?(e.child=Jd(e,t.child,null,o),e.child=Jd(e,null,a,o)):Nr(t,e,a,o),e.memoizedState=s.state,r&&sD(e,n,!0),e.child}function bM(t){var e=t.stateNode;e.pendingContext?nD(t,e.pendingContext,e.pendingContext!==e.context):e.context&&nD(t,e.context,!1),AN(t,e.containerInfo)}function vD(t,e,n,s,r){return Zd(),IN(r),e.flags|=256,Nr(t,e,n,s),e.child}var SI={dehydrated:null,treeContext:null,retryLane:0};function CI(t){return{baseLanes:t,cachePool:null,transitions:null}}function SM(t,e,n){var s=e.pendingProps,r=Wn.current,o=!1,i=(e.flags&128)!==0,a;if((a=i)||(a=t!==null&&t.memoizedState===null?!1:(r&2)!==0),a?(o=!0,e.flags&=-129):(t===null||t.memoizedState!==null)&&(r|=1),Cn(Wn,r&1),t===null)return mI(e),t=e.memoizedState,t!==null&&(t=t.dehydrated,t!==null)?(e.mode&1?t.data==="$!"?e.lanes=8:e.lanes=1073741824:e.lanes=1,null):(i=s.children,t=s.fallback,o?(s=e.mode,o=e.child,i={mode:"hidden",children:i},!(s&1)&&o!==null?(o.childLanes=0,o.pendingProps=i):o=_w(i,s,0,null),t=Bc(t,s,n,null),o.return=e,t.return=e,o.sibling=t,e.child=o,e.child.memoizedState=CI(n),e.memoizedState=SI,t):zN(e,i));if(r=t.memoizedState,r!==null&&(a=r.dehydrated,a!==null))return oQ(t,e,i,s,a,r,n);if(o){o=s.fallback,i=e.mode,r=t.child,a=r.sibling;var u={mode:"hidden",children:s.children};return!(i&1)&&e.child!==r?(s=e.child,s.childLanes=0,s.pendingProps=u,e.deletions=null):(s=ll(r,u),s.subtreeFlags=r.subtreeFlags&14680064),a!==null?o=ll(a,o):(o=Bc(o,i,n,null),o.flags|=2),o.return=e,s.return=e,s.sibling=o,e.child=s,s=o,o=e.child,i=t.child.memoizedState,i=i===null?CI(n):{baseLanes:i.baseLanes|n,cachePool:null,transitions:i.transitions},o.memoizedState=i,o.childLanes=t.childLanes&~n,e.memoizedState=SI,s}return o=t.child,t=o.sibling,s=ll(o,{mode:"visible",children:s.children}),!(e.mode&1)&&(s.lanes=n),s.return=e,s.sibling=null,t!==null&&(n=e.deletions,n===null?(e.deletions=[t],e.flags|=16):n.push(t)),e.child=s,e.memoizedState=null,s}function zN(t,e){return e=_w({mode:"visible",children:e},t.mode,0,null),e.return=t,t.child=e}function p1(t,e,n,s){return s!==null&&IN(s),Jd(e,t.child,null,n),t=zN(e,e.pendingProps.children),t.flags|=2,e.memoizedState=null,t}function oQ(t,e,n,s,r,o,i){if(n)return e.flags&256?(e.flags&=-257,s=V2(Error(Re(422))),p1(t,e,i,s)):e.memoizedState!==null?(e.child=t.child,e.flags|=128,null):(o=s.fallback,r=e.mode,s=_w({mode:"visible",children:s.children},r,0,null),o=Bc(o,r,i,null),o.flags|=2,s.return=e,o.return=e,s.sibling=o,e.child=s,e.mode&1&&Jd(e,t.child,null,i),e.child.memoizedState=CI(i),e.memoizedState=SI,o);if(!(e.mode&1))return p1(t,e,i,null);if(r.data==="$!"){if(s=r.nextSibling&&r.nextSibling.dataset,s)var a=s.dgst;return s=a,o=Error(Re(419)),s=V2(o,s,void 0),p1(t,e,i,s)}if(a=(i&t.childLanes)!==0,eo||a){if(s=Bs,s!==null){switch(i&-i){case 4:r=2;break;case 16:r=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:r=32;break;case 536870912:r=268435456;break;default:r=0}r=r&(s.suspendedLanes|i)?0:r,r!==0&&r!==o.retryLane&&(o.retryLane=r,fu(t,r),Li(s,t,r,-1))}return HN(),s=V2(Error(Re(421))),p1(t,e,i,s)}return r.data==="$?"?(e.flags|=128,e.child=t.child,e=xQ.bind(null,t),r._reactRetry=e,null):(t=o.treeContext,$o=ol(r.nextSibling),To=e,Fn=!0,Di=null,t!==null&&(ni[si++]=tu,ni[si++]=nu,ni[si++]=Xc,tu=t.id,nu=t.overflow,Xc=e),e=zN(e,s.children),e.flags|=4096,e)}function wD(t,e,n){t.lanes|=e;var s=t.alternate;s!==null&&(s.lanes|=e),gI(t.return,e,n)}function W2(t,e,n,s,r){var o=t.memoizedState;o===null?t.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:s,tail:n,tailMode:r}:(o.isBackwards=e,o.rendering=null,o.renderingStartTime=0,o.last=s,o.tail=n,o.tailMode=r)}function CM(t,e,n){var s=e.pendingProps,r=s.revealOrder,o=s.tail;if(Nr(t,e,s.children,n),s=Wn.current,s&2)s=s&1|2,e.flags|=128;else{if(t!==null&&t.flags&128)e:for(t=e.child;t!==null;){if(t.tag===13)t.memoizedState!==null&&wD(t,n,e);else if(t.tag===19)wD(t,n,e);else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break e;for(;t.sibling===null;){if(t.return===null||t.return===e)break e;t=t.return}t.sibling.return=t.return,t=t.sibling}s&=1}if(Cn(Wn,s),!(e.mode&1))e.memoizedState=null;else switch(r){case"forwards":for(n=e.child,r=null;n!==null;)t=n.alternate,t!==null&&bv(t)===null&&(r=n),n=n.sibling;n=r,n===null?(r=e.child,e.child=null):(r=n.sibling,n.sibling=null),W2(e,!1,r,n,o);break;case"backwards":for(n=null,r=e.child,e.child=null;r!==null;){if(t=r.alternate,t!==null&&bv(t)===null){e.child=r;break}t=r.sibling,r.sibling=n,n=r,r=t}W2(e,!0,n,null,o);break;case"together":W2(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function j1(t,e){!(e.mode&1)&&t!==null&&(t.alternate=null,e.alternate=null,e.flags|=2)}function mu(t,e,n){if(t!==null&&(e.dependencies=t.dependencies),Yc|=e.lanes,!(n&e.childLanes))return null;if(t!==null&&e.child!==t.child)throw Error(Re(153));if(e.child!==null){for(t=e.child,n=ll(t,t.pendingProps),e.child=n,n.return=e;t.sibling!==null;)t=t.sibling,n=n.sibling=ll(t,t.pendingProps),n.return=e;n.sibling=null}return e.child}function iQ(t,e,n){switch(e.tag){case 3:bM(e),Zd();break;case 5:YL(e);break;case 1:ro(e.type)&&mv(e);break;case 4:AN(e,e.stateNode.containerInfo);break;case 10:var s=e.type._context,r=e.memoizedProps.value;Cn(xv,s._currentValue),s._currentValue=r;break;case 13:if(s=e.memoizedState,s!==null)return s.dehydrated!==null?(Cn(Wn,Wn.current&1),e.flags|=128,null):n&e.child.childLanes?SM(t,e,n):(Cn(Wn,Wn.current&1),t=mu(t,e,n),t!==null?t.sibling:null);Cn(Wn,Wn.current&1);break;case 19:if(s=(n&e.childLanes)!==0,t.flags&128){if(s)return CM(t,e,n);e.flags|=128}if(r=e.memoizedState,r!==null&&(r.rendering=null,r.tail=null,r.lastEffect=null),Cn(Wn,Wn.current),s)break;return null;case 22:case 23:return e.lanes=0,vM(t,e,n)}return mu(t,e,n)}var kM,kI,IM,$M;kM=function(t,e){for(var n=e.child;n!==null;){if(n.tag===5||n.tag===6)t.appendChild(n.stateNode);else if(n.tag!==4&&n.child!==null){n.child.return=n,n=n.child;continue}if(n===e)break;for(;n.sibling===null;){if(n.return===null||n.return===e)return;n=n.return}n.sibling.return=n.return,n=n.sibling}};kI=function(){};IM=function(t,e,n,s){var r=t.memoizedProps;if(r!==s){t=e.stateNode,Ac(ya.current);var o=null;switch(n){case"input":r=jk(t,r),s=jk(t,s),o=[];break;case"select":r=Kn({},r,{value:void 0}),s=Kn({},s,{value:void 0}),o=[];break;case"textarea":r=qk(t,r),s=qk(t,s),o=[];break;default:typeof r.onClick!="function"&&typeof s.onClick=="function"&&(t.onclick=pv)}Qk(n,s);var i;n=null;for(l in r)if(!s.hasOwnProperty(l)&&r.hasOwnProperty(l)&&r[l]!=null)if(l==="style"){var a=r[l];for(i in a)a.hasOwnProperty(i)&&(n||(n={}),n[i]="")}else l!=="dangerouslySetInnerHTML"&&l!=="children"&&l!=="suppressContentEditableWarning"&&l!=="suppressHydrationWarning"&&l!=="autoFocus"&&(Sg.hasOwnProperty(l)?o||(o=[]):(o=o||[]).push(l,null));for(l in s){var u=s[l];if(a=r!=null?r[l]:void 0,s.hasOwnProperty(l)&&u!==a&&(u!=null||a!=null))if(l==="style")if(a){for(i in a)!a.hasOwnProperty(i)||u&&u.hasOwnProperty(i)||(n||(n={}),n[i]="");for(i in u)u.hasOwnProperty(i)&&a[i]!==u[i]&&(n||(n={}),n[i]=u[i])}else n||(o||(o=[]),o.push(l,n)),n=u;else l==="dangerouslySetInnerHTML"?(u=u?u.__html:void 0,a=a?a.__html:void 0,u!=null&&a!==u&&(o=o||[]).push(l,u)):l==="children"?typeof u!="string"&&typeof u!="number"||(o=o||[]).push(l,""+u):l!=="suppressContentEditableWarning"&&l!=="suppressHydrationWarning"&&(Sg.hasOwnProperty(l)?(u!=null&&l==="onScroll"&&Tn("scroll",t),o||a===u||(o=[])):(o=o||[]).push(l,u))}n&&(o=o||[]).push("style",n);var l=o;(e.updateQueue=l)&&(e.flags|=4)}};$M=function(t,e,n,s){n!==s&&(e.flags|=4)};function Lm(t,e){if(!Fn)switch(t.tailMode){case"hidden":e=t.tail;for(var n=null;e!==null;)e.alternate!==null&&(n=e),e=e.sibling;n===null?t.tail=null:n.sibling=null;break;case"collapsed":n=t.tail;for(var s=null;n!==null;)n.alternate!==null&&(s=n),n=n.sibling;s===null?e||t.tail===null?t.tail=null:t.tail.sibling=null:s.sibling=null}}function ir(t){var e=t.alternate!==null&&t.alternate.child===t.child,n=0,s=0;if(e)for(var r=t.child;r!==null;)n|=r.lanes|r.childLanes,s|=r.subtreeFlags&14680064,s|=r.flags&14680064,r.return=t,r=r.sibling;else for(r=t.child;r!==null;)n|=r.lanes|r.childLanes,s|=r.subtreeFlags,s|=r.flags,r.return=t,r=r.sibling;return t.subtreeFlags|=s,t.childLanes=n,e}function aQ(t,e,n){var s=e.pendingProps;switch(kN(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return ir(e),null;case 1:return ro(e.type)&&fv(),ir(e),null;case 3:return s=e.stateNode,ep(),En(so),En(fr),DN(),s.pendingContext&&(s.context=s.pendingContext,s.pendingContext=null),(t===null||t.child===null)&&(h1(e)?e.flags|=4:t===null||t.memoizedState.isDehydrated&&!(e.flags&256)||(e.flags|=1024,Di!==null&&(_I(Di),Di=null))),kI(t,e),ir(e),null;case 5:_N(e);var r=Ac(Pg.current);if(n=e.type,t!==null&&e.stateNode!=null)IM(t,e,n,s,r),t.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!s){if(e.stateNode===null)throw Error(Re(166));return ir(e),null}if(t=Ac(ya.current),h1(e)){s=e.stateNode,n=e.type;var o=e.memoizedProps;switch(s[pa]=e,s[_g]=o,t=(e.mode&1)!==0,n){case"dialog":Tn("cancel",s),Tn("close",s);break;case"iframe":case"object":case"embed":Tn("load",s);break;case"video":case"audio":for(r=0;r<Qm.length;r++)Tn(Qm[r],s);break;case"source":Tn("error",s);break;case"img":case"image":case"link":Tn("error",s),Tn("load",s);break;case"details":Tn("toggle",s);break;case"input":E_(s,o),Tn("invalid",s);break;case"select":s._wrapperState={wasMultiple:!!o.multiple},Tn("invalid",s);break;case"textarea":A_(s,o),Tn("invalid",s)}Qk(n,o),r=null;for(var i in o)if(o.hasOwnProperty(i)){var a=o[i];i==="children"?typeof a=="string"?s.textContent!==a&&(o.suppressHydrationWarning!==!0&&c1(s.textContent,a,t),r=["children",a]):typeof a=="number"&&s.textContent!==""+a&&(o.suppressHydrationWarning!==!0&&c1(s.textContent,a,t),r=["children",""+a]):Sg.hasOwnProperty(i)&&a!=null&&i==="onScroll"&&Tn("scroll",s)}switch(n){case"input":n1(s),R_(s,o,!0);break;case"textarea":n1(s),__(s);break;case"select":case"option":break;default:typeof o.onClick=="function"&&(s.onclick=pv)}s=r,e.updateQueue=s,s!==null&&(e.flags|=4)}else{i=r.nodeType===9?r:r.ownerDocument,t==="http://www.w3.org/1999/xhtml"&&(t=JO(n)),t==="http://www.w3.org/1999/xhtml"?n==="script"?(t=i.createElement("div"),t.innerHTML="<script><\/script>",t=t.removeChild(t.firstChild)):typeof s.is=="string"?t=i.createElement(n,{is:s.is}):(t=i.createElement(n),n==="select"&&(i=t,s.multiple?i.multiple=!0:s.size&&(i.size=s.size))):t=i.createElementNS(t,n),t[pa]=e,t[_g]=s,kM(t,e,!1,!1),e.stateNode=t;e:{switch(i=Zk(n,s),n){case"dialog":Tn("cancel",t),Tn("close",t),r=s;break;case"iframe":case"object":case"embed":Tn("load",t),r=s;break;case"video":case"audio":for(r=0;r<Qm.length;r++)Tn(Qm[r],t);r=s;break;case"source":Tn("error",t),r=s;break;case"img":case"image":case"link":Tn("error",t),Tn("load",t),r=s;break;case"details":Tn("toggle",t),r=s;break;case"input":E_(t,s),r=jk(t,s),Tn("invalid",t);break;case"option":r=s;break;case"select":t._wrapperState={wasMultiple:!!s.multiple},r=Kn({},s,{value:void 0}),Tn("invalid",t);break;case"textarea":A_(t,s),r=qk(t,s),Tn("invalid",t);break;default:r=s}Qk(n,r),a=r;for(o in a)if(a.hasOwnProperty(o)){var u=a[o];o==="style"?nL(t,u):o==="dangerouslySetInnerHTML"?(u=u?u.__html:void 0,u!=null&&eL(t,u)):o==="children"?typeof u=="string"?(n!=="textarea"||u!=="")&&Cg(t,u):typeof u=="number"&&Cg(t,""+u):o!=="suppressContentEditableWarning"&&o!=="suppressHydrationWarning"&&o!=="autoFocus"&&(Sg.hasOwnProperty(o)?u!=null&&o==="onScroll"&&Tn("scroll",t):u!=null&&lN(t,o,u,i))}switch(n){case"input":n1(t),R_(t,s,!1);break;case"textarea":n1(t),__(t);break;case"option":s.value!=null&&t.setAttribute("value",""+gl(s.value));break;case"select":t.multiple=!!s.multiple,o=s.value,o!=null?Md(t,!!s.multiple,o,!1):s.defaultValue!=null&&Md(t,!!s.multiple,s.defaultValue,!0);break;default:typeof r.onClick=="function"&&(t.onclick=pv)}switch(n){case"button":case"input":case"select":case"textarea":s=!!s.autoFocus;break e;case"img":s=!0;break e;default:s=!1}}s&&(e.flags|=4)}e.ref!==null&&(e.flags|=512,e.flags|=2097152)}return ir(e),null;case 6:if(t&&e.stateNode!=null)$M(t,e,t.memoizedProps,s);else{if(typeof s!="string"&&e.stateNode===null)throw Error(Re(166));if(n=Ac(Pg.current),Ac(ya.current),h1(e)){if(s=e.stateNode,n=e.memoizedProps,s[pa]=e,(o=s.nodeValue!==n)&&(t=To,t!==null))switch(t.tag){case 3:c1(s.nodeValue,n,(t.mode&1)!==0);break;case 5:t.memoizedProps.suppressHydrationWarning!==!0&&c1(s.nodeValue,n,(t.mode&1)!==0)}o&&(e.flags|=4)}else s=(n.nodeType===9?n:n.ownerDocument).createTextNode(s),s[pa]=e,e.stateNode=s}return ir(e),null;case 13:if(En(Wn),s=e.memoizedState,t===null||t.memoizedState!==null&&t.memoizedState.dehydrated!==null){if(Fn&&$o!==null&&e.mode&1&&!(e.flags&128))UL(),Zd(),e.flags|=98560,o=!1;else if(o=h1(e),s!==null&&s.dehydrated!==null){if(t===null){if(!o)throw Error(Re(318));if(o=e.memoizedState,o=o!==null?o.dehydrated:null,!o)throw Error(Re(317));o[pa]=e}else Zd(),!(e.flags&128)&&(e.memoizedState=null),e.flags|=4;ir(e),o=!1}else Di!==null&&(_I(Di),Di=null),o=!0;if(!o)return e.flags&65536?e:null}return e.flags&128?(e.lanes=n,e):(s=s!==null,s!==(t!==null&&t.memoizedState!==null)&&s&&(e.child.flags|=8192,e.mode&1&&(t===null||Wn.current&1?Es===0&&(Es=3):HN())),e.updateQueue!==null&&(e.flags|=4),ir(e),null);case 4:return ep(),kI(t,e),t===null&&Rg(e.stateNode.containerInfo),ir(e),null;case 10:return TN(e.type._context),ir(e),null;case 17:return ro(e.type)&&fv(),ir(e),null;case 19:if(En(Wn),o=e.memoizedState,o===null)return ir(e),null;if(s=(e.flags&128)!==0,i=o.rendering,i===null)if(s)Lm(o,!1);else{if(Es!==0||t!==null&&t.flags&128)for(t=e.child;t!==null;){if(i=bv(t),i!==null){for(e.flags|=128,Lm(o,!1),s=i.updateQueue,s!==null&&(e.updateQueue=s,e.flags|=4),e.subtreeFlags=0,s=n,n=e.child;n!==null;)o=n,t=s,o.flags&=14680066,i=o.alternate,i===null?(o.childLanes=0,o.lanes=t,o.child=null,o.subtreeFlags=0,o.memoizedProps=null,o.memoizedState=null,o.updateQueue=null,o.dependencies=null,o.stateNode=null):(o.childLanes=i.childLanes,o.lanes=i.lanes,o.child=i.child,o.subtreeFlags=0,o.deletions=null,o.memoizedProps=i.memoizedProps,o.memoizedState=i.memoizedState,o.updateQueue=i.updateQueue,o.type=i.type,t=i.dependencies,o.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext}),n=n.sibling;return Cn(Wn,Wn.current&1|2),e.child}t=t.sibling}o.tail!==null&&as()>np&&(e.flags|=128,s=!0,Lm(o,!1),e.lanes=4194304)}else{if(!s)if(t=bv(i),t!==null){if(e.flags|=128,s=!0,n=t.updateQueue,n!==null&&(e.updateQueue=n,e.flags|=4),Lm(o,!0),o.tail===null&&o.tailMode==="hidden"&&!i.alternate&&!Fn)return ir(e),null}else 2*as()-o.renderingStartTime>np&&n!==1073741824&&(e.flags|=128,s=!0,Lm(o,!1),e.lanes=4194304);o.isBackwards?(i.sibling=e.child,e.child=i):(n=o.last,n!==null?n.sibling=i:e.child=i,o.last=i)}return o.tail!==null?(e=o.tail,o.rendering=e,o.tail=e.sibling,o.renderingStartTime=as(),e.sibling=null,n=Wn.current,Cn(Wn,s?n&1|2:n&1),e):(ir(e),null);case 22:case 23:return GN(),s=e.memoizedState!==null,t!==null&&t.memoizedState!==null!==s&&(e.flags|=8192),s&&e.mode&1?ko&1073741824&&(ir(e),e.subtreeFlags&6&&(e.flags|=8192)):ir(e),null;case 24:return null;case 25:return null}throw Error(Re(156,e.tag))}function uQ(t,e){switch(kN(e),e.tag){case 1:return ro(e.type)&&fv(),t=e.flags,t&65536?(e.flags=t&-65537|128,e):null;case 3:return ep(),En(so),En(fr),DN(),t=e.flags,t&65536&&!(t&128)?(e.flags=t&-65537|128,e):null;case 5:return _N(e),null;case 13:if(En(Wn),t=e.memoizedState,t!==null&&t.dehydrated!==null){if(e.alternate===null)throw Error(Re(340));Zd()}return t=e.flags,t&65536?(e.flags=t&-65537|128,e):null;case 19:return En(Wn),null;case 4:return ep(),null;case 10:return TN(e.type._context),null;case 22:case 23:return GN(),null;case 24:return null;default:return null}}var f1=!1,hr=!1,lQ=typeof WeakSet=="function"?WeakSet:Set,qe=null;function Ad(t,e){var n=t.ref;if(n!==null)if(typeof n=="function")try{n(null)}catch(s){Qn(t,e,s)}else n.current=null}function II(t,e,n){try{n()}catch(s){Qn(t,e,s)}}var bD=!1;function cQ(t,e){if(uI=cv,t=RL(),SN(t)){if("selectionStart"in t)var n={start:t.selectionStart,end:t.selectionEnd};else e:{n=(n=t.ownerDocument)&&n.defaultView||window;var s=n.getSelection&&n.getSelection();if(s&&s.rangeCount!==0){n=s.anchorNode;var r=s.anchorOffset,o=s.focusNode;s=s.focusOffset;try{n.nodeType,o.nodeType}catch{n=null;break e}var i=0,a=-1,u=-1,l=0,c=0,h=t,d=null;t:for(;;){for(var f;h!==n||r!==0&&h.nodeType!==3||(a=i+r),h!==o||s!==0&&h.nodeType!==3||(u=i+s),h.nodeType===3&&(i+=h.nodeValue.length),(f=h.firstChild)!==null;)d=h,h=f;for(;;){if(h===t)break t;if(d===n&&++l===r&&(a=i),d===o&&++c===s&&(u=i),(f=h.nextSibling)!==null)break;h=d,d=h.parentNode}h=f}n=a===-1||u===-1?null:{start:a,end:u}}else n=null}n=n||{start:0,end:0}}else n=null;for(lI={focusedElem:t,selectionRange:n},cv=!1,qe=e;qe!==null;)if(e=qe,t=e.child,(e.subtreeFlags&1028)!==0&&t!==null)t.return=e,qe=t;else for(;qe!==null;){e=qe;try{var m=e.alternate;if(e.flags&1024)switch(e.tag){case 0:case 11:case 15:break;case 1:if(m!==null){var y=m.memoizedProps,x=m.memoizedState,v=e.stateNode,w=v.getSnapshotBeforeUpdate(e.elementType===e.type?y:Ai(e.type,y),x);v.__reactInternalSnapshotBeforeUpdate=w}break;case 3:var S=e.stateNode.containerInfo;S.nodeType===1?S.textContent="":S.nodeType===9&&S.documentElement&&S.removeChild(S.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(Re(163))}}catch(k){Qn(e,e.return,k)}if(t=e.sibling,t!==null){t.return=e.return,qe=t;break}qe=e.return}return m=bD,bD=!1,m}function dg(t,e,n){var s=e.updateQueue;if(s=s!==null?s.lastEffect:null,s!==null){var r=s=s.next;do{if((r.tag&t)===t){var o=r.destroy;r.destroy=void 0,o!==void 0&&II(e,n,o)}r=r.next}while(r!==s)}}function Rw(t,e){if(e=e.updateQueue,e=e!==null?e.lastEffect:null,e!==null){var n=e=e.next;do{if((n.tag&t)===t){var s=n.create;n.destroy=s()}n=n.next}while(n!==e)}}function $I(t){var e=t.ref;if(e!==null){var n=t.stateNode;switch(t.tag){case 5:t=n;break;default:t=n}typeof e=="function"?e(t):e.current=t}}function NM(t){var e=t.alternate;e!==null&&(t.alternate=null,NM(e)),t.child=null,t.deletions=null,t.sibling=null,t.tag===5&&(e=t.stateNode,e!==null&&(delete e[pa],delete e[_g],delete e[dI],delete e[jY],delete e[KY])),t.stateNode=null,t.return=null,t.dependencies=null,t.memoizedProps=null,t.memoizedState=null,t.pendingProps=null,t.stateNode=null,t.updateQueue=null}function TM(t){return t.tag===5||t.tag===3||t.tag===4}function SD(t){e:for(;;){for(;t.sibling===null;){if(t.return===null||TM(t.return))return null;t=t.return}for(t.sibling.return=t.return,t=t.sibling;t.tag!==5&&t.tag!==6&&t.tag!==18;){if(t.flags&2||t.child===null||t.tag===4)continue e;t.child.return=t,t=t.child}if(!(t.flags&2))return t.stateNode}}function NI(t,e,n){var s=t.tag;if(s===5||s===6)t=t.stateNode,e?n.nodeType===8?n.parentNode.insertBefore(t,e):n.insertBefore(t,e):(n.nodeType===8?(e=n.parentNode,e.insertBefore(t,n)):(e=n,e.appendChild(t)),n=n._reactRootContainer,n!=null||e.onclick!==null||(e.onclick=pv));else if(s!==4&&(t=t.child,t!==null))for(NI(t,e,n),t=t.sibling;t!==null;)NI(t,e,n),t=t.sibling}function TI(t,e,n){var s=t.tag;if(s===5||s===6)t=t.stateNode,e?n.insertBefore(t,e):n.appendChild(t);else if(s!==4&&(t=t.child,t!==null))for(TI(t,e,n),t=t.sibling;t!==null;)TI(t,e,n),t=t.sibling}var Ks=null,_i=!1;function zu(t,e,n){for(n=n.child;n!==null;)EM(t,e,n),n=n.sibling}function EM(t,e,n){if(ga&&typeof ga.onCommitFiberUnmount=="function")try{ga.onCommitFiberUnmount(Sw,n)}catch{}switch(n.tag){case 5:hr||Ad(n,e);case 6:var s=Ks,r=_i;Ks=null,zu(t,e,n),Ks=s,_i=r,Ks!==null&&(_i?(t=Ks,n=n.stateNode,t.nodeType===8?t.parentNode.removeChild(n):t.removeChild(n)):Ks.removeChild(n.stateNode));break;case 18:Ks!==null&&(_i?(t=Ks,n=n.stateNode,t.nodeType===8?F2(t.parentNode,n):t.nodeType===1&&F2(t,n),Ng(t)):F2(Ks,n.stateNode));break;case 4:s=Ks,r=_i,Ks=n.stateNode.containerInfo,_i=!0,zu(t,e,n),Ks=s,_i=r;break;case 0:case 11:case 14:case 15:if(!hr&&(s=n.updateQueue,s!==null&&(s=s.lastEffect,s!==null))){r=s=s.next;do{var o=r,i=o.destroy;o=o.tag,i!==void 0&&(o&2||o&4)&&II(n,e,i),r=r.next}while(r!==s)}zu(t,e,n);break;case 1:if(!hr&&(Ad(n,e),s=n.stateNode,typeof s.componentWillUnmount=="function"))try{s.props=n.memoizedProps,s.state=n.memoizedState,s.componentWillUnmount()}catch(a){Qn(n,e,a)}zu(t,e,n);break;case 21:zu(t,e,n);break;case 22:n.mode&1?(hr=(s=hr)||n.memoizedState!==null,zu(t,e,n),hr=s):zu(t,e,n);break;default:zu(t,e,n)}}function CD(t){var e=t.updateQueue;if(e!==null){t.updateQueue=null;var n=t.stateNode;n===null&&(n=t.stateNode=new lQ),e.forEach(function(s){var r=vQ.bind(null,t,s);n.has(s)||(n.add(s),s.then(r,r))})}}function Ti(t,e){var n=e.deletions;if(n!==null)for(var s=0;s<n.length;s++){var r=n[s];try{var o=t,i=e,a=i;e:for(;a!==null;){switch(a.tag){case 5:Ks=a.stateNode,_i=!1;break e;case 3:Ks=a.stateNode.containerInfo,_i=!0;break e;case 4:Ks=a.stateNode.containerInfo,_i=!0;break e}a=a.return}if(Ks===null)throw Error(Re(160));EM(o,i,r),Ks=null,_i=!1;var u=r.alternate;u!==null&&(u.return=null),r.return=null}catch(l){Qn(r,e,l)}}if(e.subtreeFlags&12854)for(e=e.child;e!==null;)RM(e,t),e=e.sibling}function RM(t,e){var n=t.alternate,s=t.flags;switch(t.tag){case 0:case 11:case 14:case 15:if(Ti(e,t),aa(t),s&4){try{dg(3,t,t.return),Rw(3,t)}catch(y){Qn(t,t.return,y)}try{dg(5,t,t.return)}catch(y){Qn(t,t.return,y)}}break;case 1:Ti(e,t),aa(t),s&512&&n!==null&&Ad(n,n.return);break;case 5:if(Ti(e,t),aa(t),s&512&&n!==null&&Ad(n,n.return),t.flags&32){var r=t.stateNode;try{Cg(r,"")}catch(y){Qn(t,t.return,y)}}if(s&4&&(r=t.stateNode,r!=null)){var o=t.memoizedProps,i=n!==null?n.memoizedProps:o,a=t.type,u=t.updateQueue;if(t.updateQueue=null,u!==null)try{a==="input"&&o.type==="radio"&&o.name!=null&&QO(r,o),Zk(a,i);var l=Zk(a,o);for(i=0;i<u.length;i+=2){var c=u[i],h=u[i+1];c==="style"?nL(r,h):c==="dangerouslySetInnerHTML"?eL(r,h):c==="children"?Cg(r,h):lN(r,c,h,l)}switch(a){case"input":Kk(r,o);break;case"textarea":ZO(r,o);break;case"select":var d=r._wrapperState.wasMultiple;r._wrapperState.wasMultiple=!!o.multiple;var f=o.value;f!=null?Md(r,!!o.multiple,f,!1):d!==!!o.multiple&&(o.defaultValue!=null?Md(r,!!o.multiple,o.defaultValue,!0):Md(r,!!o.multiple,o.multiple?[]:"",!1))}r[_g]=o}catch(y){Qn(t,t.return,y)}}break;case 6:if(Ti(e,t),aa(t),s&4){if(t.stateNode===null)throw Error(Re(162));r=t.stateNode,o=t.memoizedProps;try{r.nodeValue=o}catch(y){Qn(t,t.return,y)}}break;case 3:if(Ti(e,t),aa(t),s&4&&n!==null&&n.memoizedState.isDehydrated)try{Ng(e.containerInfo)}catch(y){Qn(t,t.return,y)}break;case 4:Ti(e,t),aa(t);break;case 13:Ti(e,t),aa(t),r=t.child,r.flags&8192&&(o=r.memoizedState!==null,r.stateNode.isHidden=o,!o||r.alternate!==null&&r.alternate.memoizedState!==null||(WN=as())),s&4&&CD(t);break;case 22:if(c=n!==null&&n.memoizedState!==null,t.mode&1?(hr=(l=hr)||c,Ti(e,t),hr=l):Ti(e,t),aa(t),s&8192){if(l=t.memoizedState!==null,(t.stateNode.isHidden=l)&&!c&&t.mode&1)for(qe=t,c=t.child;c!==null;){for(h=qe=c;qe!==null;){switch(d=qe,f=d.child,d.tag){case 0:case 11:case 14:case 15:dg(4,d,d.return);break;case 1:Ad(d,d.return);var m=d.stateNode;if(typeof m.componentWillUnmount=="function"){s=d,n=d.return;try{e=s,m.props=e.memoizedProps,m.state=e.memoizedState,m.componentWillUnmount()}catch(y){Qn(s,n,y)}}break;case 5:Ad(d,d.return);break;case 22:if(d.memoizedState!==null){ID(h);continue}}f!==null?(f.return=d,qe=f):ID(h)}c=c.sibling}e:for(c=null,h=t;;){if(h.tag===5){if(c===null){c=h;try{r=h.stateNode,l?(o=r.style,typeof o.setProperty=="function"?o.setProperty("display","none","important"):o.display="none"):(a=h.stateNode,u=h.memoizedProps.style,i=u!=null&&u.hasOwnProperty("display")?u.display:null,a.style.display=tL("display",i))}catch(y){Qn(t,t.return,y)}}}else if(h.tag===6){if(c===null)try{h.stateNode.nodeValue=l?"":h.memoizedProps}catch(y){Qn(t,t.return,y)}}else if((h.tag!==22&&h.tag!==23||h.memoizedState===null||h===t)&&h.child!==null){h.child.return=h,h=h.child;continue}if(h===t)break e;for(;h.sibling===null;){if(h.return===null||h.return===t)break e;c===h&&(c=null),h=h.return}c===h&&(c=null),h.sibling.return=h.return,h=h.sibling}}break;case 19:Ti(e,t),aa(t),s&4&&CD(t);break;case 21:break;default:Ti(e,t),aa(t)}}function aa(t){var e=t.flags;if(e&2){try{e:{for(var n=t.return;n!==null;){if(TM(n)){var s=n;break e}n=n.return}throw Error(Re(160))}switch(s.tag){case 5:var r=s.stateNode;s.flags&32&&(Cg(r,""),s.flags&=-33);var o=SD(t);TI(t,o,r);break;case 3:case 4:var i=s.stateNode.containerInfo,a=SD(t);NI(t,a,i);break;default:throw Error(Re(161))}}catch(u){Qn(t,t.return,u)}t.flags&=-3}e&4096&&(t.flags&=-4097)}function hQ(t,e,n){qe=t,AM(t)}function AM(t,e,n){for(var s=(t.mode&1)!==0;qe!==null;){var r=qe,o=r.child;if(r.tag===22&&s){var i=r.memoizedState!==null||f1;if(!i){var a=r.alternate,u=a!==null&&a.memoizedState!==null||hr;a=f1;var l=hr;if(f1=i,(hr=u)&&!l)for(qe=r;qe!==null;)i=qe,u=i.child,i.tag===22&&i.memoizedState!==null?$D(r):u!==null?(u.return=i,qe=u):$D(r);for(;o!==null;)qe=o,AM(o),o=o.sibling;qe=r,f1=a,hr=l}kD(t)}else r.subtreeFlags&8772&&o!==null?(o.return=r,qe=o):kD(t)}}function kD(t){for(;qe!==null;){var e=qe;if(e.flags&8772){var n=e.alternate;try{if(e.flags&8772)switch(e.tag){case 0:case 11:case 15:hr||Rw(5,e);break;case 1:var s=e.stateNode;if(e.flags&4&&!hr)if(n===null)s.componentDidMount();else{var r=e.elementType===e.type?n.memoizedProps:Ai(e.type,n.memoizedProps);s.componentDidUpdate(r,n.memoizedState,s.__reactInternalSnapshotBeforeUpdate)}var o=e.updateQueue;o!==null&&aD(e,o,s);break;case 3:var i=e.updateQueue;if(i!==null){if(n=null,e.child!==null)switch(e.child.tag){case 5:n=e.child.stateNode;break;case 1:n=e.child.stateNode}aD(e,i,n)}break;case 5:var a=e.stateNode;if(n===null&&e.flags&4){n=a;var u=e.memoizedProps;switch(e.type){case"button":case"input":case"select":case"textarea":u.autoFocus&&n.focus();break;case"img":u.src&&(n.src=u.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(e.memoizedState===null){var l=e.alternate;if(l!==null){var c=l.memoizedState;if(c!==null){var h=c.dehydrated;h!==null&&Ng(h)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(Re(163))}hr||e.flags&512&&$I(e)}catch(d){Qn(e,e.return,d)}}if(e===t){qe=null;break}if(n=e.sibling,n!==null){n.return=e.return,qe=n;break}qe=e.return}}function ID(t){for(;qe!==null;){var e=qe;if(e===t){qe=null;break}var n=e.sibling;if(n!==null){n.return=e.return,qe=n;break}qe=e.return}}function $D(t){for(;qe!==null;){var e=qe;try{switch(e.tag){case 0:case 11:case 15:var n=e.return;try{Rw(4,e)}catch(u){Qn(e,n,u)}break;case 1:var s=e.stateNode;if(typeof s.componentDidMount=="function"){var r=e.return;try{s.componentDidMount()}catch(u){Qn(e,r,u)}}var o=e.return;try{$I(e)}catch(u){Qn(e,o,u)}break;case 5:var i=e.return;try{$I(e)}catch(u){Qn(e,i,u)}}}catch(u){Qn(e,e.return,u)}if(e===t){qe=null;break}var a=e.sibling;if(a!==null){a.return=e.return,qe=a;break}qe=e.return}}var dQ=Math.ceil,kv=bu.ReactCurrentDispatcher,BN=bu.ReactCurrentOwner,di=bu.ReactCurrentBatchConfig,Qt=0,Bs=null,fs=null,qs=0,ko=0,_d=Dl(0),Es=0,Mg=null,Yc=0,Aw=0,VN=0,pg=null,Zr=null,WN=0,np=1/0,qa=null,Iv=!1,EI=null,al=null,m1=!1,Qu=null,$v=0,fg=0,RI=null,K1=-1,X1=0;function _r(){return Qt&6?as():K1!==-1?K1:K1=as()}function ul(t){return t.mode&1?Qt&2&&qs!==0?qs&-qs:qY.transition!==null?(X1===0&&(X1=fL()),X1):(t=un,t!==0||(t=window.event,t=t===void 0?16:bL(t.type)),t):1}function Li(t,e,n,s){if(50<fg)throw fg=0,RI=null,Error(Re(185));dy(t,n,s),(!(Qt&2)||t!==Bs)&&(t===Bs&&(!(Qt&2)&&(Aw|=n),Es===4&&qu(t,qs)),oo(t,s),n===1&&Qt===0&&!(e.mode&1)&&(np=as()+500,Nw&&Pl()))}function oo(t,e){var n=t.callbackNode;q9(t,e);var s=lv(t,t===Bs?qs:0);if(s===0)n!==null&&F_(n),t.callbackNode=null,t.callbackPriority=0;else if(e=s&-s,t.callbackPriority!==e){if(n!=null&&F_(n),e===1)t.tag===0?XY(ND.bind(null,t)):BL(ND.bind(null,t)),GY(function(){!(Qt&6)&&Pl()}),n=null;else{switch(mL(s)){case 1:n=fN;break;case 4:n=dL;break;case 16:n=uv;break;case 536870912:n=pL;break;default:n=uv}n=zM(n,_M.bind(null,t))}t.callbackPriority=e,t.callbackNode=n}}function _M(t,e){if(K1=-1,X1=0,Qt&6)throw Error(Re(327));var n=t.callbackNode;if(Ud()&&t.callbackNode!==n)return null;var s=lv(t,t===Bs?qs:0);if(s===0)return null;if(s&30||s&t.expiredLanes||e)e=Nv(t,s);else{e=s;var r=Qt;Qt|=2;var o=PM();(Bs!==t||qs!==e)&&(qa=null,np=as()+500,zc(t,e));do try{mQ();break}catch(a){DM(t,a)}while(!0);NN(),kv.current=o,Qt=r,fs!==null?e=0:(Bs=null,qs=0,e=Es)}if(e!==0){if(e===2&&(r=sI(t),r!==0&&(s=r,e=AI(t,r))),e===1)throw n=Mg,zc(t,0),qu(t,s),oo(t,as()),n;if(e===6)qu(t,s);else{if(r=t.current.alternate,!(s&30)&&!pQ(r)&&(e=Nv(t,s),e===2&&(o=sI(t),o!==0&&(s=o,e=AI(t,o))),e===1))throw n=Mg,zc(t,0),qu(t,s),oo(t,as()),n;switch(t.finishedWork=r,t.finishedLanes=s,e){case 0:case 1:throw Error(Re(345));case 2:vc(t,Zr,qa);break;case 3:if(qu(t,s),(s&130023424)===s&&(e=WN+500-as(),10<e)){if(lv(t,0)!==0)break;if(r=t.suspendedLanes,(r&s)!==s){_r(),t.pingedLanes|=t.suspendedLanes&r;break}t.timeoutHandle=hI(vc.bind(null,t,Zr,qa),e);break}vc(t,Zr,qa);break;case 4:if(qu(t,s),(s&4194240)===s)break;for(e=t.eventTimes,r=-1;0<s;){var i=31-Oi(s);o=1<<i,i=e[i],i>r&&(r=i),s&=~o}if(s=r,s=as()-s,s=(120>s?120:480>s?480:1080>s?1080:1920>s?1920:3e3>s?3e3:4320>s?4320:1960*dQ(s/1960))-s,10<s){t.timeoutHandle=hI(vc.bind(null,t,Zr,qa),s);break}vc(t,Zr,qa);break;case 5:vc(t,Zr,qa);break;default:throw Error(Re(329))}}}return oo(t,as()),t.callbackNode===n?_M.bind(null,t):null}function AI(t,e){var n=pg;return t.current.memoizedState.isDehydrated&&(zc(t,e).flags|=256),t=Nv(t,e),t!==2&&(e=Zr,Zr=n,e!==null&&_I(e)),t}function _I(t){Zr===null?Zr=t:Zr.push.apply(Zr,t)}function pQ(t){for(var e=t;;){if(e.flags&16384){var n=e.updateQueue;if(n!==null&&(n=n.stores,n!==null))for(var s=0;s<n.length;s++){var r=n[s],o=r.getSnapshot;r=r.value;try{if(!Bi(o(),r))return!1}catch{return!1}}}if(n=e.child,e.subtreeFlags&16384&&n!==null)n.return=e,e=n;else{if(e===t)break;for(;e.sibling===null;){if(e.return===null||e.return===t)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}function qu(t,e){for(e&=~VN,e&=~Aw,t.suspendedLanes|=e,t.pingedLanes&=~e,t=t.expirationTimes;0<e;){var n=31-Oi(e),s=1<<n;t[n]=-1,e&=~s}}function ND(t){if(Qt&6)throw Error(Re(327));Ud();var e=lv(t,0);if(!(e&1))return oo(t,as()),null;var n=Nv(t,e);if(t.tag!==0&&n===2){var s=sI(t);s!==0&&(e=s,n=AI(t,s))}if(n===1)throw n=Mg,zc(t,0),qu(t,e),oo(t,as()),n;if(n===6)throw Error(Re(345));return t.finishedWork=t.current.alternate,t.finishedLanes=e,vc(t,Zr,qa),oo(t,as()),null}function UN(t,e){var n=Qt;Qt|=1;try{return t(e)}finally{Qt=n,Qt===0&&(np=as()+500,Nw&&Pl())}}function Qc(t){Qu!==null&&Qu.tag===0&&!(Qt&6)&&Ud();var e=Qt;Qt|=1;var n=di.transition,s=un;try{if(di.transition=null,un=1,t)return t()}finally{un=s,di.transition=n,Qt=e,!(Qt&6)&&Pl()}}function GN(){ko=_d.current,En(_d)}function zc(t,e){t.finishedWork=null,t.finishedLanes=0;var n=t.timeoutHandle;if(n!==-1&&(t.timeoutHandle=-1,UY(n)),fs!==null)for(n=fs.return;n!==null;){var s=n;switch(kN(s),s.tag){case 1:s=s.type.childContextTypes,s!=null&&fv();break;case 3:ep(),En(so),En(fr),DN();break;case 5:_N(s);break;case 4:ep();break;case 13:En(Wn);break;case 19:En(Wn);break;case 10:TN(s.type._context);break;case 22:case 23:GN()}n=n.return}if(Bs=t,fs=t=ll(t.current,null),qs=ko=e,Es=0,Mg=null,VN=Aw=Yc=0,Zr=pg=null,Rc!==null){for(e=0;e<Rc.length;e++)if(n=Rc[e],s=n.interleaved,s!==null){n.interleaved=null;var r=s.next,o=n.pending;if(o!==null){var i=o.next;o.next=r,s.next=i}n.pending=s}Rc=null}return t}function DM(t,e){do{var n=fs;try{if(NN(),G1.current=Cv,Sv){for(var s=jn.memoizedState;s!==null;){var r=s.queue;r!==null&&(r.pending=null),s=s.next}Sv=!1}if(qc=0,Ls=Ns=jn=null,hg=!1,Fg=0,BN.current=null,n===null||n.return===null){Es=1,Mg=e,fs=null;break}e:{var o=t,i=n.return,a=n,u=e;if(e=qs,a.flags|=32768,u!==null&&typeof u=="object"&&typeof u.then=="function"){var l=u,c=a,h=c.tag;if(!(c.mode&1)&&(h===0||h===11||h===15)){var d=c.alternate;d?(c.updateQueue=d.updateQueue,c.memoizedState=d.memoizedState,c.lanes=d.lanes):(c.updateQueue=null,c.memoizedState=null)}var f=fD(i);if(f!==null){f.flags&=-257,mD(f,i,a,o,e),f.mode&1&&pD(o,l,e),e=f,u=l;var m=e.updateQueue;if(m===null){var y=new Set;y.add(u),e.updateQueue=y}else m.add(u);break e}else{if(!(e&1)){pD(o,l,e),HN();break e}u=Error(Re(426))}}else if(Fn&&a.mode&1){var x=fD(i);if(x!==null){!(x.flags&65536)&&(x.flags|=256),mD(x,i,a,o,e),IN(tp(u,a));break e}}o=u=tp(u,a),Es!==4&&(Es=2),pg===null?pg=[o]:pg.push(o),o=i;do{switch(o.tag){case 3:o.flags|=65536,e&=-e,o.lanes|=e;var v=gM(o,u,e);iD(o,v);break e;case 1:a=u;var w=o.type,S=o.stateNode;if(!(o.flags&128)&&(typeof w.getDerivedStateFromError=="function"||S!==null&&typeof S.componentDidCatch=="function"&&(al===null||!al.has(S)))){o.flags|=65536,e&=-e,o.lanes|=e;var k=yM(o,a,e);iD(o,k);break e}}o=o.return}while(o!==null)}OM(n)}catch(I){e=I,fs===n&&n!==null&&(fs=n=n.return);continue}break}while(!0)}function PM(){var t=kv.current;return kv.current=Cv,t===null?Cv:t}function HN(){(Es===0||Es===3||Es===2)&&(Es=4),Bs===null||!(Yc&268435455)&&!(Aw&268435455)||qu(Bs,qs)}function Nv(t,e){var n=Qt;Qt|=2;var s=PM();(Bs!==t||qs!==e)&&(qa=null,zc(t,e));do try{fQ();break}catch(r){DM(t,r)}while(!0);if(NN(),Qt=n,kv.current=s,fs!==null)throw Error(Re(261));return Bs=null,qs=0,Es}function fQ(){for(;fs!==null;)FM(fs)}function mQ(){for(;fs!==null&&!B9();)FM(fs)}function FM(t){var e=MM(t.alternate,t,ko);t.memoizedProps=t.pendingProps,e===null?OM(t):fs=e,BN.current=null}function OM(t){var e=t;do{var n=e.alternate;if(t=e.return,e.flags&32768){if(n=uQ(n,e),n!==null){n.flags&=32767,fs=n;return}if(t!==null)t.flags|=32768,t.subtreeFlags=0,t.deletions=null;else{Es=6,fs=null;return}}else if(n=aQ(n,e,ko),n!==null){fs=n;return}if(e=e.sibling,e!==null){fs=e;return}fs=e=t}while(e!==null);Es===0&&(Es=5)}function vc(t,e,n){var s=un,r=di.transition;try{di.transition=null,un=1,gQ(t,e,n,s)}finally{di.transition=r,un=s}return null}function gQ(t,e,n,s){do Ud();while(Qu!==null);if(Qt&6)throw Error(Re(327));n=t.finishedWork;var r=t.finishedLanes;if(n===null)return null;if(t.finishedWork=null,t.finishedLanes=0,n===t.current)throw Error(Re(177));t.callbackNode=null,t.callbackPriority=0;var o=n.lanes|n.childLanes;if(Y9(t,o),t===Bs&&(fs=Bs=null,qs=0),!(n.subtreeFlags&2064)&&!(n.flags&2064)||m1||(m1=!0,zM(uv,function(){return Ud(),null})),o=(n.flags&15990)!==0,n.subtreeFlags&15990||o){o=di.transition,di.transition=null;var i=un;un=1;var a=Qt;Qt|=4,BN.current=null,cQ(t,n),RM(n,t),OY(lI),cv=!!uI,lI=uI=null,t.current=n,hQ(n),V9(),Qt=a,un=i,di.transition=o}else t.current=n;if(m1&&(m1=!1,Qu=t,$v=r),o=t.pendingLanes,o===0&&(al=null),G9(n.stateNode),oo(t,as()),e!==null)for(s=t.onRecoverableError,n=0;n<e.length;n++)r=e[n],s(r.value,{componentStack:r.stack,digest:r.digest});if(Iv)throw Iv=!1,t=EI,EI=null,t;return $v&1&&t.tag!==0&&Ud(),o=t.pendingLanes,o&1?t===RI?fg++:(fg=0,RI=t):fg=0,Pl(),null}function Ud(){if(Qu!==null){var t=mL($v),e=di.transition,n=un;try{if(di.transition=null,un=16>t?16:t,Qu===null)var s=!1;else{if(t=Qu,Qu=null,$v=0,Qt&6)throw Error(Re(331));var r=Qt;for(Qt|=4,qe=t.current;qe!==null;){var o=qe,i=o.child;if(qe.flags&16){var a=o.deletions;if(a!==null){for(var u=0;u<a.length;u++){var l=a[u];for(qe=l;qe!==null;){var c=qe;switch(c.tag){case 0:case 11:case 15:dg(8,c,o)}var h=c.child;if(h!==null)h.return=c,qe=h;else for(;qe!==null;){c=qe;var d=c.sibling,f=c.return;if(NM(c),c===l){qe=null;break}if(d!==null){d.return=f,qe=d;break}qe=f}}}var m=o.alternate;if(m!==null){var y=m.child;if(y!==null){m.child=null;do{var x=y.sibling;y.sibling=null,y=x}while(y!==null)}}qe=o}}if(o.subtreeFlags&2064&&i!==null)i.return=o,qe=i;else e:for(;qe!==null;){if(o=qe,o.flags&2048)switch(o.tag){case 0:case 11:case 15:dg(9,o,o.return)}var v=o.sibling;if(v!==null){v.return=o.return,qe=v;break e}qe=o.return}}var w=t.current;for(qe=w;qe!==null;){i=qe;var S=i.child;if(i.subtreeFlags&2064&&S!==null)S.return=i,qe=S;else e:for(i=w;qe!==null;){if(a=qe,a.flags&2048)try{switch(a.tag){case 0:case 11:case 15:Rw(9,a)}}catch(I){Qn(a,a.return,I)}if(a===i){qe=null;break e}var k=a.sibling;if(k!==null){k.return=a.return,qe=k;break e}qe=a.return}}if(Qt=r,Pl(),ga&&typeof ga.onPostCommitFiberRoot=="function")try{ga.onPostCommitFiberRoot(Sw,t)}catch{}s=!0}return s}finally{un=n,di.transition=e}}return!1}function TD(t,e,n){e=tp(n,e),e=gM(t,e,1),t=il(t,e,1),e=_r(),t!==null&&(dy(t,1,e),oo(t,e))}function Qn(t,e,n){if(t.tag===3)TD(t,t,n);else for(;e!==null;){if(e.tag===3){TD(e,t,n);break}else if(e.tag===1){var s=e.stateNode;if(typeof e.type.getDerivedStateFromError=="function"||typeof s.componentDidCatch=="function"&&(al===null||!al.has(s))){t=tp(n,t),t=yM(e,t,1),e=il(e,t,1),t=_r(),e!==null&&(dy(e,1,t),oo(e,t));break}}e=e.return}}function yQ(t,e,n){var s=t.pingCache;s!==null&&s.delete(e),e=_r(),t.pingedLanes|=t.suspendedLanes&n,Bs===t&&(qs&n)===n&&(Es===4||Es===3&&(qs&130023424)===qs&&500>as()-WN?zc(t,0):VN|=n),oo(t,e)}function LM(t,e){e===0&&(t.mode&1?(e=o1,o1<<=1,!(o1&130023424)&&(o1=4194304)):e=1);var n=_r();t=fu(t,e),t!==null&&(dy(t,e,n),oo(t,n))}function xQ(t){var e=t.memoizedState,n=0;e!==null&&(n=e.retryLane),LM(t,n)}function vQ(t,e){var n=0;switch(t.tag){case 13:var s=t.stateNode,r=t.memoizedState;r!==null&&(n=r.retryLane);break;case 19:s=t.stateNode;break;default:throw Error(Re(314))}s!==null&&s.delete(e),LM(t,n)}var MM;MM=function(t,e,n){if(t!==null)if(t.memoizedProps!==e.pendingProps||so.current)eo=!0;else{if(!(t.lanes&n)&&!(e.flags&128))return eo=!1,iQ(t,e,n);eo=!!(t.flags&131072)}else eo=!1,Fn&&e.flags&1048576&&VL(e,yv,e.index);switch(e.lanes=0,e.tag){case 2:var s=e.type;j1(t,e),t=e.pendingProps;var r=Qd(e,fr.current);Wd(e,n),r=FN(null,e,s,t,r,n);var o=ON();return e.flags|=1,typeof r=="object"&&r!==null&&typeof r.render=="function"&&r.$$typeof===void 0?(e.tag=1,e.memoizedState=null,e.updateQueue=null,ro(s)?(o=!0,mv(e)):o=!1,e.memoizedState=r.state!==null&&r.state!==void 0?r.state:null,RN(e),r.updater=Tw,e.stateNode=r,r._reactInternals=e,xI(e,s,t,n),e=bI(null,e,s,!0,o,n)):(e.tag=0,Fn&&o&&CN(e),Nr(null,e,r,n),e=e.child),e;case 16:s=e.elementType;e:{switch(j1(t,e),t=e.pendingProps,r=s._init,s=r(s._payload),e.type=s,r=e.tag=bQ(s),t=Ai(s,t),r){case 0:e=wI(null,e,s,t,n);break e;case 1:e=xD(null,e,s,t,n);break e;case 11:e=gD(null,e,s,t,n);break e;case 14:e=yD(null,e,s,Ai(s.type,t),n);break e}throw Error(Re(306,s,""))}return e;case 0:return s=e.type,r=e.pendingProps,r=e.elementType===s?r:Ai(s,r),wI(t,e,s,r,n);case 1:return s=e.type,r=e.pendingProps,r=e.elementType===s?r:Ai(s,r),xD(t,e,s,r,n);case 3:e:{if(bM(e),t===null)throw Error(Re(387));s=e.pendingProps,o=e.memoizedState,r=o.element,HL(t,e),wv(e,s,null,n);var i=e.memoizedState;if(s=i.element,o.isDehydrated)if(o={element:s,isDehydrated:!1,cache:i.cache,pendingSuspenseBoundaries:i.pendingSuspenseBoundaries,transitions:i.transitions},e.updateQueue.baseState=o,e.memoizedState=o,e.flags&256){r=tp(Error(Re(423)),e),e=vD(t,e,s,n,r);break e}else if(s!==r){r=tp(Error(Re(424)),e),e=vD(t,e,s,n,r);break e}else for($o=ol(e.stateNode.containerInfo.firstChild),To=e,Fn=!0,Di=null,n=qL(e,null,s,n),e.child=n;n;)n.flags=n.flags&-3|4096,n=n.sibling;else{if(Zd(),s===r){e=mu(t,e,n);break e}Nr(t,e,s,n)}e=e.child}return e;case 5:return YL(e),t===null&&mI(e),s=e.type,r=e.pendingProps,o=t!==null?t.memoizedProps:null,i=r.children,cI(s,r)?i=null:o!==null&&cI(s,o)&&(e.flags|=32),wM(t,e),Nr(t,e,i,n),e.child;case 6:return t===null&&mI(e),null;case 13:return SM(t,e,n);case 4:return AN(e,e.stateNode.containerInfo),s=e.pendingProps,t===null?e.child=Jd(e,null,s,n):Nr(t,e,s,n),e.child;case 11:return s=e.type,r=e.pendingProps,r=e.elementType===s?r:Ai(s,r),gD(t,e,s,r,n);case 7:return Nr(t,e,e.pendingProps,n),e.child;case 8:return Nr(t,e,e.pendingProps.children,n),e.child;case 12:return Nr(t,e,e.pendingProps.children,n),e.child;case 10:e:{if(s=e.type._context,r=e.pendingProps,o=e.memoizedProps,i=r.value,Cn(xv,s._currentValue),s._currentValue=i,o!==null)if(Bi(o.value,i)){if(o.children===r.children&&!so.current){e=mu(t,e,n);break e}}else for(o=e.child,o!==null&&(o.return=e);o!==null;){var a=o.dependencies;if(a!==null){i=o.child;for(var u=a.firstContext;u!==null;){if(u.context===s){if(o.tag===1){u=ru(-1,n&-n),u.tag=2;var l=o.updateQueue;if(l!==null){l=l.shared;var c=l.pending;c===null?u.next=u:(u.next=c.next,c.next=u),l.pending=u}}o.lanes|=n,u=o.alternate,u!==null&&(u.lanes|=n),gI(o.return,n,e),a.lanes|=n;break}u=u.next}}else if(o.tag===10)i=o.type===e.type?null:o.child;else if(o.tag===18){if(i=o.return,i===null)throw Error(Re(341));i.lanes|=n,a=i.alternate,a!==null&&(a.lanes|=n),gI(i,n,e),i=o.sibling}else i=o.child;if(i!==null)i.return=o;else for(i=o;i!==null;){if(i===e){i=null;break}if(o=i.sibling,o!==null){o.return=i.return,i=o;break}i=i.return}o=i}Nr(t,e,r.children,n),e=e.child}return e;case 9:return r=e.type,s=e.pendingProps.children,Wd(e,n),r=gi(r),s=s(r),e.flags|=1,Nr(t,e,s,n),e.child;case 14:return s=e.type,r=Ai(s,e.pendingProps),r=Ai(s.type,r),yD(t,e,s,r,n);case 15:return xM(t,e,e.type,e.pendingProps,n);case 17:return s=e.type,r=e.pendingProps,r=e.elementType===s?r:Ai(s,r),j1(t,e),e.tag=1,ro(s)?(t=!0,mv(e)):t=!1,Wd(e,n),KL(e,s,r),xI(e,s,r,n),bI(null,e,s,!0,t,n);case 19:return CM(t,e,n);case 22:return vM(t,e,n)}throw Error(Re(156,e.tag))};function zM(t,e){return hL(t,e)}function wQ(t,e,n,s){this.tag=t,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=s,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function oi(t,e,n,s){return new wQ(t,e,n,s)}function jN(t){return t=t.prototype,!(!t||!t.isReactComponent)}function bQ(t){if(typeof t=="function")return jN(t)?1:0;if(t!=null){if(t=t.$$typeof,t===hN)return 11;if(t===dN)return 14}return 2}function ll(t,e){var n=t.alternate;return n===null?(n=oi(t.tag,e,t.key,t.mode),n.elementType=t.elementType,n.type=t.type,n.stateNode=t.stateNode,n.alternate=t,t.alternate=n):(n.pendingProps=e,n.type=t.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=t.flags&14680064,n.childLanes=t.childLanes,n.lanes=t.lanes,n.child=t.child,n.memoizedProps=t.memoizedProps,n.memoizedState=t.memoizedState,n.updateQueue=t.updateQueue,e=t.dependencies,n.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext},n.sibling=t.sibling,n.index=t.index,n.ref=t.ref,n}function q1(t,e,n,s,r,o){var i=2;if(s=t,typeof t=="function")jN(t)&&(i=1);else if(typeof t=="string")i=5;else e:switch(t){case Sd:return Bc(n.children,r,o,e);case cN:i=8,r|=8;break;case Wk:return t=oi(12,n,e,r|2),t.elementType=Wk,t.lanes=o,t;case Uk:return t=oi(13,n,e,r),t.elementType=Uk,t.lanes=o,t;case Gk:return t=oi(19,n,e,r),t.elementType=Gk,t.lanes=o,t;case XO:return _w(n,r,o,e);default:if(typeof t=="object"&&t!==null)switch(t.$$typeof){case jO:i=10;break e;case KO:i=9;break e;case hN:i=11;break e;case dN:i=14;break e;case Gu:i=16,s=null;break e}throw Error(Re(130,t==null?t:typeof t,""))}return e=oi(i,n,e,r),e.elementType=t,e.type=s,e.lanes=o,e}function Bc(t,e,n,s){return t=oi(7,t,s,e),t.lanes=n,t}function _w(t,e,n,s){return t=oi(22,t,s,e),t.elementType=XO,t.lanes=n,t.stateNode={isHidden:!1},t}function U2(t,e,n){return t=oi(6,t,null,e),t.lanes=n,t}function G2(t,e,n){return e=oi(4,t.children!==null?t.children:[],t.key,e),e.lanes=n,e.stateNode={containerInfo:t.containerInfo,pendingChildren:null,implementation:t.implementation},e}function SQ(t,e,n,s,r){this.tag=e,this.containerInfo=t,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=k2(0),this.expirationTimes=k2(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=k2(0),this.identifierPrefix=s,this.onRecoverableError=r,this.mutableSourceEagerHydrationData=null}function KN(t,e,n,s,r,o,i,a,u){return t=new SQ(t,e,n,a,u),e===1?(e=1,o===!0&&(e|=8)):e=0,o=oi(3,null,null,e),t.current=o,o.stateNode=t,o.memoizedState={element:s,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},RN(o),t}function CQ(t,e,n){var s=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:bd,key:s==null?null:""+s,children:t,containerInfo:e,implementation:n}}function BM(t){if(!t)return yl;t=t._reactInternals;e:{if(ph(t)!==t||t.tag!==1)throw Error(Re(170));var e=t;do{switch(e.tag){case 3:e=e.stateNode.context;break e;case 1:if(ro(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break e}}e=e.return}while(e!==null);throw Error(Re(171))}if(t.tag===1){var n=t.type;if(ro(n))return zL(t,n,e)}return e}function VM(t,e,n,s,r,o,i,a,u){return t=KN(n,s,!0,t,r,o,i,a,u),t.context=BM(null),n=t.current,s=_r(),r=ul(n),o=ru(s,r),o.callback=e??null,il(n,o,r),t.current.lanes=r,dy(t,r,s),oo(t,s),t}function Dw(t,e,n,s){var r=e.current,o=_r(),i=ul(r);return n=BM(n),e.context===null?e.context=n:e.pendingContext=n,e=ru(o,i),e.payload={element:t},s=s===void 0?null:s,s!==null&&(e.callback=s),t=il(r,e,i),t!==null&&(Li(t,r,i,o),U1(t,r,i)),i}function Tv(t){if(t=t.current,!t.child)return null;switch(t.child.tag){case 5:return t.child.stateNode;default:return t.child.stateNode}}function ED(t,e){if(t=t.memoizedState,t!==null&&t.dehydrated!==null){var n=t.retryLane;t.retryLane=n!==0&&n<e?n:e}}function XN(t,e){ED(t,e),(t=t.alternate)&&ED(t,e)}function kQ(){return null}var WM=typeof reportError=="function"?reportError:function(t){console.error(t)};function qN(t){this._internalRoot=t}Pw.prototype.render=qN.prototype.render=function(t){var e=this._internalRoot;if(e===null)throw Error(Re(409));Dw(t,e,null,null)};Pw.prototype.unmount=qN.prototype.unmount=function(){var t=this._internalRoot;if(t!==null){this._internalRoot=null;var e=t.containerInfo;Qc(function(){Dw(null,t,null,null)}),e[pu]=null}};function Pw(t){this._internalRoot=t}Pw.prototype.unstable_scheduleHydration=function(t){if(t){var e=xL();t={blockedOn:null,target:t,priority:e};for(var n=0;n<Xu.length&&e!==0&&e<Xu[n].priority;n++);Xu.splice(n,0,t),n===0&&wL(t)}};function YN(t){return!(!t||t.nodeType!==1&&t.nodeType!==9&&t.nodeType!==11)}function Fw(t){return!(!t||t.nodeType!==1&&t.nodeType!==9&&t.nodeType!==11&&(t.nodeType!==8||t.nodeValue!==" react-mount-point-unstable "))}function RD(){}function IQ(t,e,n,s,r){if(r){if(typeof s=="function"){var o=s;s=function(){var l=Tv(i);o.call(l)}}var i=VM(e,s,t,0,null,!1,!1,"",RD);return t._reactRootContainer=i,t[pu]=i.current,Rg(t.nodeType===8?t.parentNode:t),Qc(),i}for(;r=t.lastChild;)t.removeChild(r);if(typeof s=="function"){var a=s;s=function(){var l=Tv(u);a.call(l)}}var u=KN(t,0,!1,null,null,!1,!1,"",RD);return t._reactRootContainer=u,t[pu]=u.current,Rg(t.nodeType===8?t.parentNode:t),Qc(function(){Dw(e,u,n,s)}),u}function Ow(t,e,n,s,r){var o=n._reactRootContainer;if(o){var i=o;if(typeof r=="function"){var a=r;r=function(){var u=Tv(i);a.call(u)}}Dw(e,i,t,r)}else i=IQ(n,e,t,r,s);return Tv(i)}gL=function(t){switch(t.tag){case 3:var e=t.stateNode;if(e.current.memoizedState.isDehydrated){var n=Ym(e.pendingLanes);n!==0&&(mN(e,n|1),oo(e,as()),!(Qt&6)&&(np=as()+500,Pl()))}break;case 13:Qc(function(){var s=fu(t,1);if(s!==null){var r=_r();Li(s,t,1,r)}}),XN(t,1)}};gN=function(t){if(t.tag===13){var e=fu(t,134217728);if(e!==null){var n=_r();Li(e,t,134217728,n)}XN(t,134217728)}};yL=function(t){if(t.tag===13){var e=ul(t),n=fu(t,e);if(n!==null){var s=_r();Li(n,t,e,s)}XN(t,e)}};xL=function(){return un};vL=function(t,e){var n=un;try{return un=t,e()}finally{un=n}};eI=function(t,e,n){switch(e){case"input":if(Kk(t,n),e=n.name,n.type==="radio"&&e!=null){for(n=t;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<n.length;e++){var s=n[e];if(s!==t&&s.form===t.form){var r=$w(s);if(!r)throw Error(Re(90));YO(s),Kk(s,r)}}}break;case"textarea":ZO(t,n);break;case"select":e=n.value,e!=null&&Md(t,!!n.multiple,e,!1)}};oL=UN;iL=Qc;var $Q={usingClientEntryPoint:!1,Events:[fy,$d,$w,sL,rL,UN]},Mm={findFiberByHostInstance:Ec,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},NQ={bundleType:Mm.bundleType,version:Mm.version,rendererPackageName:Mm.rendererPackageName,rendererConfig:Mm.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:bu.ReactCurrentDispatcher,findHostInstanceByFiber:function(t){return t=lL(t),t===null?null:t.stateNode},findFiberByHostInstance:Mm.findFiberByHostInstance||kQ,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var g1=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!g1.isDisabled&&g1.supportsFiber)try{Sw=g1.inject(NQ),ga=g1}catch{}}Po.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=$Q;Po.createPortal=function(t,e){var n=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!YN(e))throw Error(Re(200));return CQ(t,e,null,n)};Po.createRoot=function(t,e){if(!YN(t))throw Error(Re(299));var n=!1,s="",r=WM;return e!=null&&(e.unstable_strictMode===!0&&(n=!0),e.identifierPrefix!==void 0&&(s=e.identifierPrefix),e.onRecoverableError!==void 0&&(r=e.onRecoverableError)),e=KN(t,1,!1,null,null,n,!1,s,r),t[pu]=e.current,Rg(t.nodeType===8?t.parentNode:t),new qN(e)};Po.findDOMNode=function(t){if(t==null)return null;if(t.nodeType===1)return t;var e=t._reactInternals;if(e===void 0)throw typeof t.render=="function"?Error(Re(188)):(t=Object.keys(t).join(","),Error(Re(268,t)));return t=lL(e),t=t===null?null:t.stateNode,t};Po.flushSync=function(t){return Qc(t)};Po.hydrate=function(t,e,n){if(!Fw(e))throw Error(Re(200));return Ow(null,t,e,!0,n)};Po.hydrateRoot=function(t,e,n){if(!YN(t))throw Error(Re(405));var s=n!=null&&n.hydratedSources||null,r=!1,o="",i=WM;if(n!=null&&(n.unstable_strictMode===!0&&(r=!0),n.identifierPrefix!==void 0&&(o=n.identifierPrefix),n.onRecoverableError!==void 0&&(i=n.onRecoverableError)),e=VM(e,null,t,1,n??null,r,!1,o,i),t[pu]=e.current,Rg(t),s)for(t=0;t<s.length;t++)n=s[t],r=n._getVersion,r=r(n._source),e.mutableSourceEagerHydrationData==null?e.mutableSourceEagerHydrationData=[n,r]:e.mutableSourceEagerHydrationData.push(n,r);return new Pw(e)};Po.render=function(t,e,n){if(!Fw(e))throw Error(Re(200));return Ow(null,t,e,!1,n)};Po.unmountComponentAtNode=function(t){if(!Fw(t))throw Error(Re(40));return t._reactRootContainer?(Qc(function(){Ow(null,null,t,!1,function(){t._reactRootContainer=null,t[pu]=null})}),!0):!1};Po.unstable_batchedUpdates=UN;Po.unstable_renderSubtreeIntoContainer=function(t,e,n,s){if(!Fw(n))throw Error(Re(200));if(t==null||t._reactInternals===void 0)throw Error(Re(38));return Ow(t,e,n,!1,s)};Po.version="18.2.0-next-9e3b772b8-20220608";function UM(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(UM)}catch(t){console.error(t)}}UM(),VO.exports=Po;var GM=VO.exports,AD=GM;Bk.createRoot=AD.createRoot,Bk.hydrateRoot=AD.hydrateRoot;/**
 * @tanstack/history/src/index.ts
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */const _D="pushstate",DD="popstate",HM="beforeunload",jM=t=>(t.preventDefault(),t.returnValue=""),TQ=()=>{removeEventListener(HM,jM,{capture:!0})};function KM(t){let e=t.getLocation(),n=new Set,s=[];const r=()=>{e=t.getLocation(),n.forEach(i=>i())},o=async i=>{var a;if(typeof document<"u"&&s.length){for(let u of s)if(!await u()){(a=t.onBlocked)==null||a.call(t,r);return}}i()};return{get location(){return e},subscribe:i=>(n.add(i),()=>{n.delete(i)}),push:(i,a)=>{a=PD(a),o(()=>{t.pushState(i,a),r()})},replace:(i,a)=>{a=PD(a),o(()=>{t.replaceState(i,a),r()})},go:i=>{o(()=>{t.go(i)})},back:()=>{o(()=>{t.back()})},forward:()=>{o(()=>{t.forward()})},createHref:i=>t.createHref(i),block:i=>(s.push(i),s.length===1&&addEventListener(HM,jM,{capture:!0}),()=>{s=s.filter(a=>a!==i),s.length||TQ()}),flush:()=>{var i;return(i=t.flush)==null?void 0:i.call(t)},destroy:()=>{var i;return(i=t.destroy)==null?void 0:i.call(t)},notify:r}}function PD(t){return t||(t={}),{...t,key:qM()}}function EQ(t){const e=(t==null?void 0:t.window)??(typeof document<"u"?window:void 0),n=(t==null?void 0:t.createHref)??(v=>v),s=(t==null?void 0:t.parseLocation)??(()=>DI(`${e.location.pathname}${e.location.search}${e.location.hash}`,e.history.state));let r=s(),o;const i=()=>r;let a,u=!0,l;const c=v=>{u=!1,v(),u=!0},h=()=>{c(()=>{a&&(e.history[a.isPush?"pushState":"replaceState"](a.state,"",a.href),a=void 0,l=void 0,o=void 0)})},d=(v,w,S)=>{const k=n(w);l||(o=r),r=DI(w,S),a={href:k,state:S,isPush:(a==null?void 0:a.isPush)||v==="push"},l||(l=Promise.resolve().then(()=>h()))},f=()=>{r=s(),x.notify()};var m=e.history.pushState,y=e.history.replaceState;const x=KM({getLocation:i,pushState:(v,w)=>d("push",v,w),replaceState:(v,w)=>d("replace",v,w),back:()=>e.history.back(),forward:()=>e.history.forward(),go:v=>e.history.go(v),createHref:v=>n(v),flush:h,destroy:()=>{e.history.pushState=m,e.history.replaceState=y,e.removeEventListener(_D,f),e.removeEventListener(DD,f)},onBlocked:v=>{o&&r!==o&&(r=o,v())}});return e.addEventListener(_D,f),e.addEventListener(DD,f),e.history.pushState=function(){let v=m.apply(e.history,arguments);return u&&x.notify(),v},e.history.replaceState=function(){let v=y.apply(e.history,arguments);return u&&x.notify(),v},x}function XM(t={initialEntries:["/"]}){const e=t.initialEntries;let n=t.initialIndex??e.length-1,s={key:qM()};return KM({getLocation:()=>DI(e[n],s),pushState:(o,i)=>{s=i,e.push(o),n++},replaceState:(o,i)=>{s=i,e[n]=o},back:()=>{n--},forward:()=>{n=Math.min(n+1,e.length-1)},go:o=>{n=Math.min(Math.max(n+o,0),e.length-1)},createHref:o=>o})}function DI(t,e){let n=t.indexOf("#"),s=t.indexOf("?");return{href:t,pathname:t.substring(0,n>0?s>0?Math.min(n,s):n:s>0?s:t.length),hash:n>-1?t.substring(n):"",search:s>-1?t.slice(s,n===-1?void 0:n):"",state:e||{}}}function qM(){return(Math.random()+1).toString(36).substring(7)}var RQ=!0,H2="Invariant failed";function fa(t,e){if(!t){if(RQ)throw new Error(H2);var n=typeof e=="function"?e():e,s=n?"".concat(H2,": ").concat(n):H2;throw new Error(s)}}var YM={exports:{}},QM={},ZM={exports:{}},JM={};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var sp=fe;function AQ(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}var _Q=typeof Object.is=="function"?Object.is:AQ,DQ=sp.useState,PQ=sp.useEffect,FQ=sp.useLayoutEffect,OQ=sp.useDebugValue;function LQ(t,e){var n=e(),s=DQ({inst:{value:n,getSnapshot:e}}),r=s[0].inst,o=s[1];return FQ(function(){r.value=n,r.getSnapshot=e,j2(r)&&o({inst:r})},[t,n,e]),PQ(function(){return j2(r)&&o({inst:r}),t(function(){j2(r)&&o({inst:r})})},[t]),OQ(n),n}function j2(t){var e=t.getSnapshot;t=t.value;try{var n=e();return!_Q(t,n)}catch{return!0}}function MQ(t,e){return e()}var zQ=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?MQ:LQ;JM.useSyncExternalStore=sp.useSyncExternalStore!==void 0?sp.useSyncExternalStore:zQ;ZM.exports=JM;var BQ=ZM.exports;/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Lw=fe,VQ=BQ;function WQ(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}var UQ=typeof Object.is=="function"?Object.is:WQ,GQ=VQ.useSyncExternalStore,HQ=Lw.useRef,jQ=Lw.useEffect,KQ=Lw.useMemo,XQ=Lw.useDebugValue;QM.useSyncExternalStoreWithSelector=function(t,e,n,s,r){var o=HQ(null);if(o.current===null){var i={hasValue:!1,value:null};o.current=i}else i=o.current;o=KQ(function(){function u(f){if(!l){if(l=!0,c=f,f=s(f),r!==void 0&&i.hasValue){var m=i.value;if(r(m,f))return h=m}return h=f}if(m=h,UQ(c,f))return m;var y=s(f);return r!==void 0&&r(m,y)?m:(c=f,h=y)}var l=!1,c,h,d=n===void 0?null:n;return[function(){return u(e())},d===null?void 0:function(){return u(d())}]},[e,n,s,r]);var a=GQ(t,o[0],o[1]);return jQ(function(){i.hasValue=!0,i.value=a},[a]),XQ(a),a};YM.exports=QM;var qQ=YM.exports,YQ=class{constructor(t,e){this.listeners=new Set,this._batching=!1,this._flushing=0,this._nextPriority=null,this.subscribe=n=>{var r,o;this.listeners.add(n);const s=(o=(r=this.options)==null?void 0:r.onSubscribe)==null?void 0:o.call(r,n,this);return()=>{this.listeners.delete(n),s==null||s()}},this.setState=(n,s)=>{var i,a,u,l,c;const r=this.state;this.state=(i=this.options)!=null&&i.updateFn?this.options.updateFn(r)(n):n(r);const o=(s==null?void 0:s.priority)??((a=this.options)==null?void 0:a.defaultPriority)??"high";this._nextPriority===null?this._nextPriority=o:this._nextPriority==="high"?this._nextPriority=o:this._nextPriority=((u=this.options)==null?void 0:u.defaultPriority)??"high",(c=(l=this.options)==null?void 0:l.onUpdate)==null||c.call(l,{priority:this._nextPriority}),this._flush()},this._flush=()=>{if(this._batching)return;const n=++this._flushing;this.listeners.forEach(s=>{this._flushing===n&&s({priority:this._nextPriority??"high"})})},this.batch=n=>{if(this._batching)return n();this._batching=!0,n(),this._batching=!1,this._flush()},this.state=t,this.options=e}};function QQ(t,e=n=>n){return qQ.useSyncExternalStoreWithSelector(t.subscribe,()=>t.state,()=>t.state,e,ZQ)}function ZQ(t,e){if(Object.is(t,e))return!0;if(typeof t!="object"||t===null||typeof e!="object"||e===null)return!1;const n=Object.keys(t);if(n.length!==Object.keys(e).length)return!1;for(let s=0;s<n.length;s++)if(!Object.prototype.hasOwnProperty.call(e,n[s])||!Object.is(t[n[s]],e[n[s]]))return!1;return!0}/**
 * @tanstack/react-router/src/index.tsx
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function ez(t){const e=t.errorComponent??QN;return fe.createElement(JQ,{getResetKey:t.getResetKey,onCatch:t.onCatch,children:({error:n})=>n?fe.createElement(e,{error:n}):t.children})}class JQ extends fe.Component{constructor(){super(...arguments);bt(this,"state",{error:null})}static getDerivedStateFromProps(n){return{resetKey:n.getResetKey()}}static getDerivedStateFromError(n){return{error:n}}componentDidUpdate(n,s){s.error&&s.resetKey!==this.state.resetKey&&this.setState({error:null})}componentDidCatch(n){var s,r;console.error(n),(r=(s=this.props).onCatch)==null||r.call(s,n)}render(){return this.props.children(this.state)}}function QN({error:t}){const[e,n]=fe.useState(!1);return fe.createElement("div",{style:{padding:".5rem",maxWidth:"100%"}},fe.createElement("div",{style:{display:"flex",alignItems:"center",gap:".5rem"}},fe.createElement("strong",{style:{fontSize:"1rem"}},"Something went wrong!"),fe.createElement("button",{style:{appearance:"none",fontSize:".6em",border:"1px solid currentColor",padding:".1rem .2rem",fontWeight:"bold",borderRadius:".25rem"},onClick:()=>n(s=>!s)},e?"Hide Error":"Show Error")),fe.createElement("div",{style:{height:".25rem"}}),e?fe.createElement("div",null,fe.createElement("pre",{style:{fontSize:".7em",border:"1px solid red",borderRadius:".25rem",padding:".3rem",color:"red",overflow:"auto"}},t.message?fe.createElement("code",null,t.message):null)):null)}function ZN(t){return t[t.length-1]}function eZ(t){return typeof t=="function"}function _c(t,e){return eZ(t)?t(e):t}function mg(t,e){return e.reduce((n,s)=>(n[s]=t[s],n),{})}function Wu(t,e){if(t===e)return t;const n=e,s=OD(t)&&OD(n);if(s||Ev(t)&&Ev(n)){const r=s?t.length:Object.keys(t).length,o=s?n:Object.keys(n),i=o.length,a=s?[]:{};let u=0;for(let l=0;l<i;l++){const c=s?l:o[l];a[c]=Wu(t[c],n[c]),a[c]===t[c]&&t[c]!==void 0&&u++}return r===i&&u===r?t:a}return n}function Ev(t){if(!FD(t))return!1;const e=t.constructor;if(typeof e>"u")return!0;const n=e.prototype;return!(!FD(n)||!n.hasOwnProperty("isPrototypeOf"))}function FD(t){return Object.prototype.toString.call(t)==="[object Object]"}function OD(t){return Array.isArray(t)&&t.length===Object.keys(t).length}function Rv(t,e,n=!1){if(t===e)return!0;if(typeof t!=typeof e)return!1;if(Ev(t)&&Ev(e)){const s=Object.keys(t),r=Object.keys(e);return!n&&s.length!==r.length?!1:!r.some(o=>!(o in t)||!Rv(t[o],e[o],n))}return Array.isArray(t)&&Array.isArray(e)?!t.some((s,r)=>!Rv(s,e[r],n)):!1}const K2=typeof window<"u"?fe.useLayoutEffect:fe.useEffect;function tZ(t){return t.replace(/\\/g,"\\\\").replace(/'/g,"\\'").replace(/"/g,'\\"')}const Mw=fe.createContext(void 0);function LD(){const t=fh(),e=gu({select:n=>{var s;return(s=ou(n)[0])==null?void 0:s.id}});return fe.createElement(Mw.Provider,{value:e},fe.createElement(ez,{getResetKey:()=>{var n;return(n=t.state.resolvedLocation.state)==null?void 0:n.key},errorComponent:QN,onCatch:()=>{}},e?fe.createElement(tz,{matchId:e}):null))}function MD(t){return fe.createElement(fe.Fragment,null,t.children)}function tz({matchId:t}){var l,c,h;const e=fh(),n=gu({select:d=>{var f;return(f=ou(d).find(m=>m.id===t))==null?void 0:f.routeId}});fa(n,`Could not find routeId for matchId "${t}". Please file an issue!`);const s=e.routesById[n],r=s.options.pendingComponent??e.options.defaultPendingComponent,o=r?fe.createElement(r,null):null,i=s.options.errorComponent??e.options.defaultErrorComponent??QN,a=s.options.wrapInSuspense??r??((l=s.options.component)==null?void 0:l.preload)??((c=s.options.pendingComponent)==null?void 0:c.preload)??((h=s.options.errorComponent)==null?void 0:h.preload)?fe.Suspense:MD,u=i?ez:MD;return fe.createElement(Mw.Provider,{value:t},fe.createElement(a,{fallback:o},fe.createElement(u,{getResetKey:()=>{var d;return(d=e.state.resolvedLocation.state)==null?void 0:d.key},errorComponent:i,onCatch:()=>{}},fe.createElement(nZ,{matchId:t,pendingElement:o}))))}function nZ({matchId:t,pendingElement:e}){const n=fh(),s=gu({select:i=>{var a;return(a=ou(i).find(u=>u.id===t))==null?void 0:a.routeId}}),r=n.routesById[s],o=gu({select:i=>mg(ou(i).find(a=>a.id===t),["status","error","showPending","loadPromise"])});if(o.status==="error")throw o.error;if(o.status==="pending"){if(o.showPending)return e;throw o.loadPromise}if(o.status==="success"){let i=r.options.component??n.options.defaultComponent;return i?fe.createElement(i,null):fe.createElement(sZ,null)}fa(!1,"Idle routeMatch status encountered during rendering! You should never see this. File an issue!")}const sZ=fe.memo(function(){const e=fe.useContext(Mw),n=gu({select:s=>{var i;const r=ou(s),o=r.findIndex(a=>a.id===e);return(i=r[o+1])==null?void 0:i.id}});return n?fe.createElement(tz,{matchId:n}):null});function ou(t){var e;return(e=t.pendingMatches)!=null&&e.some(n=>n.showPending)?t.pendingMatches:t.matches}function rp(t){var i;const e=fh(),n=fe.useContext(Mw),s=(i=ou(e.state).find(a=>a.id===n))==null?void 0:i.routeId,r=(()=>{const a=ou(e.state);return(t!=null&&t.from?a.find(l=>l.routeId===(t==null?void 0:t.from)):a.find(l=>l.id===n)).routeId})();return((t==null?void 0:t.strict)??!0)&&fa(s==r,`useMatch("${r}") is being called in a component that is meant to render the '${s}' route. Did you mean to 'useMatch("${r}", { strict: false })' or 'useRoute("${r}")' instead?`),gu({select:a=>{const u=ou(a).find(l=>l.id===n);return fa(u,`Could not find ${t!=null&&t.from?`an active match from "${t.from}"`:"a nearest match!"}`),t!=null&&t.select?t.select(u):u}})}function rZ(t){return rp({...t,select:e=>typeof t.select=="function"?t.select(e==null?void 0:e.loaderDeps):e==null?void 0:e.loaderDeps})}function oZ(t){return rp({...t,select:e=>typeof t.select=="function"?t.select(e==null?void 0:e.loaderData):e==null?void 0:e.loaderData})}const iZ=fe.useTransition||(()=>[!1,t=>{t()}]);let zg=fe.createContext(null);typeof document<"u"&&(window.__TSR_ROUTER_CONTEXT__?zg=window.__TSR_ROUTER_CONTEXT__:window.__TSR_ROUTER_CONTEXT__=zg);function aZ({router:t,...e}){t.update({...t.options,...e,context:{...t.options.context,...e==null?void 0:e.context}});const n=t.options.InnerWrap?fe.createElement(t.options.InnerWrap,null,fe.createElement(LD,null)):fe.createElement(LD,null),s=fe.createElement(zg.Provider,{value:t},n,fe.createElement(uZ,null));return t.options.Wrap?fe.createElement(t.options.Wrap,null,s):s}function uZ(){const t=fe.useRef(0),e=fh(),n=gu({select:i=>mg(i,["isLoading","location","resolvedLocation","isTransitioning"])}),[s,r]=iZ();e.startReactTransition=r,fe.useEffect(()=>{s&&e.__store.setState(i=>({...i,isTransitioning:s}))},[s]);const o=()=>{(a=>{n.isTransitioning?a():r(()=>a())})(()=>{try{e.load()}catch(a){console.error(a)}})};return K2(()=>{const i=e.history.subscribe(()=>{e.latestLocation=e.parseLocation(e.latestLocation),n.location!==e.latestLocation&&o()}),a=e.buildLocation({search:!0,params:!0,hash:!0,state:!0});return n.location.href!==a.href&&e.commitLocation({...a,replace:!0}),()=>{i()}},[e.history]),K2(()=>{var i;if(fe.useTransition?n.isTransitioning&&!s:!n.isLoading&&n.resolvedLocation!==n.location){if(e.emit({type:"onResolved",fromLocation:n.resolvedLocation,toLocation:n.location,pathChanged:n.location.href!==((i=n.resolvedLocation)==null?void 0:i.href)}),document.querySelector&&n.location.hash!==""){const a=document.getElementById(n.location.hash);a&&a.scrollIntoView()}e.__store.setState(a=>({...a,isTransitioning:!1,resolvedLocation:a.location}))}},[n.isTransitioning,s,n.isLoading,n.resolvedLocation,n.location]),K2(()=>{!window.__TSR_DEHYDRATED__&&!t.current&&(t.current++,o())},[]),null}function X2(t,e){return[...t.cachedMatches,...t.pendingMatches??[],...t.matches].find(n=>n.id===e)}function gu(t){const e=fh({warn:(t==null?void 0:t.router)===void 0});return QQ(((t==null?void 0:t.router)||e).__store,t==null?void 0:t.select)}function fh(t){const e=typeof document<"u"&&window.__TSR_ROUTER_CONTEXT__||zg,n=fe.useContext(e);return t==null||t.warn,n}function cl(t){return zw(t.filter(Boolean).join("/"))}function zw(t){return t.replace(/\/{2,}/g,"/")}function nz(t){return t==="/"?t:t.replace(/^\/{1,}/,"")}function Y1(t){return t==="/"?t:t.replace(/\/{1,}$/,"")}function sz(t){return Y1(nz(t))}function lZ(t,e,n){e=e.replace(new RegExp(`^${t}`),"/"),n=n.replace(new RegExp(`^${t}`),"/");let s=op(e);const r=op(n);r.forEach((i,a)=>{var u;if(i.value==="/")a?a===r.length-1&&s.push(i):s=[i];else if(i.value==="..")s.length>1&&((u=ZN(s))==null?void 0:u.value)==="/"&&s.pop(),s.pop();else{if(i.value===".")return;s.push(i)}});const o=cl([t,...s.map(i=>i.value)]);return zw(o)}function op(t){if(!t)return[];t=zw(t);const e=[];if(t.slice(0,1)==="/"&&(t=t.substring(1),e.push({type:"pathname",value:"/"})),!t)return e;const n=t.split("/").filter(Boolean);return e.push(...n.map(s=>s==="$"||s==="*"?{type:"wildcard",value:s}:s.charAt(0)==="$"?{type:"param",value:s}:{type:"pathname",value:s})),t.slice(-1)==="/"&&(t=t.substring(1),e.push({type:"pathname",value:"/"})),e}function q2(t,e,n=!1){const s=op(t);return cl(s.map(r=>{if(r.type==="wildcard"){const o=e[r.value];return n?`${r.value}${o??""}`:o}return r.type==="param"?e[r.value.substring(1)]??"undefined":r.value}))}function Y2(t,e,n){const s=hZ(t,e,n);if(!(n.to&&!s))return s??{}}function cZ(t,e){return t!="/"?e.substring(t.length):e}function hZ(t,e,n){e=cZ(t,e);const s=`${n.to??"$"}`,r=op(e),o=op(s);e.startsWith("/")||r.unshift({type:"pathname",value:"/"}),s.startsWith("/")||o.unshift({type:"pathname",value:"/"});const i={};return(()=>{for(let u=0;u<Math.max(r.length,o.length);u++){const l=r[u],c=o[u],h=u>=r.length-1,d=u>=o.length-1;if(c){if(c.type==="wildcard")return l!=null&&l.value?(i["*"]=cl(r.slice(u).map(f=>f.value)),!0):!1;if(c.type==="pathname"){if(c.value==="/"&&!(l!=null&&l.value))return!0;if(l){if(n.caseSensitive){if(c.value!==l.value)return!1}else if(c.value.toLowerCase()!==l.value.toLowerCase())return!1}}if(!l)return!1;if(c.type==="param"){if((l==null?void 0:l.value)==="/")return!1;l.value.charAt(0)!=="$"&&(i[c.value.substring(1)]=l.value)}}if(!h&&d)return i["**"]=cl(r.slice(u+1).map(f=>f.value)),!!n.fuzzy&&(c==null?void 0:c.value)!=="/"}return!0})()?i:void 0}function dZ(t){return gu({select:e=>{var s;const n=(s=ZN(ou(e)))==null?void 0:s.params;return t!=null&&t.select?t.select(n):n}})}function pZ(t){return rp({...t,select:e=>t!=null&&t.select?t.select(e.search):e.search})}const pc="__root__";class JN{constructor(e){bt(this,"init",e=>{var u,l;this.originalIndex=e.originalIndex;const n=this.options,s=!(n!=null&&n.path)&&!(n!=null&&n.id);this.parentRoute=(l=(u=this.options)==null?void 0:u.getParentRoute)==null?void 0:l.call(u),s?this.path=pc:fa(this.parentRoute,"Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.");let r=s?pc:n.path;r&&r!=="/"&&(r=sz(r));const o=(n==null?void 0:n.id)||r;let i=s?pc:cl([this.parentRoute.id===pc?"":this.parentRoute.id,o]);r===pc&&(r="/"),i!==pc&&(i=cl(["/",i]));const a=i===pc?"/":cl([this.parentRoute.fullPath,r]);this.path=r,this.id=i,this.fullPath=a,this.to=a});bt(this,"addChildren",e=>(this.children=e,this));bt(this,"updateLoader",e=>(Object.assign(this.options,e),this));bt(this,"update",e=>(Object.assign(this.options,e),this));bt(this,"useMatch",e=>rp({...e,from:this.id}));bt(this,"useRouteContext",e=>rp({...e,from:this.id,select:n=>e!=null&&e.select?e.select(n.context):n.context}));bt(this,"useSearch",e=>pZ({...e,from:this.id}));bt(this,"useParams",e=>dZ({...e,from:this.id}));bt(this,"useLoaderDeps",e=>rZ({...e,from:this.id}));bt(this,"useLoaderData",e=>oZ({...e,from:this.id}));this.options=e||{},this.isRoot=!(e!=null&&e.getParentRoute),fa(!(e!=null&&e.id&&(e!=null&&e.path)),"Route cannot have both an 'id' and a 'path' option."),this.$$typeof=Symbol.for("react.memo")}}class fZ extends JN{constructor(e){super(e)}}function PI(){return PI=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&(t[s]=n[s])}return t},PI.apply(this,arguments)}const Q2="Error preloading route! ";function mZ(t){const e=fh(),n=rp({strict:!1,select:ke=>ke.pathname}),{children:s,target:r,activeProps:o=()=>({className:"active"}),inactiveProps:i=()=>({}),activeOptions:a,disabled:u,hash:l,search:c,params:h,to:d,state:f,mask:m,preload:y,preloadDelay:x,replace:v,startTransition:w,resetScroll:S,style:k,className:I,onClick:T,onFocus:R,onMouseEnter:_,onMouseLeave:D,onTouchStart:L,...V}=t,U={from:t.to?n:void 0,...t};let j="internal";try{new URL(`${d}`),j="external"}catch{}if(j==="external")return{href:d};const q=e.buildLocation(U),J=y??e.options.defaultPreload,te=x??e.options.defaultPreloadDelay??0,le=gu({select:ke=>{const Ae=ke.location.pathname.split("/"),je=q.pathname.split("/").every((lt,at)=>lt===Ae[at]),rt=a!=null&&a.exact?ke.location.pathname===q.pathname:je,tt=a!=null&&a.includeHash?ke.location.hash===q.hash:!0,Et=(a==null?void 0:a.includeSearch)??!0?Rv(ke.location.search,q.search,!(a!=null&&a.exact)):!0;return rt&&tt&&Et}}),K=ke=>{!u&&!gZ(ke)&&!ke.defaultPrevented&&(!r||r==="_self")&&ke.button===0&&(ke.preventDefault(),e.commitLocation({...q,replace:v,resetScroll:S,startTransition:w}))},re=ke=>{J&&e.preloadRoute(U).catch(Ae=>{console.warn(Ae),console.warn(Q2)})},pe=ke=>{J&&e.preloadRoute(U).catch(Ae=>{console.warn(Ae),console.warn(Q2)})},he=ke=>{const Ae=ke.target||{};if(J){if(Ae.preloadTimeout)return;Ae.preloadTimeout=setTimeout(()=>{Ae.preloadTimeout=null,e.preloadRoute(U).catch(Ke=>{console.warn(Ke),console.warn(Q2)})},te)}},xe=ke=>{const Ae=ke.target||{};Ae.preloadTimeout&&(clearTimeout(Ae.preloadTimeout),Ae.preloadTimeout=null)},Ce=ke=>Ae=>{Ae.persist&&Ae.persist(),ke.filter(Boolean).forEach(Ke=>{Ae.defaultPrevented||Ke(Ae)})},Ee=le?_c(o,{})??{}:{},Ie=le?{}:_c(i,{})??{};return{...Ee,...Ie,...V,href:u?void 0:q.maskedLocation?q.maskedLocation.href:q.href,onClick:Ce([T,K]),onFocus:Ce([R,re]),onMouseEnter:Ce([_,he]),onMouseLeave:Ce([D,xe]),onTouchStart:Ce([L,pe]),target:r,style:{...k,...Ee.style,...Ie.style},className:[I,Ee.className,Ie.className].filter(Boolean).join(" ")||void 0,...u?{role:"link","aria-disabled":!0}:void 0,"data-status":le?"active":void 0}}const FI=fe.forwardRef((t,e)=>{const n=mZ(t);return fe.createElement("a",PI({ref:e},n,{children:typeof t.children=="function"?t.children({isActive:n["data-status"]==="active"}):t.children}))});function gZ(t){return!!(t.metaKey||t.altKey||t.ctrlKey||t.shiftKey)}function yZ(t,e){var n,s,r,o="";for(n in t)if((r=t[n])!==void 0)if(Array.isArray(r))for(s=0;s<r.length;s++)o&&(o+="&"),o+=encodeURIComponent(n)+"="+encodeURIComponent(r[s]);else o&&(o+="&"),o+=encodeURIComponent(n)+"="+encodeURIComponent(r);return(e||"")+o}function zD(t){if(!t)return"";var e=decodeURIComponent(t);return e==="false"?!1:e==="true"?!0:+e*0===0&&+e+""===e?+e:e}function xZ(t){for(var e,n,s={},r=t.split("&");e=r.shift();)e=e.split("="),n=e.shift(),s[n]!==void 0?s[n]=[].concat(s[n],zD(e.shift())):s[n]=zD(e.shift());return s}function cd(t){return!!(t!=null&&t.isRedirect)}const vZ=bZ(JSON.parse),wZ=SZ(JSON.stringify,JSON.parse);function bZ(t){return e=>{e.substring(0,1)==="?"&&(e=e.substring(1));let n=xZ(e);for(let s in n){const r=n[s];if(typeof r=="string")try{n[s]=t(r)}catch{}}return n}}function SZ(t,e){function n(s){if(typeof s=="object"&&s!==null)try{return t(s)}catch{}else if(typeof s=="string"&&typeof e=="function")try{return e(s),t(s)}catch{}return s}return s=>{s={...s},s&&Object.keys(s).forEach(o=>{const i=s[o];typeof i>"u"||i===void 0?delete s[o]:s[o]=n(i)});const r=yZ(s).toString();return r?`?${r}`:""}}const BD=["component","errorComponent","pendingComponent"];class CZ{constructor(e){bt(this,"tempLocationKey",`${Math.round(Math.random()*1e7)}`);bt(this,"resetNextScroll",!0);bt(this,"navigateTimeout",null);bt(this,"latestLoadPromise",Promise.resolve());bt(this,"subscribers",new Set);bt(this,"injectedHtml",[]);bt(this,"startReactTransition",e=>e());bt(this,"update",e=>{const n=this.options;this.options={...this.options,...e},(!this.basepath||e.basepath&&e.basepath!==n.basepath)&&(this.basepath=`/${sz(e.basepath??"")??""}`),(!this.history||this.options.history&&this.options.history!==this.history)&&(this.history=this.options.history??(typeof document<"u"?EQ():XM({initialEntries:[this.options.basepath||"/"]})),this.latestLocation=this.parseLocation()),this.options.routeTree!==this.routeTree&&(this.routeTree=this.options.routeTree,this.buildRouteTree()),this.__store||(this.__store=new YQ($Z(this.latestLocation),{onUpdate:()=>{this.__store.state={...this.state,status:this.state.isTransitioning||this.state.isLoading?"pending":"idle"}}}))});bt(this,"buildRouteTree",()=>{this.routesById={},this.routesByPath={};const e=this.options.notFoundRoute;e&&(e.init({originalIndex:99999999999}),this.routesById[e.id]=e);const n=r=>{r.forEach((o,i)=>{o.init({originalIndex:i});const a=this.routesById[o.id];if(fa(!a,`Duplicate routes found with id: ${String(o.id)}`),this.routesById[o.id]=o,!o.isRoot&&o.path){const l=Y1(o.fullPath);(!this.routesByPath[l]||o.fullPath.endsWith("/"))&&(this.routesByPath[l]=o)}const u=o.children;u!=null&&u.length&&n(u)})};n([this.routeTree]);const s=[];Object.values(this.routesById).forEach((r,o)=>{var l;if(r.isRoot||!r.path)return;const i=nz(r.fullPath),a=op(i);for(;a.length>1&&((l=a[0])==null?void 0:l.value)==="/";)a.shift();const u=a.map(c=>c.value==="/"?.75:c.type==="param"?.5:c.type==="wildcard"?.25:1);s.push({child:r,trimmed:i,parsed:a,index:o,scores:u})}),this.flatRoutes=s.sort((r,o)=>{const i=Math.min(r.scores.length,o.scores.length);for(let a=0;a<i;a++)if(r.scores[a]!==o.scores[a])return o.scores[a]-r.scores[a];if(r.scores.length!==o.scores.length)return o.scores.length-r.scores.length;for(let a=0;a<i;a++)if(r.parsed[a].value!==o.parsed[a].value)return r.parsed[a].value>o.parsed[a].value?1:-1;return r.index-o.index}).map((r,o)=>(r.child.rank=o,r.child))});bt(this,"subscribe",(e,n)=>{const s={eventType:e,fn:n};return this.subscribers.add(s),()=>{this.subscribers.delete(s)}});bt(this,"emit",e=>{this.subscribers.forEach(n=>{n.eventType===e.type&&n.fn(e)})});bt(this,"checkLatest",e=>this.latestLoadPromise!==e?this.latestLoadPromise:void 0);bt(this,"parseLocation",e=>{const n=({pathname:i,search:a,hash:u,state:l})=>{const c=this.options.parseSearch(a);return{pathname:i,searchStr:a,search:Wu(e==null?void 0:e.search,c),hash:u.split("#").reverse()[0]??"",href:`${i}${a}${u}`,state:Wu(e==null?void 0:e.state,l)}},s=n(this.history.location);let{__tempLocation:r,__tempKey:o}=s.state;if(r&&(!o||o===this.tempLocationKey)){const i=n(r);return i.state.key=s.state.key,delete i.state.__tempLocation,{...i,maskedLocation:s}}return s});bt(this,"resolvePathWithBase",(e,n)=>lZ(this.basepath,e,zw(n)));bt(this,"matchRoutes",(e,n,s)=>{let r={},o=this.flatRoutes.find(c=>{const h=Y2(this.basepath,Y1(e),{to:c.fullPath,caseSensitive:c.options.caseSensitive??this.options.caseSensitive,fuzzy:!0});return h?(r=h,!0):!1}),i=o||this.routesById.__root__,a=[i];for((o?o.path!=="/"&&r["**"]:Y1(e))&&this.options.notFoundRoute&&a.push(this.options.notFoundRoute);i!=null&&i.parentRoute;)i=i.parentRoute,i&&a.unshift(i);const u=a.map(c=>{let h;if(c.options.parseParams)try{const d=c.options.parseParams(r);Object.assign(r,d)}catch(d){if(h=new IZ(d.message,{cause:d}),s!=null&&s.throwOnError)throw h;return h}}),l=[];return a.forEach((c,h)=>{var R,_;const d=l[h-1],[f,m]=(()=>{const D=(d==null?void 0:d.search)??n;try{const L=typeof c.options.validateSearch=="object"?c.options.validateSearch.parse:c.options.validateSearch;let V=(L==null?void 0:L(D))??{};return[{...D,...V},void 0]}catch(L){const V=new kZ(L.message,{cause:L});if(s!=null&&s.throwOnError)throw V;return[D,V]}})(),y=((_=(R=c.options).loaderDeps)==null?void 0:_.call(R,{search:f}))??"",x=y?JSON.stringify(y):"",v=q2(c.fullPath,r),w=q2(c.id,r,!0)+x,S=X2(this.state,w),k=this.state.matches.find(D=>D.id===w)?"stay":"enter",I=!!(c.options.loader||BD.some(D=>{var L;return(L=c.options[D])==null?void 0:L.preload})),T=S?{...S,cause:k}:{id:w,routeId:c.id,params:r,pathname:cl([this.basepath,v]),updatedAt:Date.now(),search:{},searchError:void 0,status:I?"pending":"success",showPending:!1,isFetching:!1,error:void 0,paramsError:u[h],loadPromise:Promise.resolve(),routeContext:void 0,context:void 0,abortController:new AbortController,fetchCount:0,cause:k,loaderDeps:y,invalid:!1,preload:!1};T.search=Wu(T.search,f),T.searchError=m,l.push(T)}),l});bt(this,"cancelMatch",e=>{var n,s;(s=(n=X2(this.state,e))==null?void 0:n.abortController)==null||s.abort()});bt(this,"cancelMatches",()=>{var e;(e=this.state.pendingMatches)==null||e.forEach(n=>{this.cancelMatch(n.id)})});bt(this,"buildLocation",e=>{const n=(r={},o)=>{var R,_;const i=this.latestLocation,a=((R=(this.state.pendingMatches||this.state.matches).reverse()[0])==null?void 0:R.search)||i.search;let u=this.resolvePathWithBase(i.pathname,`${r.to??""}`);const l=this.matchRoutes(i.pathname,a),c=o==null?void 0:o.filter(D=>l==null?void 0:l.find(L=>L.routeId===D.routeId)),h={...(_=ZN(l))==null?void 0:_.params};let d=(r.params??!0)===!0?h:_c(r.params,h);d&&(o==null||o.map(D=>this.looseRoutesById[D.routeId].options.stringifyParams).filter(Boolean).forEach(D=>{d={...d,...D(d)}})),u=q2(u,d??{});const f=(c==null?void 0:c.map(D=>this.looseRoutesById[D.routeId].options.preSearchFilters??[]).flat().filter(Boolean))??[],m=(c==null?void 0:c.map(D=>this.looseRoutesById[D.routeId].options.postSearchFilters??[]).flat().filter(Boolean))??[],y=f!=null&&f.length?f==null?void 0:f.reduce((D,L)=>L(D),a):a,x=r.search===!0?y:r.search?_c(r.search,y)??{}:f!=null&&f.length?y:{},v=m!=null&&m.length?m.reduce((D,L)=>L(D),x):x,w=Wu(a,v),S=this.options.stringifySearch(w),k=r.hash===!0?i.hash:r.hash?_c(r.hash,i.hash):void 0,I=k?`#${k}`:"";let T=r.state===!0?i.state:r.state?_c(r.state,i.state):i.state;return T=Wu(i.state,T),{pathname:u,search:w,searchStr:S,state:T,hash:k??"",href:`${u}${S}${I}`,unmaskOnReload:r.unmaskOnReload}},s=(r={},o)=>{var d;let i=n(r),a=o?n(o):void 0;if(!a){let f={},m=(d=this.options.routeMasks)==null?void 0:d.find(y=>{const x=Y2(this.basepath,i.pathname,{to:y.from,caseSensitive:!1,fuzzy:!1});return x?(f=x,!0):!1});m&&(o={...mg(e,["from"]),...m,params:f},a=n(o))}const u=this.matchRoutes(i.pathname,i.search),l=a?this.matchRoutes(a.pathname,a.search):void 0,c=a?n(o,l):void 0,h=n(r,u);return c&&(h.maskedLocation=c),h};return e.mask?s(e,{...mg(e,["from"]),...e.mask}):s(e)});bt(this,"commitLocation",async({startTransition:e,...n})=>{if(this.navigateTimeout&&clearTimeout(this.navigateTimeout),!(this.latestLocation.href===n.href)||!n.replace){let{maskedLocation:r,...o}=n;r&&(o={...r,state:{...r.state,__tempKey:void 0,__tempLocation:{...o,search:o.searchStr,state:{...o.state,__tempKey:void 0,__tempLocation:void 0,key:void 0}}}},(o.unmaskOnReload??this.options.unmaskOnReload??!1)&&(o.state.__tempKey=this.tempLocationKey));const i=()=>{this.history[n.replace?"replace":"push"](o.href,o.state)};e??!0?this.startReactTransition(i):i()}return this.resetNextScroll=n.resetScroll??!0,this.latestLoadPromise});bt(this,"buildAndCommitLocation",({replace:e,resetScroll:n,startTransition:s,...r}={})=>{const o=this.buildLocation(r);return this.commitLocation({...o,startTransition:s,replace:e,resetScroll:n})});bt(this,"navigate",({from:e,to:n,...s})=>{const r=String(n);let o;try{new URL(`${r}`),o=!0}catch{}return fa(!o,"Attempting to navigate to external url with this.navigate!"),this.buildAndCommitLocation({...s,from:e,to:n})});bt(this,"loadMatches",async({checkLatest:e,matches:n,preload:s})=>{var l,c;let r,o;const i=h=>{var y;const d=(y=this.state.pendingMatches)==null?void 0:y.find(x=>x.id===h.id),f=this.state.matches.find(x=>x.id===h.id),m=d?"pendingMatches":f?"matches":"cachedMatches";this.__store.setState(x=>{var v;return{...x,[m]:(v=x[m])==null?void 0:v.map(w=>w.id===h.id?h:w)}})};try{for(let[h,d]of n.entries()){const f=n[h-1],m=this.looseRoutesById[d.routeId],y=new AbortController,x=(v,w)=>{var S,k;if(v.routerCode=w,o=o??h,cd(v))throw v;try{(k=(S=m.options).onError)==null||k.call(S,v)}catch(I){if(v=I,cd(I))throw I}n[h]=d={...d,error:v,status:"error",updatedAt:Date.now(),abortController:new AbortController}};try{d.paramsError&&x(d.paramsError,"PARSE_PARAMS"),d.searchError&&x(d.searchError,"VALIDATE_SEARCH");const v=(f==null?void 0:f.context)??this.options.context??{},w=await((c=(l=m.options).beforeLoad)==null?void 0:c.call(l,{search:d.search,abortController:y,params:d.params,preload:!!s,context:v,location:this.state.location,navigate:k=>this.navigate({...k,from:d.pathname}),buildLocation:this.buildLocation,cause:s?"preload":d.cause}))??{};if(cd(w))throw w;const S={...v,...w};n[h]=d={...d,routeContext:Wu(d.routeContext,w),context:Wu(d.context,S),abortController:y}}catch(v){x(v,"BEFORE_LOAD");break}}}catch(h){if(cd(h))return s||this.navigate(h),n;throw h}const a=n.slice(0,o),u=[];return a.forEach((h,d)=>{u.push(new Promise(async f=>{const m=u[d-1],y=this.looseRoutesById[h.routeId],x=U=>cd(U)?(s||this.navigate(U),!0):!1;let v;n[d]=h={...h,showPending:!1};let w=!1;const S=y.options.pendingMs??this.options.defaultPendingMs,k=y.options.pendingMinMs??this.options.defaultPendingMinMs,I=!s&&S&&(y.options.pendingComponent??this.options.defaultPendingComponent),T={params:h.params,deps:h.loaderDeps,preload:!!s,parentMatchPromise:m,abortController:h.abortController,context:h.context,location:this.state.location,navigate:U=>this.navigate({...U,from:h.pathname}),cause:s?"preload":h.cause},R=async()=>{var U,j,q,J,te;if(h.isFetching)v=(U=X2(this.state,h.id))==null?void 0:U.loadPromise;else{h.fetchCount&&h.status==="success"&&f(),n[d]=h={...h,isFetching:!0,fetchCount:h.fetchCount+1};const le=Promise.all(BD.map(async re=>{const pe=y.options[re];pe!=null&&pe.preload&&await pe.preload()})),K=(q=(j=y.options).loader)==null?void 0:q.call(j,T);v=Promise.all([le,K]).then(re=>re[1])}n[d]=h={...h,loadPromise:v},i(h);try{const le=await v;if(r=e())return await r;if(cd(le)&&x(le))return;if(w&&k&&await new Promise(K=>setTimeout(K,k)),r=e())return await r;n[d]=h={...h,error:void 0,status:"success",isFetching:!1,updatedAt:Date.now(),loaderData:le,loadPromise:void 0}}catch(le){if(r=e())return await r;if(x(le))return;try{(te=(J=y.options).onError)==null||te.call(J,le)}catch(K){if(le=K,x(K))return}n[d]=h={...h,error:le,status:"error",isFetching:!1}}i(h)},_=Date.now()-h.updatedAt;let D=s?y.options.preloadStaleTime??this.options.defaultPreloadStaleTime??3e4:y.options.staleTime??this.options.defaultStaleTime??0,L;const V=y.options.shouldReload;L=typeof V=="function"?V(T):V,n[d]=h={...h,preload:!!s&&!this.state.matches.find(U=>U.id===h.id)},h.status!=="success"?(I&&new Promise(U=>setTimeout(U,S)).then(async()=>{if(r=e())return r;w=!0,n[d]=h={...h,showPending:!0},i(h),f()}),await R()):(h.invalid||(L??_>D))&&R(),f()}))}),await Promise.all(u),n});bt(this,"invalidate",()=>{const e=n=>({...n,invalid:!0});this.__store.setState(n=>{var s;return{...n,matches:n.matches.map(e),cachedMatches:n.cachedMatches.map(e),pendingMatches:(s=n.pendingMatches)==null?void 0:s.map(e)}}),this.load()});bt(this,"load",async()=>{const e=new Promise(async(n,s)=>{const r=this.latestLocation,o=this.state.resolvedLocation,i=o.href!==r.href;let a;this.cancelMatches(),this.emit({type:"onBeforeLoad",fromLocation:o,toLocation:r,pathChanged:i});let u;const l=this.state.matches;this.__store.batch(()=>{this.cleanCache(),u=this.matchRoutes(r.pathname,r.search,{debug:!0}),this.__store.setState(c=>({...c,isLoading:!0,location:r,pendingMatches:u,cachedMatches:c.cachedMatches.filter(h=>!u.find(d=>d.id===h.id))}))});try{try{await this.loadMatches({matches:u,checkLatest:()=>this.checkLatest(e)})}catch{}if(a=this.checkLatest(e))return a;const c=l.filter(f=>!u.find(m=>m.id===f.id)),h=u.filter(f=>!l.find(m=>m.id===f.id)),d=l.filter(f=>u.find(m=>m.id===f.id));this.__store.batch(()=>{this.__store.setState(f=>({...f,isLoading:!1,matches:f.pendingMatches,pendingMatches:void 0,cachedMatches:[...f.cachedMatches,...c.filter(m=>m.status!=="error")]})),this.cleanCache()}),[[c,"onLeave"],[h,"onEnter"],[d,"onStay"]].forEach(([f,m])=>{f.forEach(y=>{var x,v;(v=(x=this.looseRoutesById[y.routeId].options)[m])==null||v.call(x,y)})}),this.emit({type:"onLoad",fromLocation:o,toLocation:r,pathChanged:i}),n()}catch(c){if(a=this.checkLatest(e))return a;s(c)}});return this.latestLoadPromise=e,this.latestLoadPromise});bt(this,"cleanCache",()=>{this.__store.setState(e=>({...e,cachedMatches:e.cachedMatches.filter(n=>{const s=this.looseRoutesById[n.routeId];if(!s.options.loader)return!1;const r=(n.preload?s.options.preloadGcTime??this.options.defaultPreloadGcTime:s.options.gcTime??this.options.defaultGcTime)??5*60*1e3;return n.status!=="error"&&Date.now()-n.updatedAt<r})}))});bt(this,"preloadRoute",async(e=this.state.location)=>{let n=this.buildLocation(e),s=this.matchRoutes(n.pathname,n.search,{throwOnError:!0});const r=Object.fromEntries([...this.state.matches,...this.state.pendingMatches??[],...this.state.cachedMatches].map(o=>[o.id,!0]));return this.__store.batch(()=>{s.forEach(o=>{r[o.id]||this.__store.setState(i=>({...i,cachedMatches:[...i.cachedMatches,o]}))})}),s=await this.loadMatches({matches:s,preload:!0,checkLatest:()=>{}}),s});bt(this,"matchRoute",(e,n)=>{e={...e,to:e.to?this.resolvePathWithBase(e.from||"",e.to):void 0};const s=this.buildLocation(e);if(n!=null&&n.pending&&this.state.status!=="pending")return!1;const r=n!=null&&n.pending?this.latestLocation:this.state.resolvedLocation;if(!r)return!1;const o=Y2(this.basepath,r.pathname,{...n,to:s.pathname});return o?o&&((n==null?void 0:n.includeSearch)??!0)?Rv(r.search,s.search,!0)?o:!1:o:!1});bt(this,"injectHtml",async e=>{this.injectedHtml.push(e)});bt(this,"dehydrateData",(e,n)=>{if(typeof document>"u"){const s=typeof e=="string"?e:JSON.stringify(e);return this.injectHtml(async()=>{const r=`__TSR_DEHYDRATED__${s}`,o=typeof n=="function"?await n():n;return`<script id='${r}' suppressHydrationWarning>window["__TSR_DEHYDRATED__${tZ(s)}"] = ${JSON.stringify(o)}
          ;(() => {
            var el = document.getElementById('${r}')
            el.parentElement.removeChild(el)
          })()
          <\/script>`}),()=>this.hydrateData(e)}return()=>{}});bt(this,"hydrateData",e=>{if(typeof document<"u"){const n=typeof e=="string"?e:JSON.stringify(e);return window[`__TSR_DEHYDRATED__${n}`]}});bt(this,"dehydrate",()=>({state:{dehydratedMatches:this.state.matches.map(e=>mg(e,["id","status","updatedAt","loaderData"]))}}));bt(this,"hydrate",async e=>{var i,a;let n=e;typeof document<"u"&&(n=window.__TSR_DEHYDRATED__),fa(n,"Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?");const s=n;this.dehydratedData=s.payload,(a=(i=this.options).hydrate)==null||a.call(i,s.payload);const r=s.router.state;let o=this.matchRoutes(this.state.location.pathname,this.state.location.search).map(u=>{const l=r.dehydratedMatches.find(c=>c.id===u.id);return fa(l,`Could not find a client-side match for dehydrated match with id: ${u.id}!`),l?{...u,...l}:u});this.__store.setState(u=>({...u,matches:o}))});this.update({defaultPreloadDelay:50,defaultPendingMs:1e3,defaultPendingMinMs:500,context:void 0,...e,stringifySearch:(e==null?void 0:e.stringifySearch)??wZ,parseSearch:(e==null?void 0:e.parseSearch)??vZ})}get state(){return this.__store.state}get looseRoutesById(){return this.routesById}}class kZ extends Error{}class IZ extends Error{}function $Z(t){return{isLoading:!1,isTransitioning:!1,status:"idle",resolvedLocation:{...t},location:t,matches:[],pendingMatches:[],cachedMatches:[],lastUpdated:Date.now()}}const NZ=typeof window<"u"&&window.sessionStorage;let Z2=NZ?(()=>{const t="tsr-scroll-restoration-v2";return{state:JSON.parse(window.sessionStorage.getItem(t)||"null")||{cached:{},next:{}},set:n=>{Z2.state=_c(n,Z2.state),window.sessionStorage.setItem(t,JSON.stringify(Z2.state))}}})():void 0;const Bw=fe.createContext({sets:[],upsertSet:()=>{}}),TZ=t=>{const[e,n]=fe.useState([]),s=r=>{n(o=>o.includes(r)?o.filter(i=>i!==r):[...o,r])};return Pt.jsx(Bw.Provider,{value:{sets:e,upsertSet:s},children:t.children})};function yu(){return yu=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&(t[s]=n[s])}return t},yu.apply(this,arguments)}function EZ(t,e){typeof t=="function"?t(e):t!=null&&(t.current=e)}function rz(...t){return e=>t.forEach(n=>EZ(n,e))}function oz(...t){return fe.useCallback(rz(...t),t)}function RZ(t,e=[]){let n=[];function s(o,i){const a=fe.createContext(i),u=n.length;n=[...n,i];function l(h){const{scope:d,children:f,...m}=h,y=(d==null?void 0:d[t][u])||a,x=fe.useMemo(()=>m,Object.values(m));return fe.createElement(y.Provider,{value:x},f)}function c(h,d){const f=(d==null?void 0:d[t][u])||a,m=fe.useContext(f);if(m)return m;if(i!==void 0)return i;throw new Error(`\`${h}\` must be used within \`${o}\``)}return l.displayName=o+"Provider",[l,c]}const r=()=>{const o=n.map(i=>fe.createContext(i));return function(a){const u=(a==null?void 0:a[t])||o;return fe.useMemo(()=>({[`__scope${t}`]:{...a,[t]:u}}),[a,u])}};return r.scopeName=t,[s,AZ(r,...e)]}function AZ(...t){const e=t[0];if(t.length===1)return e;const n=()=>{const s=t.map(r=>({useScope:r(),scopeName:r.scopeName}));return function(o){const i=s.reduce((a,{useScope:u,scopeName:l})=>{const h=u(o)[`__scope${l}`];return{...a,...h}},{});return fe.useMemo(()=>({[`__scope${e.scopeName}`]:i}),[i])}};return n.scopeName=e.scopeName,n}function VD(t,e,{checkForDefaultPrevented:n=!0}={}){return function(r){if(t==null||t(r),n===!1||!r.defaultPrevented)return e==null?void 0:e(r)}}function iz(t){const e=fe.useRef(t);return fe.useEffect(()=>{e.current=t}),fe.useMemo(()=>(...n)=>{var s;return(s=e.current)===null||s===void 0?void 0:s.call(e,...n)},[])}function _Z({prop:t,defaultProp:e,onChange:n=()=>{}}){const[s,r]=DZ({defaultProp:e,onChange:n}),o=t!==void 0,i=o?t:s,a=iz(n),u=fe.useCallback(l=>{if(o){const h=typeof l=="function"?l(t):l;h!==t&&a(h)}else r(l)},[o,t,r,a]);return[i,u]}function DZ({defaultProp:t,onChange:e}){const n=fe.useState(t),[s]=n,r=fe.useRef(s),o=iz(e);return fe.useEffect(()=>{r.current!==s&&(o(s),r.current=s)},[s,r,o]),n}function PZ(t){const e=fe.useRef({value:t,previous:t});return fe.useMemo(()=>(e.current.value!==t&&(e.current.previous=e.current.value,e.current.value=t),e.current.previous),[t])}const OI=globalThis!=null&&globalThis.document?fe.useLayoutEffect:()=>{};function FZ(t){const[e,n]=fe.useState(void 0);return OI(()=>{if(t){n({width:t.offsetWidth,height:t.offsetHeight});const s=new ResizeObserver(r=>{if(!Array.isArray(r)||!r.length)return;const o=r[0];let i,a;if("borderBoxSize"in o){const u=o.borderBoxSize,l=Array.isArray(u)?u[0]:u;i=l.inlineSize,a=l.blockSize}else i=t.offsetWidth,a=t.offsetHeight;n({width:i,height:a})});return s.observe(t,{box:"border-box"}),()=>s.unobserve(t)}else n(void 0)},[t]),e}function OZ(t,e){return fe.useReducer((n,s)=>{const r=e[n][s];return r??n},t)}const az=t=>{const{present:e,children:n}=t,s=LZ(e),r=typeof n=="function"?n({present:s.isPresent}):fe.Children.only(n),o=oz(s.ref,r.ref);return typeof n=="function"||s.isPresent?fe.cloneElement(r,{ref:o}):null};az.displayName="Presence";function LZ(t){const[e,n]=fe.useState(),s=fe.useRef({}),r=fe.useRef(t),o=fe.useRef("none"),i=t?"mounted":"unmounted",[a,u]=OZ(i,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}});return fe.useEffect(()=>{const l=y1(s.current);o.current=a==="mounted"?l:"none"},[a]),OI(()=>{const l=s.current,c=r.current;if(c!==t){const d=o.current,f=y1(l);t?u("MOUNT"):f==="none"||(l==null?void 0:l.display)==="none"?u("UNMOUNT"):u(c&&d!==f?"ANIMATION_OUT":"UNMOUNT"),r.current=t}},[t,u]),OI(()=>{if(e){const l=h=>{const f=y1(s.current).includes(h.animationName);h.target===e&&f&&GM.flushSync(()=>u("ANIMATION_END"))},c=h=>{h.target===e&&(o.current=y1(s.current))};return e.addEventListener("animationstart",c),e.addEventListener("animationcancel",l),e.addEventListener("animationend",l),()=>{e.removeEventListener("animationstart",c),e.removeEventListener("animationcancel",l),e.removeEventListener("animationend",l)}}else u("ANIMATION_END")},[e,u]),{isPresent:["mounted","unmountSuspended"].includes(a),ref:fe.useCallback(l=>{l&&(s.current=getComputedStyle(l)),n(l)},[])}}function y1(t){return(t==null?void 0:t.animationName)||"none"}const uz=fe.forwardRef((t,e)=>{const{children:n,...s}=t,r=fe.Children.toArray(n),o=r.find(zZ);if(o){const i=o.props.children,a=r.map(u=>u===o?fe.Children.count(i)>1?fe.Children.only(null):fe.isValidElement(i)?i.props.children:null:u);return fe.createElement(LI,yu({},s,{ref:e}),fe.isValidElement(i)?fe.cloneElement(i,void 0,a):null)}return fe.createElement(LI,yu({},s,{ref:e}),n)});uz.displayName="Slot";const LI=fe.forwardRef((t,e)=>{const{children:n,...s}=t;return fe.isValidElement(n)?fe.cloneElement(n,{...BZ(s,n.props),ref:e?rz(e,n.ref):n.ref}):fe.Children.count(n)>1?fe.Children.only(null):null});LI.displayName="SlotClone";const MZ=({children:t})=>fe.createElement(fe.Fragment,null,t);function zZ(t){return fe.isValidElement(t)&&t.type===MZ}function BZ(t,e){const n={...e};for(const s in e){const r=t[s],o=e[s];/^on[A-Z]/.test(s)?r&&o?n[s]=(...a)=>{o(...a),r(...a)}:r&&(n[s]=r):s==="style"?n[s]={...r,...o}:s==="className"&&(n[s]=[r,o].filter(Boolean).join(" "))}return{...t,...n}}const VZ=["a","button","div","form","h2","h3","img","input","label","li","nav","ol","p","span","svg","ul"],eT=VZ.reduce((t,e)=>{const n=fe.forwardRef((s,r)=>{const{asChild:o,...i}=s,a=o?uz:e;return fe.useEffect(()=>{window[Symbol.for("radix-ui")]=!0},[]),fe.createElement(a,yu({},i,{ref:r}))});return n.displayName=`Primitive.${e}`,{...t,[e]:n}},{}),lz="Checkbox",[WZ,iWe]=RZ(lz),[UZ,GZ]=WZ(lz),HZ=fe.forwardRef((t,e)=>{const{__scopeCheckbox:n,name:s,checked:r,defaultChecked:o,required:i,disabled:a,value:u="on",onCheckedChange:l,...c}=t,[h,d]=fe.useState(null),f=oz(e,S=>d(S)),m=fe.useRef(!1),y=h?!!h.closest("form"):!0,[x=!1,v]=_Z({prop:r,defaultProp:o,onChange:l}),w=fe.useRef(x);return fe.useEffect(()=>{const S=h==null?void 0:h.form;if(S){const k=()=>v(w.current);return S.addEventListener("reset",k),()=>S.removeEventListener("reset",k)}},[h,v]),fe.createElement(UZ,{scope:n,state:x,disabled:a},fe.createElement(eT.button,yu({type:"button",role:"checkbox","aria-checked":Vc(x)?"mixed":x,"aria-required":i,"data-state":cz(x),"data-disabled":a?"":void 0,disabled:a,value:u},c,{ref:f,onKeyDown:VD(t.onKeyDown,S=>{S.key==="Enter"&&S.preventDefault()}),onClick:VD(t.onClick,S=>{v(k=>Vc(k)?!0:!k),y&&(m.current=S.isPropagationStopped(),m.current||S.stopPropagation())})})),y&&fe.createElement(XZ,{control:h,bubbles:!m.current,name:s,value:u,checked:x,required:i,disabled:a,style:{transform:"translateX(-100%)"}}))}),jZ="CheckboxIndicator",KZ=fe.forwardRef((t,e)=>{const{__scopeCheckbox:n,forceMount:s,...r}=t,o=GZ(jZ,n);return fe.createElement(az,{present:s||Vc(o.state)||o.state===!0},fe.createElement(eT.span,yu({"data-state":cz(o.state),"data-disabled":o.disabled?"":void 0},r,{ref:e,style:{pointerEvents:"none",...t.style}})))}),XZ=t=>{const{control:e,checked:n,bubbles:s=!0,...r}=t,o=fe.useRef(null),i=PZ(n),a=FZ(e);return fe.useEffect(()=>{const u=o.current,l=window.HTMLInputElement.prototype,h=Object.getOwnPropertyDescriptor(l,"checked").set;if(i!==n&&h){const d=new Event("click",{bubbles:s});u.indeterminate=Vc(n),h.call(u,Vc(n)?!1:n),u.dispatchEvent(d)}},[i,n,s]),fe.createElement("input",yu({type:"checkbox","aria-hidden":!0,defaultChecked:Vc(n)?!1:n},r,{tabIndex:-1,ref:o,style:{...t.style,...a,position:"absolute",pointerEvents:"none",opacity:0,margin:0}}))};function Vc(t){return t==="indeterminate"}function cz(t){return Vc(t)?"indeterminate":t?"checked":"unchecked"}const hz=HZ,qZ=KZ;/**
 * @license lucide-react v0.309.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var YZ={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};/**
 * @license lucide-react v0.309.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const QZ=t=>t.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase().trim(),ZZ=(t,e)=>{const n=fe.forwardRef(({color:s="currentColor",size:r=24,strokeWidth:o=2,absoluteStrokeWidth:i,className:a="",children:u,...l},c)=>fe.createElement("svg",{ref:c,...YZ,width:r,height:r,stroke:s,strokeWidth:i?Number(o)*24/Number(r):o,className:["lucide",`lucide-${QZ(t)}`,a].join(" "),...l},[...e.map(([h,d])=>fe.createElement(h,d)),...Array.isArray(u)?u:[u]]));return n.displayName=`${t}`,n};/**
 * @license lucide-react v0.309.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const JZ=ZZ("Check",[["path",{d:"M20 6 9 17l-5-5",key:"1gmf2c"}]]);function dz(t){var e,n,s="";if(typeof t=="string"||typeof t=="number")s+=t;else if(typeof t=="object")if(Array.isArray(t)){var r=t.length;for(e=0;e<r;e++)t[e]&&(n=dz(t[e]))&&(s&&(s+=" "),s+=n)}else for(n in t)t[n]&&(s&&(s+=" "),s+=n);return s}function eJ(){for(var t,e,n=0,s="",r=arguments.length;n<r;n++)(t=arguments[n])&&(e=dz(t))&&(s&&(s+=" "),s+=e);return s}const tT="-";function tJ(t){const e=sJ(t),{conflictingClassGroups:n,conflictingClassGroupModifiers:s}=t;function r(i){const a=i.split(tT);return a[0]===""&&a.length!==1&&a.shift(),pz(a,e)||nJ(i)}function o(i,a){const u=n[i]||[];return a&&s[i]?[...u,...s[i]]:u}return{getClassGroupId:r,getConflictingClassGroupIds:o}}function pz(t,e){var i;if(t.length===0)return e.classGroupId;const n=t[0],s=e.nextPart.get(n),r=s?pz(t.slice(1),s):void 0;if(r)return r;if(e.validators.length===0)return;const o=t.join(tT);return(i=e.validators.find(({validator:a})=>a(o)))==null?void 0:i.classGroupId}const WD=/^\[(.+)\]$/;function nJ(t){if(WD.test(t)){const e=WD.exec(t)[1],n=e==null?void 0:e.substring(0,e.indexOf(":"));if(n)return"arbitrary.."+n}}function sJ(t){const{theme:e,prefix:n}=t,s={nextPart:new Map,validators:[]};return oJ(Object.entries(t.classGroups),n).forEach(([o,i])=>{MI(i,s,o,e)}),s}function MI(t,e,n,s){t.forEach(r=>{if(typeof r=="string"){const o=r===""?e:UD(e,r);o.classGroupId=n;return}if(typeof r=="function"){if(rJ(r)){MI(r(s),e,n,s);return}e.validators.push({validator:r,classGroupId:n});return}Object.entries(r).forEach(([o,i])=>{MI(i,UD(e,o),n,s)})})}function UD(t,e){let n=t;return e.split(tT).forEach(s=>{n.nextPart.has(s)||n.nextPart.set(s,{nextPart:new Map,validators:[]}),n=n.nextPart.get(s)}),n}function rJ(t){return t.isThemeGetter}function oJ(t,e){return e?t.map(([n,s])=>{const r=s.map(o=>typeof o=="string"?e+o:typeof o=="object"?Object.fromEntries(Object.entries(o).map(([i,a])=>[e+i,a])):o);return[n,r]}):t}function iJ(t){if(t<1)return{get:()=>{},set:()=>{}};let e=0,n=new Map,s=new Map;function r(o,i){n.set(o,i),e++,e>t&&(e=0,s=n,n=new Map)}return{get(o){let i=n.get(o);if(i!==void 0)return i;if((i=s.get(o))!==void 0)return r(o,i),i},set(o,i){n.has(o)?n.set(o,i):r(o,i)}}}const fz="!";function aJ(t){const e=t.separator,n=e.length===1,s=e[0],r=e.length;return function(i){const a=[];let u=0,l=0,c;for(let y=0;y<i.length;y++){let x=i[y];if(u===0){if(x===s&&(n||i.slice(y,y+r)===e)){a.push(i.slice(l,y)),l=y+r;continue}if(x==="/"){c=y;continue}}x==="["?u++:x==="]"&&u--}const h=a.length===0?i:i.substring(l),d=h.startsWith(fz),f=d?h.substring(1):h,m=c&&c>l?c-l:void 0;return{modifiers:a,hasImportantModifier:d,baseClassName:f,maybePostfixModifierPosition:m}}}function uJ(t){if(t.length<=1)return t;const e=[];let n=[];return t.forEach(s=>{s[0]==="["?(e.push(...n.sort(),s),n=[]):n.push(s)}),e.push(...n.sort()),e}function lJ(t){return{cache:iJ(t.cacheSize),splitModifiers:aJ(t),...tJ(t)}}const cJ=/\s+/;function hJ(t,e){const{splitModifiers:n,getClassGroupId:s,getConflictingClassGroupIds:r}=e,o=new Set;return t.trim().split(cJ).map(i=>{const{modifiers:a,hasImportantModifier:u,baseClassName:l,maybePostfixModifierPosition:c}=n(i);let h=s(c?l.substring(0,c):l),d=!!c;if(!h){if(!c)return{isTailwindClass:!1,originalClassName:i};if(h=s(l),!h)return{isTailwindClass:!1,originalClassName:i};d=!1}const f=uJ(a).join(":");return{isTailwindClass:!0,modifierId:u?f+fz:f,classGroupId:h,originalClassName:i,hasPostfixModifier:d}}).reverse().filter(i=>{if(!i.isTailwindClass)return!0;const{modifierId:a,classGroupId:u,hasPostfixModifier:l}=i,c=a+u;return o.has(c)?!1:(o.add(c),r(u,l).forEach(h=>o.add(a+h)),!0)}).reverse().map(i=>i.originalClassName).join(" ")}function dJ(){let t=0,e,n,s="";for(;t<arguments.length;)(e=arguments[t++])&&(n=mz(e))&&(s&&(s+=" "),s+=n);return s}function mz(t){if(typeof t=="string")return t;let e,n="";for(let s=0;s<t.length;s++)t[s]&&(e=mz(t[s]))&&(n&&(n+=" "),n+=e);return n}function pJ(t,...e){let n,s,r,o=i;function i(u){const l=e.reduce((c,h)=>h(c),t());return n=lJ(l),s=n.cache.get,r=n.cache.set,o=a,a(u)}function a(u){const l=s(u);if(l)return l;const c=hJ(u,n);return r(u,c),c}return function(){return o(dJ.apply(null,arguments))}}function Nn(t){const e=n=>n[t]||[];return e.isThemeGetter=!0,e}const gz=/^\[(?:([a-z-]+):)?(.+)\]$/i,fJ=/^\d+\/\d+$/,mJ=new Set(["px","full","screen"]),gJ=/^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,yJ=/\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,xJ=/^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/,vJ=/^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;function Xa(t){return Dc(t)||mJ.has(t)||fJ.test(t)}function Bu(t){return $p(t,"length",NJ)}function Dc(t){return!!t&&!Number.isNaN(Number(t))}function x1(t){return $p(t,"number",Dc)}function zm(t){return!!t&&Number.isInteger(Number(t))}function wJ(t){return t.endsWith("%")&&Dc(t.slice(0,-1))}function Tt(t){return gz.test(t)}function Vu(t){return gJ.test(t)}const bJ=new Set(["length","size","percentage"]);function SJ(t){return $p(t,bJ,yz)}function CJ(t){return $p(t,"position",yz)}const kJ=new Set(["image","url"]);function IJ(t){return $p(t,kJ,EJ)}function $J(t){return $p(t,"",TJ)}function Bm(){return!0}function $p(t,e,n){const s=gz.exec(t);return s?s[1]?typeof e=="string"?s[1]===e:e.has(s[1]):n(s[2]):!1}function NJ(t){return yJ.test(t)}function yz(){return!1}function TJ(t){return xJ.test(t)}function EJ(t){return vJ.test(t)}function RJ(){const t=Nn("colors"),e=Nn("spacing"),n=Nn("blur"),s=Nn("brightness"),r=Nn("borderColor"),o=Nn("borderRadius"),i=Nn("borderSpacing"),a=Nn("borderWidth"),u=Nn("contrast"),l=Nn("grayscale"),c=Nn("hueRotate"),h=Nn("invert"),d=Nn("gap"),f=Nn("gradientColorStops"),m=Nn("gradientColorStopPositions"),y=Nn("inset"),x=Nn("margin"),v=Nn("opacity"),w=Nn("padding"),S=Nn("saturate"),k=Nn("scale"),I=Nn("sepia"),T=Nn("skew"),R=Nn("space"),_=Nn("translate"),D=()=>["auto","contain","none"],L=()=>["auto","hidden","clip","visible","scroll"],V=()=>["auto",Tt,e],U=()=>[Tt,e],j=()=>["",Xa,Bu],q=()=>["auto",Dc,Tt],J=()=>["bottom","center","left","left-bottom","left-top","right","right-bottom","right-top","top"],te=()=>["solid","dashed","dotted","double","none"],le=()=>["normal","multiply","screen","overlay","darken","lighten","color-dodge","color-burn","hard-light","soft-light","difference","exclusion","hue","saturation","color","luminosity","plus-lighter"],K=()=>["start","end","center","between","around","evenly","stretch"],re=()=>["","0",Tt],pe=()=>["auto","avoid","all","avoid-page","page","left","right","column"],he=()=>[Dc,x1],xe=()=>[Dc,Tt];return{cacheSize:500,separator:":",theme:{colors:[Bm],spacing:[Xa,Bu],blur:["none","",Vu,Tt],brightness:he(),borderColor:[t],borderRadius:["none","","full",Vu,Tt],borderSpacing:U(),borderWidth:j(),contrast:he(),grayscale:re(),hueRotate:xe(),invert:re(),gap:U(),gradientColorStops:[t],gradientColorStopPositions:[wJ,Bu],inset:V(),margin:V(),opacity:he(),padding:U(),saturate:he(),scale:he(),sepia:re(),skew:xe(),space:U(),translate:U()},classGroups:{aspect:[{aspect:["auto","square","video",Tt]}],container:["container"],columns:[{columns:[Vu]}],"break-after":[{"break-after":pe()}],"break-before":[{"break-before":pe()}],"break-inside":[{"break-inside":["auto","avoid","avoid-page","avoid-column"]}],"box-decoration":[{"box-decoration":["slice","clone"]}],box:[{box:["border","content"]}],display:["block","inline-block","inline","flex","inline-flex","table","inline-table","table-caption","table-cell","table-column","table-column-group","table-footer-group","table-header-group","table-row-group","table-row","flow-root","grid","inline-grid","contents","list-item","hidden"],float:[{float:["right","left","none","start","end"]}],clear:[{clear:["left","right","both","none","start","end"]}],isolation:["isolate","isolation-auto"],"object-fit":[{object:["contain","cover","fill","none","scale-down"]}],"object-position":[{object:[...J(),Tt]}],overflow:[{overflow:L()}],"overflow-x":[{"overflow-x":L()}],"overflow-y":[{"overflow-y":L()}],overscroll:[{overscroll:D()}],"overscroll-x":[{"overscroll-x":D()}],"overscroll-y":[{"overscroll-y":D()}],position:["static","fixed","absolute","relative","sticky"],inset:[{inset:[y]}],"inset-x":[{"inset-x":[y]}],"inset-y":[{"inset-y":[y]}],start:[{start:[y]}],end:[{end:[y]}],top:[{top:[y]}],right:[{right:[y]}],bottom:[{bottom:[y]}],left:[{left:[y]}],visibility:["visible","invisible","collapse"],z:[{z:["auto",zm,Tt]}],basis:[{basis:V()}],"flex-direction":[{flex:["row","row-reverse","col","col-reverse"]}],"flex-wrap":[{flex:["wrap","wrap-reverse","nowrap"]}],flex:[{flex:["1","auto","initial","none",Tt]}],grow:[{grow:re()}],shrink:[{shrink:re()}],order:[{order:["first","last","none",zm,Tt]}],"grid-cols":[{"grid-cols":[Bm]}],"col-start-end":[{col:["auto",{span:["full",zm,Tt]},Tt]}],"col-start":[{"col-start":q()}],"col-end":[{"col-end":q()}],"grid-rows":[{"grid-rows":[Bm]}],"row-start-end":[{row:["auto",{span:[zm,Tt]},Tt]}],"row-start":[{"row-start":q()}],"row-end":[{"row-end":q()}],"grid-flow":[{"grid-flow":["row","col","dense","row-dense","col-dense"]}],"auto-cols":[{"auto-cols":["auto","min","max","fr",Tt]}],"auto-rows":[{"auto-rows":["auto","min","max","fr",Tt]}],gap:[{gap:[d]}],"gap-x":[{"gap-x":[d]}],"gap-y":[{"gap-y":[d]}],"justify-content":[{justify:["normal",...K()]}],"justify-items":[{"justify-items":["start","end","center","stretch"]}],"justify-self":[{"justify-self":["auto","start","end","center","stretch"]}],"align-content":[{content:["normal",...K(),"baseline"]}],"align-items":[{items:["start","end","center","baseline","stretch"]}],"align-self":[{self:["auto","start","end","center","stretch","baseline"]}],"place-content":[{"place-content":[...K(),"baseline"]}],"place-items":[{"place-items":["start","end","center","baseline","stretch"]}],"place-self":[{"place-self":["auto","start","end","center","stretch"]}],p:[{p:[w]}],px:[{px:[w]}],py:[{py:[w]}],ps:[{ps:[w]}],pe:[{pe:[w]}],pt:[{pt:[w]}],pr:[{pr:[w]}],pb:[{pb:[w]}],pl:[{pl:[w]}],m:[{m:[x]}],mx:[{mx:[x]}],my:[{my:[x]}],ms:[{ms:[x]}],me:[{me:[x]}],mt:[{mt:[x]}],mr:[{mr:[x]}],mb:[{mb:[x]}],ml:[{ml:[x]}],"space-x":[{"space-x":[R]}],"space-x-reverse":["space-x-reverse"],"space-y":[{"space-y":[R]}],"space-y-reverse":["space-y-reverse"],w:[{w:["auto","min","max","fit","svw","lvw","dvw",Tt,e]}],"min-w":[{"min-w":[Tt,e,"min","max","fit"]}],"max-w":[{"max-w":[Tt,e,"none","full","min","max","fit","prose",{screen:[Vu]},Vu]}],h:[{h:[Tt,e,"auto","min","max","fit","svh","lvh","dvh"]}],"min-h":[{"min-h":[Tt,e,"min","max","fit","svh","lvh","dvh"]}],"max-h":[{"max-h":[Tt,e,"min","max","fit","svh","lvh","dvh"]}],size:[{size:[Tt,e,"auto","min","max","fit"]}],"font-size":[{text:["base",Vu,Bu]}],"font-smoothing":["antialiased","subpixel-antialiased"],"font-style":["italic","not-italic"],"font-weight":[{font:["thin","extralight","light","normal","medium","semibold","bold","extrabold","black",x1]}],"font-family":[{font:[Bm]}],"fvn-normal":["normal-nums"],"fvn-ordinal":["ordinal"],"fvn-slashed-zero":["slashed-zero"],"fvn-figure":["lining-nums","oldstyle-nums"],"fvn-spacing":["proportional-nums","tabular-nums"],"fvn-fraction":["diagonal-fractions","stacked-fractons"],tracking:[{tracking:["tighter","tight","normal","wide","wider","widest",Tt]}],"line-clamp":[{"line-clamp":["none",Dc,x1]}],leading:[{leading:["none","tight","snug","normal","relaxed","loose",Xa,Tt]}],"list-image":[{"list-image":["none",Tt]}],"list-style-type":[{list:["none","disc","decimal",Tt]}],"list-style-position":[{list:["inside","outside"]}],"placeholder-color":[{placeholder:[t]}],"placeholder-opacity":[{"placeholder-opacity":[v]}],"text-alignment":[{text:["left","center","right","justify","start","end"]}],"text-color":[{text:[t]}],"text-opacity":[{"text-opacity":[v]}],"text-decoration":["underline","overline","line-through","no-underline"],"text-decoration-style":[{decoration:[...te(),"wavy"]}],"text-decoration-thickness":[{decoration:["auto","from-font",Xa,Bu]}],"underline-offset":[{"underline-offset":["auto",Xa,Tt]}],"text-decoration-color":[{decoration:[t]}],"text-transform":["uppercase","lowercase","capitalize","normal-case"],"text-overflow":["truncate","text-ellipsis","text-clip"],"text-wrap":[{text:["wrap","nowrap","balance","pretty"]}],indent:[{indent:U()}],"vertical-align":[{align:["baseline","top","middle","bottom","text-top","text-bottom","sub","super",Tt]}],whitespace:[{whitespace:["normal","nowrap","pre","pre-line","pre-wrap","break-spaces"]}],break:[{break:["normal","words","all","keep"]}],hyphens:[{hyphens:["none","manual","auto"]}],content:[{content:["none",Tt]}],"bg-attachment":[{bg:["fixed","local","scroll"]}],"bg-clip":[{"bg-clip":["border","padding","content","text"]}],"bg-opacity":[{"bg-opacity":[v]}],"bg-origin":[{"bg-origin":["border","padding","content"]}],"bg-position":[{bg:[...J(),CJ]}],"bg-repeat":[{bg:["no-repeat",{repeat:["","x","y","round","space"]}]}],"bg-size":[{bg:["auto","cover","contain",SJ]}],"bg-image":[{bg:["none",{"gradient-to":["t","tr","r","br","b","bl","l","tl"]},IJ]}],"bg-color":[{bg:[t]}],"gradient-from-pos":[{from:[m]}],"gradient-via-pos":[{via:[m]}],"gradient-to-pos":[{to:[m]}],"gradient-from":[{from:[f]}],"gradient-via":[{via:[f]}],"gradient-to":[{to:[f]}],rounded:[{rounded:[o]}],"rounded-s":[{"rounded-s":[o]}],"rounded-e":[{"rounded-e":[o]}],"rounded-t":[{"rounded-t":[o]}],"rounded-r":[{"rounded-r":[o]}],"rounded-b":[{"rounded-b":[o]}],"rounded-l":[{"rounded-l":[o]}],"rounded-ss":[{"rounded-ss":[o]}],"rounded-se":[{"rounded-se":[o]}],"rounded-ee":[{"rounded-ee":[o]}],"rounded-es":[{"rounded-es":[o]}],"rounded-tl":[{"rounded-tl":[o]}],"rounded-tr":[{"rounded-tr":[o]}],"rounded-br":[{"rounded-br":[o]}],"rounded-bl":[{"rounded-bl":[o]}],"border-w":[{border:[a]}],"border-w-x":[{"border-x":[a]}],"border-w-y":[{"border-y":[a]}],"border-w-s":[{"border-s":[a]}],"border-w-e":[{"border-e":[a]}],"border-w-t":[{"border-t":[a]}],"border-w-r":[{"border-r":[a]}],"border-w-b":[{"border-b":[a]}],"border-w-l":[{"border-l":[a]}],"border-opacity":[{"border-opacity":[v]}],"border-style":[{border:[...te(),"hidden"]}],"divide-x":[{"divide-x":[a]}],"divide-x-reverse":["divide-x-reverse"],"divide-y":[{"divide-y":[a]}],"divide-y-reverse":["divide-y-reverse"],"divide-opacity":[{"divide-opacity":[v]}],"divide-style":[{divide:te()}],"border-color":[{border:[r]}],"border-color-x":[{"border-x":[r]}],"border-color-y":[{"border-y":[r]}],"border-color-t":[{"border-t":[r]}],"border-color-r":[{"border-r":[r]}],"border-color-b":[{"border-b":[r]}],"border-color-l":[{"border-l":[r]}],"divide-color":[{divide:[r]}],"outline-style":[{outline:["",...te()]}],"outline-offset":[{"outline-offset":[Xa,Tt]}],"outline-w":[{outline:[Xa,Bu]}],"outline-color":[{outline:[t]}],"ring-w":[{ring:j()}],"ring-w-inset":["ring-inset"],"ring-color":[{ring:[t]}],"ring-opacity":[{"ring-opacity":[v]}],"ring-offset-w":[{"ring-offset":[Xa,Bu]}],"ring-offset-color":[{"ring-offset":[t]}],shadow:[{shadow:["","inner","none",Vu,$J]}],"shadow-color":[{shadow:[Bm]}],opacity:[{opacity:[v]}],"mix-blend":[{"mix-blend":le()}],"bg-blend":[{"bg-blend":le()}],filter:[{filter:["","none"]}],blur:[{blur:[n]}],brightness:[{brightness:[s]}],contrast:[{contrast:[u]}],"drop-shadow":[{"drop-shadow":["","none",Vu,Tt]}],grayscale:[{grayscale:[l]}],"hue-rotate":[{"hue-rotate":[c]}],invert:[{invert:[h]}],saturate:[{saturate:[S]}],sepia:[{sepia:[I]}],"backdrop-filter":[{"backdrop-filter":["","none"]}],"backdrop-blur":[{"backdrop-blur":[n]}],"backdrop-brightness":[{"backdrop-brightness":[s]}],"backdrop-contrast":[{"backdrop-contrast":[u]}],"backdrop-grayscale":[{"backdrop-grayscale":[l]}],"backdrop-hue-rotate":[{"backdrop-hue-rotate":[c]}],"backdrop-invert":[{"backdrop-invert":[h]}],"backdrop-opacity":[{"backdrop-opacity":[v]}],"backdrop-saturate":[{"backdrop-saturate":[S]}],"backdrop-sepia":[{"backdrop-sepia":[I]}],"border-collapse":[{border:["collapse","separate"]}],"border-spacing":[{"border-spacing":[i]}],"border-spacing-x":[{"border-spacing-x":[i]}],"border-spacing-y":[{"border-spacing-y":[i]}],"table-layout":[{table:["auto","fixed"]}],caption:[{caption:["top","bottom"]}],transition:[{transition:["none","all","","colors","opacity","shadow","transform",Tt]}],duration:[{duration:xe()}],ease:[{ease:["linear","in","out","in-out",Tt]}],delay:[{delay:xe()}],animate:[{animate:["none","spin","ping","pulse","bounce",Tt]}],transform:[{transform:["","gpu","none"]}],scale:[{scale:[k]}],"scale-x":[{"scale-x":[k]}],"scale-y":[{"scale-y":[k]}],rotate:[{rotate:[zm,Tt]}],"translate-x":[{"translate-x":[_]}],"translate-y":[{"translate-y":[_]}],"skew-x":[{"skew-x":[T]}],"skew-y":[{"skew-y":[T]}],"transform-origin":[{origin:["center","top","top-right","right","bottom-right","bottom","bottom-left","left","top-left",Tt]}],accent:[{accent:["auto",t]}],appearance:[{appearance:["none","auto"]}],cursor:[{cursor:["auto","default","pointer","wait","text","move","help","not-allowed","none","context-menu","progress","cell","crosshair","vertical-text","alias","copy","no-drop","grab","grabbing","all-scroll","col-resize","row-resize","n-resize","e-resize","s-resize","w-resize","ne-resize","nw-resize","se-resize","sw-resize","ew-resize","ns-resize","nesw-resize","nwse-resize","zoom-in","zoom-out",Tt]}],"caret-color":[{caret:[t]}],"pointer-events":[{"pointer-events":["none","auto"]}],resize:[{resize:["none","y","x",""]}],"scroll-behavior":[{scroll:["auto","smooth"]}],"scroll-m":[{"scroll-m":U()}],"scroll-mx":[{"scroll-mx":U()}],"scroll-my":[{"scroll-my":U()}],"scroll-ms":[{"scroll-ms":U()}],"scroll-me":[{"scroll-me":U()}],"scroll-mt":[{"scroll-mt":U()}],"scroll-mr":[{"scroll-mr":U()}],"scroll-mb":[{"scroll-mb":U()}],"scroll-ml":[{"scroll-ml":U()}],"scroll-p":[{"scroll-p":U()}],"scroll-px":[{"scroll-px":U()}],"scroll-py":[{"scroll-py":U()}],"scroll-ps":[{"scroll-ps":U()}],"scroll-pe":[{"scroll-pe":U()}],"scroll-pt":[{"scroll-pt":U()}],"scroll-pr":[{"scroll-pr":U()}],"scroll-pb":[{"scroll-pb":U()}],"scroll-pl":[{"scroll-pl":U()}],"snap-align":[{snap:["start","end","center","align-none"]}],"snap-stop":[{snap:["normal","always"]}],"snap-type":[{snap:["none","x","y","both"]}],"snap-strictness":[{snap:["mandatory","proximity"]}],touch:[{touch:["auto","none","manipulation"]}],"touch-x":[{"touch-pan":["x","left","right"]}],"touch-y":[{"touch-pan":["y","up","down"]}],"touch-pz":["touch-pinch-zoom"],select:[{select:["none","text","all","auto"]}],"will-change":[{"will-change":["auto","scroll","contents","transform",Tt]}],fill:[{fill:[t,"none"]}],"stroke-w":[{stroke:[Xa,Bu,x1]}],stroke:[{stroke:[t,"none"]}],sr:["sr-only","not-sr-only"],"forced-color-adjust":[{"forced-color-adjust":["auto","none"]}]},conflictingClassGroups:{overflow:["overflow-x","overflow-y"],overscroll:["overscroll-x","overscroll-y"],inset:["inset-x","inset-y","start","end","top","right","bottom","left"],"inset-x":["right","left"],"inset-y":["top","bottom"],flex:["basis","grow","shrink"],gap:["gap-x","gap-y"],p:["px","py","ps","pe","pt","pr","pb","pl"],px:["pr","pl"],py:["pt","pb"],m:["mx","my","ms","me","mt","mr","mb","ml"],mx:["mr","ml"],my:["mt","mb"],size:["w","h"],"font-size":["leading"],"fvn-normal":["fvn-ordinal","fvn-slashed-zero","fvn-figure","fvn-spacing","fvn-fraction"],"fvn-ordinal":["fvn-normal"],"fvn-slashed-zero":["fvn-normal"],"fvn-figure":["fvn-normal"],"fvn-spacing":["fvn-normal"],"fvn-fraction":["fvn-normal"],"line-clamp":["display","overflow"],rounded:["rounded-s","rounded-e","rounded-t","rounded-r","rounded-b","rounded-l","rounded-ss","rounded-se","rounded-ee","rounded-es","rounded-tl","rounded-tr","rounded-br","rounded-bl"],"rounded-s":["rounded-ss","rounded-es"],"rounded-e":["rounded-se","rounded-ee"],"rounded-t":["rounded-tl","rounded-tr"],"rounded-r":["rounded-tr","rounded-br"],"rounded-b":["rounded-br","rounded-bl"],"rounded-l":["rounded-tl","rounded-bl"],"border-spacing":["border-spacing-x","border-spacing-y"],"border-w":["border-w-s","border-w-e","border-w-t","border-w-r","border-w-b","border-w-l"],"border-w-x":["border-w-r","border-w-l"],"border-w-y":["border-w-t","border-w-b"],"border-color":["border-color-t","border-color-r","border-color-b","border-color-l"],"border-color-x":["border-color-r","border-color-l"],"border-color-y":["border-color-t","border-color-b"],"scroll-m":["scroll-mx","scroll-my","scroll-ms","scroll-me","scroll-mt","scroll-mr","scroll-mb","scroll-ml"],"scroll-mx":["scroll-mr","scroll-ml"],"scroll-my":["scroll-mt","scroll-mb"],"scroll-p":["scroll-px","scroll-py","scroll-ps","scroll-pe","scroll-pt","scroll-pr","scroll-pb","scroll-pl"],"scroll-px":["scroll-pr","scroll-pl"],"scroll-py":["scroll-pt","scroll-pb"],touch:["touch-x","touch-y","touch-pz"],"touch-x":["touch"],"touch-y":["touch"],"touch-pz":["touch"]},conflictingClassGroupModifiers:{"font-size":["leading"]}}}const AJ=pJ(RJ);function zI(...t){return AJ(eJ(t))}const xz=fe.forwardRef(({className:t,...e},n)=>Pt.jsx(hz,{ref:n,className:zI("peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",t),...e,children:Pt.jsx(qZ,{className:zI("flex items-center justify-center text-current"),children:Pt.jsx(JZ,{className:"h-4 w-4"})})}));xz.displayName=hz.displayName;const _J=fe.forwardRef((t,e)=>fe.createElement(eT.label,yu({},t,{ref:e,onMouseDown:n=>{var s;(s=t.onMouseDown)===null||s===void 0||s.call(t,n),!n.defaultPrevented&&n.detail>1&&n.preventDefault()}}))),vz=_J;function wz(t){var e,n,s="";if(typeof t=="string"||typeof t=="number")s+=t;else if(typeof t=="object")if(Array.isArray(t))for(e=0;e<t.length;e++)t[e]&&(n=wz(t[e]))&&(s&&(s+=" "),s+=n);else for(e in t)t[e]&&(s&&(s+=" "),s+=e);return s}function DJ(){for(var t,e,n=0,s="";n<arguments.length;)(t=arguments[n++])&&(e=wz(t))&&(s&&(s+=" "),s+=e);return s}const GD=t=>typeof t=="boolean"?"".concat(t):t===0?"0":t,HD=DJ,PJ=(t,e)=>n=>{var s;if((e==null?void 0:e.variants)==null)return HD(t,n==null?void 0:n.class,n==null?void 0:n.className);const{variants:r,defaultVariants:o}=e,i=Object.keys(r).map(l=>{const c=n==null?void 0:n[l],h=o==null?void 0:o[l];if(c===null)return null;const d=GD(c)||GD(h);return r[l][d]}),a=n&&Object.entries(n).reduce((l,c)=>{let[h,d]=c;return d===void 0||(l[h]=d),l},{}),u=e==null||(s=e.compoundVariants)===null||s===void 0?void 0:s.reduce((l,c)=>{let{class:h,className:d,...f}=c;return Object.entries(f).every(m=>{let[y,x]=m;return Array.isArray(x)?x.includes({...o,...a}[y]):{...o,...a}[y]===x})?[...l,h,d]:l},[]);return HD(t,i,u,n==null?void 0:n.class,n==null?void 0:n.className)},FJ=PJ("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"),bz=fe.forwardRef(({className:t,...e},n)=>Pt.jsx(vz,{ref:n,className:zI(FJ(),t),...e}));bz.displayName=vz.displayName;const OJ=["FOUR","TWO","ONE","PIPE","FIX","BACK","C","SHOOT"];function LJ(){const{sets:t,upsertSet:e}=fe.useContext(Bw),n=t.length<2;return Pt.jsxs("div",{className:"m-auto flex flex-col justify-center p-4",children:[Pt.jsx("p",{className:"font-semibold text-white text-4xl text-indigo-100 mb-4",children:"Choose your sets"}),Pt.jsx("div",{className:"flex flex-col flex-wrap md:flex-row md:justify-center md:items-center",children:OJ.map(s=>Pt.jsxs("div",{className:"flex items-center space-x-2 mr-4 w-24 my-4",children:[Pt.jsx(xz,{id:s,checked:t.includes(s),className:"border border-indigo-100",onCheckedChange:()=>e(s)}),Pt.jsx(bz,{htmlFor:s,className:"text-sm text-white font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",children:s})]},s))}),Pt.jsx(FI,{to:"/training",disabled:n,className:`ml-auto w-32 mt-8 px-4 py-2 flex justify-center items-center rounded-md ${n?"bg-indigo-100 text-indigo-950 cursor-not-allowed":"bg-indigo-900 text-indigo-100"}`,children:"Continue"})]})}var MJ={};(function(){var t;function e(b){var $=0;return function(){return $<b.length?{done:!1,value:b[$++]}:{done:!0}}}var n=typeof Object.defineProperties=="function"?Object.defineProperty:function(b,$,A){return b==Array.prototype||b==Object.prototype||(b[$]=A.value),b};function s(b){b=[typeof globalThis=="object"&&globalThis,b,typeof window=="object"&&window,typeof self=="object"&&self,typeof Rr=="object"&&Rr];for(var $=0;$<b.length;++$){var A=b[$];if(A&&A.Math==Math)return A}throw Error("Cannot find global object")}var r=s(this);function o(b,$){if($)e:{var A=r;b=b.split(".");for(var F=0;F<b.length-1;F++){var W=b[F];if(!(W in A))break e;A=A[W]}b=b[b.length-1],F=A[b],$=$(F),$!=F&&$!=null&&n(A,b,{configurable:!0,writable:!0,value:$})}}o("Symbol",function(b){function $(H){if(this instanceof $)throw new TypeError("Symbol is not a constructor");return new A(F+(H||"")+"_"+W++,H)}function A(H,G){this.h=H,n(this,"description",{configurable:!0,writable:!0,value:G})}if(b)return b;A.prototype.toString=function(){return this.h};var F="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",W=0;return $}),o("Symbol.iterator",function(b){if(b)return b;b=Symbol("Symbol.iterator");for(var $="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),A=0;A<$.length;A++){var F=r[$[A]];typeof F=="function"&&typeof F.prototype[b]!="function"&&n(F.prototype,b,{configurable:!0,writable:!0,value:function(){return i(e(this))}})}return b});function i(b){return b={next:b},b[Symbol.iterator]=function(){return this},b}function a(b){var $=typeof Symbol<"u"&&Symbol.iterator&&b[Symbol.iterator];return $?$.call(b):{next:e(b)}}function u(b){if(!(b instanceof Array)){b=a(b);for(var $,A=[];!($=b.next()).done;)A.push($.value);b=A}return b}var l=typeof Object.assign=="function"?Object.assign:function(b,$){for(var A=1;A<arguments.length;A++){var F=arguments[A];if(F)for(var W in F)Object.prototype.hasOwnProperty.call(F,W)&&(b[W]=F[W])}return b};o("Object.assign",function(b){return b||l});var c=typeof Object.create=="function"?Object.create:function(b){function $(){}return $.prototype=b,new $},h;if(typeof Object.setPrototypeOf=="function")h=Object.setPrototypeOf;else{var d;e:{var f={a:!0},m={};try{m.__proto__=f,d=m.a;break e}catch{}d=!1}h=d?function(b,$){if(b.__proto__=$,b.__proto__!==$)throw new TypeError(b+" is not extensible");return b}:null}var y=h;function x(b,$){if(b.prototype=c($.prototype),b.prototype.constructor=b,y)y(b,$);else for(var A in $)if(A!="prototype")if(Object.defineProperties){var F=Object.getOwnPropertyDescriptor($,A);F&&Object.defineProperty(b,A,F)}else b[A]=$[A];b.za=$.prototype}function v(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function w(b){if(b.m)throw new TypeError("Generator is already running");b.m=!0}v.prototype.u=function(b){this.i=b};function S(b,$){b.l={ma:$,na:!0},b.h=b.s||b.v}v.prototype.return=function(b){this.l={return:b},this.h=this.v};function k(b,$,A){return b.h=A,{value:$}}function I(b){this.h=new v,this.i=b}function T(b,$){w(b.h);var A=b.h.j;return A?R(b,"return"in A?A.return:function(F){return{value:F,done:!0}},$,b.h.return):(b.h.return($),_(b))}function R(b,$,A,F){try{var W=$.call(b.h.j,A);if(!(W instanceof Object))throw new TypeError("Iterator result "+W+" is not an object");if(!W.done)return b.h.m=!1,W;var H=W.value}catch(G){return b.h.j=null,S(b.h,G),_(b)}return b.h.j=null,F.call(b.h,H),_(b)}function _(b){for(;b.h.h;)try{var $=b.i(b.h);if($)return b.h.m=!1,{value:$.value,done:!1}}catch(A){b.h.i=void 0,S(b.h,A)}if(b.h.m=!1,b.h.l){if($=b.h.l,b.h.l=null,$.na)throw $.ma;return{value:$.return,done:!0}}return{value:void 0,done:!0}}function D(b){this.next=function($){return w(b.h),b.h.j?$=R(b,b.h.j.next,$,b.h.u):(b.h.u($),$=_(b)),$},this.throw=function($){return w(b.h),b.h.j?$=R(b,b.h.j.throw,$,b.h.u):(S(b.h,$),$=_(b)),$},this.return=function($){return T(b,$)},this[Symbol.iterator]=function(){return this}}function L(b){function $(F){return b.next(F)}function A(F){return b.throw(F)}return new Promise(function(F,W){function H(G){G.done?F(G.value):Promise.resolve(G.value).then($,A).then(H,W)}H(b.next())})}function V(b){return L(new D(new I(b)))}o("Promise",function(b){function $(G){this.i=0,this.j=void 0,this.h=[],this.u=!1;var oe=this.l();try{G(oe.resolve,oe.reject)}catch(me){oe.reject(me)}}function A(){this.h=null}function F(G){return G instanceof $?G:new $(function(oe){oe(G)})}if(b)return b;A.prototype.i=function(G){if(this.h==null){this.h=[];var oe=this;this.j(function(){oe.m()})}this.h.push(G)};var W=r.setTimeout;A.prototype.j=function(G){W(G,0)},A.prototype.m=function(){for(;this.h&&this.h.length;){var G=this.h;this.h=[];for(var oe=0;oe<G.length;++oe){var me=G[oe];G[oe]=null;try{me()}catch(Te){this.l(Te)}}}this.h=null},A.prototype.l=function(G){this.j(function(){throw G})},$.prototype.l=function(){function G(Te){return function(Oe){me||(me=!0,Te.call(oe,Oe))}}var oe=this,me=!1;return{resolve:G(this.I),reject:G(this.m)}},$.prototype.I=function(G){if(G===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(G instanceof $)this.L(G);else{e:switch(typeof G){case"object":var oe=G!=null;break e;case"function":oe=!0;break e;default:oe=!1}oe?this.F(G):this.s(G)}},$.prototype.F=function(G){var oe=void 0;try{oe=G.then}catch(me){this.m(me);return}typeof oe=="function"?this.M(oe,G):this.s(G)},$.prototype.m=function(G){this.v(2,G)},$.prototype.s=function(G){this.v(1,G)},$.prototype.v=function(G,oe){if(this.i!=0)throw Error("Cannot settle("+G+", "+oe+"): Promise already settled in state"+this.i);this.i=G,this.j=oe,this.i===2&&this.K(),this.H()},$.prototype.K=function(){var G=this;W(function(){if(G.D()){var oe=r.console;typeof oe<"u"&&oe.error(G.j)}},1)},$.prototype.D=function(){if(this.u)return!1;var G=r.CustomEvent,oe=r.Event,me=r.dispatchEvent;return typeof me>"u"?!0:(typeof G=="function"?G=new G("unhandledrejection",{cancelable:!0}):typeof oe=="function"?G=new oe("unhandledrejection",{cancelable:!0}):(G=r.document.createEvent("CustomEvent"),G.initCustomEvent("unhandledrejection",!1,!0,G)),G.promise=this,G.reason=this.j,me(G))},$.prototype.H=function(){if(this.h!=null){for(var G=0;G<this.h.length;++G)H.i(this.h[G]);this.h=null}};var H=new A;return $.prototype.L=function(G){var oe=this.l();G.T(oe.resolve,oe.reject)},$.prototype.M=function(G,oe){var me=this.l();try{G.call(oe,me.resolve,me.reject)}catch(Te){me.reject(Te)}},$.prototype.then=function(G,oe){function me(He,ze){return typeof He=="function"?function(it){try{Te(He(it))}catch(It){Oe(It)}}:ze}var Te,Oe,ct=new $(function(He,ze){Te=He,Oe=ze});return this.T(me(G,Te),me(oe,Oe)),ct},$.prototype.catch=function(G){return this.then(void 0,G)},$.prototype.T=function(G,oe){function me(){switch(Te.i){case 1:G(Te.j);break;case 2:oe(Te.j);break;default:throw Error("Unexpected state: "+Te.i)}}var Te=this;this.h==null?H.i(me):this.h.push(me),this.u=!0},$.resolve=F,$.reject=function(G){return new $(function(oe,me){me(G)})},$.race=function(G){return new $(function(oe,me){for(var Te=a(G),Oe=Te.next();!Oe.done;Oe=Te.next())F(Oe.value).T(oe,me)})},$.all=function(G){var oe=a(G),me=oe.next();return me.done?F([]):new $(function(Te,Oe){function ct(it){return function(It){He[it]=It,ze--,ze==0&&Te(He)}}var He=[],ze=0;do He.push(void 0),ze++,F(me.value).T(ct(He.length-1),Oe),me=oe.next();while(!me.done)})},$});function U(b,$){b instanceof String&&(b+="");var A=0,F=!1,W={next:function(){if(!F&&A<b.length){var H=A++;return{value:$(H,b[H]),done:!1}}return F=!0,{done:!0,value:void 0}}};return W[Symbol.iterator]=function(){return W},W}o("Array.prototype.keys",function(b){return b||function(){return U(this,function($){return $})}}),o("Array.prototype.fill",function(b){return b||function($,A,F){var W=this.length||0;for(0>A&&(A=Math.max(0,W+A)),(F==null||F>W)&&(F=W),F=Number(F),0>F&&(F=Math.max(0,W+F)),A=Number(A||0);A<F;A++)this[A]=$;return this}});function j(b){return b||Array.prototype.fill}o("Int8Array.prototype.fill",j),o("Uint8Array.prototype.fill",j),o("Uint8ClampedArray.prototype.fill",j),o("Int16Array.prototype.fill",j),o("Uint16Array.prototype.fill",j),o("Int32Array.prototype.fill",j),o("Uint32Array.prototype.fill",j),o("Float32Array.prototype.fill",j),o("Float64Array.prototype.fill",j),o("Object.is",function(b){return b||function($,A){return $===A?$!==0||1/$===1/A:$!==$&&A!==A}}),o("Array.prototype.includes",function(b){return b||function($,A){var F=this;F instanceof String&&(F=String(F));var W=F.length;for(A=A||0,0>A&&(A=Math.max(A+W,0));A<W;A++){var H=F[A];if(H===$||Object.is(H,$))return!0}return!1}}),o("String.prototype.includes",function(b){return b||function($,A){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if($ instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf($,A||0)!==-1}});var q=this||self;function J(b,$){b=b.split(".");var A=q;b[0]in A||typeof A.execScript>"u"||A.execScript("var "+b[0]);for(var F;b.length&&(F=b.shift());)b.length||$===void 0?A[F]&&A[F]!==Object.prototype[F]?A=A[F]:A=A[F]={}:A[F]=$}function te(b){var $;e:{if(($=q.navigator)&&($=$.userAgent))break e;$=""}return $.indexOf(b)!=-1}var le=Array.prototype.map?function(b,$){return Array.prototype.map.call(b,$,void 0)}:function(b,$){for(var A=b.length,F=Array(A),W=typeof b=="string"?b.split(""):b,H=0;H<A;H++)H in W&&(F[H]=$.call(void 0,W[H],H,b));return F},K={},re=null;function pe(b){var $=b.length,A=3*$/4;A%3?A=Math.floor(A):"=.".indexOf(b[$-1])!=-1&&(A="=.".indexOf(b[$-2])!=-1?A-2:A-1);var F=new Uint8Array(A),W=0;return he(b,function(H){F[W++]=H}),W!==A?F.subarray(0,W):F}function he(b,$){function A(me){for(;F<b.length;){var Te=b.charAt(F++),Oe=re[Te];if(Oe!=null)return Oe;if(!/^[\s\xa0]*$/.test(Te))throw Error("Unknown base64 encoding at char: "+Te)}return me}xe();for(var F=0;;){var W=A(-1),H=A(0),G=A(64),oe=A(64);if(oe===64&&W===-1)break;$(W<<2|H>>4),G!=64&&($(H<<4&240|G>>2),oe!=64&&$(G<<6&192|oe))}}function xe(){if(!re){re={};for(var b="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),$=["+/=","+/","-_=","-_.","-_"],A=0;5>A;A++){var F=b.concat($[A].split(""));K[A]=F;for(var W=0;W<F.length;W++){var H=F[W];re[H]===void 0&&(re[H]=W)}}}}var Ce=typeof Uint8Array<"u",Ee=!(te("Trident")||te("MSIE"))&&typeof q.btoa=="function";function Ie(b){if(!Ee){var $;$===void 0&&($=0),xe(),$=K[$];for(var A=Array(Math.floor(b.length/3)),F=$[64]||"",W=0,H=0;W<b.length-2;W+=3){var G=b[W],oe=b[W+1],me=b[W+2],Te=$[G>>2];G=$[(G&3)<<4|oe>>4],oe=$[(oe&15)<<2|me>>6],me=$[me&63],A[H++]=Te+G+oe+me}switch(Te=0,me=F,b.length-W){case 2:Te=b[W+1],me=$[(Te&15)<<2]||F;case 1:b=b[W],A[H]=$[b>>2]+$[(b&3)<<4|Te>>4]+me+F}return A.join("")}for($="";10240<b.length;)$+=String.fromCharCode.apply(null,b.subarray(0,10240)),b=b.subarray(10240);return $+=String.fromCharCode.apply(null,b),btoa($)}var ke=RegExp("[-_.]","g");function Ae(b){switch(b){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function Ke(b){if(!Ee)return pe(b);ke.test(b)&&(b=b.replace(ke,Ae)),b=atob(b);for(var $=new Uint8Array(b.length),A=0;A<b.length;A++)$[A]=b.charCodeAt(A);return $}var je;function rt(){return je||(je=new Uint8Array(0))}var tt={},Et=typeof Uint8Array.prototype.slice=="function",lt=0,at=0;function Lt(b){var $=0>b;b=Math.abs(b);var A=b>>>0;b=Math.floor((b-A)/4294967296),$&&(A=a(Ft(A,b)),$=A.next().value,b=A.next().value,A=$),lt=A>>>0,at=b>>>0}var qt=typeof BigInt=="function";function Ft(b,$){return $=~$,b?b=~b+1:$+=1,[b,$]}function Zt(b,$){this.i=b>>>0,this.h=$>>>0}function Wr(b){if(!b)return yn||(yn=new Zt(0,0));if(!/^-?\d+$/.test(b))return null;if(16>b.length)Lt(Number(b));else if(qt)b=BigInt(b),lt=Number(b&BigInt(4294967295))>>>0,at=Number(b>>BigInt(32)&BigInt(4294967295));else{var $=+(b[0]==="-");at=lt=0;for(var A=b.length,F=$,W=(A-$)%6+$;W<=A;F=W,W+=6)F=Number(b.slice(F,W)),at*=1e6,lt=1e6*lt+F,4294967296<=lt&&(at+=lt/4294967296|0,lt%=4294967296);$&&($=a(Ft(lt,at)),b=$.next().value,$=$.next().value,lt=b,at=$)}return new Zt(lt,at)}var yn;function Mn(b,$){return Error("Invalid wire type: "+b+" (at position "+$+")")}function zn(){return Error("Failed to read varint, encoding is invalid.")}function vr(b,$){return Error("Tried to read past the end of the data "+$+" > "+b)}function rs(){throw Error("Invalid UTF8")}function Ps(b,$){return $=String.fromCharCode.apply(null,$),b==null?$:b+$}var wr=void 0,Fs,Gs=typeof TextDecoder<"u",Bo,_a=typeof TextEncoder<"u",Ji;function $u(b){if(b!==tt)throw Error("illegal external caller")}function Ur(b,$){if($u($),this.V=b,b!=null&&b.length===0)throw Error("ByteString should be constructed with non-empty values")}function Da(){return Ji||(Ji=new Ur(null,tt))}function Nu(b){$u(tt);var $=b.V;return $=$==null||Ce&&$!=null&&$ instanceof Uint8Array?$:typeof $=="string"?Ke($):null,$==null?$:b.V=$}function Uf(b){if(typeof b=="string")return{buffer:Ke(b),C:!1};if(Array.isArray(b))return{buffer:new Uint8Array(b),C:!1};if(b.constructor===Uint8Array)return{buffer:b,C:!1};if(b.constructor===ArrayBuffer)return{buffer:new Uint8Array(b),C:!1};if(b.constructor===Ur)return{buffer:Nu(b)||rt(),C:!0};if(b instanceof Uint8Array)return{buffer:new Uint8Array(b.buffer,b.byteOffset,b.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function Oh(b,$){this.i=null,this.m=!1,this.h=this.j=this.l=0,Gf(this,b,$)}function Gf(b,$,A){A=A===void 0?{}:A,b.S=A.S===void 0?!1:A.S,$&&($=Uf($),b.i=$.buffer,b.m=$.C,b.l=0,b.j=b.i.length,b.h=b.l)}Oh.prototype.reset=function(){this.h=this.l};function Pa(b,$){if(b.h=$,$>b.j)throw vr(b.j,$)}function Kl(b){var $=b.i,A=b.h,F=$[A++],W=F&127;if(F&128&&(F=$[A++],W|=(F&127)<<7,F&128&&(F=$[A++],W|=(F&127)<<14,F&128&&(F=$[A++],W|=(F&127)<<21,F&128&&(F=$[A++],W|=F<<28,F&128&&$[A++]&128&&$[A++]&128&&$[A++]&128&&$[A++]&128&&$[A++]&128)))))throw zn();return Pa(b,A),W}function Hf(b,$){if(0>$)throw Error("Tried to read a negative byte length: "+$);var A=b.h,F=A+$;if(F>b.j)throw vr($,b.j-A);return b.h=F,A}var jf=[];function Kf(){this.h=[]}Kf.prototype.length=function(){return this.h.length},Kf.prototype.end=function(){var b=this.h;return this.h=[],b};function j0(b,$,A){for(;0<A||127<$;)b.h.push($&127|128),$=($>>>7|A<<25)>>>0,A>>>=7;b.h.push($)}function Fa(b,$){for(;127<$;)b.h.push($&127|128),$>>>=7;b.h.push($)}function Xf(b,$){if(jf.length){var A=jf.pop();Gf(A,b,$),b=A}else b=new Oh(b,$);this.h=b,this.j=this.h.h,this.i=this.l=-1,this.setOptions($)}Xf.prototype.setOptions=function(b){b=b===void 0?{}:b,this.ca=b.ca===void 0?!1:b.ca},Xf.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function qf(b){var $=b.h;if($.h==$.j)return!1;b.j=b.h.h;var A=Kl(b.h)>>>0;if($=A>>>3,A&=7,!(0<=A&&5>=A))throw Mn(A,b.j);if(1>$)throw Error("Invalid field number: "+$+" (at position "+b.j+")");return b.l=$,b.i=A,!0}function Lh(b){switch(b.i){case 0:if(b.i!=0)Lh(b);else e:{b=b.h;for(var $=b.h,A=$+10,F=b.i;$<A;)if(!(F[$++]&128)){Pa(b,$);break e}throw zn()}break;case 1:b=b.h,Pa(b,b.h+8);break;case 2:b.i!=2?Lh(b):($=Kl(b.h)>>>0,b=b.h,Pa(b,b.h+$));break;case 5:b=b.h,Pa(b,b.h+4);break;case 3:$=b.l;do{if(!qf(b))throw Error("Unmatched start-group tag: stream EOF");if(b.i==4){if(b.l!=$)throw Error("Unmatched end-group tag");break}Lh(b)}while(!0);break;default:throw Mn(b.i,b.j)}}var Mh=[];function aC(){this.j=[],this.i=0,this.h=new Kf}function ea(b,$){$.length!==0&&(b.j.push($),b.i+=$.length)}function uC(b,$){if($=$.R){ea(b,b.h.end());for(var A=0;A<$.length;A++)ea(b,Nu($[A])||rt())}}var go=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function Oa(b,$){return go?b[go]|=$:b.A!==void 0?b.A|=$:(Object.defineProperties(b,{A:{value:$,configurable:!0,writable:!0,enumerable:!1}}),$)}function K0(b,$){go?b[go]&&(b[go]&=~$):b.A!==void 0&&(b.A&=~$)}function Bn(b){var $;return go?$=b[go]:$=b.A,$??0}function Vo(b,$){go?b[go]=$:b.A!==void 0?b.A=$:Object.defineProperties(b,{A:{value:$,configurable:!0,writable:!0,enumerable:!1}})}function Yf(b){return Oa(b,1),b}function lC(b,$){Vo($,(b|0)&-51)}function zh(b,$){Vo($,(b|18)&-41)}var Qf={};function Xl(b){return b!==null&&typeof b=="object"&&!Array.isArray(b)&&b.constructor===Object}var ql,X0=[];Vo(X0,23),ql=Object.freeze(X0);function Zf(b){if(Bn(b.o)&2)throw Error("Cannot mutate an immutable Message")}function Jf(b){var $=b.length;($=$?b[$-1]:void 0)&&Xl($)?$.g=1:($={},b.push(($.g=1,$)))}function q0(b){var $=b.i+b.G;return b.B||(b.B=b.o[$]={})}function yo(b,$){return $===-1?null:$>=b.i?b.B?b.B[$]:void 0:b.o[$+b.G]}function br(b,$,A,F){Zf(b),Yl(b,$,A,F)}function Yl(b,$,A,F){b.j&&(b.j=void 0),$>=b.i||F?q0(b)[$]=A:(b.o[$+b.G]=A,(b=b.B)&&$ in b&&delete b[$])}function Tu(b,$,A,F){var W=yo(b,$);Array.isArray(W)||(W=ql);var H=Bn(W);if(H&1||Yf(W),F)H&2||Oa(W,2),A&1||Object.freeze(W);else{F=!(A&2);var G=H&2;A&1||!G?F&&H&16&&!G&&K0(W,16):(W=Yf(Array.prototype.slice.call(W)),Yl(b,$,W))}return W}function em(b,$){var A=yo(b,$),F=A==null?A:typeof A=="number"||A==="NaN"||A==="Infinity"||A==="-Infinity"?Number(A):void 0;return F!=null&&F!==A&&Yl(b,$,F),F}function Y0(b,$,A,F,W){b.h||(b.h={});var H=b.h[A],G=Tu(b,A,3,W);if(!H){var oe=G;H=[];var me=!!(Bn(b.o)&16);G=!!(Bn(oe)&2);var Te=oe;!W&&G&&(oe=Array.prototype.slice.call(oe));for(var Oe=G,ct=0;ct<oe.length;ct++){var He=oe[ct],ze=$,it=!1;if(it=it===void 0?!1:it,He=Array.isArray(He)?new ze(He):it?new ze:void 0,He!==void 0){ze=He.o;var It=it=Bn(ze);G&&(It|=2),me&&(It|=16),It!=it&&Vo(ze,It),ze=It,Oe=Oe||!!(2&ze),H.push(He)}}return b.h[A]=H,me=Bn(oe),$=me|33,$=Oe?$&-9:$|8,me!=$&&(Oe=oe,Object.isFrozen(Oe)&&(Oe=Array.prototype.slice.call(Oe)),Vo(Oe,$),oe=Oe),Te!==oe&&Yl(b,A,oe),(W||F&&G)&&Oa(H,2),F&&Object.freeze(H),H}return W||(W=Object.isFrozen(H),F&&!W?Object.freeze(H):!F&&W&&(H=Array.prototype.slice.call(H),b.h[A]=H)),H}function tm(b,$,A){var F=!!(Bn(b.o)&2);if($=Y0(b,$,A,F,F),b=Tu(b,A,3,F),!(F||Bn(b)&8)){for(F=0;F<$.length;F++){if(A=$[F],Bn(A.o)&2){var W=Zl(A,!1);W.j=A}else W=A;A!==W&&($[F]=W,b[F]=W.o)}Oa(b,8)}return $}function xo(b,$,A){if(A!=null&&typeof A!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof A+": "+A);br(b,$,A)}function nm(b,$,A,F,W){Zf(b);var H=Y0(b,A,$,!1,!1);return A=F??new A,b=Tu(b,$,2,!1),W!=null?(H.splice(W,0,A),b.splice(W,0,A.o)):(H.push(A),b.push(A.o)),A.C()&&K0(b,8),A}function Ql(b,$){return b??$}function Wo(b,$,A){return A=A===void 0?0:A,Ql(em(b,$),A)}var Bh;function cC(b){switch(typeof b){case"number":return isFinite(b)?b:String(b);case"object":if(b)if(Array.isArray(b)){if(Bn(b)&128)return b=Array.prototype.slice.call(b),Jf(b),b}else{if(Ce&&b!=null&&b instanceof Uint8Array)return Ie(b);if(b instanceof Ur){var $=b.V;return $==null?"":typeof $=="string"?$:b.V=Ie($)}}}return b}function Q0(b,$,A,F){if(b!=null){if(Array.isArray(b))b=Vh(b,$,A,F!==void 0);else if(Xl(b)){var W={},H;for(H in b)W[H]=Q0(b[H],$,A,F);b=W}else b=$(b,F);return b}}function Vh(b,$,A,F){var W=Bn(b);F=F?!!(W&16):void 0,b=Array.prototype.slice.call(b);for(var H=0;H<b.length;H++)b[H]=Q0(b[H],$,A,F);return A(W,b),b}function Z0(b){return b.ja===Qf?b.toJSON():cC(b)}function J0(b,$){b&128&&Jf($)}function Wh(b,$,A){if(A=A===void 0?zh:A,b!=null){if(Ce&&b instanceof Uint8Array)return b.length?new Ur(new Uint8Array(b),tt):Da();if(Array.isArray(b)){var F=Bn(b);return F&2?b:$&&!(F&32)&&(F&16||F===0)?(Vo(b,F|2),b):(b=Vh(b,Wh,F&4?zh:A,!0),$=Bn(b),$&4&&$&2&&Object.freeze(b),b)}return b.ja===Qf?sm(b):b}}function ex(b,$,A,F,W,H,G){if(b=b.h&&b.h[A]){if(F=Bn(b),F&2?F=b:(H=le(b,sm),zh(F,H),Object.freeze(H),F=H),Zf($),G=F==null?ql:Yf([]),F!=null){for(H=!!F.length,b=0;b<F.length;b++){var oe=F[b];H=H&&!(Bn(oe.o)&2),G[b]=oe.o}H=(H?8:0)|1,b=Bn(G),(b&H)!==H&&(Object.isFrozen(G)&&(G=Array.prototype.slice.call(G)),Vo(G,b|H)),$.h||($.h={}),$.h[A]=F}else $.h&&($.h[A]=void 0);Yl($,A,G,W)}else br($,A,Wh(F,H,G),W)}function sm(b){return Bn(b.o)&2||(b=Zl(b,!0),Oa(b.o,2)),b}function Zl(b,$){var A=b.o,F=[];Oa(F,16);var W=b.constructor.h;if(W&&F.push(W),W=b.B,W){F.length=A.length,F.fill(void 0,F.length,A.length);var H={};F[F.length-1]=H}Bn(A)&128&&Jf(F),$=$||b.C()?zh:lC,H=b.constructor,Bh=F,F=new H(F),Bh=void 0,b.R&&(F.R=b.R.slice()),H=!!(Bn(A)&16);for(var G=W?A.length-1:A.length,oe=0;oe<G;oe++)ex(b,F,oe-b.G,A[oe],!1,H,$);if(W)for(var me in W)ex(b,F,+me,W[me],!0,H,$);return F}function Hs(b,$,A){b==null&&(b=Bh),Bh=void 0;var F=this.constructor.i||0,W=0<F,H=this.constructor.h,G=!1;if(b==null){b=H?[H]:[];var oe=48,me=!0;W&&(F=0,oe|=128),Vo(b,oe)}else{if(!Array.isArray(b)||H&&H!==b[0])throw Error();var Te=oe=Oa(b,0);if((me=(16&Te)!==0)&&((G=(32&Te)!==0)||(Te|=32)),W){if(128&Te)F=0;else if(0<b.length){var Oe=b[b.length-1];if(Xl(Oe)&&"g"in Oe){F=0,Te|=128,delete Oe.g;var ct=!0,He;for(He in Oe){ct=!1;break}ct&&b.pop()}}}else if(128&Te)throw Error();oe!==Te&&Vo(b,Te)}this.G=(H?0:-1)-F,this.h=void 0,this.o=b;e:{if(H=this.o.length,F=H-1,H&&(H=this.o[F],Xl(H))){this.B=H,this.i=F-this.G;break e}$!==void 0&&-1<$?(this.i=Math.max($,F+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!W&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(A){$=me&&!G&&!0,W=this.i;var ze;for(me=0;me<A.length;me++)G=A[me],G<W?(G+=this.G,(F=b[G])?tx(F,$):b[G]=ql):(ze||(ze=q0(this)),(F=ze[G])?tx(F,$):ze[G]=ql)}}Hs.prototype.toJSON=function(){return Vh(this.o,Z0,J0)},Hs.prototype.C=function(){return!!(Bn(this.o)&2)};function tx(b,$){if(Array.isArray(b)){var A=Bn(b),F=1;!$||A&2||(F|=16),(A&F)!==F&&Vo(b,A|F)}}Hs.prototype.ja=Qf,Hs.prototype.toString=function(){return this.o.toString()};function rm(b,$,A){if(A){var F={},W;for(W in A){var H=A[W],G=H.ra;G||(F.J=H.xa||H.oa.W,H.ia?(F.aa=im(H.ia),G=function(oe){return function(me,Te,Oe){return oe.J(me,Te,Oe,oe.aa)}}(F)):H.ka?(F.Z=rx(H.da.P,H.ka),G=function(oe){return function(me,Te,Oe){return oe.J(me,Te,Oe,oe.Z)}}(F)):G=F.J,H.ra=G),G($,b,H.da),F={J:F.J,aa:F.aa,Z:F.Z}}}uC($,b)}var Jl=Symbol();function Uh(b,$,A){return b[Jl]||(b[Jl]=function(F,W){return $(F,W,A)})}function nx(b){var $=b[Jl];if(!$){var A=um(b);$=function(F,W){return Hh(F,W,A)},b[Jl]=$}return $}function sx(b){var $=b.ia;if($)return nx($);if($=b.wa)return Uh(b.da.P,$,b.ka)}function om(b){var $=sx(b),A=b.da,F=b.oa.U;return $?function(W,H){return F(W,H,A,$)}:function(W,H){return F(W,H,A)}}function Gh(b,$){var A=b[$];return typeof A=="function"&&A.length===0&&(A=A(),b[$]=A),Array.isArray(A)&&(tc in A||Eu in A||0<A.length&&typeof A[0]=="function")?A:void 0}function La(b,$,A,F,W,H){$.P=b[0];var G=1;if(b.length>G&&typeof b[G]!="number"){var oe=b[G++];A($,oe)}for(;G<b.length;){A=b[G++];for(var me=G+1;me<b.length&&typeof b[me]!="number";)me++;switch(oe=b[G++],me-=G,me){case 0:F($,A,oe);break;case 1:(me=Gh(b,G))?(G++,W($,A,oe,me)):F($,A,oe,b[G++]);break;case 2:me=G++,me=Gh(b,me),W($,A,oe,me,b[G++]);break;case 3:H($,A,oe,b[G++],b[G++],b[G++]);break;case 4:H($,A,oe,b[G++],b[G++],b[G++],b[G++]);break;default:throw Error("unexpected number of binary field arguments: "+me)}}return $}var ec=Symbol();function im(b){var $=b[ec];if(!$){var A=am(b);$=function(F,W){return lx(F,W,A)},b[ec]=$}return $}function rx(b,$){var A=b[ec];return A||(A=function(F,W){return rm(F,W,$)},b[ec]=A),A}var Eu=Symbol();function ox(b,$){b.push($)}function ix(b,$,A){b.push($,A.W)}function ax(b,$,A,F){var W=im(F),H=am(F).P,G=A.W;b.push($,function(oe,me,Te){return G(oe,me,Te,H,W)})}function hC(b,$,A,F,W,H){var G=rx(F,H),oe=A.W;b.push($,function(me,Te,Oe){return oe(me,Te,Oe,F,G)})}function am(b){var $=b[Eu];return $||($=La(b,b[Eu]=[],ox,ix,ax,hC),tc in b&&Eu in b&&(b.length=0),$)}var tc=Symbol();function ux(b,$){b[0]=$}function dC(b,$,A,F){var W=A.U;b[$]=F?function(H,G,oe){return W(H,G,oe,F)}:W}function pC(b,$,A,F,W){var H=A.U,G=nx(F),oe=um(F).P;b[$]=function(me,Te,Oe){return H(me,Te,Oe,oe,G,W)}}function fC(b,$,A,F,W,H,G){var oe=A.U,me=Uh(F,W,H);b[$]=function(Te,Oe,ct){return oe(Te,Oe,ct,F,me,G)}}function um(b){var $=b[tc];return $||($=La(b,b[tc]={},ux,dC,pC,fC),tc in b&&Eu in b&&(b.length=0),$)}function Hh(b,$,A){for(;qf($)&&$.i!=4;){var F=$.l,W=A[F];if(!W){var H=A[0];H&&(H=H[F])&&(W=A[F]=om(H))}if(!W||!W($,b,F)){W=$,F=b,H=W.j,Lh(W);var G=W;if(!G.ca){if(W=G.h.h-H,G.h.h=H,G=G.h,W==0)W=Da();else{if(H=Hf(G,W),G.S&&G.m)W=G.i.subarray(H,H+W);else{G=G.i;var oe=H;W=H+W,W=oe===W?rt():Et?G.slice(oe,W):new Uint8Array(G.subarray(oe,W))}W=W.length==0?Da():new Ur(W,tt)}(H=F.R)?H.push(W):F.R=[W]}}}return b}function lx(b,$,A){for(var F=A.length,W=F%2==1,H=W?1:0;H<F;H+=2)(0,A[H+1])($,b,A[H]);rm(b,$,W?A[0]:void 0)}function nc(b,$){return{U:b,W:$}}var vo=nc(function(b,$,A){if(b.i!==5)return!1;b=b.h;var F=b.i,W=b.h,H=F[W],G=F[W+1],oe=F[W+2];return F=F[W+3],Pa(b,b.h+4),G=(H<<0|G<<8|oe<<16|F<<24)>>>0,b=2*(G>>31)+1,H=G>>>23&255,G&=8388607,br($,A,H==255?G?NaN:1/0*b:H==0?b*Math.pow(2,-149)*G:b*Math.pow(2,H-150)*(G+Math.pow(2,23))),!0},function(b,$,A){if($=em($,A),$!=null){Fa(b.h,8*A+5),b=b.h;var F=+$;F===0?0<1/F?lt=at=0:(at=0,lt=2147483648):isNaN(F)?(at=0,lt=2147483647):(F=(A=0>F?-2147483648:0)?-F:F,34028234663852886e22<F?(at=0,lt=(A|2139095040)>>>0):11754943508222875e-54>F?(F=Math.round(F/Math.pow(2,-149)),at=0,lt=(A|F)>>>0):($=Math.floor(Math.log(F)/Math.LN2),F*=Math.pow(2,-$),F=Math.round(8388608*F),16777216<=F&&++$,at=0,lt=(A|$+127<<23|F&8388607)>>>0)),A=lt,b.h.push(A>>>0&255),b.h.push(A>>>8&255),b.h.push(A>>>16&255),b.h.push(A>>>24&255)}}),mC=nc(function(b,$,A){if(b.i!==0)return!1;var F=b.h,W=0,H=b=0,G=F.i,oe=F.h;do{var me=G[oe++];W|=(me&127)<<H,H+=7}while(32>H&&me&128);for(32<H&&(b|=(me&127)>>4),H=3;32>H&&me&128;H+=7)me=G[oe++],b|=(me&127)<<H;if(Pa(F,oe),128>me)F=W>>>0,me=b>>>0,(b=me&2147483648)&&(F=~F+1>>>0,me=~me>>>0,F==0&&(me=me+1>>>0)),F=4294967296*me+(F>>>0);else throw zn();return br($,A,b?-F:F),!0},function(b,$,A){$=yo($,A),$!=null&&(typeof $=="string"&&Wr($),$!=null&&(Fa(b.h,8*A),typeof $=="number"?(b=b.h,Lt($),j0(b,lt,at)):(A=Wr($),j0(b.h,A.i,A.h))))}),gC=nc(function(b,$,A){return b.i!==0?!1:(br($,A,Kl(b.h)),!0)},function(b,$,A){if($=yo($,A),$!=null&&$!=null)if(Fa(b.h,8*A),b=b.h,A=$,0<=A)Fa(b,A);else{for($=0;9>$;$++)b.h.push(A&127|128),A>>=7;b.h.push(1)}}),hn=nc(function(b,$,A){if(b.i!==2)return!1;var F=Kl(b.h)>>>0;b=b.h;var W=Hf(b,F);if(b=b.i,Gs){var H=b,G;(G=Fs)||(G=Fs=new TextDecoder("utf-8",{fatal:!0})),b=W+F,H=W===0&&b===H.length?H:H.subarray(W,b);try{var oe=G.decode(H)}catch(ct){if(wr===void 0){try{G.decode(new Uint8Array([128]))}catch{}try{G.decode(new Uint8Array([97])),wr=!0}catch{wr=!1}}throw!wr&&(Fs=void 0),ct}}else{oe=W,F=oe+F,W=[];for(var me=null,Te,Oe;oe<F;)Te=b[oe++],128>Te?W.push(Te):224>Te?oe>=F?rs():(Oe=b[oe++],194>Te||(Oe&192)!==128?(oe--,rs()):W.push((Te&31)<<6|Oe&63)):240>Te?oe>=F-1?rs():(Oe=b[oe++],(Oe&192)!==128||Te===224&&160>Oe||Te===237&&160<=Oe||((H=b[oe++])&192)!==128?(oe--,rs()):W.push((Te&15)<<12|(Oe&63)<<6|H&63)):244>=Te?oe>=F-2?rs():(Oe=b[oe++],(Oe&192)!==128||(Te<<28)+(Oe-144)>>30||((H=b[oe++])&192)!==128||((G=b[oe++])&192)!==128?(oe--,rs()):(Te=(Te&7)<<18|(Oe&63)<<12|(H&63)<<6|G&63,Te-=65536,W.push((Te>>10&1023)+55296,(Te&1023)+56320))):rs(),8192<=W.length&&(me=Ps(me,W),W.length=0);oe=Ps(me,W)}return br($,A,oe),!0},function(b,$,A){if($=yo($,A),$!=null){var F=!1;if(F=F===void 0?!1:F,_a){if(F&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test($))throw Error("Found an unpaired surrogate");$=(Bo||(Bo=new TextEncoder)).encode($)}else{for(var W=0,H=new Uint8Array(3*$.length),G=0;G<$.length;G++){var oe=$.charCodeAt(G);if(128>oe)H[W++]=oe;else{if(2048>oe)H[W++]=oe>>6|192;else{if(55296<=oe&&57343>=oe){if(56319>=oe&&G<$.length){var me=$.charCodeAt(++G);if(56320<=me&&57343>=me){oe=1024*(oe-55296)+me-56320+65536,H[W++]=oe>>18|240,H[W++]=oe>>12&63|128,H[W++]=oe>>6&63|128,H[W++]=oe&63|128;continue}else G--}if(F)throw Error("Found an unpaired surrogate");oe=65533}H[W++]=oe>>12|224,H[W++]=oe>>6&63|128}H[W++]=oe&63|128}}$=W===H.length?H:H.subarray(0,W)}Fa(b.h,8*A+2),Fa(b.h,$.length),ea(b,b.h.end()),ea(b,$)}}),rn=nc(function(b,$,A,F,W){if(b.i!==2)return!1;$=nm($,A,F),A=b.h.j,F=Kl(b.h)>>>0;var H=b.h.h+F,G=H-A;if(0>=G&&(b.h.j=H,W($,b,void 0,void 0,void 0),G=H-b.h.h),G)throw Error("Message parsing ended unexpectedly. Expected to read "+(F+" bytes, instead read "+(F-G)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return b.h.h=H,b.h.j=A,!0},function(b,$,A,F,W){if($=tm($,F,A),$!=null)for(F=0;F<$.length;F++){var H=b;Fa(H.h,8*A+2);var G=H.h.end();ea(H,G),G.push(H.i),H=G,W($[F],b),G=b;var oe=H.pop();for(oe=G.i+G.h.length()-oe;127<oe;)H.push(oe&127|128),oe>>>=7,G.i++;H.push(oe),G.i++}});function lm(b){return function($,A){e:{if(Mh.length){var F=Mh.pop();F.setOptions(A),Gf(F.h,$,A),$=F}else $=new Xf($,A);try{var W=um(b),H=Hh(new W.P,$,W);break e}finally{W=$.h,W.i=null,W.m=!1,W.l=0,W.j=0,W.h=0,W.S=!1,$.l=-1,$.i=-1,100>Mh.length&&Mh.push($)}H=void 0}return H}}function cm(b){return function(){var $=new aC;lx(this,$,am(b)),ea($,$.h.end());for(var A=new Uint8Array($.i),F=$.j,W=F.length,H=0,G=0;G<W;G++){var oe=F[G];A.set(oe,H),H+=oe.length}return $.j=[A],A}}function Ru(b){Hs.call(this,b)}x(Ru,Hs);var cx=[Ru,1,gC,2,vo,3,hn,4,hn];Ru.prototype.l=cm(cx);function hm(b){Hs.call(this,b,-1,yC)}x(hm,Hs),hm.prototype.addClassification=function(b,$){return nm(this,1,Ru,b,$),this};var yC=[1],hx=lm([hm,1,rn,cx]);function sc(b){Hs.call(this,b)}x(sc,Hs);var hs=[sc,1,vo,2,vo,3,vo,4,vo,5,vo];sc.prototype.l=cm(hs);function jh(b){Hs.call(this,b,-1,Ma)}x(jh,Hs);var Ma=[1],dx=lm([jh,1,rn,hs]);function Au(b){Hs.call(this,b)}x(Au,Hs);var Sr=[Au,1,vo,2,vo,3,vo,4,vo,5,vo,6,mC],px=lm(Sr);Au.prototype.l=cm(Sr);function dm(b,$,A){if(A=b.createShader(A===0?b.VERTEX_SHADER:b.FRAGMENT_SHADER),b.shaderSource(A,$),b.compileShader(A),!b.getShaderParameter(A,b.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+b.getShaderInfoLog(A));return A}function fx(b){return tm(b,Ru,1).map(function($){var A=yo($,1);return{index:A??0,qa:Wo($,2),label:yo($,3)!=null?Ql(yo($,3),""):void 0,displayName:yo($,4)!=null?Ql(yo($,4),""):void 0}})}function mx(b){return{x:Wo(b,1),y:Wo(b,2),z:Wo(b,3),visibility:em(b,4)!=null?Wo(b,4):void 0}}function Kh(b){return tm(dx(b),sc,1).map(mx)}function Xh(b,$){this.i=b,this.h=$,this.m=0}function tr(b,$,A){return xC(b,$),typeof b.h.canvas.transferToImageBitmap=="function"?Promise.resolve(b.h.canvas.transferToImageBitmap()):A?Promise.resolve(b.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(b.h.canvas):(b.j===void 0&&(b.j=document.createElement("canvas")),new Promise(function(F){b.j.height=b.h.canvas.height,b.j.width=b.h.canvas.width,b.j.getContext("2d",{}).drawImage(b.h.canvas,0,0,b.h.canvas.width,b.h.canvas.height),F(b.j)}))}function xC(b,$){var A=b.h;if(b.s===void 0){var F=dm(A,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),W=dm(A,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),H=A.createProgram();if(A.attachShader(H,F),A.attachShader(H,W),A.linkProgram(H),!A.getProgramParameter(H,A.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+A.getProgramInfoLog(H));F=b.s=H,A.useProgram(F),W=A.getUniformLocation(F,"sampler0"),b.l={O:A.getAttribLocation(F,"aVertex"),N:A.getAttribLocation(F,"aTex"),ya:W},b.v=A.createBuffer(),A.bindBuffer(A.ARRAY_BUFFER,b.v),A.enableVertexAttribArray(b.l.O),A.vertexAttribPointer(b.l.O,2,A.FLOAT,!1,0,0),A.bufferData(A.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),A.STATIC_DRAW),A.bindBuffer(A.ARRAY_BUFFER,null),b.u=A.createBuffer(),A.bindBuffer(A.ARRAY_BUFFER,b.u),A.enableVertexAttribArray(b.l.N),A.vertexAttribPointer(b.l.N,2,A.FLOAT,!1,0,0),A.bufferData(A.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),A.STATIC_DRAW),A.bindBuffer(A.ARRAY_BUFFER,null),A.uniform1i(W,0)}F=b.l,A.useProgram(b.s),A.canvas.width=$.width,A.canvas.height=$.height,A.viewport(0,0,$.width,$.height),A.activeTexture(A.TEXTURE0),b.i.bindTexture2d($.glName),A.enableVertexAttribArray(F.O),A.bindBuffer(A.ARRAY_BUFFER,b.v),A.vertexAttribPointer(F.O,2,A.FLOAT,!1,0,0),A.enableVertexAttribArray(F.N),A.bindBuffer(A.ARRAY_BUFFER,b.u),A.vertexAttribPointer(F.N,2,A.FLOAT,!1,0,0),A.bindFramebuffer(A.DRAW_FRAMEBUFFER?A.DRAW_FRAMEBUFFER:A.FRAMEBUFFER,null),A.clearColor(0,0,0,0),A.clear(A.COLOR_BUFFER_BIT),A.colorMask(!0,!0,!0,!0),A.drawArrays(A.TRIANGLE_FAN,0,4),A.disableVertexAttribArray(F.O),A.disableVertexAttribArray(F.N),A.bindBuffer(A.ARRAY_BUFFER,null),b.i.bindTexture2d(0)}function Gr(b){this.h=b}var vC=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function gx(b,$){return $+b}function Ci(b,$){window[b]=$}function qh(b){var $=document.createElement("script");return $.setAttribute("src",b),$.setAttribute("crossorigin","anonymous"),new Promise(function(A){$.addEventListener("load",function(){A()},!1),$.addEventListener("error",function(){A()},!1),document.body.appendChild($)})}function pm(){return V(function(b){switch(b.h){case 1:return b.s=2,k(b,WebAssembly.instantiate(vC),4);case 4:b.h=3,b.s=0;break;case 2:return b.s=0,b.l=null,b.return(!1);case 3:return b.return(!0)}})}function dn(b){if(this.h=b,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=b&&b.locateFile||gx,typeof window=="object")var $=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")$=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=$,b.options){$=a(Object.keys(b.options));for(var A=$.next();!A.done;A=$.next()){A=A.value;var F=b.options[A].default;F!==void 0&&(this.l[A]=typeof F=="function"?F():F)}}}t=dn.prototype,t.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function ta(b){var $,A,F,W,H,G,oe,me,Te,Oe,ct;return V(function(He){switch(He.h){case 1:return b.ga?($=b.h.files===void 0?[]:typeof b.h.files=="function"?b.h.files(b.l):b.h.files,k(He,pm(),2)):He.return();case 2:if(A=He.i,typeof window=="object")return Ci("createMediapipeSolutionsWasm",{locateFile:b.locateFile}),Ci("createMediapipeSolutionsPackedAssets",{locateFile:b.locateFile}),G=$.filter(function(ze){return ze.data!==void 0}),oe=$.filter(function(ze){return ze.data===void 0}),me=Promise.all(G.map(function(ze){var it=_u(b,ze.url);if(ze.path!==void 0){var It=ze.path;it=it.then(function(pn){return b.overrideFile(It,pn),Promise.resolve(pn)})}return it})),Te=Promise.all(oe.map(function(ze){return ze.simd===void 0||ze.simd&&A||!ze.simd&&!A?qh(b.locateFile(ze.url,b.ha)):Promise.resolve()})).then(function(){var ze,it,It;return V(function(pn){if(pn.h==1)return ze=window.createMediapipeSolutionsWasm,it=window.createMediapipeSolutionsPackedAssets,It=b,k(pn,ze(it),2);It.i=pn.i,pn.h=0})}),Oe=function(){return V(function(ze){return b.h.graph&&b.h.graph.url?ze=k(ze,_u(b,b.h.graph.url),0):(ze.h=0,ze=void 0),ze})}(),k(He,Promise.all([Te,me,Oe]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return F=$.filter(function(ze){return ze.simd===void 0||ze.simd&&A||!ze.simd&&!A}).map(function(ze){return b.locateFile(ze.url,b.ha)}),importScripts.apply(null,u(F)),W=b,k(He,createMediapipeSolutionsWasm(Module),6);case 6:W.i=He.i,b.m=new OffscreenCanvas(1,1),b.i.canvas=b.m,H=b.i.GL.createContext(b.m,{antialias:!1,alpha:!1,va:typeof WebGL2RenderingContext<"u"?2:1}),b.i.GL.makeContextCurrent(H),He.h=4;break;case 7:if(b.m=document.createElement("canvas"),ct=b.m.getContext("webgl2",{}),!ct&&(ct=b.m.getContext("webgl",{}),!ct))return alert("Failed to create WebGL canvas context when passing video frame."),He.return();b.K=ct,b.i.canvas=b.m,b.i.createContext(b.m,!0,!0,{});case 4:b.j=new b.i.SolutionWasm,b.ga=!1,He.h=0}})}function fm(b){var $,A,F,W,H,G,oe,me;return V(function(Te){if(Te.h==1){if(b.h.graph&&b.h.graph.url&&b.fa===b.h.graph.url)return Te.return();if(b.u=!0,!b.h.graph||!b.h.graph.url){Te.h=2;return}return b.fa=b.h.graph.url,k(Te,_u(b,b.h.graph.url),3)}for(Te.h!=2&&($=Te.i,b.j.loadGraph($)),A=a(Object.keys(b.D)),F=A.next();!F.done;F=A.next())W=F.value,b.j.overrideFile(W,b.D[W]);if(b.D={},b.h.listeners)for(H=a(b.h.listeners),G=H.next();!G.done;G=H.next())oe=G.value,CC(b,oe);me=b.l,b.l={},b.setOptions(me),Te.h=0})}t.reset=function(){var b=this;return V(function($){b.j&&(b.j.reset(),b.s={},b.v={}),$.h=0})},t.setOptions=function(b,$){var A=this;if($=$||this.h.options){for(var F=[],W=[],H={},G=a(Object.keys(b)),oe=G.next();!oe.done;H={X:H.X,Y:H.Y},oe=G.next())if(oe=oe.value,!(oe in this.l&&this.l[oe]===b[oe])){this.l[oe]=b[oe];var me=$[oe];me!==void 0&&(me.onChange&&(H.X=me.onChange,H.Y=b[oe],F.push(function(Te){return function(){var Oe;return V(function(ct){if(ct.h==1)return k(ct,Te.X(Te.Y),2);Oe=ct.i,Oe===!0&&(A.u=!0),ct.h=0})}}(H))),me.graphOptionXref&&(oe=Object.assign({},{calculatorName:"",calculatorIndex:0},me.graphOptionXref,{valueNumber:me.type===1?b[oe]:0,valueBoolean:me.type===0?b[oe]:!1,valueString:me.type===2?b[oe]:""}),W.push(oe)))}(F.length!==0||W.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(W),this.F=(this.F===void 0?[]:this.F).concat(F))}};function wC(b){var $,A,F,W,H,G,oe;return V(function(me){switch(me.h){case 1:if(!b.u)return me.return();if(!b.F){me.h=2;break}$=a(b.F),A=$.next();case 3:if(A.done){me.h=5;break}return F=A.value,k(me,F(),4);case 4:A=$.next(),me.h=3;break;case 5:b.F=void 0;case 2:if(b.H){for(W=new b.i.GraphOptionChangeRequestList,H=a(b.H),G=H.next();!G.done;G=H.next())oe=G.value,W.push_back(oe);b.j.changeOptions(W),W.delete(),b.H=void 0}b.u=!1,me.h=0}})}t.initialize=function(){var b=this;return V(function($){return $.h==1?k($,ta(b),2):$.h!=3?k($,fm(b),3):k($,wC(b),0)})};function _u(b,$){var A,F;return V(function(W){return $ in b.L?W.return(b.L[$]):(A=b.locateFile($,""),F=fetch(A).then(function(H){return H.arrayBuffer()}),b.L[$]=F,W.return(F))})}t.overrideFile=function(b,$){this.j?this.j.overrideFile(b,$):this.D[b]=$},t.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},t.send=function(b,$){var A=this,F,W,H,G,oe,me,Te,Oe,ct;return V(function(He){switch(He.h){case 1:return A.h.inputs?(F=1e3*($??performance.now()),k(He,A.I,2)):He.return();case 2:return k(He,A.initialize(),3);case 3:for(W=new A.i.PacketDataList,H=a(Object.keys(b)),G=H.next();!G.done;G=H.next())if(oe=G.value,me=A.h.inputs[oe]){e:{var ze=b[oe];switch(me.type){case"video":var it=A.s[me.stream];if(it||(it=new Xh(A.i,A.K),A.s[me.stream]=it),it.m===0&&(it.m=it.i.createTexture()),typeof HTMLVideoElement<"u"&&ze instanceof HTMLVideoElement)var It=ze.videoWidth,pn=ze.videoHeight;else typeof HTMLImageElement<"u"&&ze instanceof HTMLImageElement?(It=ze.naturalWidth,pn=ze.naturalHeight):(It=ze.width,pn=ze.height);pn={glName:it.m,width:It,height:pn},It=it.h,It.canvas.width=pn.width,It.canvas.height=pn.height,It.activeTexture(It.TEXTURE0),it.i.bindTexture2d(it.m),It.texImage2D(It.TEXTURE_2D,0,It.RGBA,It.RGBA,It.UNSIGNED_BYTE,ze),it.i.bindTexture2d(0),it=pn;break e;case"detections":for(it=A.s[me.stream],it||(it=new Gr(A.i),A.s[me.stream]=it),it.data||(it.data=new it.h.DetectionListData),it.data.reset(ze.length),pn=0;pn<ze.length;++pn){It=ze[pn];var fn=it.data,ks=fn.setBoundingBox,Hr=pn,nr=It.la,Kt=new Au;if(xo(Kt,1,nr.sa),xo(Kt,2,nr.ta),xo(Kt,3,nr.height),xo(Kt,4,nr.width),xo(Kt,5,nr.rotation),br(Kt,6,nr.pa),nr=Kt.l(),ks.call(fn,Hr,nr),It.ea)for(fn=0;fn<It.ea.length;++fn){Kt=It.ea[fn],ks=it.data,Hr=ks.addNormalizedLandmark,nr=pn,Kt=Object.assign({},Kt,{visibility:Kt.visibility?Kt.visibility:0});var Dn=new sc;xo(Dn,1,Kt.x),xo(Dn,2,Kt.y),xo(Dn,3,Kt.z),Kt.visibility&&xo(Dn,4,Kt.visibility),Kt=Dn.l(),Hr.call(ks,nr,Kt)}if(It.ba)for(fn=0;fn<It.ba.length;++fn)ks=it.data,Hr=ks.addClassification,nr=pn,Kt=It.ba[fn],Dn=new Ru,xo(Dn,2,Kt.qa),Kt.index&&br(Dn,1,Kt.index),Kt.label&&br(Dn,3,Kt.label),Kt.displayName&&br(Dn,4,Kt.displayName),Kt=Dn.l(),Hr.call(ks,nr,Kt)}it=it.data;break e;default:it={}}}switch(Te=it,Oe=me.stream,me.type){case"video":W.pushTexture2d(Object.assign({},Te,{stream:Oe,timestamp:F}));break;case"detections":ct=Te,ct.stream=Oe,ct.timestamp=F,W.pushDetectionList(ct);break;default:throw Error("Unknown input config type: '"+me.type+"'")}}return A.j.send(W),k(He,A.I,4);case 4:W.delete(),He.h=0}})};function bC(b,$,A){var F,W,H,G,oe,me,Te,Oe,ct,He,ze,it,It,pn;return V(function(fn){switch(fn.h){case 1:if(!A)return fn.return($);for(F={},W=0,H=a(Object.keys(A)),G=H.next();!G.done;G=H.next())oe=G.value,me=A[oe],typeof me!="string"&&me.type==="texture"&&$[me.stream]!==void 0&&++W;1<W&&(b.M=!1),Te=a(Object.keys(A)),G=Te.next();case 2:if(G.done){fn.h=4;break}if(Oe=G.value,ct=A[Oe],typeof ct=="string")return It=F,pn=Oe,k(fn,SC(b,Oe,$[ct]),14);if(He=$[ct.stream],ct.type==="detection_list"){if(He){for(var ks=He.getRectList(),Hr=He.getLandmarksList(),nr=He.getClassificationsList(),Kt=[],Dn=0;Dn<ks.size();++Dn){var na=px(ks.get(Dn)),kC=Wo(na,1),gm=Wo(na,2),yx=Wo(na,3),sa=Wo(na,4),Yh=Wo(na,5,0),Qh=void 0;Qh=Qh===void 0?0:Qh,na={la:{sa:kC,ta:gm,height:yx,width:sa,rotation:Yh,pa:Ql(yo(na,6),Qh)},ea:Kh(Hr.get(Dn)),ba:fx(hx(nr.get(Dn)))},Kt.push(na)}ks=Kt}else ks=[];F[Oe]=ks,fn.h=7;break}if(ct.type==="proto_list"){if(He){for(ks=Array(He.size()),Hr=0;Hr<He.size();Hr++)ks[Hr]=He.get(Hr);He.delete()}else ks=[];F[Oe]=ks,fn.h=7;break}if(He===void 0){fn.h=3;break}if(ct.type==="float_list"){F[Oe]=He,fn.h=7;break}if(ct.type==="proto"){F[Oe]=He,fn.h=7;break}if(ct.type!=="texture")throw Error("Unknown output config type: '"+ct.type+"'");return ze=b.v[Oe],ze||(ze=new Xh(b.i,b.K),b.v[Oe]=ze),k(fn,tr(ze,He,b.M),13);case 13:it=fn.i,F[Oe]=it;case 7:ct.transform&&F[Oe]&&(F[Oe]=ct.transform(F[Oe])),fn.h=3;break;case 14:It[pn]=fn.i;case 3:G=Te.next(),fn.h=2;break;case 4:return fn.return(F)}})}function SC(b,$,A){var F;return V(function(W){return typeof A=="number"||A instanceof Uint8Array||A instanceof b.i.Uint8BlobList?W.return(A):A instanceof b.i.Texture2dDataOut?(F=b.v[$],F||(F=new Xh(b.i,b.K),b.v[$]=F),W.return(tr(F,A,b.M))):W.return(void 0)})}function CC(b,$){for(var A=$.name||"$",F=[].concat(u($.wants)),W=new b.i.StringList,H=a($.wants),G=H.next();!G.done;G=H.next())W.push_back(G.value);H=b.i.PacketListener.implement({onResults:function(oe){for(var me={},Te=0;Te<$.wants.length;++Te)me[F[Te]]=oe.get(Te);var Oe=b.listeners[A];Oe&&(b.I=bC(b,me,$.outs).then(function(ct){ct=Oe(ct);for(var He=0;He<$.wants.length;++He){var ze=me[F[He]];typeof ze=="object"&&ze.hasOwnProperty&&ze.hasOwnProperty("delete")&&ze.delete()}ct&&(b.I=ct)}))}}),b.j.attachMultiListener(W,H),W.delete()}t.onResults=function(b,$){this.listeners[$||"$"]=b},J("Solution",dn),J("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"});function mm(b){switch(b===void 0&&(b=0),b){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function rc(b){var $=this;b=b||{},this.h=new dn({locateFile:b.locateFile,files:function(A){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:mm(A.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:Kh},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:Kh},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(A){var F,W,H;return V(function(G){return G.h==1?(F=mm(A),W="third_party/mediapipe/modules/pose_landmark/"+F,k(G,_u($.h,F),2)):(H=G.i,$.h.overrideFile(W,H),G.return(!0))})}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}t=rc.prototype,t.reset=function(){this.h.reset()},t.close=function(){return this.h.close(),Promise.resolve()},t.onResults=function(b){this.h.onResults(b)},t.initialize=function(){var b=this;return V(function($){return k($,b.h.initialize(),0)})},t.send=function(b,$){var A=this;return V(function(F){return k(F,A.h.send(b,$),0)})},t.setOptions=function(b){this.h.setOptions(b)},J("Pose",rc),J("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),J("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),J("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),J("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),J("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),J("VERSION","0.5.1675469404")}).call(Rr);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zJ=1e-7,BJ=1e-4;class nT{constructor(e,n){this.backend=e,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,n){this.dataIdsCount++,this.data.set(e,n)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Vw{refCount(e){return Yr("refCount")}incRef(e){return Yr("incRef")}timerAvailable(){return!0}time(e){return Yr("time")}read(e){return Yr("read")}readSync(e){return Yr("readSync")}readToGPU(e,n){return Yr("readToGPU")}numDataIds(){return Yr("numDataIds")}disposeData(e,n){return Yr("disposeData")}write(e,n,s){return Yr("write")}move(e,n,s,r,o){return Yr("move")}createTensorFromGPUData(e,n,s){return Yr("createTensorFromGPUData")}memory(){return Yr("memory")}floatPrecision(){return Yr("floatPrecision")}epsilon(){return this.floatPrecision()===32?zJ:BJ}dispose(){return Yr("dispose")}}function Yr(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VJ(t){let e=t.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,yd(t,e,n)}function Zc(t,e,n){return Math.max(t,Math.min(e,n))}function sT(t){return t%2===0?t:t+1}function yd(t,e,n){const s=t[e];t[e]=t[n],t[n]=s}function Sz(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function O(t,e){if(!t)throw new Error(typeof e=="string"?e:e())}function Br(t,e,n=""){O(kt(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function Np(t){O(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ie(t){if(t.length===0)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function jD(t){return t.length===0}function WJ(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==null&&e[n]!==null&&t[n]!==e[n])return!1;return!0}function kt(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function ip(t){return t%1===0}function BI(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function Gd(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function KD(t,e=r=>0,n,s){return new Promise((r,o)=>{let i=0;const a=()=>{if(t()){r();return}i++;const u=e(i);if(n!=null&&i>=n){o();return}s!=null?s(a,u):setTimeout(a,u)};a()})}function rT(t,e){let n=1,s=-1;for(let o=0;o<t.length;++o)if(t[o]>=0)n*=t[o];else if(t[o]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${o}`);s=o}else if(t[o]<0)throw Error(`Shapes can not be < 0. Found ${t[o]} at dim ${o}`);if(s===-1){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(n===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const r=t.slice();return r[s]=e/n,r}function vt(t,e){const n=e.length;return t=t==null?e.map((s,r)=>r):[].concat(t),O(t.every(s=>s>=-n&&s<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),O(t.every(s=>ip(s)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(s=>s<0?n+s:s)}function Fl(t,e){const n=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||r?null:vt(e,t).sort();let i=0;for(let a=0;a<t.length;++a){if(o!=null){if(o[i]===a&&t[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);(o[i]==null||o[i]>a)&&t[a]===1&&(n.push(t[a]),s.push(a)),o[i]<=a&&i++}t[a]!==1&&(n.push(t[a]),s.push(a))}return{newShape:n,keptDims:s}}function ws(t,e){return Hn(t,e)}function Hn(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else if(t==="string")n=new Array(e);else throw new Error(`Unknown data type ${t}`);return n}function UJ(t,e){for(let n=0;n<t.length;n++){const s=t[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function GJ(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function oT(t,e){return!(e==="complex64"||e==="float32"&&t!=="complex64"||e==="int32"&&t!=="float32"&&t!=="complex64"||e==="bool"&&t==="bool")}function Av(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function HJ(t){if(t==null)return 0;let e=0;return t.forEach(n=>e+=n.length),e}function Tp(t){return typeof t=="string"||t instanceof String}function jJ(t){return typeof t=="boolean"}function VI(t){return typeof t=="number"}function mh(t){return Array.isArray(t)?mh(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":VI(t)?"float32":Tp(t)?"string":jJ(t)?"bool":"float32"}function WI(t){return!!(t&&t.constructor&&t.call&&t.apply)}function UI(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function et(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let s=e-3;s>=0;--s)n[s]=n[s+1]*t[s+1];return n}function Cz(t,e,n,s=!1){const r=new Array;if(e.length===1){const o=e[0]*(s?2:1);for(let i=0;i<o;i++)r[i]=n[t+i]}else{const o=e[0],i=e.slice(1),a=i.reduce((u,l)=>u*l)*(s?2:1);for(let u=0;u<o;u++)r[u]=Cz(t+u*a,i,n,s)}return r}function pi(t,e,n=!1){if(t.length===0)return e[0];const s=t.reduce((r,o)=>r*o)*(n?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return Cz(0,t,e,n)}function Q1(t,e){if(Array.isArray(t))return t;if(e==="float32")return t instanceof Float32Array?t:new Float32Array(t);if(e==="int32")return t instanceof Int32Array?t:new Int32Array(t);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(t));throw new Error(`Unknown dtype ${e}`)}function iT(t,e){const n=Vs(t,e);for(let s=0;s<n.length;s++)n[s]=1;return n}function Vs(t,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function kz(t,e){const n=t.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return pi(t,new Float32Array(n));if(e==="int32")return pi(t,new Int32Array(n));if(e==="bool")return pi(t,new Uint8Array(n));throw new Error(`Unknown data type ${e}`)}function Oo(t){t.forEach(e=>{O(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function xa(t,e,n){if(e===0)return 0;if(e===1)return t[0];let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=n[r]*t[r];return s}function Ep(t,e,n){if(e===0)return[];if(e===1)return[t];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(t/n[r]),t-=s[r]*n[r];return s[s.length-1]=t,s}function Jc(t){return t&&t.then&&typeof t.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XD="tfjsflags";class KJ{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=XJ,this.populateURLFlags()}setPlatform(e,n){this.platform!=null&&(ce().getBool("IS_TEST")||ce().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=n}registerFlag(e,n,s){if(this.flagRegistry[e]={evaluationFn:n,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];ce().getBool("IS_TEST")||ce().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const n=this.evaluateFlag(e);if(Jc(n))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=n,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,n){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=n,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(n)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);XD in e&&e[XD].split(",").forEach(s=>{const[r,o]=s.split(":");this.urlFlags[r]=YJ(r,o)})}}function XJ(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...s)=>(qJ(e,s[0],s[1]),s.join("="))),e}function qJ(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function YJ(t,e){const n=e.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:e}function ce(){return Iz}let Iz=null;function QJ(t){Iz=t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let J2;function $z(){if(J2==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");J2=t}return J2}function ZJ(){const t=$z();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function aT(t,e){const n=ZJ();if(n.has(t))return n.get(t);{const s=e();return n.set(t,s),n.get(t)}}const gy="Abs",Rp="Acos",Ap="Acosh",gh="Add",yy="AddN",Ww="All",Uw="Any",xy="ArgMax",vy="ArgMin",_p="Asin",Dp="Asinh",Pp="Atan",Fp="Atanh",Op="Atan2",wy="AvgPool",Gw="AvgPoolGrad",by="AvgPool3D",Hw="AvgPool3DGrad",Sy="BatchMatMul",Cy="BatchToSpaceND",jw="Bincount",Kw="BitwiseAnd",JJ="BroadcastTo",Xw="BroadcastArgs",Lp="Cast",Mp="Ceil",zp="ClipByValue",qw="Complex",ky="ComplexAbs",Iy="Concat",$y="Conv2D",Yw="Conv2DBackpropFilter",Ny="Conv2DBackpropInput",Ty="Conv3D",Qw="Conv3DBackpropFilterV2",Zw="Conv3DBackpropInputV2",Bp="Cos",Vp="Cosh",Jw="Cumprod",Ey="Cumsum",eb="CropAndResize",tb="DenseBincount",nb="DepthToSpace",Ry="DepthwiseConv2dNative",sb="DepthwiseConv2dNativeBackpropFilter",rb="DepthwiseConv2dNativeBackpropInput",ob="Diag",Ay="Dilation2D",_v="Dilation2DBackpropInput",Dv="Dilation2DBackpropFilter",uT="Draw",Wp="RealDiv",ib="Einsum",Up="Elu",ab="EluGrad",Gp="Erf",_y="Equal",Hp="Exp",Dy="ExpandDims",jp="Expm1",ub="FFT",lb="Fill",cb="FlipLeftRight",Kp="Floor",Xp="FloorDiv",Py="FusedBatchNorm",Fy="GatherV2",hb="GatherNd",Oy="Greater",qp="GreaterEqual",Yp="Identity",db="IFFT",pb="Imag",Qp="IsFinite",Zp="IsInf",Jp="IsNan",Ly="LeakyRelu",My="Less",zy="LessEqual",fb="LinSpace",ef="Log",tf="Log1p",By="LogicalAnd",Vy="LogicalNot",Wy="LogicalOr",eee="LogSoftmax",Uy="LRN",mb="LRNGrad",Gy="Max",nf="Maximum",Hy="MaxPool",gb="MaxPoolGrad",jy="MaxPool3D",yb="MaxPool3DGrad",xb="MaxPoolWithArgmax",Ky="Mean",Xy="Min",sf="Minimum",qy="MirrorPad",rf="Mod",vb="Multinomial",of="Multiply",Yy="Neg",Qy="NotEqual",wb="NonMaxSuppressionV3",lT="NonMaxSuppressionV4",bb="NonMaxSuppressionV5",Zy="OnesLike",Jy="OneHot",e0="Pack",t0="PadV2",af="Pow",n0="Prelu",s0="Prod",cT="RaggedGather",hT="RaggedRange",dT="RaggedTensorToTensor",Sb="Range",Cb="Real",uf="Reciprocal",lf="Relu",r0="Reshape",o0="ResizeNearestNeighbor",kb="ResizeNearestNeighborGrad",i0="ResizeBilinear",Ib="ResizeBilinearGrad",cf="Relu6",a0="Reverse",hf="Round",df="Rsqrt",$b="ScatterNd",Nb="TensorScatterUpdate",Tb="SearchSorted",u0="Select",pf="Selu",l0="Slice",ff="Sin",mf="Sinh",gf="Sign",yf="Sigmoid",xf="Softplus",vf="Sqrt",c0="Sum",h0="SpaceToBatchND",d0="SplitV",p0="Softmax",pT="SparseFillEmptyRows",fT="SparseReshape",Eb="SparseSegmentMean",Rb="SparseSegmentSum",Ab="SparseToDense",wf="SquaredDifference",_b="Square",Db="StaticRegexReplace",Pb="StridedSlice",Fb="StringNGrams",mT="StringSplit",gT="StringToHashBucketFast",bf="Sub",Sf="Tan",Cf="Tanh",kf="Tile",Ob="TopK",Lb="Transform",Wc="Transpose",yT="Unique",f0="Unpack",m0="UnsortedSegmentSum",g0="ZerosLike",If="Step",Pv="FromPixels",Mb="RotateWithOffset",Bg="_FusedMatMul",Vg="FusedConv2D",Wg="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Io(...t){ce().getBool("IS_TEST")||ce().getBool("PROD")||console.warn(...t)}function tee(...t){ce().getBool("IS_TEST")||ce().getBool("PROD")||console.log(...t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fv=aT("kernelRegistry",()=>new Map),GI=aT("gradRegistry",()=>new Map);function Ov(t,e){const n=Nz(t,e);return Fv.get(n)}function qD(t){return GI.get(t)}function YD(t){const e=Fv.entries(),n=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[o,i]=r,[a]=o.split("_");a===t&&n.push(i)}return n}function xT(t){const{kernelName:e,backendName:n}=t,s=Nz(e,n);Fv.has(s)&&Io(`The kernel '${e}' for backend '${n}' is already registered`),Fv.set(s,t)}function nee(t){const{kernelName:e}=t;GI.has(e)&&ce().getBool("DEBUG")&&Io(`Overriding the gradient for '${e}'`),GI.set(e,t)}function Nz(t,e){return`${e}_${t}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tz(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}var Ez=kn,ii=null;try{ii=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function kn(t,e,n){this.low=t|0,this.high=e|0,this.unsigned=!!n}kn.prototype.__isLong__;Object.defineProperty(kn.prototype,"__isLong__",{value:!0});function po(t){return(t&&t.__isLong__)===!0}kn.isLong=po;var QD={},ZD={};function yh(t,e){var n,s,r;return e?(t>>>=0,(r=0<=t&&t<256)&&(s=ZD[t],s)?s:(n=In(t,(t|0)<0?-1:0,!0),r&&(ZD[t]=n),n)):(t|=0,(r=-128<=t&&t<128)&&(s=QD[t],s)?s:(n=In(t,t<0?-1:0,!1),r&&(QD[t]=n),n))}kn.fromInt=yh;function ai(t,e){if(isNaN(t))return e?Pc:ui;if(e){if(t<0)return Pc;if(t>=Rz)return Dz}else{if(t<=-e3)return to;if(t+1>=e3)return _z}return t<0?ai(-t,e).neg():In(t%ap|0,t/ap|0,e)}kn.fromNumber=ai;function In(t,e,n){return new kn(t,e,n)}kn.fromBits=In;var Lv=Math.pow;function vT(t,e,n){if(t.length===0)throw Error("empty string");if(t==="NaN"||t==="Infinity"||t==="+Infinity"||t==="-Infinity")return ui;if(typeof e=="number"?(n=e,e=!1):e=!!e,n=n||10,n<2||36<n)throw RangeError("radix");var s;if((s=t.indexOf("-"))>0)throw Error("interior hyphen");if(s===0)return vT(t.substring(1),e,n).neg();for(var r=ai(Lv(n,8)),o=ui,i=0;i<t.length;i+=8){var a=Math.min(8,t.length-i),u=parseInt(t.substring(i,i+a),n);if(a<8){var l=ai(Lv(n,a));o=o.mul(l).add(ai(u))}else o=o.mul(r),o=o.add(ai(u))}return o.unsigned=e,o}kn.fromString=vT;function qi(t,e){return typeof t=="number"?ai(t,e):typeof t=="string"?vT(t,e):In(t.low,t.high,typeof e=="boolean"?e:t.unsigned)}kn.fromValue=qi;var JD=65536,see=1<<24,ap=JD*JD,Rz=ap*ap,e3=Rz/2,t3=yh(see),ui=yh(0);kn.ZERO=ui;var Pc=yh(0,!0);kn.UZERO=Pc;var Dd=yh(1);kn.ONE=Dd;var Az=yh(1,!0);kn.UONE=Az;var HI=yh(-1);kn.NEG_ONE=HI;var _z=In(-1,2147483647,!1);kn.MAX_VALUE=_z;var Dz=In(-1,-1,!0);kn.MAX_UNSIGNED_VALUE=Dz;var to=In(0,-2147483648,!1);kn.MIN_VALUE=to;var Me=kn.prototype;Me.toInt=function(){return this.unsigned?this.low>>>0:this.low};Me.toNumber=function(){return this.unsigned?(this.high>>>0)*ap+(this.low>>>0):this.high*ap+(this.low>>>0)};Me.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(to)){var n=ai(e),s=this.div(n),r=s.mul(n).sub(this);return s.toString(e)+r.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var o=ai(Lv(e,6),this.unsigned),i=this,a="";;){var u=i.div(o),l=i.sub(u.mul(o)).toInt()>>>0,c=l.toString(e);if(i=u,i.isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}};Me.getHighBits=function(){return this.high};Me.getHighBitsUnsigned=function(){return this.high>>>0};Me.getLowBits=function(){return this.low};Me.getLowBitsUnsigned=function(){return this.low>>>0};Me.getNumBitsAbs=function(){if(this.isNegative())return this.eq(to)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,n=31;n>0&&!(e&1<<n);n--);return this.high!=0?n+33:n+1};Me.isZero=function(){return this.high===0&&this.low===0};Me.eqz=Me.isZero;Me.isNegative=function(){return!this.unsigned&&this.high<0};Me.isPositive=function(){return this.unsigned||this.high>=0};Me.isOdd=function(){return(this.low&1)===1};Me.isEven=function(){return(this.low&1)===0};Me.equals=function(e){return po(e)||(e=qi(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};Me.eq=Me.equals;Me.notEquals=function(e){return!this.eq(e)};Me.neq=Me.notEquals;Me.ne=Me.notEquals;Me.lessThan=function(e){return this.comp(e)<0};Me.lt=Me.lessThan;Me.lessThanOrEqual=function(e){return this.comp(e)<=0};Me.lte=Me.lessThanOrEqual;Me.le=Me.lessThanOrEqual;Me.greaterThan=function(e){return this.comp(e)>0};Me.gt=Me.greaterThan;Me.greaterThanOrEqual=function(e){return this.comp(e)>=0};Me.gte=Me.greaterThanOrEqual;Me.ge=Me.greaterThanOrEqual;Me.compare=function(e){if(po(e)||(e=qi(e)),this.eq(e))return 0;var n=this.isNegative(),s=e.isNegative();return n&&!s?-1:!n&&s?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};Me.comp=Me.compare;Me.negate=function(){return!this.unsigned&&this.eq(to)?to:this.not().add(Dd)};Me.neg=Me.negate;Me.add=function(e){po(e)||(e=qi(e));var n=this.high>>>16,s=this.high&65535,r=this.low>>>16,o=this.low&65535,i=e.high>>>16,a=e.high&65535,u=e.low>>>16,l=e.low&65535,c=0,h=0,d=0,f=0;return f+=o+l,d+=f>>>16,f&=65535,d+=r+u,h+=d>>>16,d&=65535,h+=s+a,c+=h>>>16,h&=65535,c+=n+i,c&=65535,In(d<<16|f,c<<16|h,this.unsigned)};Me.subtract=function(e){return po(e)||(e=qi(e)),this.add(e.neg())};Me.sub=Me.subtract;Me.multiply=function(e){if(this.isZero())return ui;if(po(e)||(e=qi(e)),ii){var n=ii.mul(this.low,this.high,e.low,e.high);return In(n,ii.get_high(),this.unsigned)}if(e.isZero())return ui;if(this.eq(to))return e.isOdd()?to:ui;if(e.eq(to))return this.isOdd()?to:ui;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(t3)&&e.lt(t3))return ai(this.toNumber()*e.toNumber(),this.unsigned);var s=this.high>>>16,r=this.high&65535,o=this.low>>>16,i=this.low&65535,a=e.high>>>16,u=e.high&65535,l=e.low>>>16,c=e.low&65535,h=0,d=0,f=0,m=0;return m+=i*c,f+=m>>>16,m&=65535,f+=o*c,d+=f>>>16,f&=65535,f+=i*l,d+=f>>>16,f&=65535,d+=r*c,h+=d>>>16,d&=65535,d+=o*l,h+=d>>>16,d&=65535,d+=i*u,h+=d>>>16,d&=65535,h+=s*c+r*l+o*u+i*a,h&=65535,In(f<<16|m,h<<16|d,this.unsigned)};Me.mul=Me.multiply;Me.divide=function(e){if(po(e)||(e=qi(e)),e.isZero())throw Error("division by zero");if(ii){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var n=(this.unsigned?ii.div_u:ii.div_s)(this.low,this.high,e.low,e.high);return In(n,ii.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Pc:ui;var s,r,o;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Pc;if(e.gt(this.shru(1)))return Az;o=Pc}else{if(this.eq(to)){if(e.eq(Dd)||e.eq(HI))return to;if(e.eq(to))return Dd;var i=this.shr(1);return s=i.div(e).shl(1),s.eq(ui)?e.isNegative()?Dd:HI:(r=this.sub(e.mul(s)),o=s.add(r.div(e)),o)}else if(e.eq(to))return this.unsigned?Pc:ui;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=ui}for(r=this;r.gte(e);){s=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(s)/Math.LN2),u=a<=48?1:Lv(2,a-48),l=ai(s),c=l.mul(e);c.isNegative()||c.gt(r);)s-=u,l=ai(s,this.unsigned),c=l.mul(e);l.isZero()&&(l=Dd),o=o.add(l),r=r.sub(c)}return o};Me.div=Me.divide;Me.modulo=function(e){if(po(e)||(e=qi(e)),ii){var n=(this.unsigned?ii.rem_u:ii.rem_s)(this.low,this.high,e.low,e.high);return In(n,ii.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};Me.mod=Me.modulo;Me.rem=Me.modulo;Me.not=function(){return In(~this.low,~this.high,this.unsigned)};Me.and=function(e){return po(e)||(e=qi(e)),In(this.low&e.low,this.high&e.high,this.unsigned)};Me.or=function(e){return po(e)||(e=qi(e)),In(this.low|e.low,this.high|e.high,this.unsigned)};Me.xor=function(e){return po(e)||(e=qi(e)),In(this.low^e.low,this.high^e.high,this.unsigned)};Me.shiftLeft=function(e){return po(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?In(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):In(0,this.low<<e-32,this.unsigned)};Me.shl=Me.shiftLeft;Me.shiftRight=function(e){return po(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?In(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):In(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};Me.shr=Me.shiftRight;Me.shiftRightUnsigned=function(e){if(po(e)&&(e=e.toInt()),e&=63,e===0)return this;var n=this.high;if(e<32){var s=this.low;return In(s>>>e|n<<32-e,n>>>e,this.unsigned)}else return e===32?In(n,0,this.unsigned):In(n>>>e-32,0,this.unsigned)};Me.shru=Me.shiftRightUnsigned;Me.shr_u=Me.shiftRightUnsigned;Me.toSigned=function(){return this.unsigned?In(this.low,this.high,!1):this};Me.toUnsigned=function(){return this.unsigned?this:In(this.low,this.high,!0)};Me.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};Me.toBytesLE=function(){var e=this.high,n=this.low;return[n&255,n>>>8&255,n>>>16&255,n>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};Me.toBytesBE=function(){var e=this.high,n=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,n>>>24,n>>>16&255,n>>>8&255,n&255]};kn.fromBytes=function(e,n,s){return s?kn.fromBytesLE(e,n):kn.fromBytesBE(e,n)};kn.fromBytesLE=function(e,n){return new kn(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,n)};kn.fromBytesBE=function(e,n){return new kn(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],n)};const Pz=RO(Ez),ree=n9({__proto__:null,default:Pz},[Ez]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kc=Pz||ree;function zb(t){return kc.fromString(t,!0,16)}const Fz=zb("c3a5c85c97cb3127"),wc=zb("b492b66fbe98f273"),dr=zb("9ae16a3b2f90404f");function jI(t){return t.xor(t.shru(47))}function Oz(t,e,n){const s=t.slice(e,e+n);return kc.fromBytes(Array.from(s),!0,!0)}function vn(t,e){return Oz(t,e,8)}function n3(t,e){return Oz(t,e,4)}function Ts(t,e){return e===0?t:t.shru(e).or(t.shl(64-e))}function hl(t,e,n=zb("9ddfea08eb382d69")){let s=t.xor(e).mul(n);s=s.xor(s.shru(47));let r=e.xor(s).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function oee(t,e,n,s,r,o){r=r.add(t),o=Ts(o.add(r).add(s),21);const i=r;return r=r.add(e),r=r.add(n),o=o.add(Ts(r,44)),[r.add(s),o.add(i)]}function v1(t,e,n,s){return oee(vn(t,e),vn(t,e+8),vn(t,e+16),vn(t,e+24),n,s)}function iee(t,e=t.length){if(e>=8){const n=dr.add(e*2),s=vn(t,0).add(dr),r=vn(t,e-8),o=Ts(r,37).mul(n).add(s),i=Ts(s,25).add(r).mul(n);return hl(o,i,n)}if(e>=4){const n=dr.add(e*2),s=n3(t,0);return hl(s.shl(3).add(e),n3(t,e-4),n)}if(e>0){const n=t[0],s=t[e>>1],r=t[e-1],o=n+(s<<8),i=e+(r<<2);return jI(dr.mul(o).xor(Fz.mul(i))).mul(dr)}return dr}function aee(t,e=t.length){const n=dr.add(e*2),s=vn(t,0).mul(wc),r=vn(t,8),o=vn(t,e-8).mul(n),i=vn(t,e-16).mul(dr);return hl(Ts(s.add(r),43).add(Ts(o,30)).add(i),s.add(Ts(r.add(dr),18)).add(o),n)}function uee(t,e=t.length){const n=dr.add(e*2),s=vn(t,0).mul(dr),r=vn(t,8),o=vn(t,e-8).mul(n),i=vn(t,e-16).mul(dr),a=Ts(s.add(r),43).add(Ts(o,30)).add(i),u=hl(a,s.add(Ts(r.add(dr),18)).add(o),n),l=vn(t,16).mul(n),c=vn(t,24),h=a.add(vn(t,e-32)).mul(n),d=u.add(vn(t,e-24)).mul(n);return hl(Ts(l.add(c),43).add(Ts(h,30)).add(d),l.add(Ts(c.add(s),18)).add(h),n)}function lee(t,e=t.length){const n=kc.fromNumber(81,!0);if(e<=32)return e<=16?iee(t,e):aee(t,e);if(e<=64)return uee(t,e);let s=n,r=n.mul(wc).add(113),o=jI(r.mul(dr).add(113)).mul(dr),i=[kc.UZERO,kc.UZERO],a=[kc.UZERO,kc.UZERO];s=s.mul(dr).add(vn(t,0));let u=0;const l=(e-1>>6)*64,c=l+(e-1&63)-63;do s=Ts(s.add(r).add(i[0]).add(vn(t,u+8)),37).mul(wc),r=Ts(r.add(i[1]).add(vn(t,u+48)),42).mul(wc),s=s.xor(a[1]),r=r.add(i[0]).add(vn(t,u+40)),o=Ts(o.add(a[0]),33).mul(wc),i=v1(t,u,i[1].mul(wc),s.add(a[0])),a=v1(t,u+32,o.add(a[1]),r.add(vn(t,u+16))),[o,s]=[s,o],u+=64;while(u!==l);const h=wc.add(o.and(255).shl(1));return u=c,a[0]=a[0].add(e-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),s=Ts(s.add(r).add(i[0]).add(vn(t,u+8)),37).mul(h),r=Ts(r.add(i[1]).add(vn(t,u+48)),42).mul(h),s=s.xor(a[1].mul(9)),r=r.add(i[0].mul(9).add(vn(t,u+40))),o=Ts(o.add(a[0]),33).mul(h),i=v1(t,u,i[1].mul(h),s.add(a[0])),a=v1(t,u+32,o.add(a[1]),r.add(vn(t,u+16))),[o,s]=[s,o],hl(hl(i[0],a[0],h).add(jI(r).mul(Fz)).add(o),hl(i[1],a[1],h).add(s),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ol(t,e){return e==="string"?iu(t):xh([t],e)}function cee(t,e){return t instanceof Float32Array&&e==="float32"||t instanceof Int32Array&&e==="int32"||t instanceof Uint8Array&&e==="bool"}function xh(t,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=xu(t)),ce().getBool("DEBUG")&&UJ(t,e),cee(t,e))return t;if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool"){const n=new Uint8Array(t.length);for(let s=0;s<n.length;++s)Math.round(t[s])!==0&&(n[s]=1);return n}else throw new Error(`Unknown data type ${e}`)}function Tr(){return ce().platform.now()}function iu(t,e="utf-8"){return e=e||"utf-8",ce().platform.encode(t,e)}function Vi(t,e="utf-8"){return e=e||"utf-8",ce().platform.decode(t,e)}function xi(t){return ce().platform.isTypedArray!=null?ce().platform.isTypedArray(t):Tz(t)}function xu(t,e=[],n=!1){if(e==null&&(e=[]),typeof t=="boolean"||typeof t=="number"||typeof t=="string"||Jc(t)||t==null||xi(t)&&n)e.push(t);else if(Array.isArray(t)||xi(t))for(let s=0;s<t.length;++s)xu(t[s],e,n);else{let s=-1;for(const r of Object.keys(t))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)xu(t[r],e,n)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hee{constructor(e,n){this.backendTimer=e,this.logger=n,n==null&&(this.logger=new pee)}profileKernel(e,n,s){let r;const o=()=>{r=s()};let i;const a=Tr();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(o);else{o();for(const l of r)l.dataSync();i=Promise.resolve({kernelMs:Tr()-a})}if(ce().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<r.length;l++){const c=r[l];c.data().then(h=>{dee(h,c.dtype,e)})}return{kernelName:e,outputs:r,inputs:n,timeMs:i.then(l=>l.kernelMs),extraInfo:i.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:n,outputs:s,timeMs:r,inputs:o,extraInfo:i}=e;s.forEach(a=>{Promise.all([a.data(),r,i]).then(u=>{this.logger.logKernelProfile(n,a,u[0],u[1],o,u[2])})})}}function dee(t,e,n){if(e!=="float32")return!1;for(let s=0;s<t.length;s++){const r=t[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class pee{logKernelProfile(e,n,s,r,o,i){const a=typeof r=="number"?Gd(`${r}ms`,9):r.error,u=Gd(e,25),l=n.rank,c=n.size,h=Gd(n.shape.toString(),14);let d="";for(const f in o){const m=o[f];if(m!=null){const y=m.shape||n.shape,x=y.length;d+=`${f}: ${x}D ${x>0?y:""} `}}console.log(`%c${u}	%c${a}	%c${l}D ${h}	%c${c}	%c${d}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fee(t,e,n){const s={},r={};for(let u=0;u<e.length;u++)s[e[u].id]=!0;for(let u=0;u<t.length;u++){const l=t[u],c=l.inputs;for(const h in c){const d=c[h];let f=!1;for(let m=0;m<e.length;m++)if(s[d.id]){l.outputs.forEach(y=>s[y.id]=!0),f=!0,r[l.id]=!0;break}if(f)break}}const o={};o[n.id]=!0;const i={};for(let u=t.length-1;u>=0;u--){const l=t[u],c=l.inputs;for(let h=0;h<l.outputs.length;h++)if(o[l.outputs[h].id]){for(const d in c)o[c[d].id]=!0,i[l.id]=!0;break}}const a=[];for(let u=0;u<t.length;u++){const l=t[u];if(r[l.id]&&i[l.id]){const c={};for(const d in l.inputs){const f=l.inputs[d];s[f.id]&&(c[d]=f)}const h=Object.assign({},l);h.inputs=c,h.outputs=l.outputs,a.push(h)}}return a}function mee(t,e,n,s){for(let r=e.length-1;r>=0;r--){const o=e[r],i=[];if(o.outputs.forEach(u=>{const l=t[u.id];l!=null?i.push(l):i.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const u in o.inputs){if(!(u in a))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(a)}.`);const l=n(()=>a[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);const c=o.inputs[u];if(!kt(l.shape,c.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${c.shape}'`);if(t[c.id]==null)t[c.id]=l;else{const h=t[c.id];t[c.id]=s(h,l),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s3=20,Vm=3,ek=7;function gee(t,e,n,s){const r=et(e),o=yee(t,e,n,r),i=e.length,a=Z1(t,e,n,r,o),u=["Tensor"];return s&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${i}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(a.map(l=>"    "+l).join(`
`)),u.join(`
`)}function yee(t,e,n,s){const r=ie(e),o=s[s.length-1],i=new Array(o).fill(0),a=e.length,u=n==="complex64"?Jm(t):t;if(a>1)for(let l=0;l<r/o;l++){const c=l*o;for(let h=0;h<o;h++)i[h]=Math.max(i[h],Zm(u[c+h],0,n).length)}return i}function Zm(t,e,n){let s;return Array.isArray(t)?s=`${parseFloat(t[0].toFixed(ek))} + ${parseFloat(t[1].toFixed(ek))}j`:Tp(t)?s=`'${t}'`:n==="bool"?s=Lz(t):s=parseFloat(t.toFixed(ek)).toString(),Gd(s,e)}function Lz(t){return t===0?"false":"true"}function Z1(t,e,n,s,r,o=!0){const i=n==="complex64"?2:1,a=e[0],u=e.length;if(u===0){if(n==="complex64"){const y=Jm(t);return[Zm(y[0],0,n)]}return n==="bool"?[Lz(t[0])]:[t[0].toString()]}if(u===1){if(a>s3){const x=Vm*i;let v=Array.from(t.slice(0,x)),w=Array.from(t.slice((a-Vm)*i,a*i));return n==="complex64"&&(v=Jm(v),w=Jm(w)),["["+v.map((S,k)=>Zm(S,r[k],n)).join(", ")+", ..., "+w.map((S,k)=>Zm(S,r[a-Vm+k],n)).join(", ")+"]"]}return["["+(n==="complex64"?Jm(t):Array.from(t)).map((x,v)=>Zm(x,r[v],n)).join(", ")+"]"]}const l=e.slice(1),c=s.slice(1),h=s[0]*i,d=[];if(a>s3){for(let y=0;y<Vm;y++){const x=y*h,v=x+h;d.push(...Z1(t.slice(x,v),l,n,c,r,!1))}d.push("...");for(let y=a-Vm;y<a;y++){const x=y*h,v=x+h;d.push(...Z1(t.slice(x,v),l,n,c,r,y===a-1))}}else for(let y=0;y<a;y++){const x=y*h,v=x+h;d.push(...Z1(t.slice(x,v),l,n,c,r,y===a-1))}const f=u===2?",":"";d[0]="["+(a>0?d[0]+f:"");for(let y=1;y<d.length-1;y++)d[y]=" "+d[y]+f;let m=`,
`;for(let y=2;y<u;y++)m+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(o?"":m),d}function Jm(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ys{constructor(e,n,s){if(this.dtype=n,this.shape=e.slice(),this.size=ie(e),s!=null){const r=s.length;O(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||Hn(n,this.size),this.strides=et(e)}set(e,...n){n.length===0&&(n=[0]),O(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const s=this.locToIndex(n);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let n=0;for(const r of e){if(r<0||r>=this.shape[n]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}n++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let n=e[e.length-1];for(let s=0;s<e.length-1;++s)n+=this.strides[s]*e[s];return n}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const n=new Array(this.shape.length);for(let s=0;s<n.length-1;++s)n[s]=Math.floor(e/this.strides[s]),e-=n[s]*this.strides[s];return n[n.length-1]=e,n}get rank(){return this.shape.length}toTensor(){return Pi().makeTensor(this.values,this.shape,this.dtype)}}let Pi=null,xd=null;function xee(t){Pi=t}function vee(t){xd=t}class en{constructor(e,n,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=n||"float32",this.size=ie(e),this.strides=et(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return xd.buffer(this.shape,this.dtype,e)}bufferSync(){return xd.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return pi(this.shape,e,this.dtype==="complex64")}arraySync(){return pi(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Pi().read(this.dataId);if(this.dtype==="string"){const n=await e;try{return n.map(s=>Vi(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Pi().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Pi().readSync(this.dataId);if(this.dtype==="string")try{return e.map(n=>Vi(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Pi().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Pi().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return xd.print(this,e)}clone(){return this.throwIfDisposed(),xd.clone(this)}toString(e=!1){const n=this.dataSync();return gee(n,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),xd.cast(this,e)}variable(e=!0,n,s){return this.throwIfDisposed(),Pi().makeVariable(this,e,n,s)}}Object.defineProperty(en,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function ye(){return aT("Tensor",()=>en)}ye();class Mv extends en{constructor(e,n,s,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=n,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!kt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Pi().disposeTensor(this),this.dataId=e.dataId,Pi().incRef(this,null)}dispose(){Pi().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Mv,Symbol.hasInstance,{value:t=>t instanceof en&&t.assign!=null&&t.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var r3;(function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"})(r3||(r3={}));var KI;(function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"})(KI||(KI={}));var XI;(function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"})(XI||(XI={}));var qI;(function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"})(qI||(qI={}));var YI;(function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"})(YI||(YI={}));const wee={float32:qI,int32:KI,bool:XI,complex64:YI};function _s(t,e){if(t==="string"||e==="string"){if(t==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return wee[t][e]}function Bb(t){return _s(t,"int32")}function Mz(t){return t!=null&&typeof t=="object"&&"texture"in t&&t.texture instanceof WebGLTexture}function zz(t){return typeof GPUBuffer<"u"&&t!=null&&typeof t=="object"&&"buffer"in t&&t.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xn(t,e){if(t.dtype===e.dtype)return[t,e];const n=_s(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function bee(t,e){O(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function Bz(t){const e=[];return Vz(t,e,new Set),e}function Vz(t,e,n){if(t==null)return;if(t instanceof en){e.push(t);return}if(!See(t))return;const s=t;for(const r in s){const o=s[r];n.has(o)||(n.add(o),Vz(o,e,n))}}function See(t){return Array.isArray(t)||typeof t=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tk(t){return t.kernelName!=null}class o3{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class up{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new o3}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const s=e[n];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,s=1){return e in this.registryFactory?(Io(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:n,asyncInit:s}=this.initializeBackend(e);if(!(s?await n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new hee(this.backendInstance),!0}setupRegisteredKernels(){YD(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){YD(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=n.factory();if(s&&!(s instanceof Vw)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,o=s.then(i=>r<this.pendingBackendInitId?!1:(this.registry[e]=i,this.pendingBackendInit=null,!0)).catch(i=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Io(`Initialization of backend ${e} failed`),Io(i.stack||i.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return Io(`Initialization of backend ${e} failed`),Io(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const s=e[n],{success:r,asyncInit:o}=this.initializeBackend(s);if(o||r)return{name:s,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){const s=this.state.tensorInfo.get(n),r=s.backend,o=this.readSync(n),i=r.refCount(n);r.disposeData(n,!0),s.backend=e,e.move(n,o,s.shape,s.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let s=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=n(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,n,s){e();try{const r=s();return n(),r}catch(r){throw n(),r}}nextTensorId(){return up.nextTensorId++}nextVariableId(){return up.nextVariableId++}clone(e){const n=Z.runKernel(Yp,{x:e}),s={x:e},r=i=>({x:()=>{const a="float32",u={x:i},l={dtype:a};return Z.runKernel(Lp,u,l)}}),o=[];return this.addTapeNode(this.state.activeScope.name,s,[n],r,o,{}),n}runKernel(e,n,s){if(this.backendName==null&&this.backend,!(Ov(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,s){const r=this.backend.numDataIds();let o=0;s.forEach(u=>{o+=u.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-n-o-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let n,s=[];const r=this.isTapeOn(),o=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let u;const l=tk(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(tk(e)){const{kernelName:m,inputs:y,attrs:x}=e;this.backendName==null&&this.backend;const v=Ov(m,this.backendName);O(v!=null,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),a=()=>{const w=this.backend.numDataIds();u=v.kernelFunc({inputs:y,attrs:x,backend:this.backend});const S=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,w,S);const k=S.map(I=>I.rank!=null?I:this.makeTensorFromTensorInfo(I));if(r){const I=this.getTensorsForGradient(m,y,k);s=this.saveTensorsForBackwardMode(I)}return k}}else{const{forwardFunc:m}=e,y=x=>{r&&(s=x.map(v=>this.keep(this.clone(v))))};a=()=>{const x=this.backend.numDataIds();u=this.tidy(()=>m(this.backend,y));const v=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,x,v),v}}const{inputs:c,attrs:h}=e,d=tk(e)?null:e.backwardsFunc;let f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=a():(f=this.profiler.profileKernel(l,c,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),n=f.outputs)}),r&&this.addTapeNode(l,c,n,d,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(m=>c[m]!=null?c[m].shape:null),outputShapes:n.map(m=>m.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(u)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,n,s){const r=qD(e);if(r!=null){const o=r.inputsToSave||[],i=r.outputsToSave||[];let a;r.saveAllInputs?(O(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(n).map(l=>n[l])):a=o.map(l=>n[l]);const u=s.filter((l,c)=>i[c]);return a.concat(u)}return[]}makeTensor(e,n,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let o=e;s==="string"&&Tp(e[0])&&(o=e.map(u=>iu(u)));const i=r.write(o,n,s),a=new en(n,s,i,this.nextTensorId());if(this.trackTensor(a,r),s==="string"){const u=this.state.tensorInfo.get(i),l=HJ(o);this.state.numBytes+=l-u.bytes,u.bytes=l}return a}makeTensorFromDataId(e,n,s,r){s=s||"float32";const o={dataId:e,shape:n,dtype:s};return this.makeTensorFromTensorInfo(o,r)}makeTensorFromTensorInfo(e,n){const{dataId:s,shape:r,dtype:o}=e,i=new en(r,o,s,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(e,n=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const o=new Mv(e,n,s,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*Av(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof Mv||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*Av(e.dtype);this.state.numBytes-=s}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const n=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,s,r,o,i){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:s,saved:o},u=qD(e);u!=null&&(r=u.gradFunc),r!=null&&(a.gradient=l=>(l=l.map((c,h)=>{if(c==null){const d=s[h],f=Vs(d.size,d.dtype);return this.makeTensor(f,d.shape,d.dtype)}return c}),r(l.length>1?l:l[0],o,i))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){const n=Bz(e),s=new Set(n.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const i=this.state.activeScope.track[o];!i.kept&&!s.has(i.id)&&i.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(o=>{!o.kept&&o.scopeId===r.id&&this.track(o)})}gradients(e,n,s,r=!1){if(O(n.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));O(o instanceof en,()=>"The result y returned by f() must be a tensor.");const i=fee(this.state.activeTape,n,o);if(!r&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[o.id]=s??Cee(o.shape),mee(a,i,l=>this.tidy(l),kee);const u=n.map(l=>a[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(const c of l.saved)c.dispose()}),this.state.activeTape=null),{value:o,grads:u}})}customGrad(e){return O(WI(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{O(n.every(a=>a instanceof en),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};n.forEach((a,u)=>{r[u]=a});const o=(a,u)=>(s=e(...n,u),O(s.value instanceof en,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),O(WI(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),i=(a,u)=>{const l=s.gradFunc(a,u),c=Array.isArray(l)?l:[l];O(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),O(c.every(d=>d instanceof en),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return c.forEach((d,f)=>{h[f]=()=>d}),h};return this.runKernelFunc({forwardFunc:o,backwardsFunc:i,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,n){return this.state.tensorInfo.get(e).backend.readToGPU(e,n)}async time(e){const n=Tr(),s=await this.backend.time(e);return s.wallMs=Tr()-n,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new o3;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}up.nextTensorId=0;up.nextVariableId=0;function Cee(t){const e=iT(ie(t),"float32");return Z.makeTensor(e,t,"float32")}function Wz(){const t=$z();if(t._tfengine==null){const e=new KJ(t);t._tfengine=new up(e)}return QJ(t._tfengine.ENV),xee(()=>t._tfengine),t._tfengine}const Z=Wz();function kee(t,e){const n={a:t,b:e};return Z.runKernel(gh,n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iee(){return typeof navigator<"u"&&navigator!=null}function Uz(t){if(t||Iee()){if(t||(t=navigator),t.product==="ReactNative")return!0;const e=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!e){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function Gz(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fr=ce();Fr.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Fr.registerFlag("IS_BROWSER",()=>Gz());Fr.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Fr.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Fr.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Fr.registerFlag("PROD",()=>!1);Fr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Fr.getBool("DEBUG"));Fr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Fr.registerFlag("IS_TEST",()=>!1);Fr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Fr.getBool("DEBUG"));Fr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Fr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Fr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ll(t,e){let n=t;if(xi(t))return e==="string"?[]:[t.length];if(Mz(t)){const r=t.channels||"RGBA";return[t.height,t.width*r.length]}else if(zz(t))return[t.buffer.size/(e==null?4:Av(e))];if(!Array.isArray(t))return[];const s=[];for(;Array.isArray(n)||xi(n)&&e!=="string";)s.push(n.length),n=n[0];return Array.isArray(t)&&ce().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Hz(t,s,[]),s}function Hz(t,e,n){if(n=n||[],!Array.isArray(t)&&!xi(t)){O(e.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}O(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),O(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const s=e.slice(1);for(let r=0;r<t.length;++r)Hz(t[r],s,n.concat(r))}function i3(t,e,n,s){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==e||t==="numeric"&&e==="string")throw new Error(`Argument '${n}' passed to '${s}' must be ${t} tensor, but got ${e} tensor`)}}function M(t,e,n,s="numeric"){if(t instanceof ye())return i3(s,t.dtype,e,n),t;let r=mh(t);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),i3(s,r,e,n),t==null||!xi(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){const u=t==null?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${u}'`)}const o=Ll(t,r);!xi(t)&&!Array.isArray(t)&&(t=[t]);const a=r!=="string"?xh(t,r):xu(t,[],!0);return Z.makeTensor(a,o,r)}function zv(t,e,n,s="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((o,i)=>M(o,`${e}[${i}]`,n,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jz="__op";function Q(t){const e=Object.keys(t);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const s=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+jz;const r=(...o)=>{Z.startScope(n);try{const i=s(...o);return Jc(i)&&console.error("Cannot return a Promise inside of tidy."),Z.endScope(i),i}catch(i){throw Z.endScope(null),i}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ee(t,e){const n=M(t,"real","complex"),s=M(e,"imag","complex");Br(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:n,imag:s};return Z.runKernel(qw,r)}const xl=Q({complex_:$ee});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ml(t,e,n,s){if(s==null)s=mh(t);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(zz(t)||Mz(t)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return Z.backend.createTensorFromGPUData(t,e||n,s)}if(!xi(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Oo(e);const r=ie(e),o=ie(n);O(r===o,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${o}`);for(let i=0;i<n.length;++i){const a=n[i],u=i===n.length-1?a!==ie(e.slice(i)):!0;O(n[i]===e[i]||!u,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return!xi(t)&&!Array.isArray(t)&&(t=[t]),e=e||n,t=s!=="string"?xh(t,s):xu(t,[],!0),Z.makeTensor(t,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mi(t,e,n){const s=Ll(t,n);return Ml(t,e,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eh={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Yi{static join(e){return new Yi(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(s=>xi(s)?s.buffer:s),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let n=0;for(let s=0;s<e.length;s++){const r=e[s];s!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const o=n+r.byteLength;this.shards.push({buffer:r,start:n,end:o}),n=o}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,n=isNaN(Number(n))?0:n,e=Math.max(0,e),n=Math.min(this.byteLength,n),n<=e)return new ArrayBuffer(0);const s=this.findShardForByte(e);if(s===-1)throw new Error(`Could not find start shard for byte ${e}`);const r=n-e,o=new ArrayBuffer(r),i=new Uint8Array(o);let a=0;for(let u=s;u<this.shards.length;u++){const l=this.shards[u],h=e+a-l.start,d=a,m=Math.min(n,l.end)-l.start,y=new Uint8Array(l.buffer,h,m-h);if(i.set(y,d),a+=y.length,n<l.end)break}return o}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function n(r){return e<r.start?-1:e>=r.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=Nee(this.shards,n);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function Nee(t,e){let n=0,s=t.length;for(;n<=s;){const r=Math.floor((s-n)/2)+n,o=e(t[r]);if(o===0)return r;o<0?s=r:n=r+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lr(){return Z}function QI(){return Z.memory()}function ae(t,e){return Z.tidy(t,e)}function ot(t){Bz(t).forEach(n=>n.dispose())}function Rs(t){return Z.keep(t)}function Tee(t){return Z.setBackend(t)}function Ug(){return Z.backendName}function wT(t,e,n=1){return Z.registerBackend(t,e,n)}function th(){return Z.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vl=4;async function ZI(t,e){const n=[],s=[],r=Array.isArray(t)?t.map(i=>i.name):Object.keys(t);for(let i=0;i<r.length;++i){const a=r[i],u=Array.isArray(t)?t[i].tensor:t[a];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${u.dtype}`);const l={name:a,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const c=new Promise(async h=>{const d=await u.bytes(),f=d.reduce((x,v)=>x+v.length,0)+vl*d.length,m=new Uint8Array(f);let y=0;for(let x=0;x<d.length;x++){const v=d[x],w=new Uint8Array(new Uint32Array([v.length]).buffer);m.set(w,y),y+=vl,m.set(v,y),y+=v.length}h(m)});s.push(c)}else s.push(u.data());e!=null&&(l.group=e),n.push(l)}const o=await Promise.all(s);return{data:Aee(o),specs:n}}function Kz(t,e){const n=new Yi(t),s={};let r=0;for(const o of e){const i=Eee(o,(a,u)=>n.slice(r+a,r+u));s[o.name]=Xz(o,n.slice(r,r+i)),r+=i}return s}function Eee(t,e){const n=ie(t.shape);let s;if("quantization"in t){const r=t.quantization;s=eh[r.dtype]}else if(t.dtype==="string"){let r=0;for(let o=0;o<n;o++)r+=vl+new Uint32Array(e(r,r+vl))[0];return r}else s=eh[t.dtype];return n*s}async function Ree(t,e){const n=ie(t.shape);let s;if("quantization"in t){const r=t.quantization;s=eh[r.dtype]}else if(t.dtype==="string"){let r=0;for(let o=0;o<n;o++)r+=vl+new Uint32Array(await e(r,r+vl))[0];return r}else s=eh[t.dtype];return n*s}function Xz(t,e){const n=t.name,s=t.dtype,r=t.shape,o=ie(r);let i,a=0;if("quantization"in t){const u=t.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${t.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${t.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${t.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const l=eh[u.dtype],c=u.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(s==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){i=new Float32Array(c.length);for(let h=0;h<c.length;h++){const d=c[h];i[h]=d*u.scale+u.min}}else if(u.dtype==="float16")i=Lee()(c);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(s==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);i=new Int32Array(c.length);for(let h=0;h<c.length;h++){const d=c[h];i[h]=Math.round(d*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${s}`);a+=o*l}else if(s==="string"){const u=ie(t.shape);i=[];for(let l=0;l<u;l++){const c=new Uint32Array(e.slice(a,a+vl))[0];a+=vl;const h=new Uint8Array(e.slice(a,a+c));i.push(h),a+=c}}else{const u=eh[s];if(s==="float32")i=new Float32Array(e);else if(s==="int32")i=new Int32Array(e);else if(s==="bool")i=new Uint8Array(e);else if(s==="complex64"){i=new Float32Array(e);const l=new Float32Array(i.length/2),c=new Float32Array(i.length/2);for(let m=0;m<l.length;m++)l[m]=i[m*2],c[m]=i[m*2+1];const h=Mi(l,r,"float32"),d=Mi(c,r,"float32"),f=xl(h,d);return h.dispose(),d.dispose(),f}else throw new Error(`Unsupported dtype in weight '${n}': ${s}`);a+=o*u}return Mi(i,r,s)}async function a3(t,e,n){let s=new Uint8Array(e);for(;s.byteLength<n;){const{done:r,value:o}=await t.read();if(r&&o==null){const a=n-s.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}const i=new Uint8Array(s.length+o.byteLength);i.set(s,0),i.set(new Uint8Array(o),s.length),s=i}return s.buffer}async function qz(t,e){const n={},s=t.getReader();let r=new ArrayBuffer(0);for(const o of e){const i=await Ree(o,async(l,c)=>(r=await a3(s,r,c),r.slice(l,c)));r=await a3(s,r,i);const a=r.slice(0,i);r=r.slice(i);const u=Xz(o,a);if(n[o.name]=u,Ug()==="webgpu"){const l=th();"uploadToGPU"in l&&ie(u.shape)>=ce().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&l.uploadToGPU(u.dataId)}}return n}function Aee(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(o=>{if(e+=o.byteLength,n.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const s=new Uint8Array(e);let r=0;return n.forEach(o=>{s.set(new Uint8Array(o.buffer),r),r+=o.byteLength}),s.buffer}const bT=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function u3(t){return bT?Buffer.byteLength(t,"utf8"):new Blob([t]).size}function _ee(t){if(bT)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let s=0,r=e.length;s<r;s++)n+=String.fromCharCode(e[s]);return btoa(n)}function Dee(t){if(bT){const s=Buffer.from(t,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let s=0;s<e.length;++s)n.set([e.charCodeAt(s)],s);return n.buffer}function Yz(t){return Yi.join(t)}function l3(t){const e="/";for(t=t.trim();t.endsWith(e);)t=t.slice(0,t.length-1);const n=t.split(e);return n[n.length-1]}function Qz(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(n.initializerSignature=t.initializerSignature),t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),n}function Zz(t,e,n){const s={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null&&(s.trainingConfig=t.trainingConfig),t.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=n}return t.signature!=null&&(s.signature=t.signature),t.userDefinedMetadata!=null&&(s.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(s.modelInitializer=t.modelInitializer),t.initializerSignature!=null&&(s.initializerSignature=t.initializerSignature),s}async function ST(t,e){let n,s;return t.weightsManifest!=null&&([n,s]=await e(t.weightsManifest)),Zz(t,n,s)}function y0(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:u3(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:u3(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:new Yi(t.weightData).byteLength}}function JI(t){const e=[];for(const n of t)e.push(...n.weights);return e}function Pee(){const t=n=>{let s=n<<13,r=0;for(;!(s&8388608);)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}function Fee(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}function Oee(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}function Lee(){const t=Pee(),e=Fee(),n=Oee();return s=>{const r=new ArrayBuffer(4*s.length),o=new Uint32Array(r);for(let i=0;i<s.length;i++){const a=s[i],u=t[n[a>>10]+(a&1023)]+e[a>>10];o[i]=u}return new Float32Array(r)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Pn.instance==null&&(Pn.instance=new Pn),Pn.instance}static registerSaveRouter(e){Pn.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Pn.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Pn.getHandlers(e,"save")}static getLoadHandlers(e,n){return Pn.getHandlers(e,"load",n)}static getHandlers(e,n,s){const r=[];return(n==="load"?Pn.getInstance().loadRouters:Pn.getInstance().saveRouters).forEach(i=>{const a=i(e,s);a!==null&&r.push(a)}),r}}const Mee=t=>Pn.registerSaveRouter(t),zee=t=>Pn.registerLoadRouter(t),Jz=t=>Pn.getSaveHandlers(t),Bee=(t,e)=>Pn.getLoadHandlers(t,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e$="tensorflowjs",t$=1,Fc="models_store",Zu="model_info_store";function eB(){if(!ce().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function n$(t){const e=t.result;e.createObjectStore(Fc,{keyPath:"modelPath"}),e.createObjectStore(Zu,{keyPath:"modelPath"})}class nh{constructor(e){if(this.indexedDB=eB(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,n){return new Promise((s,r)=>{const o=this.indexedDB.open(e$,t$);o.onupgradeneeded=()=>n$(o),o.onsuccess=()=>{const i=o.result;if(n==null){const a=i.transaction(Fc,"readonly"),l=a.objectStore(Fc).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return i.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(l.result.modelArtifacts)},l.onerror=c=>(i.close(),r(l.error)),a.oncomplete=()=>i.close()}else{n.weightData=Yi.join(n.weightData);const a=y0(n),u=i.transaction(Zu,"readwrite");let l=u.objectStore(Zu),c;try{c=l.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(d){return r(d)}let h;c.onsuccess=()=>{h=i.transaction(Fc,"readwrite");const d=h.objectStore(Fc);let f;try{f=d.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:a})}catch(m){return r(m)}f.onsuccess=()=>s({modelArtifactsInfo:a}),f.onerror=m=>{l=u.objectStore(Zu);const y=l.delete(this.modelPath);y.onsuccess=()=>(i.close(),r(f.error)),y.onerror=x=>(i.close(),r(f.error))}},c.onerror=d=>(i.close(),r(c.error)),u.oncomplete=()=>{h==null?i.close():h.oncomplete=()=>i.close()}}},o.onerror=i=>r(o.error)})}}nh.URL_SCHEME="indexeddb://";const tB=t=>ce().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(nh.URL_SCHEME)?Vee(t.slice(nh.URL_SCHEME.length)):null;Pn.registerSaveRouter(tB);Pn.registerLoadRouter(tB);function Vee(t){return new nh(t)}function Wee(t){return t.startsWith(nh.URL_SCHEME)?t.slice(nh.URL_SCHEME.length):t}class Uee{constructor(){this.indexedDB=eB()}async listModels(){return new Promise((e,n)=>{const s=this.indexedDB.open(e$,t$);s.onupgradeneeded=()=>n$(s),s.onsuccess=()=>{const r=s.result,o=r.transaction(Zu,"readonly"),a=o.objectStore(Zu).getAll();a.onsuccess=()=>{const u={};for(const l of a.result)u[l.modelPath]=l.modelArtifactsInfo;e(u)},a.onerror=u=>(r.close(),n(a.error)),o.oncomplete=()=>r.close()},s.onerror=r=>n(s.error)})}async removeModel(e){return e=Wee(e),new Promise((n,s)=>{const r=this.indexedDB.open(e$,t$);r.onupgradeneeded=()=>n$(r),r.onsuccess=()=>{const o=r.result,i=o.transaction(Zu,"readwrite"),a=i.objectStore(Zu),u=a.get(e);let l;u.onsuccess=()=>{if(u.result==null)return o.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const c=a.delete(e),h=()=>{l=o.transaction(Fc,"readwrite");const f=l.objectStore(Fc).delete(e);f.onsuccess=()=>n(u.result.modelArtifactsInfo),f.onerror=m=>s(u.error)};c.onsuccess=h,c.onerror=d=>(h(),o.close(),s(u.error))}},u.onerror=c=>(o.close(),s(u.error)),i.oncomplete=()=>{l==null?o.close():l.oncomplete=()=>o.close()}},r.onerror=o=>s(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eu="/",vd="tensorflowjs_models",nB="info",Gee="model_topology",Hee="weight_specs",jee="weight_data",Kee="model_metadata";function sB(t){return{info:[vd,t,nB].join(eu),topology:[vd,t,Gee].join(eu),weightSpecs:[vd,t,Hee].join(eu),weightData:[vd,t,jee].join(eu),modelMetadata:[vd,t,Kee].join(eu)}}function rB(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function Xee(t){const e=t.split(eu);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(eu)}function qee(t){return t.startsWith(sh.URL_SCHEME)?t.slice(sh.URL_SCHEME.length):t}class sh{constructor(e){if(!ce().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=sB(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=y0(e),o=Yi.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,_ee(o));const i={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:r}}catch{throw rB(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=r;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const a=JSON.parse(o);n.format=a.format,n.generatedBy=a.generatedBy,n.convertedBy=a.convertedBy,a.signature!=null&&(n.signature=a.signature),a.userDefinedMetadata!=null&&(n.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(n.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(n.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(n.trainingConfig=a.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=Dee(i),n}}sh.URL_SCHEME="localstorage://";const oB=t=>ce().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(sh.URL_SCHEME)?Yee(t.slice(sh.URL_SCHEME.length)):null;Pn.registerSaveRouter(oB);Pn.registerLoadRouter(oB);function Yee(t){return new sh(t)}class Qee{constructor(){O(ce().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),O(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},n=vd+eu,s=eu+nB;for(let r=0;r<this.LS.length;++r){const o=this.LS.key(r);if(o.startsWith(n)&&o.endsWith(s)){const i=Xee(o);e[i]=JSON.parse(this.LS.getItem(o))}}return e}async removeModel(e){e=qee(e);const n=sB(e);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(n.info));return rB(n),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hd="://";class cr{constructor(){this.managers={}}static getInstance(){return cr.instance==null&&(cr.instance=new cr),cr.instance}static registerManager(e,n){O(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Hd)&&(e=e.slice(0,e.indexOf(Hd))),O(e.length>0,()=>"scheme must not be an empty string.");const s=cr.getInstance();O(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=n}static getManager(e){const n=cr.getInstance().managers[e];if(n==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return n}static getSchemes(){return Object.keys(cr.getInstance().managers)}}function J1(t){if(t.indexOf(Hd)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${cr.getSchemes().join(",")}`);return{scheme:t.split(Hd)[0],path:t.split(Hd)[1]}}async function iB(t,e,n=!1){O(t!==e,()=>`Old path and new path are the same: '${t}'`);const s=Pn.getLoadHandlers(t);O(s.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),O(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${t}.`);const r=s[0],o=Pn.getSaveHandlers(e);O(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),O(o.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const i=o[0],a=J1(t).scheme,u=J1(t).path,l=a===J1(t).scheme,c=await r.load();n&&l&&await cr.getManager(a).removeModel(u);const h=await i.save(c);return n&&!l&&await cr.getManager(a).removeModel(u),h.modelArtifactsInfo}async function Zee(){const t=cr.getSchemes(),e={};for(const n of t){const s=await cr.getManager(n).listModels();for(const r in s){const o=n+Hd+r;e[o]=s[r]}}return e}async function Jee(t){const e=J1(t);return cr.getManager(e.scheme).removeModel(e.path)}async function ete(t,e){return iB(t,e,!1)}async function tte(t,e){return iB(t,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nte{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,n){return fetch(e,n)}now(){return performance.now()}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,n){return new TextDecoder(n).decode(e)}setTimeoutCustom(e,n){if(typeof window>"u"||!ce().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,n);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return Tz(e)}}if(ce().get("IS_BROWSER")){ce().setPlatform("browser",new nte);try{cr.registerManager(sh.URL_SCHEME,new Qee)}catch{}try{cr.registerManager(nh.URL_SCHEME,new Uee)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ste={importFetch:()=>require("node-fetch")};let nk;class rte{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,n){return ce().global.fetch!=null?ce().global.fetch(e,n):(nk==null&&(nk=ste.importFetch()),nk(e,n))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(e)}decode(e,n){return e.length===0?"":new this.util.TextDecoder(n).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}ce().get("IS_NODE")&&!ce().get("IS_BROWSER")&&ce().setPlatform("node",new rte);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xt(t,e="float32",n){return e=e||"float32",Oo(t),new ys(t,e,n)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ote(t,e){const n=M(t,"x","cast");if(!GJ(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&n.dtype!=="string"||e!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:n},r={dtype:e};return Z.runKernel(Lp,s,r)}const De=Q({cast_:ote});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ite(t){const n={x:M(t,"x","clone","string_or_numeric")};return Z.runKernel(Yp,n)}const au=Q({clone_:ite});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aB(t,e=!1){console.log(t.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Wz();const ate={buffer:xt,cast:De,clone:au,print:aB};vee(ate);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ute(t,e){let n=M(t,"a","add"),s=M(e,"b","add");[n,s]=Xn(n,s);const r={a:n,b:s};return Z.runKernel(gh,r)}const we=Q({add_:ute});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lte(t,e){let n=M(t,"a","floorDiv"),s=M(e,"b","floorDiv");[n,s]=Xn(n,s);const r={a:n,b:s};return Z.runKernel(Xp,r)}const CT=Q({floorDiv_:lte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cte(t,e){let n=M(t,"a","div"),s=M(e,"b","div");if([n,s]=Xn(n,s),n.dtype==="int32"&&s.dtype==="int32")return CT(n,s);const r={a:n,b:s},o={};return Z.runKernel(Wp,r,o)}const Ge=Q({div_:cte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hte(t,e){let n=M(t,"a","mul"),s=M(e,"b","mul");[n,s]=Xn(n,s);const r={a:n,b:s};return Z.runKernel(of,r)}const Y=Q({mul_:hte});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dte(t){const e=M(t,"x","abs");if(e.dtype==="complex64"){const n={x:e};return Z.runKernel(ky,n)}else{const n={x:e};return Z.runKernel(gy,n)}}const ps=Q({abs_:dte});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pte(t){const n={x:M(t,"x","acos")};return Z.runKernel(Rp,n)}const uB=Q({acos_:pte});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fte(t){const n={x:M(t,"x","acosh")};return Z.runKernel(Ap,n)}const lB=Q({acosh_:fte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mte(t){O(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),O(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((r,o)=>M(r,`tensors${o}`,"addN")),n=e[0];e.forEach(r=>{if(r.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!kt(r.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return Z.runKernel(yy,s)}const gte=Q({addN_:mte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yte(t,e=null,n=!1){const r={x:M(t,"x","all","bool")},o={axis:e,keepDims:n};return Z.runKernel(Ww,r,o)}const kT=Q({all_:yte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xte(t,e=null,n=!1){const r={x:M(t,"x","any","bool")},o={axis:e,keepDims:n};return Z.runKernel(Uw,r,o)}const Bv=Q({any_:xte});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vte(t,e=0){const s={x:M(t,"x","argMax")},r={axis:e};return Z.runKernel(xy,s,r)}const rh=Q({argMax_:vte});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wte(t,e=0){const s={x:M(t,"x","argMin")},r={axis:e};return Z.runKernel(vy,s,r)}const cB=Q({argMin_:wte});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bte(t){const n={x:M(t,"x","asin")};return Z.runKernel(_p,n)}const hB=Q({asin_:bte});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ste(t){const n={x:M(t,"x","asinh")};return Z.runKernel(Dp,n)}const dB=Q({asinh_:Ste});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cte(t){const n={x:M(t,"x","atan")};return Z.runKernel(Pp,n)}const pB=Q({atan_:Cte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kte(t,e){let n=M(t,"a","atan2"),s=M(e,"b","atan2");[n,s]=Xn(n,s);const r={a:n,b:s};return Z.runKernel(Op,r)}const fB=Q({atan2_:kte});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ite(t){const n={x:M(t,"x","atanh")};return Z.runKernel(Fp,n)}const mB=Q({atanh_:Ite});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zl(t,e,n,s,r="NHWC",o){const i=t[3],a=[...e,i],u=fo(r);return bn(t,a,n,o,s,null,null,u)}function Js(t,e,n,s,r,o,i="channelsLast"){const[a,u]=Gg(e);let l;if(i==="channelsLast")l=[a,u,t[3],t[3]];else if(i==="channelsFirst")l=[a,u,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return bn(t,l,n,s,r,o,!1,i)}function Lo(t,e,n,s,r,o,i="NDHWC"){const[a,u,l]=s$(e);let c,h;if(i==="NDHWC")h="channelsLast",c=[a,u,l,t[4],t[4]];else if(i==="NCDHW")h="channelsFirst",c=[a,u,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${i}`);return Qi(t,c,n,s,r,!1,h,o)}function bn(t,e,n,s,r,o,i=!1,a="channelsLast"){let[u,l,c,h]=[-1,-1,-1,-1];if(a==="channelsLast")[u,l,c,h]=t;else if(a==="channelsFirst")[u,h,l,c]=t;else throw new Error(`Unknown dataFormat ${a}`);const[d,f,,m]=e,[y,x]=Gg(n),[v,w]=Gg(s),S=jd(d,v),k=jd(f,w),{padInfo:I,outHeight:T,outWidth:R}=Tte(r,l,c,y,x,S,k,o,a),_=i?m*h:m;let D;return a==="channelsFirst"?D=[u,_,T,R]:a==="channelsLast"&&(D=[u,T,R,_]),{batchSize:u,dataFormat:a,inHeight:l,inWidth:c,inChannels:h,outHeight:T,outWidth:R,outChannels:_,padInfo:I,strideHeight:y,strideWidth:x,filterHeight:d,filterWidth:f,effectiveFilterHeight:S,effectiveFilterWidth:k,dilationHeight:v,dilationWidth:w,inShape:t,outShape:D,filterShape:e}}function Qi(t,e,n,s,r,o=!1,i="channelsLast",a){let[u,l,c,h,d]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[u,l,c,h,d]=t;else if(i==="channelsFirst")[u,d,l,c,h]=t;else throw new Error(`Unknown dataFormat ${i}`);const[f,m,y,,x]=e,[v,w,S]=s$(n),[k,I,T]=s$(s),R=jd(f,k),_=jd(m,I),D=jd(y,T),{padInfo:L,outDepth:V,outHeight:U,outWidth:j}=Ete(r,l,c,h,v,w,S,R,_,D,a),q=o?x*d:x;let J;return i==="channelsFirst"?J=[u,q,V,U,j]:i==="channelsLast"&&(J=[u,V,U,j,q]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:c,inWidth:h,inChannels:d,outDepth:V,outHeight:U,outWidth:j,outChannels:q,padInfo:L,strideDepth:v,strideHeight:w,strideWidth:S,filterDepth:f,filterHeight:m,filterWidth:y,effectiveFilterDepth:R,effectiveFilterHeight:_,effectiveFilterWidth:D,dilationDepth:k,dilationHeight:I,dilationWidth:T,inShape:t,outShape:J,filterShape:e}}function $te(t,e,n,s,r){s==null&&(s=IT(t,e,n));const o=t[0],i=t[1],a=Hg((o-e+2*s)/n+1,r),u=Hg((i-e+2*s)/n+1,r);return[a,u]}function Nte(t,e,n,s,r,o){r==null&&(r=IT(t,e[0],s[0]));const i=[0,0,0,n];for(let a=0;a<3;a++)t[a]+2*r>=e[a]&&(i[a]=Hg((t[a]-e[a]+2*r)/s[a]+1,o));return i}function IT(t,e,n,s=1){const r=jd(e,s);return Math.floor((t[0]*(n-1)-n+r)/2)}function Gg(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function s$(t){return typeof t=="number"?[t,t,t]:t}function jd(t,e){return e<=1?t:t+(t-1)*(e-1)}function Tte(t,e,n,s,r,o,i,a,u){let l,c,h;if(typeof t=="number"){l={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};const f=$te([e,n],o,s,t,a);c=f[0],h=f[1]}else if(t==="same"){c=Math.ceil(e/s),h=Math.ceil(n/r);const d=Math.max(0,(c-1)*s+o-e),f=Math.max(0,(h-1)*r+i-n),m=Math.floor(d/2),y=d-m,x=Math.floor(f/2),v=f-x;l={top:m,bottom:y,left:x,right:v,type:"SAME"}}else if(t==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((e-o+1)/s),h=Math.ceil((n-i+1)/r);else if(typeof t=="object"){const d=u==="channelsLast"?t[1][0]:t[2][0],f=u==="channelsLast"?t[1][1]:t[2][1],m=u==="channelsLast"?t[2][0]:t[3][0],y=u==="channelsLast"?t[2][1]:t[3][1];l={top:d,bottom:f,left:m,right:y,type:d===0&&f===0&&m===0&&y===0?"VALID":"EXPLICIT"},c=Hg((e-o+d+f)/s+1,a),h=Hg((n-i+m+y)/r+1,a)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:l,outHeight:c,outWidth:h}}function Ete(t,e,n,s,r,o,i,a,u,l,c){let h,d,f,m;if(t==="valid"&&(t=0),typeof t=="number"){h={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};const x=Nte([e,n,s,1],[a,u,l],1,[r,o,i],t,c);d=x[0],f=x[1],m=x[2]}else if(t==="same"){d=Math.ceil(e/r),f=Math.ceil(n/o),m=Math.ceil(s/i);const y=(d-1)*r+a-e,x=(f-1)*o+u-n,v=(m-1)*i+l-s,w=Math.floor(y/2),S=y-w,k=Math.floor(x/2),I=x-k,T=Math.floor(v/2),R=v-T;h={top:k,bottom:I,left:T,right:R,front:w,back:S,type:"SAME"}}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:h,outDepth:d,outHeight:f,outWidth:m}}function Hg(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function wl(t){const[e,n,s]=Gg(t);return e===1&&n===1&&s===1}function Ss(t,e){return wl(t)||wl(e)}function oh(t){return Gg(t).every(e=>e>0)}function fo(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function yr(t,e,n){if(n!=null){if(typeof e=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if(typeof e=="number")O(ip(e),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{O(ip(r),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rte(t,e){const s={x:M(t,"x","reshape","string_or_numeric")},r={shape:e};return Z.runKernel(r0,s,r)}const ee=Q({reshape_:Rte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ate(t,e,n,s,r){const o=M(t,"x","avgPool","float32"),i=1;O(Ss(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let a=o,u=!1;o.rank===3&&(u=!0,a=ee(o,[1,o.shape[0],o.shape[1],o.shape[2]])),O(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),yr("avgPool",s,r);const l={x:a},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r};let h=Z.runKernel(wy,l,c);return h=De(h,o.dtype),u?ee(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Vb=Q({avgPool_:Ate});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _te(t,e,n,s,r,o="NDHWC"){const i=M(t,"x","avgPool3d","float32");let a=i,u=!1;i.rank===4&&(u=!0,a=ee(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),O(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),O(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),O(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),yr("avgPool3d",s,r);const l={x:a},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:o};let h=Z.runKernel(by,l,c);return h=De(h,a.dtype),u?ee(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const gB=Q({avgPool3d_:_te});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dte(t,e=0){O(t.length>=1,()=>"Pass at least one tensor to concat");const n=zv(t,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),n.length===1)return au(n[0]);const s=n,r={axis:e};return Z.runKernel(Iy,s,r)}const Ln=Q({concat_:Dte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pte(t,e,n=!1,s=!1){let r=M(t,"a","matMul"),o=M(e,"b","matMul");[r,o]=Xn(r,o);const i={a:r,b:o},a={transposeA:n,transposeB:s};return Z.runKernel(Sy,i,a)}const Dt=Q({matMul_:Pte});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fte(t){const n={x:M(t,"x","sigmoid","float32")};return Z.runKernel(yf,n)}const Eo=Q({sigmoid_:Fte});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ote(t,e,n){const s=M(t,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},o={begin:e,size:n};return Z.runKernel(l0,r,o)}const mt=Q({slice_:Ote});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lte(t){const n={x:M(t,"x","tanh","float32")};return Z.runKernel(Cf,n)}const lp=Q({tanh_:Lte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mte(t,e,n,s,r,o){const i=M(t,"forgetBias","basicLSTMCell"),a=M(e,"lstmKernel","basicLSTMCell"),u=M(n,"lstmBias","basicLSTMCell"),l=M(s,"data","basicLSTMCell"),c=M(r,"c","basicLSTMCell"),h=M(o,"h","basicLSTMCell"),d=Ln([l,h],1),f=Dt(d,a),m=we(f,u),y=m.shape[0],x=m.shape[1]/4,v=[y,x],w=mt(m,[0,0],v),S=mt(m,[0,x],v),k=mt(m,[0,x*2],v),I=mt(m,[0,x*3],v),T=we(Y(Eo(w),lp(S)),Y(c,Eo(we(i,k)))),R=Y(lp(T),Eo(I));return[T,R]}const zte=Q({basicLSTMCell_:Mte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bte(t,e,n){const s=M(t,"x","batchToSpaceND"),r=e.reduce((a,u)=>a*u);O(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),O(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),O(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const o={x:s},i={blockShape:e,crops:n};return Z.runKernel(Cy,o,i)}const Wb=Q({batchToSpaceND_:Bte});function Vte(t){let e;return t.rank===0||t.rank===1?e=ee(t,[1,1,1,t.size]):t.rank===2?e=ee(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?e=ee(t,[1,t.shape[0],t.shape[1],t.shape[2]]):e=t,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wte(t,e,n,s,r,o){o==null&&(o=.001);const i=M(t,"x","batchNorm"),a=M(e,"mean","batchNorm"),u=M(n,"variance","batchNorm");let l;r!=null&&(l=M(r,"scale","batchNorm"));let c;s!=null&&(c=M(s,"offset","batchNorm")),O(a.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O(l==null||a.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:Vte(i),scale:l,offset:c,mean:a,variance:u},f={varianceEpsilon:o},m=Z.runKernel(Py,d,f);return ee(m,i.shape)}const x0=Q({batchNorm_:Wte});function Ute(t,e,n,s,r,o){const i=M(t,"x","batchNorm"),a=M(e,"mean","batchNorm"),u=M(n,"variance","batchNorm");let l;r!=null&&(l=M(r,"scale","batchNorm"));let c;return s!=null&&(c=M(s,"offset","batchNorm")),O(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),O(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),O(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&O(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&O(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),x0(i,a,u,c,l,o)}const yB=Q({batchNorm2d_:Ute});function Gte(t,e,n,s,r,o){const i=M(t,"x","batchNorm"),a=M(e,"mean","batchNorm"),u=M(n,"variance","batchNorm");let l;r!=null&&(l=M(r,"scale","batchNorm"));let c;return s!=null&&(c=M(s,"offset","batchNorm")),O(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),O(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),O(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&O(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&O(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),x0(i,a,u,c,l,o)}const xB=Q({batchNorm3d_:Gte});function Hte(t,e,n,s,r,o){const i=M(t,"x","batchNorm"),a=M(e,"mean","batchNorm"),u=M(n,"variance","batchNorm");let l;r!=null&&(l=M(r,"scale","batchNorm"));let c;return s!=null&&(c=M(s,"offset","batchNorm")),O(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),O(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),O(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&O(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&O(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),x0(i,a,u,c,l,o)}const vB=Q({batchNorm4d_:Hte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jte(t,e,n){const s=M(t,"x","bincount"),r=M(e,"weights","bincount");O(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),O(n>=0,()=>`size must be non-negative, but got ${n}.`),O(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const o={x:s,weights:r},i={size:n};return Z.runKernel(jw,o,i)}const wB=Q({bincount_:jte});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kte(t,e){const n=M(t,"x","bitwiseAnd"),s=M(e,"y","bitwiseAnd");if(!kt(n.shape,s.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${s.shape}`);if(n.dtype!=="int32"||s.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${s.dtype}`);const r={a:n,b:s};return Z.runKernel(Kw,r)}const Xte=Q({bitwiseAnd_:Kte});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qte(t,e){const n=M(t,"s0","broadcastArgs","int32"),s=M(e,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:n,s1:s};return Z.runKernel(Xw,r)}const Yte=Q({broadcastArgs_:qte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qte(t,e){let n=M(t,"broadcastTo","x");const s=n.shape;if(Oo(e),e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const l=n.shape.slice();for(;l.length<e.length;)l.unshift(1);n=ee(n,l)}const r=n.shape,o=Array.from(e);for(let l=e.length-1;l>=0;l--)if(r[l]===e[l])o[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(o.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return au(n);const a={x:n},u={reps:o};return Z.runKernel(kf,a,u)}const Kd=Q({broadcastTo_:Qte});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zte(t){const n={x:M(t,"x","ceil","float32")};return Z.runKernel(Mp,n)}const bB=Q({ceil_:Zte});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $f(t,e,n){Oo(t),n=n||mh(e);const s={shape:t,value:e,dtype:n};return Z.runKernel(lb,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jte(t,e,n){const s=M(t,"x","clipByValue");if(O(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),e===n)return $f(s.shape,e,s.dtype);const r={x:s},o={clipValueMin:e,clipValueMax:n};return Z.runKernel(zp,r,o)}const Or=Q({clipByValue_:Jte});function ene(t){return Ln(t,0)}const SB=Q({concat1d_:ene});function tne(t,e){return Ln(t,e)}const CB=Q({concat2d_:tne});function nne(t,e){return Ln(t,e)}const kB=Q({concat3d_:nne});function sne(t,e){return Ln(t,e)}const IB=Q({concat4d_:sne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rne(t,e,n,s,r="NHWC",o=[1,1],i){const a=M(t,"x","conv2d","float32"),u=M(e,"filter","conv2d","float32");let l=a,c=!1;a.rank===3&&(c=!0,l=ee(a,[1,a.shape[0],a.shape[1],a.shape[2]])),O(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),O(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),yr("conv2d",s,i);const h=r==="NHWC"?l.shape[3]:l.shape[1];O(h===u.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${u.shape[2]}.`),O(Ss(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),O(oh(o),()=>"Error in conv2D: Dilated rates should be larger than 0."),O(oh(n),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:l,filter:u},f={strides:n,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i},m=Z.runKernel($y,d,f);return c?ee(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const bl=Q({conv2d_:rne});function one(t,e,n,s,r="NWC",o=1,i){const a=M(t,"x","conv1d"),u=M(e,"filter","conv1d");let l=a,c=!1;a.rank===2&&(c=!0,l=ee(a,[1,a.shape[0],a.shape[1]])),O(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),O(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),yr("conv1d",s,i),O(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),O(Ss(n,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${o}'`),O(oh(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),O(oh(n),()=>"Error in conv1D: Stride should be larger than 0."),O(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=ee(u,[1,u.shape[0],u.shape[1],u.shape[2]]),d=ee(l,[l.shape[0],1,l.shape[1],l.shape[2]]),x=bl(d,h,[1,n],s,"NHWC",[1,o],i);return c?ee(x,[x.shape[2],x.shape[3]]):ee(x,[x.shape[0],x.shape[2],x.shape[3]])}const $T=Q({conv1d_:one});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ine(t,e,n,s,r,o="NHWC",i){O(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let a=t,u=e,l=!1;e.rank===3&&(l=!0,u=ee(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,t[0],t[1],t[2]]),O(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),O(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),O(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c=o==="NHWC"?a[3]:a[1],h=o==="NHWC"?u.shape[3]:u.shape[1];O(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),O(h===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`),yr("conv2dDerInput",r,i);const d={dy:u,filter:n},f={strides:s,pad:r,dataFormat:o,dimRoundingMode:i,inputShape:a},m=Z.runKernel(Ny,d,f);return l?ee(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const NT=Q({conv2DBackpropInput_:ine});function ane(t,e,n,s,r,o){const i=M(t,"x","conv2dTranspose"),a=M(e,"filter","conv2dTranspose");return NT(n,i,a,s,r,"NHWC",o)}const TT=Q({conv2dTranspose_:ane});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function une(t,e,n,s,r="NDHWC",o=[1,1,1]){const i=M(t,"x","conv3d"),a=M(e,"filter","conv3d");let u=i,l=!1;i.rank===4&&(l=!0,u=ee(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),O(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),O(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),O(u.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${a.shape[3]}.`),O(Ss(n,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),O(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),O(oh(o),()=>"Error in conv3D: Dilated rates should be larger than 0."),O(oh(n),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:u,filter:a},h={strides:n,pad:s,dataFormat:r,dilations:o},d=Z.runKernel(Ty,c,h);return l?ee(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const $B=Q({conv3d_:une});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lne(t,e,n,s,r){O(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let o=t,i=e,a=!1;e.rank===4&&(a=!0,i=ee(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),o=[1,t[0],t[1],t[2],t[3]]);const u=o[4],l=i.shape[4];O(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),O(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),O(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),O(u===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`),O(l===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`);const c={dy:i,filter:n},h={pad:r,strides:s,inputShape:o},d=Z.runKernel(Zw,c,h);return a?ee(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const NB=Q({conv3DBackpropInput_:lne});function cne(t,e,n,s,r){const o=M(t,"x","conv3dTranspose"),i=M(e,"filter","conv3dTranspose");return NB(n,o,i,s,r)}const TB=Q({conv3dTranspose_:cne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hne(t){const n={x:M(t,"x","cos","float32")};return Z.runKernel(Bp,n)}const Ub=Q({cos_:hne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dne(t){const n={x:M(t,"x","cosh","float32")};return Z.runKernel(Vp,n)}const ET=Q({cosh_:dne});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pne(t,e=0,n=!1,s=!1){const o={x:M(t,"x","cumprod")},i={axis:e,exclusive:n,reverse:s};return Z.runKernel(Jw,o,i)}const Vv=Q({cumprod_:pne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fne(t,e=0,n=!1,s=!1){const o={x:M(t,"x","cumsum")},i={axis:e,exclusive:n,reverse:s};return Z.runKernel(Ey,o,i)}const RT=Q({cumsum_:fne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mne(t,e,n,s=!1){const r=M(t,"x","denseBincount"),o=M(e,"weights","denseBincount");O(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),O(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),O(n>=0,()=>`size must be non-negative, but got ${n}.`),O(o.size===r.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${o.shape}.`);const i={x:r,weights:o},a={size:n,binaryOutput:s};return Z.runKernel(tb,i,a)}const r$=Q({denseBincount_:mne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gne(t,e,n="NHWC"){const s=M(t,"x","depthToSpace","float32"),r=n==="NHWC"?s.shape[1]:s.shape[2],o=n==="NHWC"?s.shape[2]:s.shape[3],i=n==="NHWC"?s.shape[3]:s.shape[1];O(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),O(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),O(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${s.shape}`),O(i%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${s.shape}`);const a={x:s},u={blockSize:e,dataFormat:n};return Z.runKernel(nb,a,u)}const EB=Q({depthToSpace_:gne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yne(t,e,n,s,r="NHWC",o=[1,1],i){const a=M(t,"x","depthwiseConv2d","float32"),u=M(e,"filter","depthwiseConv2d","float32");let l=a,c=!1;a.rank===3&&(c=!0,l=ee(a,[1,a.shape[0],a.shape[1],a.shape[2]])),O(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),O(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const h=r==="NHWC"?l.shape[3]:l.shape[1];O(h===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${u.shape[2]}.`),yr("depthwiseConv2d",s,i);const d={x:l,filter:u},f={strides:n,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i},m=Z.runKernel(Ry,d,f);return c?ee(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const v0=Q({depthwiseConv2d_:yne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xne(t){const n={x:M(t,"x","diag")};return Z.runKernel(ob,n)}const vne=Q({diag_:xne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wne(t,e,n,s,r=[1,1],o="NHWC"){const i=M(t,"x","dilation2d"),a=M(e,"filter","dilation2d");O(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),O(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),O(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let u=i,l=!1;i.rank===3&&(u=ee(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0),O(u.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${a.shape[2]}`);const c={x:u,filter:a},h={strides:n,pad:s,dilations:r},d=Z.runKernel(Ay,c,h);return l?ee(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const RB=Q({dilation2d_:wne});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sl(t,e){const n=t.length,s=[];for(let r=0;r<n;r++){const o=n-1-r,i=t[o]||1;(e[e.length-1-r]||1)>1&&i===1&&s.unshift(o)}return s}function bs(t,e){const n=[];for(let s=0;s<e.length;s++){const r=t[t.length-s-1],o=e.length-s-1,i=e[o];(r==null||r===1&&i>1)&&n.unshift(o)}return n}function ut(t,e){const n=Math.max(t.length,e.length),s=new Array(n);for(let r=0;r<n;r++){let o=t[t.length-r-1];o==null&&(o=1);let i=e[e.length-r-1];if(i==null&&(i=1),o===1)s[n-r-1]=i;else if(i===1)s[n-r-1]=o;else if(o!==i){const a=`Operands could not be broadcast together with shapes ${t} and ${e}.`;throw Error(a)}else s[n-r-1]=o}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bne(t,e){let n=M(t,"a","equal","string_or_numeric"),s=M(e,"b","equal","string_or_numeric");[n,s]=Xn(n,s),ut(n.shape,s.shape);const r={a:n,b:s};return Z.runKernel(_y,r)}const Wi=Q({equal_:bne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sne(t,e,n){const s=M(e,"a","where"),r=M(n,"b","where"),o=M(t,"condition","where","bool"),i=ut(ut(o.shape,s.shape),r.shape),a=Kd(o,i),u=Kd(s,i),l=Kd(r,i),c={condition:a,t:u,e:l};return Z.runKernel(u0,c)}const Ys=Q({where_:Sne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cne(t){const n={x:M(t,"x","zerosLike")};return Z.runKernel(g0,n)}const Wt=Q({zerosLike_:Cne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kne(t,e){let n=M(t,"a","div"),s=M(e,"b","div");[n,s]=Xn(n,s);const r=Ge(n,s),o=Wt(r),i=Wi(s,o);return Ys(i,o,r)}const AB=Q({divNoNan_:kne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ine(t,e){const n=M(t,"t1","dot"),s=M(e,"t2","dot");O((n.rank===1||n.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);const r=n.rank===1?n.size:n.shape[1],o=s.rank===1?s.size:s.shape[0];if(O(r===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${o}.`),n.rank===1&&s.rank===1){const i=ee(n,[1,-1]),a=ee(s,[-1,1]),u=Dt(i,a);return ee(u,[])}else if(n.rank===1&&s.rank===2){const i=ee(n,[1,-1]),a=ee(s,[s.shape[0],s.shape[1]]),u=Dt(i,a);return ee(u,[u.size])}else if(n.rank===2&&s.rank===1){const i=ee(s,[-1,1]),a=Dt(n,i);return ee(a,[a.size])}else{const i=ee(s,[s.shape[0],s.shape[1]]);return Dt(n,i)}}const _B=Q({dot_:Ine});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ne(t,...e){const n=e.map((r,o)=>M(r,`tensors${o}`,"einsum")),s={equation:t};return Z.runKernel(ib,n,s)}const wd=Q({einsum_:$ne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nne(t){const n={x:M(t,"x","elu","float32")};return Z.runKernel(Up,n)}const w0=Q({elu_:Nne});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tne(t,e){const n=M(t,"x","ensureShape","string_or_numeric");if(!WJ(n.shape,e))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${e}`);return t}const Ene=Q({ensureShape_:Tne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rne(t){let e=M(t,"x","erf");O(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=De(e,"float32"));const n={x:e};return Z.runKernel(Gp,n)}const DB=Q({erf_:Rne});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AT(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function PB(t,e,n){const s=t.length+e.length,r=[];let o=0,i=0;for(let a=0;a<s;a++)n.indexOf(a)===-1?r.push(t[o++]):r.push(e[i++]);return r}function ts(t,e){const n=[],s=t.length;for(let o=0;o<s;o++)e.indexOf(o)===-1&&n.push(t[o]);const r=e.map(o=>t[o]);return[n,r]}function qn(t,e){const n=e.map(s=>1);return PB(t,n,e)}function cs(t,e,n){O(AT(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function cn(t,e){if(AT(t,e))return null;const n=[];for(let s=0;s<e;++s)t.indexOf(s)===-1&&n.push(s);return t.forEach(s=>n.push(s)),n}function Ta(t){return t.map((e,n)=>[n,e]).sort((e,n)=>e[1]-n[1]).map(e=>e[0])}function Sn(t,e){const n=[];for(let s=e-t;s<e;++s)n.push(s);return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ane(t,e=null,n=!1){const r={x:M(t,"x","max")},o={reductionIndices:e,keepDims:n};return Z.runKernel(Gy,r,o)}const fi=Q({max_:Ane});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ne(t,e=null,n=!1){const r={x:M(t,"x","min")},o={axis:e,keepDims:n};return Z.runKernel(Xy,r,o)}const jg=Q({min_:_ne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dne(t,e){let n=M(t,"base","pow"),s=M(e,"exp","pow");[n,s]=Xn(n,s);const r={a:n,b:s};return Z.runKernel(af,r)}const Cl=Q({pow_:Dne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nt(t,e){if((xi(t)&&e!=="string"||Array.isArray(t))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&xi(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Ml(t,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pne(t){const n={x:M(t,"x","sqrt","float32")};return Z.runKernel(vf,n)}const Zs=Q({sqrt_:Pne});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fne(t){const e=M(t,"x","square"),n={};return Z.runKernel("Square",{x:e},n)}const an=Q({square_:Fne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function One(t,e=null,n=!1){let s=M(t,"x","sum");s.dtype==="bool"&&(s=De(s,"int32"));const r={x:s},o={axis:e,keepDims:n};return Z.runKernel(c0,r,o)}const Qe=Q({sum_:One});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lne(t,e="euclidean",n=null,s=!1){t=M(t,"x","norm");const r=FB(t,e,n);let o=r.shape;if(s){const i=vt(n,t.shape);o=qn(r.shape,i)}return ee(r,o)}function FB(t,e,n=null){if(t.rank===0)return ps(t);if(t.rank!==1&&n===null)return FB(ee(t,[-1]),e,n);if(t.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(e===1)return Qe(ps(t),n);if(e===1/0)return fi(ps(t),n);if(e===-1/0)return jg(ps(t),n);if(e==="euclidean"||e===2)return Zs(Qe(Cl(ps(t),nt(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&n.length===2){if(e===1)return fi(Qe(ps(t),n[0]),n[1]-1);if(e===1/0)return fi(Qe(ps(t),n[1]),n[0]);if(e===-1/0)return jg(Qe(ps(t),n[1]),n[0]);if(e==="fro"||e==="euclidean")return Zs(Qe(an(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const b0=Q({norm_:Lne});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mne(t,e=null,n=!1){return b0(t,"euclidean",e,n)}const OB=Q({euclideanNorm_:Mne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zne(t){const n={x:M(t,"x","exp")};return Z.runKernel(Hp,n)}const mr=Q({exp_:zne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bne(t,e=0){const n=M(t,"x","expandDims","string_or_numeric");O(e<=n.rank,()=>"Axis must be <= rank of the tensor");const s={input:n},r={dim:e};return Z.runKernel(Dy,s,r)}const us=Q({expandDims_:Bne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vne(t){const n={x:M(t,"x","expm1")};return Z.runKernel(jp,n)}const LB=Q({expm1_:Vne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wne(t,e){const n=M(t,"x","tile","string_or_numeric");O(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);const s={x:n},r={reps:e};return Z.runKernel(kf,s,r)}const li=Q({tile_:Wne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Une(t,e,n,s="float32"){e==null&&(e=t);const r=xt([t,e],s),o=t<=e?t:e;for(let a=0;a<o;++a)r.set(1,a,a);const i=ee(r.toTensor(),[t,e]);if(n==null)return i;if(n.length===1)return li(us(i,0),[n[0],1,1]);if(n.length===2)return li(us(us(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return li(us(us(us(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const _T=Q({eye_:Une});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gne(t){const n={x:M(t,"x","floor","float32")};return Z.runKernel(Kp,n)}const S0=Q({floor_:Gne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hne(t,e,n=0,s=0){const r=M(t,"x","gather"),o=M(e,"indices","gather","int32"),i={x:r,indices:o},a={axis:n,batchDims:s};return Z.runKernel(Fy,i,a)}const C0=Q({gather_:Hne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jne(t,e){let n=M(t,"a","greater","string_or_numeric"),s=M(e,"b","greater","string_or_numeric");[n,s]=Xn(n,s),ut(n.shape,s.shape);const r={a:n,b:s};return Z.runKernel(Oy,r)}const mo=Q({greater_:jne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kne(t,e){let n=M(t,"a","greaterEqual","string_or_numeric"),s=M(e,"b","greaterEqual","string_or_numeric");[n,s]=Xn(n,s),ut(n.shape,s.shape);const r={a:n,b:s};return Z.runKernel(qp,r)}const Bl=Q({greaterEqual_:Kne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xne(t){const n={input:M(t,"input","imag")};return Z.runKernel(pb,n)}const Gb=Q({imag_:Xne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qne(t){const n={x:M(t,"x","isFinite")};return Z.runKernel(Qp,n)}const MB=Q({isFinite_:qne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yne(t){const n={x:M(t,"x","isInf")};return Z.runKernel(Zp,n)}const zB=Q({isInf_:Yne});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qne(t){const n={x:M(t,"x","isNaN")};return Z.runKernel(Jp,n)}const BB=Q({isNaN_:Qne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zne(t,e=.2){const s={x:M(t,"x","leakyRelu")},r={alpha:e};return Z.runKernel(Ly,s,r)}const Hb=Q({leakyRelu_:Zne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jne(t,e){let n=M(t,"a","less","string_or_numeric"),s=M(e,"b","less","string_or_numeric");[n,s]=Xn(n,s),ut(n.shape,s.shape);const r={a:n,b:s};return Z.runKernel(My,r)}const Kg=Q({less_:Jne});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ese(t,e){let n=M(t,"a","lessEqual","string_or_numeric"),s=M(e,"b","lessEqual","string_or_numeric");[n,s]=Xn(n,s),ut(n.shape,s.shape);const r={a:n,b:s};return Z.runKernel(zy,r)}const vh=Q({lessEqual_:ese});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tse(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const s={start:t,stop:e,num:n};return Z.runKernel(fb,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nse(t,e=5,n=1,s=1,r=.5){const o=M(t,"x","localResponseNormalization");O(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),O(ip(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let i=o,a=!1;o.rank===3&&(a=!0,i=ee(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const u={x:i},l={depthRadius:e,bias:n,alpha:s,beta:r},c=Z.runKernel(Uy,u,l);return a?ee(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const VB=Q({localResponseNormalization_:nse});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sse(t){const n={x:M(t,"x","log","float32")};return Z.runKernel(ef,n)}const Ao=Q({log_:sse});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rse(t){const n={x:M(t,"x","log1p")};return Z.runKernel(tf,n)}const jb=Q({log1p_:rse});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ose(t,e){O(WI(t),()=>"The f passed in variableGrads(f) must be a function"),O(e==null||Array.isArray(e)&&e.every(l=>l instanceof Mv),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=e!=null;if(!n){e=[];for(const l in Z.registeredVariables)e.push(Z.registeredVariables[l])}const s=n?e.filter(l=>!l.trainable):null,r=e.length;e=e.filter(l=>l.trainable),O(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const o=!0,{value:i,grads:a}=Z.gradients(t,e,null,o);O(a.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),O(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const u={};return e.forEach((l,c)=>{a[c]!=null&&(u[l.name]=a[c])}),s!=null&&s.forEach(l=>u[l.name]=null),{value:i,grads:u}}function vu(t){return Z.customGrad(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ise(t){const n={x:M(t,"x","neg")};return Z.runKernel(Yy,n)}const $n=Q({neg_:ise});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ase(t){const n={x:M(t,"x","softplus")};return Z.runKernel(xf,n)}const Nf=Q({softplus_:ase});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function use(t){const e=M(t,"x","logSigmoid");return vu(s=>({value:$n(Nf($n(s))),gradFunc:i=>Y(i,Eo($n(s)))}))(e)}const WB=Q({logSigmoid_:use});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lse(t,e){let n=M(t,"a","sub"),s=M(e,"b","sub");[n,s]=Xn(n,s);const r={a:n,b:s};return Z.runKernel(bf,r)}const Be=Q({sub_:lse});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cse(t,e=-1){const n=M(t,"logits","logSoftmax");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return vu((r,o)=>{const a=fi(r,e,!0),u=Be(r,a),l=Be(De(u,"float32"),Ao(Qe(mr(u),e,!0)));return o([l]),{value:l,gradFunc:(h,d)=>{const[f]=d,m=!0,y=mr(f);return Be(h,Y(Qe(h,e,m),y))}}})(n)}const DT=Q({logSoftmax_:cse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hse(t,e=null,n=!1){const s=M(t,"x","logSumExp"),r=vt(e,s.shape),o=fi(s,r,!0),i=Be(s,o),a=mr(i),u=Qe(a,r),l=Ao(u),c=we(ee(o,l.shape),l);if(n){const h=qn(c.shape,r);return ee(c,h)}return c}const Kb=Q({logSumExp_:hse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dse(t,e){const n=M(t,"a","logicalAnd","bool"),s=M(e,"b","logicalAnd","bool");ut(n.shape,s.shape);const r={a:n,b:s};return Z.runKernel(By,r)}const Ca=Q({logicalAnd_:dse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pse(t){const n={x:M(t,"x","logicalNot","bool")};return Z.runKernel(Vy,n)}const Xb=Q({logicalNot_:pse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fse(t,e){const n=M(t,"a","logicalOr","bool"),s=M(e,"b","logicalOr","bool");ut(n.shape,s.shape);const r={a:n,b:s};return Z.runKernel(Wy,r)}const PT=Q({logicalOr_:fse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mse(t,e){const n=M(t,"a","logicalXor","bool"),s=M(e,"b","logicalXor","bool");return ut(n.shape,s.shape),Ca(PT(t,e),Xb(Ca(t,e)))}const UB=Q({logicalXor_:mse});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w1=2147483648;function gse(t,e,n="left"){const s=M(t,"sortedSequence","searchSorted"),r=M(e,"values","searchSorted"),o=s.shape[s.shape.length-1],i=r.shape[r.shape.length-1],a=ee(s,[-1,o]),u=ee(r,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(ie(u.shape)>=w1)throw new Error(`values tensor size must less than ${w1}`);if(a.shape[1]>=w1)throw new Error(`trailing dim_size must less than ${w1} for int32 output type, was ${a.shape[1]}`);const l={sortedSequence:a,values:u},c={side:n};return Z.runKernel(Tb,l,c)}const FT=Q({searchSorted_:gse});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yse(t,e){return FT(t,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xse(t,e,n,s,r){const o=M(t,"x","maxPool"),i=1;let a=o,u=!1;o.rank===3&&(u=!0,a=ee(o,[1,o.shape[0],o.shape[1],o.shape[2]])),O(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),O(Ss(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),yr("maxPool",s,r);const l={x:a},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r},h=Z.runKernel(Hy,l,c);return u?ee(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const qb=Q({maxPool_:xse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vse(t,e=[1,1,1],n,s,r,o="NDHWC"){const i=M(t,"x","maxPool3d");let a=i,u=!1;i.rank===4&&(u=!0,a=ee(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),O(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),O(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),yr("maxPool3d",s,r);const l={x:a},c={filterSize:e,strides:n,pad:s,dimRoundingMode:r,dataFormat:o},h=Z.runKernel(jy,l,c);return u?ee(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const GB=Q({maxPool3d_:vse});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wse(t,e,n,s,r=!1){const i={x:M(t,"x","maxPoolWithArgmax")},a={filterSize:e,strides:n,pad:s,includeBatchInIndex:r},u=Z.runKernel(xb,i,a);return{result:u[0],indexes:u[1]}}const bse=Q({maxPoolWithArgmax_:wse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sse(t,e){let n=M(t,"a","maximum"),s=M(e,"b","maximum");[n,s]=Xn(n,s),n.dtype==="bool"&&(n=De(n,"int32"),s=De(s,"int32")),ut(n.shape,s.shape);const r={a:n,b:s};return Z.runKernel(nf,r)}const Su=Q({maximum_:Sse});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cse(t,e=null,n=!1){const r={x:M(t,"x","mean")},o={axis:e,keepDims:n};return Z.runKernel(Ky,r,o)}const Un=Q({mean_:Cse});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zn(t,e="float32"){if(Oo(t),e==="complex64"){const s=Zn(t,"float32"),r=Zn(t,"float32");return xl(s,r)}const n=Vs(ie(t),e);return Z.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function no(t,e="float32"){if(Oo(t),e==="complex64"){const s=no(t,"float32"),r=Zn(t,"float32");return xl(s,r)}const n=iT(ie(t),e);return Z.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kse(t,e,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(t===void 0)return[];let s=M(t,"x","meshgrid",t instanceof en?t.dtype:"float32");if(e===void 0)return[s];let r=M(e,"y","meshgrid",e instanceof en?e.dtype:"float32");const o=ie(s.shape),i=ie(r.shape);return n==="xy"?(s=ee(s,[1,-1]),r=ee(r,[-1,1]),[Dt(no([i,1],s.dtype),s),Dt(r,no([1,o],r.dtype))]):(s=ee(s,[-1,1]),r=ee(r,[1,-1]),[Dt(s,no([1,i],s.dtype)),Dt(no([o,1],r.dtype),r)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ise(t,e){let n=M(t,"a","minimum"),s=M(e,"b","minimum");[n,s]=Xn(n,s),n.dtype==="bool"&&(n=De(n,"int32"),s=De(s,"int32")),ut(n.shape,s.shape);const r={a:n,b:s};return Z.runKernel(sf,r)}const kl=Q({minimum_:Ise});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $se(t,e,n){O(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const s=M(t,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");O(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=n==="reflect"?1:0;for(let a=0;a<s.rank;a++)O(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),O(e[a][0]>=0&&e[a][0]<=s.shape[a]-r&&e[a][1]>=0&&e[a][1]<=s.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a]-r} or less than 0 for input of shape ${s.shape}`);const o={paddings:e,mode:n},i={x:s};return Z.runKernel(qy,i,o)}const OT=Q({mirrorPad_:$se});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nse(t,e){let n=M(t,"a","mod"),s=M(e,"b","mod");[n,s]=Xn(n,s);const r={a:n,b:s};return Z.runKernel(rf,r)}const HB=Q({mod_:Nse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tse(t,e=null,n=!1){t=M(t,"x","moments");const s=vt(e,t.shape),r=Un(t,s,n);let o=r.shape;n||(o=qn(r.shape,s));const i=an(Be(De(t,"float32"),ee(r,o))),a=Un(i,s,n);return{mean:r,variance:a}}const Yb=Q({moments_:Tse});function Ese(t,e,n,s){const r=M(e,"data","multiRNNCell"),o=zv(n,"c","multiRNNCell"),i=zv(s,"h","multiRNNCell");let a=r;const u=[];for(let h=0;h<t.length;h++){const d=t[h](a,o[h],i[h]);u.push(d[0]),u.push(d[1]),a=d[1]}const l=[],c=[];for(let h=0;h<u.length;h+=2)l.push(u[h]),c.push(u[h+1]);return[l,c]}const Rse=Q({multiRNNCell_:Ese});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ase(t,e,n,s=!1){const r=M(t,"logits","multinomial"),o=r.size,i=r.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const u={logits:i===1?ee(r,[1,-1]):r},l={numSamples:e,seed:n,normalized:s},c=Z.runKernel(vb,u,l);return i===1?ee(c,[c.size]):c}const _se=Q({multinomial_:Ase});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dse(t,e){let n=M(t,"a","notEqual","string_or_numeric"),s=M(e,"b","notEqual","string_or_numeric");[n,s]=Xn(n,s),ut(n.shape,s.shape);const r={a:n,b:s};return Z.runKernel(Qy,r)}const cp=Q({notEqual_:Dse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pse(t,e,n=1,s=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const i={indices:M(t,"indices","oneHot","int32")},a={dtype:r,depth:e,onValue:n,offValue:s};return Z.runKernel(Jy,i,a)}const LT=Q({oneHot_:Pse});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fse(t){const n={x:M(t,"x","onesLike")};return Z.runKernel(Zy,n)}const _o=Q({onesLike_:Fse});function Ose(t,e){const n=M(t,"v1","outerProduct"),s=M(e,"v2","outerProduct");O(n.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${s.rank}.`);const r=ee(n,[-1,1]),o=ee(s,[1,-1]);return Dt(r,o)}const Lse=Q({outerProduct_:Ose});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mse(t,e,n=0){const s=M(t,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:n},o={x:s};return Z.runKernel(t0,o,r)}const Ui=Q({pad_:Mse});function zse(t,e,n=0){return O(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Ui(t,[e],n)}const Bse=Q({pad1d_:zse});function Vse(t,e,n=0){return O(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ui(t,e,n)}const Wse=Q({pad2d_:Vse});function Use(t,e,n=0){return O(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ui(t,e,n)}const Gse=Q({pad3d_:Use});function Hse(t,e,n=0){return O(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ui(t,e,n)}const jse=Q({pad4d_:Hse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kse(t,e,n){const s=M(t,"x","spaceToBatchND");O(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),O(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),O(s.shape.reduce((i,a,u)=>u>0&&u<=e.length?i&&(a+n[u-1][0]+n[u-1][1])%e[u-1]===0:i,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},o={blockShape:e,paddings:n};return Z.runKernel(h0,r,o)}const Qb=Q({spaceToBatchND_:Kse});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xse(t,e,n,s,r,o,i){r==null&&(r=[1,1]),o==null&&(o=1),s===0&&(s="valid");const a=M(t,"x","maxPool");let u=a,l=!1;a.rank===3&&(l=!0,u=ee(a,[1,a.shape[0],a.shape[1],a.shape[2]])),O(Ss(o,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${r}'`);const c=Js(u.shape,e,o,r,s),h=[c.dilationHeight,c.dilationWidth];let d;s==="same"?d=Yse([c.filterHeight,c.filterWidth],h):d=[[0,0],[0,0]];const f=h[0]===1&&h[1]===1,[m,y]=qse([c.inHeight,c.inWidth],h,d),x=f?s:"valid",v=f?u:Qb(u,h,m),S=(n==="avg"?()=>Vb(v,e,o,x,i):()=>qb(v,e,o,x,i))(),k=f?S:Wb(S,h,y);return l?ee(k,[k.shape[1],k.shape[2],k.shape[3]]):k}function qse(t,e,n){const s=n.map(c=>c[0]),r=n.map(c=>c[1]),o=t.concat(s,r),i=e.map((c,h)=>(c-o[h]%c)%c),a=r.map((c,h)=>c+i[h]),u=e.map((c,h)=>[s[h],a[h]]),l=e.map((c,h)=>[0,i[h]]);return[u,l]}function Yse(t,e){const s=t.map((i,a)=>i+(i-1)*(e[a]-1)).map(i=>i-1),r=s.map(i=>Math.floor(i/2)),o=s.map((i,a)=>i-r[a]);return s.map((i,a)=>[r[a],o[a]])}const jB=Q({pool_:Xse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qse(t,e){const n=M(t,"x","prelu"),s=M(e,"alpha","prelu"),r={x:n,alpha:s};return Z.runKernel(n0,r)}const Zb=Q({prelu_:Qse});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zse(t,e=null,n=!1){let s=M(t,"x","prod");s.dtype==="bool"&&(s=De(s,"int32"));const r={x:s},o={axis:e,keepDims:n};return Z.runKernel(s0,r,o)}const KB=Q({prod_:Zse});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jse(t,e,n,s){const r=t.map((c,h)=>M(c,`tensors${h}`,"raggedGather","int32")),o=M(e,"paramsDenseValues","raggedGather"),i=M(n,"indices","raggedGather","int32"),a={paramsNestedSplits:r,paramsDenseValues:o,indices:i},u={outputRaggedRank:s},l=Z.runKernel(cT,a,u);return{outputNestedSplits:l.slice(0,l.length-1),outputDenseValues:l[l.length-1]}}const ere=Q({raggedGather_:Jse});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tre(t,e,n){const s=M(t,"starts","raggedRange"),r=M(e,"limits","raggedRange",s.dtype),o=M(n,"deltas","raggedRange",s.dtype),i={starts:s,limits:r,deltas:o},a=Z.runKernel(hT,i);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const nre=Q({raggedRange_:tre});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sre(t,e,n,s,r){const o=M(t,"shape","raggedTensorToTensor","int32"),i=M(e,"values","raggedTensorToTensor"),a=M(n,"defaultValue","raggedTensorToTensor",i.dtype),u=s.map((h,d)=>M(h,`tensors${d}`,"raggedTensorToTensor","int32")),l={shape:o,values:i,defaultValue:a,rowPartitionTensors:u},c={rowPartitionTypes:r};return Z.runKernel(dT,l,c)}const rre=Q({raggedTensorToTensor_:sre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ore(t,e,n){Oo(t);const s=ie(t);let r=null;if(n==null||n==="float32")r=new Float32Array(s);else if(n==="int32")r=new Int32Array(s);else if(n==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${n}`);for(let o=0;o<s;o++)r[o]=e();return Z.makeTensor(r,t,n)}const ire=Q({rand_:ore});var MT={exports:{}};MT.exports;(function(t){(function(e,n,s){function r(u){var l=this,c=a();l.next=function(){var h=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=h-(l.c=h|0)},l.c=1,l.s0=c(" "),l.s1=c(" "),l.s2=c(" "),l.s0-=c(u),l.s0<0&&(l.s0+=1),l.s1-=c(u),l.s1<0&&(l.s1+=1),l.s2-=c(u),l.s2<0&&(l.s2+=1),c=null}function o(u,l){return l.c=u.c,l.s0=u.s0,l.s1=u.s1,l.s2=u.s2,l}function i(u,l){var c=new r(u),h=l&&l.state,d=c.next;return d.int32=function(){return c.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,h&&(typeof h=="object"&&o(h,c),d.state=function(){return o(c,{})}),d}function a(){var u=4022871197,l=function(c){c=String(c);for(var h=0;h<c.length;h++){u+=c.charCodeAt(h);var d=.02519603282416938*u;u=d>>>0,d-=u,d*=u,u=d>>>0,d-=u,u+=d*4294967296}return(u>>>0)*23283064365386963e-26};return l}n&&n.exports?n.exports=i:s&&s.amd?s(function(){return i}):this.alea=i})(Rr,t,!1)})(MT);var are=MT.exports,zT={exports:{}};zT.exports;(function(t){(function(e,n,s){function r(a){var u=this,l="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var h=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^h^h>>>8},a===(a|0)?u.x=a:l+=a;for(var c=0;c<l.length+64;c++)u.x^=l.charCodeAt(c)|0,u.next()}function o(a,u){return u.x=a.x,u.y=a.y,u.z=a.z,u.w=a.w,u}function i(a,u){var l=new r(a),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var d=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(d+f)/(1<<21);while(m===0);return m},h.int32=l.next,h.quick=h,c&&(typeof c=="object"&&o(c,l),h.state=function(){return o(l,{})}),h}n&&n.exports?n.exports=i:s&&s.amd?s(function(){return i}):this.xor128=i})(Rr,t,!1)})(zT);var ure=zT.exports,BT={exports:{}};BT.exports;(function(t){(function(e,n,s){function r(a){var u=this,l="";u.next=function(){var h=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(h^h<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,a===(a|0)?u.x=a:l+=a;for(var c=0;c<l.length+64;c++)u.x^=l.charCodeAt(c)|0,c==l.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function o(a,u){return u.x=a.x,u.y=a.y,u.z=a.z,u.w=a.w,u.v=a.v,u.d=a.d,u}function i(a,u){var l=new r(a),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var d=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(d+f)/(1<<21);while(m===0);return m},h.int32=l.next,h.quick=h,c&&(typeof c=="object"&&o(c,l),h.state=function(){return o(l,{})}),h}n&&n.exports?n.exports=i:s&&s.amd?s(function(){return i}):this.xorwow=i})(Rr,t,!1)})(BT);var lre=BT.exports,VT={exports:{}};VT.exports;(function(t){(function(e,n,s){function r(a){var u=this;u.next=function(){var c=u.x,h=u.i,d,f;return d=c[h],d^=d>>>7,f=d^d<<24,d=c[h+1&7],f^=d^d>>>10,d=c[h+3&7],f^=d^d>>>3,d=c[h+4&7],f^=d^d<<7,d=c[h+7&7],d=d^d<<13,f^=d^d<<9,c[h]=f,u.i=h+1&7,f};function l(c,h){var d,f=[];if(h===(h|0))f[0]=h;else for(h=""+h,d=0;d<h.length;++d)f[d&7]=f[d&7]<<15^h.charCodeAt(d)+f[d+1&7]<<13;for(;f.length<8;)f.push(0);for(d=0;d<8&&f[d]===0;++d);for(d==8?f[7]=-1:f[d],c.x=f,c.i=0,d=256;d>0;--d)c.next()}l(u,a)}function o(a,u){return u.x=a.x.slice(),u.i=a.i,u}function i(a,u){a==null&&(a=+new Date);var l=new r(a),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var d=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(d+f)/(1<<21);while(m===0);return m},h.int32=l.next,h.quick=h,c&&(c.x&&o(c,l),h.state=function(){return o(l,{})}),h}n&&n.exports?n.exports=i:s&&s.amd?s(function(){return i}):this.xorshift7=i})(Rr,t,!1)})(VT);var cre=VT.exports,WT={exports:{}};WT.exports;(function(t){(function(e,n,s){function r(a){var u=this;u.next=function(){var c=u.w,h=u.X,d=u.i,f,m;return u.w=c=c+1640531527|0,m=h[d+34&127],f=h[d=d+1&127],m^=m<<13,f^=f<<17,m^=m>>>15,f^=f>>>12,m=h[d]=m^f,u.i=d,m+(c^c>>>16)|0};function l(c,h){var d,f,m,y,x,v=[],w=128;for(h===(h|0)?(f=h,h=null):(h=h+"\0",f=0,w=Math.max(w,h.length)),m=0,y=-32;y<w;++y)h&&(f^=h.charCodeAt((y+32)%h.length)),y===0&&(x=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,y>=0&&(x=x+1640531527|0,d=v[y&127]^=f+x,m=d==0?m+1:0);for(m>=128&&(v[(h&&h.length||0)&127]=-1),m=127,y=4*128;y>0;--y)f=v[m+34&127],d=v[m=m+1&127],f^=f<<13,d^=d<<17,f^=f>>>15,d^=d>>>12,v[m]=f^d;c.w=x,c.X=v,c.i=m}l(u,a)}function o(a,u){return u.i=a.i,u.w=a.w,u.X=a.X.slice(),u}function i(a,u){a==null&&(a=+new Date);var l=new r(a),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var d=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(d+f)/(1<<21);while(m===0);return m},h.int32=l.next,h.quick=h,c&&(c.X&&o(c,l),h.state=function(){return o(l,{})}),h}n&&n.exports?n.exports=i:s&&s.amd?s(function(){return i}):this.xor4096=i})(Rr,t,!1)})(WT);var hre=WT.exports,UT={exports:{}};UT.exports;(function(t){(function(e,n,s){function r(a){var u=this,l="";u.next=function(){var h=u.b,d=u.c,f=u.d,m=u.a;return h=h<<25^h>>>7^d,d=d-f|0,f=f<<24^f>>>8^m,m=m-h|0,u.b=h=h<<20^h>>>12^d,u.c=d=d-f|0,u.d=f<<16^d>>>16^m,u.a=m-h|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,a===Math.floor(a)?(u.a=a/4294967296|0,u.b=a|0):l+=a;for(var c=0;c<l.length+20;c++)u.b^=l.charCodeAt(c)|0,u.next()}function o(a,u){return u.a=a.a,u.b=a.b,u.c=a.c,u.d=a.d,u}function i(a,u){var l=new r(a),c=u&&u.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var d=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(d+f)/(1<<21);while(m===0);return m},h.int32=l.next,h.quick=h,c&&(typeof c=="object"&&o(c,l),h.state=function(){return o(l,{})}),h}n&&n.exports?n.exports=i:s&&s.amd?s(function(){return i}):this.tychei=i})(Rr,t,!1)})(UT);var dre=UT.exports,XB={exports:{}};const pre={},fre=Object.freeze(Object.defineProperty({__proto__:null,default:pre},Symbol.toStringTag,{value:"Module"})),mre=s9(fre);(function(t){(function(e,n,s){var r=256,o=6,i=52,a="random",u=s.pow(r,o),l=s.pow(2,i),c=l*2,h=r-1,d;function f(k,I,T){var R=[];I=I==!0?{entropy:!0}:I||{};var _=v(x(I.entropy?[k,S(n)]:k??w(),3),R),D=new m(R),L=function(){for(var V=D.g(o),U=u,j=0;V<l;)V=(V+j)*r,U*=r,j=D.g(1);for(;V>=c;)V/=2,U/=2,j>>>=1;return(V+j)/U};return L.int32=function(){return D.g(4)|0},L.quick=function(){return D.g(4)/4294967296},L.double=L,v(S(D.S),n),(I.pass||T||function(V,U,j,q){return q&&(q.S&&y(q,D),V.state=function(){return y(D,{})}),j?(s[a]=V,U):V})(L,_,"global"in I?I.global:this==s,I.state)}function m(k){var I,T=k.length,R=this,_=0,D=R.i=R.j=0,L=R.S=[];for(T||(k=[T++]);_<r;)L[_]=_++;for(_=0;_<r;_++)L[_]=L[D=h&D+k[_%T]+(I=L[_])],L[D]=I;(R.g=function(V){for(var U,j=0,q=R.i,J=R.j,te=R.S;V--;)U=te[q=h&q+1],j=j*r+te[h&(te[q]=te[J=h&J+U])+(te[J]=U)];return R.i=q,R.j=J,j})(r)}function y(k,I){return I.i=k.i,I.j=k.j,I.S=k.S.slice(),I}function x(k,I){var T=[],R=typeof k,_;if(I&&R=="object")for(_ in k)try{T.push(x(k[_],I-1))}catch{}return T.length?T:R=="string"?k:k+"\0"}function v(k,I){for(var T=k+"",R,_=0;_<T.length;)I[h&_]=h&(R^=I[h&_]*19)+T.charCodeAt(_++);return S(I)}function w(){try{var k;return d&&(k=d.randomBytes)?k=k(r):(k=new Uint8Array(r),(e.crypto||e.msCrypto).getRandomValues(k)),S(k)}catch{var I=e.navigator,T=I&&I.plugins;return[+new Date,e,T,e.screen,S(n)]}}function S(k){return String.fromCharCode.apply(0,k)}if(v(s.random(),n),t.exports){t.exports=f;try{d=mre}catch{}}else s["seed"+a]=f})(typeof self<"u"?self:Rr,[],Math)})(XB);var gre=XB.exports,yre=are,xre=ure,vre=lre,wre=cre,bre=hre,Sre=dre,wh=gre;wh.alea=yre;wh.xor128=xre;wh.xorwow=vre;wh.xorshift7=wre;wh.xor4096=bre;wh.tychei=Sre;var Jb=wh;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GT{constructor(e,n,s,r,o){this.mean=e,this.stdDev=n,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=o||Math.random();this.random=Jb.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,n,s=!1;for(;!s;){let r,o,i;do r=2*this.random()-1,o=2*this.random()-1,i=r*r+o*o;while(i>=1||i===0);const a=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*r*a,n=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class Cre{constructor(e,n,s,r){this.alpha=e,this.beta=1/n,this.dtype=s;const o=r||Math.random();this.randu=Jb.alea(o.toString()),this.randn=new GT(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,n,s,r,o,i;for(;;){do r=this.randn.nextValue(),i=1+this.c*r;while(i<=0);if(i*=i*i,e=r*r,n=1-.331*e*e,s=.5*e+this.d*(1-i+Math.log(i)),o=this.randu(),o<n||Math.log(o)<s)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class kre{constructor(e=0,n=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=n-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);this.random=Jb.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ire(t,e,n=1,s="float32",r){if(Oo(t),n==null&&(n=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const o=new Cre(e,n,s,r),i=xt(t,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const $re=Q({randomGamma_:Ire});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nre(t,e=0,n=1,s,r){if(Oo(t),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const o=new GT(e,n,s,!1,r),i=xt(t,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const HT=Q({randomNormal_:Nre});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tre(t,e,n){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return HT(t,0,1,e,n)}const Ere=Q({randomStandardNormal_:Tre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rre(t,e=0,n=1,s="float32",r){Oo(t);const o=xt(t,s),i=new kre(e,n,null,r);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const bh=Q({randomUniform_:Rre});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Are(t,e,n,s){return bh(t,e,n,"int32",s)}const _re=Q({randomUniformInt_:Are});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hp(t,e,n=1,s="float32"){if(n===0)throw new Error("Cannot have a step of zero");const r={start:t,stop:e,step:n,dtype:s};return Z.runKernel(Sb,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dre(t){const n={input:M(t,"input","real")};return Z.runKernel(Cb,n)}const Xg=Q({real_:Dre});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pre(t){const n={x:M(t,"x","reciprocal")};return Z.runKernel(uf,n)}const qB=Q({reciprocal_:Pre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fre(t){const n={x:M(t,"x","relu")};return Z.runKernel(lf,n)}const Ea=Q({relu_:Fre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ore(t){const n={x:M(t,"x","relu6")};return Z.runKernel(cf,n)}const jT=Q({relu6_:Ore});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lre(t,e){const s={x:M(t,"x","reverse")},r={dims:e};return Z.runKernel(a0,s,r)}const vi=Q({reverse_:Lre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mre(t){const e=M(t,"x","reverse");return O(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),vi(e,0)}const zre=Q({reverse1d_:Mre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bre(t,e){const n=M(t,"x","reverse");return O(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),vi(n,e)}const Vre=Q({reverse2d_:Bre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wre(t,e){const n=M(t,"x","reverse");return O(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),vi(n,e)}const Ure=Q({reverse3d_:Wre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gre(t,e){const n=M(t,"x","reverse");return O(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),vi(n,e)}const Hre=Q({reverse4d_:Gre});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jre(t){const n={x:M(t,"x","round")};return Z.runKernel(hf,n)}const KT=Q({round_:jre});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kre(t){const n={x:M(t,"x","rsqrt","float32")};return Z.runKernel(df,n)}const XT=Q({rsqrt_:Kre});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xre(t){const n={x:M(t,"x","selu")};return Z.runKernel(pf,n)}const qT=Q({selu_:Xre});function qre(t,e,n,s,r,o=[1,1],i="NHWC"){const a=M(t,"x","separableConv2d"),u=M(e,"depthwiseFilter","separableConv2d"),l=M(n,"pointwiseFilter","separableConv2d");let c=a,h=!1;if(a.rank===3&&(h=!0,c=ee(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");O(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),O(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),O(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),O(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),O(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);const d=u.shape[2],f=u.shape[3];O(l.shape[2]===d*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*f}, but got ${l.shape[2]}.`);const m=v0(c,u,s,r,i,o),x=bl(m,l,1,"valid",i);return h?ee(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const YT=Q({separableConv2d_:qre});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Yre(t,e){const n=M(t,"x","setdiff1d"),s=M(e,"y","setdiff1d");O(n.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${s.dtype}).`),O(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),O(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await n.data(),o=await s.data(),i=new Set(o);let a=0;for(let c=0;c<r.length;c++)i.has(r[c])||a++;const u=new ys([a],n.dtype),l=new ys([a],"int32");for(let c=0,h=0;c<r.length;c++)i.has(r[c])||(u.values[h]=r[c],l.values[h]=c,h++);return[u.toTensor(),l.toTensor()]}const Qre=Yre;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zre(t){const n={x:M(t,"x","sign")};return Z.runKernel(gf,n)}const YB=Q({sign_:Zre});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jre(t){const n={x:M(t,"x","sin","float32")};return Z.runKernel(ff,n)}const QT=Q({sin_:Jre});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eoe(t){const n={x:M(t,"x","sinh")};return Z.runKernel(mf,n)}const ZT=Q({sinh_:eoe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function toe(t,e,n){const s=M(t,"x","slice1d");return O(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),mt(s,[e],[n])}const eS=Q({slice1d_:toe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function noe(t,e,n){const s=M(t,"x","slice2d");return O(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),mt(s,e,n)}const JT=Q({slice2d_:noe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function soe(t,e,n){const s=M(t,"x","slice3d");return O(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),mt(s,e,n)}const tS=Q({slice3d_:soe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function roe(t,e,n){const s=M(t,"x","slice4d");return O(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),mt(s,e,n)}const qg=Q({slice4d_:roe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ooe(t,e=-1){const n=M(t,"logits","softmax","float32");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const s={logits:n},r={dim:e};return Z.runKernel(p0,s,r)}const nS=Q({softmax_:ooe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ioe(t){O(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);const e={input:t};return Z.runKernel(ub,e)}const sS=Q({fft_:ioe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aoe(t){O(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);const e={input:t};return Z.runKernel(db,e)}const Yg=Q({ifft_:aoe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uoe(t){const e=t.shape[t.shape.length-1],n=t.size/e;let s;if(e<=2){const r=ee(t,[n,e]);s=Yg(r)}else{const r=[n,2*(e-1)],o=ee(Xg(t),[n,e]),i=ee(Gb(t),[n,e]),a=vi(mt(o,[0,1],[n,e-2]),1),u=Y(vi(mt(i,[0,1],[n,e-2]),1),nt(-1)),l=Ln([o,a],1),c=Ln([i,u],1),h=ee(xl(l,c),[r[0],r[1]]);s=Yg(h)}if(s=Xg(s),t.rank===3&&t.shape[0]!==0){const r=s,o=t.shape[0];s=ee(s,[o,s.shape[0]/o,s.shape[1]]),r.dispose()}return s}const eE=Q({irfft_:uoe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function loe(t,e,n=0){const r={x:M(t,"x","split")},o={numOrSizeSplits:e,axis:n};return Z.runKernel(d0,r,o)}const io=Q({split_:loe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function coe(t,e){O(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const s=t.size/n;let r;if(e!=null&&e<n){const m=t.shape.map(x=>0),y=t.shape.map(x=>x);y[t.shape.length-1]=e,r=mt(t,m,y),n=e}else if(e!=null&&e>n){const m=t.shape.map(y=>y);m[t.shape.length-1]=e-n,r=Ln([t,Zn(m)],t.shape.length-1),n=e}else r=t;const o=Wt(r),i=ee(xl(r,o),[s,n]),a=sS(i),u=Math.floor(n/2)+1,l=Xg(a),c=Gb(a),h=io(l,[u,n-u],l.shape.length-1),d=io(c,[u,n-u],c.shape.length-1),f=r.shape.slice();return f[r.shape.length-1]=u,ee(xl(h[0],d[0]),f)}const rS=Q({rfft_:coe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hoe(t,e){let n=M(t,"a","squaredDifference"),s=M(e,"b","squaredDifference");[n,s]=Xn(n,s),ut(n.shape,s.shape);const r={a:n,b:s},o={};return Z.runKernel(wf,r,o)}const tE=Q({squaredDifference_:hoe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function doe(t,e){const n=M(t,"x","squeeze","string_or_numeric");return ee(n,Fl(n.shape,e).newShape)}const Yt=Q({squeeze_:doe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function poe(t,e=0){const n=zv(t,"tensors","stack","string_or_numeric");O(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&O(e<=n[0].rank,()=>"Axis must be <= rank of the tensor");const s=n,r={axis:e};return Z.runKernel(e0,s,r)}const ao=Q({stack_:poe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function foe(t,e=0){const s={x:M(t,"x","step")},r={alpha:e};return Z.runKernel(If,s,r)}const Tf=Q({step_:foe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function moe(t,e,n,s,r=0,o=0,i=0,a=0,u=0){const c={x:M(t,"x","stridedSlice","string_or_numeric")},h={begin:e,end:n,strides:s,beginMask:r,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};return Z.runKernel(Pb,c,h)}const QB=Q({stridedSlice_:moe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function goe(t){const n={x:M(t,"x","tan","float32")};return Z.runKernel(Sf,n)}const ZB=Q({tan_:goe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ls(t,e){Np(t);const n=Ll(t,e);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Ml(t,null,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mi(t,e,n){if(Np(t),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Ll(t,n);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Ml(t,e,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JB(t,e,n){if(Np(t),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=Ll(t,n);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Ml(t,e,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yoe(t,e,n){if(Np(t),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=Ll(t,n);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Ml(t,e,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xoe(t,e,n){if(Np(t),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=Ll(t,n);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Ml(t,e,s,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function voe(t,e,n){if(Np(t),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=Ll(t,n);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,Ml(t,e,s,n)}function eV(t,e,n){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${s}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(o+` update.rank < ${r}. `);if(t.length<s+(n.rank-r))throw new Error(o+` Output shape length < ${s+(n.rank-r)}`);if(n.rank!==r+t.length-s)throw new Error(o+` update.rank != ${r+t.length-s}`);for(let i=0;i<r;++i)if(n.shape[i]!==e.shape[i])throw new Error(o+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${e.shape[i]}).`);for(let i=0;i<n.rank-r;++i)if(n.shape[i+r]!==t[i+s])throw new Error(o+` updates.shape[${i+r}] (${n.shape[i+r]}) != shape[${i+r}] (${t[i+r]})`)}function nE(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}eV(n,e,t)}function Ra(t,e,n){const s=e.shape.length,r=s>1?e.shape[s-1]:1,o=n.length;let i=1;for(let h=r;h<o;++h)i*=n[h];const a=r<1?1:r,u=ie(e.shape)/a,l=[...et(n.slice(0,r)),1],c=ie(n);return{sliceRank:r,numUpdates:u,sliceSize:i,strides:l,outputSize:c}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function woe(t,e,n){const s=M(t,"tensor","tensorScatterupdate"),r=M(e,"indices","tensorScatterupdate","int32"),o=M(n,"updates","tensorScatterupdate");if(nE(o,r,s.shape),s.dtype!==o.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${s.dtype} and ${o.dtype}.`);const i={tensor:s,indices:r,updates:o},a={};return Z.runKernel(Nb,i,a)}const boe=Q({tensorScatterUpdate_:woe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Soe(t,e=1,n=!0){const s=M(t,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const o={x:s},i={k:e,sorted:n},[a,u]=Z.runKernel(Ob,o,i);return{values:a,indices:u}}const tV=Q({topk_:Soe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Coe(t,e=0,n=1,s,r){if(Oo(t),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new GT(e,n,s,!0,r),i=xt(t,s);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const sE=Q({truncatedNormal_:Coe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function koe(t,e=0){const n=M(t,"x","unique","string_or_numeric");O(n.rank>0,()=>"The input tensor must be at least 1D");const s={x:n},r={axis:e},[o,i]=Z.runKernel(yT,s,r);return{values:o,indices:i}}const nV=Q({unique_:koe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ioe(t,e,n){const s=M(t,"x","unsortedSegmentSum"),r=M(e,"segmentIds","unsortedSegmentSum","int32");O(ip(n),()=>"numSegments must be of dtype int");const o={x:s,segmentIds:r},i={numSegments:n};return Z.runKernel(m0,o,i)}const rE=Q({unsortedSegmentSum_:Ioe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $oe(t,e=0){const n=M(t,"x","unstack","string_or_numeric");O(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);const s={value:n},r={axis:e};return Z.runKernel(f0,s,r)}const wi=Q({unstack_:$oe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Noe(t,e){return FT(t,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sV(t,e=!0,n,s){return Z.makeVariable(t,e,n,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oE(t,e){const n=[];for(let o=0;o<e.length;o++)e[o]&&n.push(o);const s=xt(t,"int32"),r=xt([n.length,t.length],"int32");for(let o=0;o<n.length;o++){const i=s.indexToLoc(n[o]),a=o*t.length;r.values.set(i,a)}return r.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Toe(t){const e=M(t,"condition","whereAsync","bool"),n=await e.data(),s=oE(e.shape,n);return t!==e&&e.dispose(),s}const rV=Toe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Eoe(t,e,n){const s=M(t,"tensor","boolMask"),r=M(e,"mask","boolMask","bool"),o=n??0,i=r.rank,a=s.shape;O(i>0,()=>"mask cannot be scalar"),Br(a.slice(o,o+i),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let y=o;y<o+i;y++)u*=a[y];const l=a.slice(0,o).concat([u],a.slice(o+i)),c=ee(s,l),h=ee(r,[-1]),d=await rV(h),f=Yt(d,[1]),m=C0(c,f,o);return t!==s&&s.dispose(),e!==r&&r.dispose(),f.dispose(),c.dispose(),h.dispose(),d.dispose(),m}const Roe=Eoe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aoe(t,e,n){const s=M(t,"x","transpose");if(e==null&&(e=s.shape.map((i,a)=>a).reverse()),O(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(i=>{O(i>=0&&i<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const r={x:s},o={perm:e};return s.dtype==="complex64"?ae(()=>{let i=Xg(s),a=Gb(s);return i=Z.runKernel(Wc,{x:i},o),a=Z.runKernel(Wc,{x:a},o),n&&(a=$n(a)),xl(i,a)}):Z.runKernel(Wc,r,o)}const Vt=Q({transpose_:Aoe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _oe(t,e,n,s,r=!0){const o=M(t,"v","movingAverage"),i=M(e,"x","movingAverage"),a=M(n,"decay","movingAverage");bee(o,i),O(kt(o.shape,i.shape),()=>"Shape mismatch in v and x");const u=nt(1),l=Be(u,a);let c=Y(Be(i,o),l);if(r){O(s!=null,()=>"When using zeroDebias: true, step is required.");const h=M(s,"step","movingAverage");c=Ge(c,Be(u,Cl(a,h)))}return we(o,c)}const Doe=Q({movingAverage_:_oe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Poe(t,e,n){Oo(n);const s=M(t,"indices","scatterND","int32"),r=M(e,"updates","scatterND");nE(r,s,n);const o={indices:s,updates:r},i={shape:n};return Z.runKernel($b,o,i)}const Foe=Q({scatterND_:Poe});function Ooe(t,e,n,s){if(t.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const r=t.rank>0?t.shape[0]:1,o=t.rank>1?t.shape[1]:1;if(n.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${o}.`);const i=e.size;if(!(e.rank===0||e.rank===1&&i===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Loe(t,e,n,s=0){Oo(n);const r=M(t,"sparseIndices","sparseToDense","int32"),o=M(e,"sparseValues","sparseToDense","string_or_numeric"),i=M(s,"defaultValue","sparseToDense",o.dtype);Ooe(r,o,n,i);const a={sparseIndices:r,sparseValues:o,defaultValue:i},u={outputShape:n};return Z.runKernel(Ab,a,u)}const Moe=Q({sparseToDense_:Loe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zoe(t,e){const n=M(e,"indices","gatherND","int32"),r={params:M(t,"x","gatherND","string_or_numeric"),indices:n};return Z.runKernel(hb,r)}const Boe=Q({gatherND_:zoe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Voe(t,e){if(e==null)return t.shape.slice();if(kt(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let s=0;s<t.shape.length;s++)e[s]==null&&t.shape[s]!=null?n.push(t.shape[s]):n.push(e[s]);return n}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Woe(t,e,n,s){const r=M(t,"x","dropout");if(O(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),O(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return t instanceof en?r.clone():r;const o=Voe(r,n),i=1-e,a=Ge(S0(we(bh(o,0,1,"float32",s),i)),i);return Y(r,a)}const oV=Q({dropout_:Woe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iV(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function iE(t,e,n){const s=1-t%2,r=new Float32Array(t);for(let o=0;o<t;++o){const i=2*Math.PI*o/(t+s-1);r[o]=e-n*Math.cos(i)}return ls(r,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Uoe(t,e,n=1){const s=M(t,"predictions","inTopK"),r=M(e,"targets","inTopK");O(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),O(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),Br(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=s.shape[s.shape.length-1];O(n>0&&n<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${n}`);const i=await s.data(),a=await r.data(),[u,l]=[i.length/o,o],c=ws("bool",u);for(let h=0;h<u;h++){const d=h*l,f=i.subarray(d,d+l),m=[];for(let y=0;y<f.length;y++)m.push({value:f[y],index:y});m.sort((y,x)=>x.value-y.value),c[h]=0;for(let y=0;y<n;y++)if(m[y].index===a[h]){c[h]=1;break}}return t!==s&&s.dispose(),e!==r&&r.dispose(),Mi(c,r.shape,"bool")}const Goe=Uoe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hoe(t,e,n,s,r,o="NHWC",i){let a=t;t.rank===3&&(a=ee(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;u.rank===3&&(u=ee(e,[1,e.shape[0],e.shape[1],e.shape[2]])),O(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),O(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),O(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const l=o==="NHWC"?a.shape[3]:a.shape[1],c=o==="NHWC"?u.shape[3]:u.shape[1];O(l===n[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`),O(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),yr("conv2dDerFilter",r,i);const h={x:a,dy:u},d={strides:s,pad:r,dataFormat:o,dimRoundingMode:i,filterShape:n};return Z.runKernel(Yw,h,d)}const aE=Q({conv2DBackpropFilter_:Hoe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oS(t,e,n){if(n==null||n==="linear")return t;if(n==="relu")return Y(t,Tf(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function iS(t,e){let n=e;const s=bs(t.shape,e.shape);return s.length>0&&(n=Qe(n,s)),ee(n,t.shape)}function aS(t,e,n,s){if(e==="linear")return t;if(e==="relu")return Ea(t);if(e==="elu")return w0(t);if(e==="relu6")return jT(t);if(e==="prelu")return Zb(t,n);if(e==="leakyrelu")return Hb(t,s);if(e==="sigmoid")return Eo(t);throw new Error(`Unknown fused activation ${e}.`)}const uS=(t,e)=>!(t>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function joe({x:t,filter:e,strides:n,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(u=u||"linear",uS(Z.state.gradientDepth,u)===!1){O(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let T=bl(t,e,n,s,r,o,i);return a!=null&&(T=we(T,a)),aS(T,u,l,c)}const h=M(t,"x","conv2d","float32"),d=M(e,"filter","conv2d","float32");let f=h,m=!1;h.rank===3&&(m=!0,f=ee(h,[1,h.shape[0],h.shape[1],h.shape[2]])),O(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),O(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),yr("fused conv2d",s,i);const y=r==="NHWC"?f.shape[3]:f.shape[1];O(d.shape[2]===y,()=>`Error in conv2d: depth of input (${y}) must match input depth for filter ${d.shape[2]}.`),O(Ss(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);const x=bn(f.shape,d.shape,n,o,s,i);let v;a!=null&&(v=M(a,"bias","fused conv2d"),[v]=Xn(v,h),r==="NHWC"?ut(x.outShape,v.shape):(O(v.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${v.shape.length}.`),O(v.shape.length===0||v.shape[0]===x.outChannels||v.shape[0]===1,()=>`Error in fused conv2d: bias shape (${v.shape}) is not compatible with the number of output channels (${x.outChannels})`)));let w;if(l!=null){const T=l.shape;if(O(T.length<=1||T.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${T.length}.`),T.length===1)O(T[0]===1||T[0]===x.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${T}) is not compatible with the number of output channels (${x.outChannels}).`);else if(T.length===3)try{ut(T,x.outShape)}catch{const _=`Error in fused conv2d: PReLU activation weights (${T}) is not compatible with the output shape of the conv2d (${x.outShape}).`;throw Error(_)}w=M(l,"prelu weights","fused conv2d")}const S=(T,R)=>{O(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[_,D,L,V]=R,U=oS(T,L,u);O(wl(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const j=NT(D.shape,U,_,n,s),q=aE(D,U,_.shape,n,s),J=[j,q];if(V!=null){const te=iS(V,U);J.push(te)}return J},k={x:f,filter:d,bias:v,preluActivationWeights:w},I={strides:n,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return a==null?vu((R,_,D)=>{let L=Z.runKernel(Vg,k,I);return D([_,R,L]),m&&(L=ee(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:S}})(f,d):vu((R,_,D,L)=>{let V=Z.runKernel(Vg,k,I);return L([_,R,V,D]),m&&(V=ee(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:S}})(f,d,v)}const aV=Q({fusedConv2d_:joe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Koe(t,e,n,s,r,o=[1,1],i){let a=t;t.rank===3&&(a=ee(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u=e;u.rank===3&&(u=ee(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:a,dy:u},c={strides:s,pad:r,dimRoundingMode:i,dilations:o,filterShape:n};return Z.runKernel(sb,l,c)}const uV=Q({depthwiseConv2dNativeBackpropFilter_:Koe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xoe(t,e,n,s,r,o=[1,1],i){let a=e,u=!1;e.rank===3&&(u=!0,a=ee(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:a,filter:n},c={strides:s,pad:r,dimRoundingMode:i,dilations:o,inputShape:t},h=Z.runKernel(rb,l,c);return u?ee(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const lV=Q({depthwiseConv2dNativeBackpropInput_:Xoe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qoe({x:t,filter:e,strides:n,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:c}){if(uS(Z.state.gradientDepth,u)===!1){let I=v0(t,e,n,s,r,o,i);return a!=null&&(I=we(I,a)),aS(I,u,l,c)}const h=M(t,"x","depthwiseConv2d","float32"),d=M(e,"filter","depthwiseConv2d","float32");let f=h,m=!1;h.rank===3&&(m=!0,f=ee(h,[1,h.shape[0],h.shape[1],h.shape[2]])),O(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),O(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),O(f.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),o==null&&(o=[1,1]),O(Ss(n,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),yr("fused depthwiseConv2d",s,i);const y=bn(f.shape,d.shape,n,o,s,i,!0);let x;a!=null&&(x=M(a,"bias","fused conv2d"),[x]=Xn(x,h),ut(y.outShape,x.shape));let v;l!=null&&(v=M(l,"prelu weights","fused depthwiseConv2d"));const w=(I,T)=>{O(wl(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[R,_,D,L]=T,V=oS(I,D,u),U=lV(_.shape,V,R,n,s,o,i),j=uV(_,V,R.shape,n,s,o,i);if(L!=null){const q=iS(x,V);return[U,j,q]}return[U,j]},S={x:f,filter:d,bias:x,preluActivationWeights:v},k={strides:n,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i,activation:u,leakyreluAlpha:c};return a==null?vu((T,R,_)=>{let D=Z.runKernel(Wg,S,k);return _([R,T,D]),m&&(D=ee(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:w}})(f,d):vu((T,R,_,D)=>{let L=Z.runKernel(Wg,S,k);return D([R,T,L,_]),m&&(L=ee(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:w}})(f,d,x)}const Yoe=Q({fusedDepthwiseConv2d_:qoe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qoe({a:t,b:e,transposeA:n=!1,transposeB:s=!1,bias:r,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(uS(Z.state.gradientDepth,o)===!1){let V=Dt(t,e,n,s);return r!=null&&(V=we(V,r)),aS(V,o,i,a)}let u=M(t,"a","fused matMul"),l=M(e,"b","fused matMul");[u,l]=Xn(u,l);const c=n?u.shape[u.rank-2]:u.shape[u.rank-1],h=s?l.shape[l.rank-1]:l.shape[l.rank-2],d=n?u.shape[u.rank-1]:u.shape[u.rank-2],f=s?l.shape[l.rank-2]:l.shape[l.rank-1],m=u.shape.slice(0,-2),y=l.shape.slice(0,-2),x=ie(m),v=ie(y);O(c===h,()=>`Error in fused matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${n} and transposeB=${s} must match.`);const S=ut(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([d,f]),k=n?ee(u,[x,c,d]):ee(u,[x,d,c]),I=s?ee(l,[v,f,h]):ee(l,[v,h,f]);let T;r!=null&&(T=M(r,"bias","fused matMul"),[T]=Xn(T,u),ut(S,T.shape));let R;i!=null&&(R=M(i,"prelu weights","fused matMul"));const _=(V,U)=>{const[j,q,J,te]=U,le=oS(ee(V,J.shape),J,o);let K,re;if(!n&&!s?(K=Dt(le,q,!1,!0),re=Dt(j,le,!0,!1)):!n&&s?(K=Dt(le,q,!1,!1),re=Dt(le,j,!0,!1)):n&&!s?(K=Dt(q,le,!1,!0),re=Dt(j,le,!1,!1)):(K=Dt(q,le,!0,!0),re=Dt(le,j,!0,!0)),r!=null){const pe=iS(te,le);return[K,re,pe]}else return[K,re]},D={a:k,b:I,bias:T,preluActivationWeights:R},L={transposeA:n,transposeB:s,activation:o,leakyreluAlpha:a};return r==null?vu((U,j,q)=>{const J=Z.runKernel(Bg,D,L);return q([U,j,J]),{value:ee(J,S),gradFunc:_}})(k,I):vu((U,j,q,J)=>{const te=Z.runKernel(Bg,D,L);return J([U,j,te,q]),{value:ee(te,S),gradFunc:_}})(k,I,T)}const o$=Q({fusedMatMul_:Qoe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zoe=Object.freeze(Object.defineProperty({__proto__:null,conv2d:aV,depthwiseConv2d:Yoe,matMul:o$},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Joe(t){return iE(t,.54,.46)}const eie=Q({hammingWindow_:Joe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tie(t){return iE(t,.5,.5)}const cV=Q({hannWindow_:tie});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nie(t,e,n,s=!1,r=0){let o=0;const i=[];for(;o+e<=t.size;)i.push(mt(t,o,e)),o+=n;if(s)for(;o<t.size;){const a=o+e-t.size,u=Ln([mt(t,o,e-a),$f([a],r)]);i.push(u),o+=n}return i.length===0?mi([],[0,e]):ee(Ln(i),[i.length,e])}const hV=Q({frame_:nie});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sie(t,e,n,s,r=cV){s==null&&(s=iV(e));const o=hV(t,e,n),i=Y(o,r(e));return rS(i,s)}const rie=Q({stft_:sie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oie(t,e,n,s,r="bilinear",o=0){const i=M(t,"image","cropAndResize"),a=M(e,"boxes","cropAndResize","float32"),u=M(n,"boxInd","cropAndResize","int32"),l=a.shape[0];O(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),O(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${a.shape}.`),O(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${a.shape}.`),O(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),O(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),O(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const c={image:i,boxes:a,boxInd:u},h={method:r,extrapolationValue:o,cropSize:s};return Z.runKernel(eb,c,h)}const iie=Q({cropAndResize_:oie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aie(t){const e=M(t,"image","flipLeftRight","float32");O(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const n={image:e};return Z.runKernel(cb,n,{})}const uie=Q({flipLeftRight_:aie});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lie(t){const e=M(t,"image","grayscaleToRGB"),n=e.rank-1,s=e.shape[n];O(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),O(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,n),r[n]=3,li(e,r)}const cie=Q({grayscaleToRGB_:lie});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hie(t){const e=M(t,"image","RGBToGrayscale"),n=e.rank-1,s=e.shape[n];O(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),O(s===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=e.dtype,o=De(e,"float32"),i=ls([.2989,.587,.114]);let a;switch(e.rank){case 2:a=wd("ij,j->i",o,i);break;case 3:a=wd("ijk,k->ij",o,i);break;case 4:a=wd("ijkl,l->ijk",o,i);break;case 5:a=wd("ijklm,m->ijkl",o,i);break;case 6:a=wd("ijklmn,n->ijklm",o,i);break;default:throw new Error("Not a valid tensor rank.")}return a=us(a,-1),De(a,r)}const die=Q({rgbToGrayscale_:hie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pie(t,e,n=0,s=.5){const r=M(t,"image","rotateWithOffset","float32");O(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const o={image:r},i={radians:e,fillValue:n,center:s};return Z.runKernel(Mb,o,i)}const fie=Q({rotateWithOffset_:pie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ef(t,e,n,s,r,o){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),o==null&&(o=0);const i=t.shape[0];return n=Math.min(n,i),O(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),O(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),O(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),O(e.rank===1,()=>"scores must be a 1D tensor"),O(e.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`),O(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mie(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY){const o=M(t,"boxes","nonMaxSuppression","float32"),i=M(e,"scores","nonMaxSuppression","float32"),a=Ef(o,i,n,s,r);n=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const u={maxOutputSize:n,iouThreshold:s,scoreThreshold:r};return Z.runKernel(wb,{boxes:o,scores:i},u)}const gie=Q({nonMaxSuppression_:mie});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yie(t,e,n){const s=xie(t,e,n),r=s<0?-(s+1):s;t.splice(r,0,e)}function xie(t,e,n){return wie(t,e,n||vie)}function vie(t,e){return t>e?1:t<e?-1:0}function wie(t,e,n){let s=0,r=t.length,o=0,i=!1;for(;s<r;){o=s+(r-s>>>1);const a=n(e,t[o]);a>0?s=o+1:(r=o,i=!a)}return i?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lS(t,e,n,s,r){return lE(t,e,n,s,r,0)}function uE(t,e,n,s,r,o){return lE(t,e,n,s,r,0,!1,o,!0)}function cS(t,e,n,s,r,o){return lE(t,e,n,s,r,o,!0)}function lE(t,e,n,s,r,o,i=!1,a=!1,u=!1){const l=[];for(let x=0;x<e.length;x++)e[x]>r&&l.push({score:e[x],boxIndex:x,suppressBeginIndex:0});l.sort(c3);const c=o>0?-.5/o:0,h=[],d=[];for(;h.length<n&&l.length>0;){const x=l.pop(),{score:v,boxIndex:w,suppressBeginIndex:S}=x;if(v<r)break;let k=!1;for(let I=h.length-1;I>=S;--I){const T=bie(t,w,h[I]);if(T>=s){k=!0;break}if(x.score=x.score*Sie(s,c,T),x.score<=r)break}x.suppressBeginIndex=h.length,k||(x.score===v?(h.push(w),d.push(x.score)):x.score>r&&yie(l,x,c3))}const f=h.length,m=n-f;a&&m>0&&(h.push(...new Array(m).fill(0)),d.push(...new Array(m).fill(0)));const y={selectedIndices:h};return i&&(y.selectedScores=d),u&&(y.validOutputs=f),y}function bie(t,e,n){const s=t.subarray(e*4,e*4+4),r=t.subarray(n*4,n*4+4),o=Math.min(s[0],s[2]),i=Math.min(s[1],s[3]),a=Math.max(s[0],s[2]),u=Math.max(s[1],s[3]),l=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),f=(a-o)*(u-i),m=(h-l)*(d-c);if(f<=0||m<=0)return 0;const y=Math.max(o,l),x=Math.max(i,c),v=Math.min(a,h),w=Math.min(u,d),S=Math.max(v-y,0)*Math.max(w-x,0);return S/(f+m-S)}function Sie(t,e,n){const s=Math.exp(e*n*n);return n<=t?s:0}function c3(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Cie(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY){const o=M(t,"boxes","nonMaxSuppressionAsync"),i=M(e,"scores","nonMaxSuppressionAsync"),a=Ef(o,i,n,s,r);n=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const u=await Promise.all([o.data(),i.data()]),l=u[0],c=u[1],{selectedIndices:h}=lS(l,c,n,s,r);return o!==t&&o.dispose(),i!==e&&i.dispose(),ls(h,"int32")}const kie=Cie;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iie(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const i=M(t,"boxes","nonMaxSuppression"),a=M(e,"scores","nonMaxSuppression"),u=Ef(i,a,n,s,r,o);n=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,o=u.softNmsSigma;const l={boxes:i,scores:a},c={maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:o},h=Z.runKernel(bb,l,c);return{selectedIndices:h[0],selectedScores:h[1]}}const $ie=Q({nonMaxSuppressionWithScore_:Iie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Nie(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const i=M(t,"boxes","nonMaxSuppressionAsync"),a=M(e,"scores","nonMaxSuppressionAsync"),u=Ef(i,a,n,s,r,o);n=u.maxOutputSize,s=u.iouThreshold,r=u.scoreThreshold,o=u.softNmsSigma;const l=await Promise.all([i.data(),a.data()]),c=l[0],h=l[1],{selectedIndices:d,selectedScores:f}=cS(c,h,n,s,r,o);return i!==t&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:ls(d,"int32"),selectedScores:ls(f)}}const Tie=Nie;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eie(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){const i=M(t,"boxes","nonMaxSuppression"),a=M(e,"scores","nonMaxSuppression"),u=Ef(i,a,n,s,r,null),l=u.maxOutputSize,c=u.iouThreshold,h=u.scoreThreshold,d={boxes:i,scores:a},f={maxOutputSize:l,iouThreshold:c,scoreThreshold:h,padToMaxOutputSize:o},m=Z.runKernel(lT,d,f);return{selectedIndices:m[0],validOutputs:m[1]}}const Rie=Q({nonMaxSuppressionPadded_:Eie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Aie(t,e,n,s=.5,r=Number.NEGATIVE_INFINITY,o=!1){const i=M(t,"boxes","nonMaxSuppressionAsync"),a=M(e,"scores","nonMaxSuppressionAsync"),u=Ef(i,a,n,s,r,null),l=u.maxOutputSize,c=u.iouThreshold,h=u.scoreThreshold,[d,f]=await Promise.all([i.data(),a.data()]),{selectedIndices:m,validOutputs:y}=uE(d,f,l,c,h,o);return i!==t&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:ls(m,"int32"),validOutputs:nt(y,"int32")}}const _ie=Aie;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Die(t,e,n=!1,s=!1){const r=M(t,"images","resizeBilinear");O(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),O(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),O(s===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=r,i=!1;r.rank===3&&(i=!0,o=ee(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:o},u={alignCorners:n,halfPixelCenters:s,size:e},l=Z.runKernel(i0,a,u);return i?ee(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const dV=Q({resizeBilinear_:Die});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pie(t,e,n=!1,s=!1){const r=M(t,"images","resizeNearestNeighbor");O(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),O(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),O(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),O(s===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=r,i=!1;r.rank===3&&(i=!0,o=ee(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:o},u={alignCorners:n,halfPixelCenters:s,size:e},l=Z.runKernel(o0,a,u);return i?ee(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const pV=Q({resizeNearestNeighbor_:Pie});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fie(t,e="binary",n=!1,s=.5){const r=M(t,"image","threshold"),o=.2989,i=.587,a=.114,u=r.shape[0]*r.shape[1];let l=Y(ls([s]),255),c,h,d,f;if(O(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),O(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),O(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),O(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[c,h,d]=io(r,[1,1,1],-1);const x=Y(c,o),v=Y(h,i),w=Y(d,a);f=we(we(x,v),w)}else f=t;if(e==="otsu"){const x=wB(De(KT(f),"int32"),Mi([]),256);l=Oie(x,u)}const m=n?vh(f,l):mo(f,l);return De(Y(m,255),"int32")}function Oie(t,e){let n=ls([-1]),s=ls([0]),r=ls([0]),o,i,a,u,l,c;for(let h=0;h<t.size-1;h++){o=mt(t,0,h+1),i=mt(t,h+1),l=Ge(Qe(o),e),c=Ge(Qe(i),e);const d=Qe(Y(o,hp(0,o.size)));a=Ge(d,Qe(o));const f=$f(i.shape,o.size),m=we(hp(0,i.size),f),y=Y(i,m);u=Ge(Qe(y),Qe(i));const x=Be(a,u),v=Be(a,u),w=Y(l,c);r=Y(Y(w,x),v);const S=mo(r,s);s=Ys(S,r,s),n=Ys(S,ls([h]),n)}return n}const Lie=Q({threshold_:Fie});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mie(t,e,n="nearest",s="constant",r=0,o){const i=M(t,"image","transform","float32"),a=M(e,"transforms","transform","float32");O(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),O(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),O(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const u={image:i,transforms:a},l={interpolation:n,fillMode:s,fillValue:r,outputShape:o};return Z.runKernel(Lb,u,l)}const zie=Q({transform_:Mie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bie(t,e,n){const s=M(t,"a","bandPart");O(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[o,i]=s.shape.slice(-2);let a,u;typeof e=="number"?(O(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),O(e<=o,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`),a=M(e<0?o:e,"numLower","bandPart")):(O(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=Ys(Kg(e,0),o,kl(e,o))),typeof n=="number"?(O(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),O(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),u=M(n<0?i:n,"numUpper","bandPart")):(O(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=Ys(Kg(n,0),i,kl(n,i)));const l=ee(hp(0,o,1,"int32"),[-1,1]),c=hp(0,i,1,"int32"),h=Be(l,c),d=Ca(vh(h,a),Bl(h,$n(u))),f=Zn([o,i],s.dtype);return ee(ao(wi(ee(s,[-1,o,i])).map(m=>Ys(d,m,f))),r)}const Vie=Q({bandPart_:Bie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wie(t){let e;if(Array.isArray(t)){e=!1,O(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=t[0].shape[0];for(let o=1;o<t.length;++o)O(t[o].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[o].shape[0]} vs. ${r})`)}else e=!0,t=io(t,t.shape[0],0).map(r=>Yt(r,[0]));O(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],s=t;for(let r=0;r<t.length;++r)n.push(Z.tidy(()=>{let o=s[r];if(r>0)for(let i=0;i<r;++i){const a=Y(Qe(Y(n[i],o)),n[i]);o=Be(o,a)}return Ge(o,b0(o,"euclidean"))}));return e?ao(n,0):n}const Uie=Q({gramSchmidt_:Wie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gie(t,e=!1){if(O(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return h3(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((u,l)=>u*l),s=wi(ee(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),r=[],o=[];s.forEach(u=>{const[l,c]=h3(u,e);r.push(l),o.push(c)});const i=ee(ao(r,0),t.shape),a=ee(ao(o,0),t.shape);return[i,a]}}function h3(t,e=!1){return Z.tidy(()=>{O(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],s=t.shape[1];let r=_T(n),o=au(t);const i=mi([[1]],[1,1]);let a=au(i);const u=n>=s?s:n;for(let l=0;l<u;++l){const c=o,h=a,d=r;[a,o,r]=Z.tidy(()=>{const f=mt(o,[l,l],[n-l,1]),m=b0(f),y=mt(o,[l,l],[1,1]),x=Ys(mo(y,0),mi([[-1]]),mi([[1]])),v=Be(y,Y(x,m)),w=Ge(f,v);w.shape[0]===1?a=au(i):a=Ln([i,mt(w,[1,0],[w.shape[0]-1,w.shape[1]])],0);const S=$n(Ge(Dt(x,v),m)),k=mt(o,[l,0],[n-l,s]),I=Y(S,a),T=Vt(a);if(l===0)o=Be(k,Dt(I,Dt(T,k)));else{const D=Be(k,Dt(I,Dt(T,k)));o=Ln([mt(o,[0,0],[l,s]),D],0)}const R=Vt(I),_=mt(r,[0,l],[n,r.shape[1]-l]);if(l===0)r=Be(_,Dt(Dt(_,a),R));else{const D=Be(_,Dt(Dt(_,a),R));r=Ln([mt(r,[0,0],[n,l]),D],1)}return[a,o,r]}),ot([c,h,d])}return!e&&n>s&&(r=mt(r,[0,0],[n,s]),o=mt(o,[0,0],[s,s])),[r,o]})}const Hie=Q({qr_:Gie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ar;(function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Ar||(Ar={}));function jie(t,e,n=Ar.SUM_BY_NONZERO_WEIGHTS){const s=M(t,"losses","computeWeightedLoss");let r=null;e!=null&&(r=M(e,"weights","computeWeightedLoss"));const o=r==null?s:Y(s,r);if(n===Ar.NONE)return o;if(n===Ar.SUM)return Qe(o);if(n===Ar.MEAN){if(r==null)return Un(o);{const i=s.size/r.size,a=Ge(Qe(o),Qe(r));return i>1?Ge(a,nt(i)):a}}if(n===Ar.SUM_BY_NONZERO_WEIGHTS){if(r==null)return Ge(Qe(o),nt(s.size));{const i=Y(r,no(s.shape)),a=De(Qe(cp(i,nt(0))),"float32");return Ge(Qe(o),a)}}throw Error(`Unknown reduction: ${n}`)}const Cu=Q({computeWeightedLoss_:jie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kie(t,e,n,s=Ar.SUM_BY_NONZERO_WEIGHTS){const r=M(t,"labels","absoluteDifference"),o=M(e,"predictions","absoluteDifference");let i=null;n!=null&&(i=M(n,"weights","absoluteDifference")),Br(r.shape,o.shape,"Error in absoluteDifference: ");const a=ps(Be(r,o));return Cu(a,i,s)}const Xie=Q({absoluteDifference_:Kie});function qie(t,e,n,s,r=Ar.SUM_BY_NONZERO_WEIGHTS){const o=M(t,"labels","cosineDistance"),i=M(e,"predictions","cosineDistance");let a=null;s!=null&&(a=M(s,"weights","cosineDistance")),Br(o.shape,i.shape,"Error in cosineDistance: ");const u=nt(1),l=Be(u,Qe(Y(o,i),n,!0));return Cu(l,a,r)}const Yie=Q({cosineDistance_:qie});function Qie(t,e,n,s=Ar.SUM_BY_NONZERO_WEIGHTS){let r=M(t,"labels","hingeLoss");const o=M(e,"predictions","hingeLoss");let i=null;n!=null&&(i=M(n,"weights","hingeLoss")),Br(r.shape,o.shape,"Error in hingeLoss: ");const a=nt(1);r=Be(Y(nt(2),r),a);const u=Ea(Be(a,Y(r,o)));return Cu(u,i,s)}const Zie=Q({hingeLoss_:Qie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jie(t,e,n,s=1,r=Ar.SUM_BY_NONZERO_WEIGHTS){const o=M(t,"labels","huberLoss"),i=M(e,"predictions","huberLoss");let a=null;n!=null&&(a=M(n,"weights","huberLoss")),Br(o.shape,i.shape,"Error in huberLoss: ");const u=nt(s),l=ps(Be(i,o)),c=kl(l,u),h=Be(l,c),d=we(Y(nt(.5),an(c)),Y(u,h));return Cu(d,a,r)}const eae=Q({huberLoss_:Jie});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tae(t,e,n,s=1e-7,r=Ar.SUM_BY_NONZERO_WEIGHTS){const o=M(t,"labels","logLoss"),i=M(e,"predictions","logLoss");let a=null;n!=null&&(a=M(n,"weights","logLoss")),Br(o.shape,i.shape,"Error in logLoss: ");const u=nt(1),l=nt(s),c=$n(Y(o,Ao(we(i,l)))),h=Y(Be(u,o),Ao(we(Be(u,i),l))),d=Be(c,h);return Cu(d,a,r)}const nae=Q({logLoss_:tae});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sae(t,e,n,s=Ar.SUM_BY_NONZERO_WEIGHTS){const r=M(t,"labels","meanSquaredError"),o=M(e,"predictions","meanSquaredError");let i=null;n!=null&&(i=M(n,"weights","meanSquaredError")),Br(r.shape,o.shape,"Error in meanSquaredError: ");const a=tE(r,o);return Cu(a,i,s)}const rae=Q({meanSquaredError_:sae});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oae(t,e){const n=M(t,"labels","sigmoidCrossEntropyWithLogits"),s=M(e,"logits","sigmoidCrossEntropyWithLogits");Br(n.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=Ea(s),o=Y(s,n),i=jb(mr($n(ps(s))));return we(Be(r,o),i)}function iae(t,e,n,s=0,r=Ar.SUM_BY_NONZERO_WEIGHTS){let o=M(t,"multiClassLabels","sigmoidCrossEntropy");const i=M(e,"logits","sigmoidCrossEntropy");let a=null;if(n!=null&&(a=M(n,"weights","sigmoidCrossEntropy")),Br(o.shape,i.shape,"Error in sigmoidCrossEntropy: "),s>0){const l=nt(s),c=nt(1),h=nt(.5);o=we(Y(o,Be(c,l)),Y(h,l))}const u=oae(o,i);return Cu(u,a,r)}const aae=Q({sigmoidCrossEntropy_:iae});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uae(t,e,n=-1){if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return vu((r,o,i)=>{const u=Kb(o,[n],!0),l=Be(De(o,"float32"),u);i([r,l]);const c=$n(Y(l,r));return{value:Qe(c,[n]),gradFunc:(f,m)=>{const[y,x]=m,v=qn(f.shape,[n]);return[Y(ee(f,v),Be(De(y,"float32"),mr(x))),Y(ee(f,v),Be(mr(x),De(y,"float32")))]}}})(t,e)}function lae(t,e,n,s=0,r=Ar.SUM_BY_NONZERO_WEIGHTS){let o=M(t,"onehotLabels","softmaxCrossEntropy");const i=M(e,"logits","softmaxCrossEntropy");let a=null;if(n!=null&&(a=M(n,"weights","softmaxCrossEntropy")),Br(o.shape,i.shape,"Error in softmaxCrossEntropy: "),s>0){const l=nt(s),c=nt(1),h=nt(o.shape[1]);o=we(Y(o,Be(c,l)),Ge(l,h))}const u=uae(o,i);return Cu(u,a,r)}const cae=Q({softmaxCrossEntropy_:lae});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hae(t,e,n,s){const r=M(t,"indices","sparseFillEmptyRows","int32"),o=M(e,"values","sparseFillEmptyRows"),i=M(n,"denseShape","sparseFillEmptyRows","int32"),a=M(s,"defaultValue","sparseFillEmptyRows",o.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const u={indices:r,values:o,denseShape:i,defaultValue:a},l=Z.runKernel(pT,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}const dae=Q({sparseFillEmptyRows_:hae});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pae(t,e,n){const s=M(t,"inputIndices","sparseReshape","int32"),r=M(e,"inputShape","sparseReshape","int32"),o=M(n,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const i={inputIndices:s,inputShape:r,newShape:o},a=Z.runKernel(fT,i);return{outputIndices:a[0],outputShape:a[1]}}const fae=Q({sparseReshape_:pae});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mae(t,e,n){const s=M(t,"data","sparseSegmentMean"),r=M(e,"indices","sparseSegmentMean","int32"),o=M(n,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const i={data:s,indices:r,segmentIds:o};return Z.runKernel(Eb,i)}const gae=Q({sparseSegmentMean_:mae});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yae(t,e,n){const s=M(t,"data","sparseSegmentSum"),r=M(e,"indices","sparseSegmentSum","int32"),o=M(n,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const i={data:s,indices:r,segmentIds:o};return Z.runKernel(Rb,i)}const xae=Q({sparseSegmentSum_:yae});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vae(t,e,n,s,r,o,i,a){const u=M(t,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const l=M(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:s,leftPad:r,rightPad:o,padWidth:i,preserveShortSequences:a},h={data:u,dataSplits:l},d=Z.runKernel(Fb,h,c);return{nGrams:d[0],nGramsSplits:d[1]}}const wae=Q({stringNGrams_:vae});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bae(t,e,n=!0){const s=M(t,"input","stringSplit","string"),r=M(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const o={skipEmpty:n},i={input:s,delimiter:r},a=Z.runKernel(mT,i,o);return{indices:a[0],values:a[1],shape:a[2]}}const Sae=Q({stringSplit_:bae});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cae(t,e){const n=M(t,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:n};return Z.runKernel(gT,r,s)}const kae=Q({stringToHashBucketFast_:Cae});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iae(t,e,n,s=!0){const r=M(t,"input","staticRegexReplace","string"),o={pattern:e,rewrite:n,replaceGlobal:s};return Z.runKernel(Db,{x:r},o)}const $ae=Q({staticRegexReplace_:Iae});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nae={fft:sS,ifft:Yg,rfft:rS,irfft:eE},Tae={hammingWindow:eie,hannWindow:cV,frame:hV,stft:rie},Xs={flipLeftRight:uie,grayscaleToRGB:cie,resizeNearestNeighbor:pV,resizeBilinear:dV,rgbToGrayscale:die,rotateWithOffset:fie,cropAndResize:iie,nonMaxSuppression:gie,nonMaxSuppressionAsync:kie,nonMaxSuppressionWithScore:$ie,nonMaxSuppressionWithScoreAsync:Tie,nonMaxSuppressionPadded:Rie,nonMaxSuppressionPaddedAsync:_ie,threshold:Lie,transform:zie},fV={bandPart:Vie,gramSchmidt:Uie,qr:Hie},Eae={absoluteDifference:Xie,computeWeightedLoss:Cu,cosineDistance:Yie,hingeLoss:Zie,huberLoss:eae,logLoss:nae,meanSquaredError:rae,sigmoidCrossEntropy:aae,softmaxCrossEntropy:cae},Rae={sparseFillEmptyRows:dae,sparseReshape:fae,sparseSegmentMean:gae,sparseSegmentSum:xae},Aae={stringNGrams:wae,stringSplit:Sae,stringToHashBucketFast:kae,staticRegexReplace:$ae};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ae=new Map,Dae=new Map;class Rf{getClassName(){return this.constructor.className}static fromConfig(e,n){return new e(n)}}class ri{constructor(){this.classNameMap={}}static getMap(){return ri.instance==null&&(ri.instance=new ri),ri.instance}static register(e){ri.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function $e(t,e,n){O(t.className!=null,()=>"Class being registered does not have the static className property defined."),O(typeof t.className=="string",()=>"className is required to be a string, but got type "+typeof t.className),O(t.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof n>"u"&&(n=t.className);const s=n,r=e+">"+s;return ri.register(t),_ae.set(r,t),Dae.set(t,r),t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vl extends Rf{minimize(e,n=!1,s){const{value:r,grads:o}=this.computeGradients(e,s);if(s!=null){const i=s.map(a=>({name:a.name,tensor:o[a.name]}));this.applyGradients(i)}else this.applyGradients(o);return ot(o),n?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,n){return ose(e,n)}dispose(){this.iterations_!=null&&ot(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:nt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Vl,Symbol.hasInstance,{value:t=>t.minimize!=null&&t.computeGradients!=null&&t.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mV extends Vl{static get className(){return"Adadelta"}constructor(e,n,s=null){super(),this.learningRate=e,this.rho=n,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=Z.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=Z.registeredVariables[s],i=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:ae(()=>Wt(o).variable(i))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:ae(()=>Wt(o).variable(i))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const u=this.accumulatedGrads[r].variable,l=this.accumulatedUpdates[r].variable;ae(()=>{const c=we(Y(u,this.rho),Y(an(a),1-this.rho)),h=Y(Ge(Zs(we(l,this.epsilon)),Zs(we(u,this.epsilon))),a),d=we(Y(l,this.rho),Y(an(h),1-this.rho));u.assign(c),l.assign(d);const f=we(Y(h,-this.learningRate),o);o.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(ot(this.accumulatedGrads.map(e=>e.variable)),ot(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.rho,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gV extends Vl{static get className(){return"Adagrad"}constructor(e,n=.1){super(),this.learningRate=e,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=Z.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:ae(()=>$f(o.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const a=this.accumulatedGrads[r].variable;ae(()=>{const u=we(a,an(i));a.assign(u);const l=we(Y(Ge(i,Zs(we(u,Z.backend.epsilon()))),-this.learningRate),o);o.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&ot(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,n){return new e(n.learningRate,n.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yV extends Vl{static get className(){return"Adam"}constructor(e,n,s,r=null){super(),this.learningRate=e,this.beta1=n,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ae(()=>{this.accBeta1=nt(n).variable(),this.accBeta2=nt(s).variable()}),r==null&&(this.epsilon=Z.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);ae(()=>{const s=Be(1,this.accBeta1),r=Be(1,this.accBeta2);n.forEach((o,i)=>{const a=Z.registeredVariables[o],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:ae(()=>Wt(a).variable(u))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${o}/v`,variable:ae(()=>Wt(a).variable(u))});const l=Array.isArray(e)?e[i].tensor:e[o];if(l==null)return;const c=this.accumulatedFirstMoment[i].variable,h=this.accumulatedSecondMoment[i].variable,d=we(Y(c,this.beta1),Y(l,1-this.beta1)),f=we(Y(h,this.beta2),Y(an(l),1-this.beta2)),m=Ge(d,s),y=Ge(f,r);c.assign(d),h.assign(f);const x=we(Y(Ge(m,we(Zs(y),this.epsilon)),-this.learningRate),a);a.assign(x)}),this.accBeta1.assign(Y(this.accBeta1,this.beta1)),this.accBeta2.assign(Y(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&ot(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&ot(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e),ae(()=>{this.accBeta1.assign(Cl(this.beta1,this.iterations_+1)),this.accBeta2.assign(Cl(this.beta2,this.iterations_+1))});const n=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xV extends Vl{static get className(){return"Adamax"}constructor(e,n,s,r=null,o=0){super(),this.learningRate=e,this.beta1=n,this.beta2=s,this.epsilon=r,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ae(()=>{this.iteration=nt(0).variable(),this.accBeta1=nt(n).variable()}),r==null&&(this.epsilon=Z.backend.epsilon())}applyGradients(e){const n=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);ae(()=>{const s=Be(1,this.accBeta1),r=Ge(-this.learningRate,we(Y(this.iteration,this.decay),1));n.forEach((o,i)=>{const a=Z.registeredVariables[o],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:Wt(a).variable(u)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${o}/v`,variable:Wt(a).variable(u)});const l=Array.isArray(e)?e[i].tensor:e[o];if(l==null)return;const c=this.accumulatedFirstMoment[i].variable,h=this.accumulatedWeightedInfNorm[i].variable,d=we(Y(c,this.beta1),Y(l,1-this.beta1)),f=Y(h,this.beta2),m=ps(l),y=Su(f,m);c.assign(d),h.assign(y);const x=we(Y(Ge(r,s),Ge(d,we(y,this.epsilon))),a);a.assign(x)}),this.iteration.assign(we(this.iteration,1)),this.accBeta1.assign(Y(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&ot(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&ot(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cE extends Vl{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const i=Z.registeredVariables[s];ae(()=>{const a=we(Y(this.c,o),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Rs(nt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,n){return new e(n.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vV extends cE{static get className(){return"Momentum"}constructor(e,n,s=!1){super(e),this.learningRate=e,this.momentum=n,this.useNesterov=s,this.accumulations=[],this.m=nt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=Z.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:ae(()=>Wt(o).variable(!1))});const i=this.accumulations[r].variable,a=Array.isArray(e)?e[r].tensor:e[s];a!=null&&ae(()=>{let u;const l=we(Y(this.m,i),a);this.useNesterov?u=we(Y(this.c,we(a,Y(l,this.m))),o):u=we(Y(this.c,l),o),i.assign(l),o.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&ot(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,n){return new e(n.learningRate,n.momentum,n.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wV extends Vl{static get className(){return"RMSProp"}constructor(e,n=.9,s=0,r=null,o=!1){if(super(),this.learningRate=e,this.decay=n,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,r==null&&(this.epsilon=Z.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const o=Z.registeredVariables[s],i=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:ae(()=>Wt(o).variable(i))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:ae(()=>Wt(o).variable(i))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:ae(()=>Wt(o).variable(i))});const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const u=this.accumulatedMeanSquares[r].variable,l=this.accumulatedMoments[r].variable;ae(()=>{const c=we(Y(u,this.decay),Y(an(a),1-this.decay));if(this.centered){const h=this.accumulatedMeanGrads[r].variable,d=we(Y(h,this.decay),Y(a,1-this.decay)),f=Ge(Y(a,this.learningRate),Zs(Be(c,we(an(d),this.epsilon)))),m=we(Y(l,this.momentum),f);u.assign(c),h.assign(d),l.assign(m);const y=Be(o,m);o.assign(y)}else{const h=we(Y(u,this.decay),Y(an(a),1-this.decay)),d=we(Y(l,this.momentum),Ge(Y(a,this.learningRate),Zs(we(h,this.epsilon))));u.assign(h),l.assign(d);const f=Be(o,d);o.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&ot(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&ot(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&ot(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);const n=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(n*2,n*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,n){return new e(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pae=[mV,gV,yV,xV,vV,wV,cE];function Fae(){for(const t of Pae)$e(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oae="model",Lae=".json",Mae=".weights.bin";function d3(t){return new Promise(e=>setTimeout(e)).then(t)}class ih{constructor(e){if(!ce().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(ih.URL_SCHEME)&&(e=e.slice(ih.URL_SCHEME.length)),(e==null||e.length===0)&&(e=Oae),this.modelJsonFileName=e+Lae,this.weightDataFileName=e+Mae}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=Yi.join(e.weightData),s=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o=Qz(e,r),i=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=i,await d3(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=s,await d3(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:y0(e)}}}}ih.URL_SCHEME="downloads://";class zae{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,n)=>{const s=new FileReader;s.onload=r=>{const o=JSON.parse(r.target.result),i=o.modelTopology;if(i==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(o.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}const u=ST(o,l=>this.loadWeights(l));e(u)},s.onerror=r=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const n=[],s=[];for(const i of e)n.push(...i.weights),s.push(...i.paths);const r=this.checkManifestAndWeightFiles(e),o=s.map(i=>this.loadWeightsFile(i,r[i]));return Promise.all(o).then(i=>[n,i])}loadWeightsFile(e,n){return new Promise((s,r)=>{const o=new FileReader;o.onload=i=>{const a=i.target.result;s(a)},o.onerror=i=>r(`Failed to weights data from file of path '${e}'.`),o.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(e){const n=[],s=this.weightsFiles.map(o=>l3(o.name)),r={};for(const o of e)o.paths.forEach(i=>{const a=l3(i);if(n.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(n.push(a),s.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);r[i]=this.weightsFiles[s.indexOf(a)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const Bae=t=>ce().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(ih.URL_SCHEME)?Vae(t.slice(ih.URL_SCHEME.length)):null;Pn.registerSaveRouter(Bae);function Vae(t="model"){return new ih(t)}function Wae(t){return new zae(t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p3(t,e,n,s){i(t),n=n??0,s=s??1,a(n,s);let r=0;const o=u=>(u.then(l=>{const c=n+ ++r/t.length*(s-n);return e(c),l}),u);function i(u){O(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function a(u,l){O(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),O(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),O(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(t.map(o))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function bV(t,e){e==null&&(e={});const n=e.fetchFunc==null?ce().platform.fetch:e.fetchFunc,s=t.map(h=>n(h,e.requestInit,{isBinary:!0})),r=0,o=.5,a=(e.onProgress==null?await Promise.all(s):await p3(s,e.onProgress,r,o)).map(h=>h.arrayBuffer()),u=.5,l=1;return e.onProgress==null?await Promise.all(a):await p3(a,e.onProgress,u,l)}function Uae(t,e){var n;const s=e.fetchFunc==null?ce().platform.fetch:e.fetchFunc;let r=0,o;return(n=e.onProgress)===null||n===void 0||n.call(e,0),new ReadableStream({pull:async i=>{for(var a;r<t.length;){o||(o=(await s(t[r],e.requestInit,{isBinary:!0})).body.getReader());const{done:u,value:l}=await o.read();if(u){r++,o=void 0,(a=e.onProgress)===null||a===void 0||a.call(e,r/t.length);continue}i.enqueue(l);return}i.close()}})}async function Gae(t,e="",n,s){return SV(i=>bV(i,{requestInit:s}))(t,e,n)}function SV(t){return async(e,n="",s)=>{const r=e.map(()=>!1),o={},i=s!=null?s.map(()=>!1):[],a=[];if(e.forEach((f,m)=>{let y=0;f.weights.forEach(x=>{const v="quantization"in x?x.quantization.dtype:x.dtype,w=eh[v]*ie(x.shape),S=()=>{r[m]=!0,o[m]==null&&(o[m]=[]),o[m].push({manifestEntry:x,groupOffset:y,sizeBytes:w})};s!=null?s.forEach((k,I)=>{k===x.name&&(S(),i[I]=!0)}):S(),a.push(x.name),y+=w})}),!i.every(f=>f)){const f=s.filter((m,y)=>!i[y]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const u=r.reduce((f,m,y)=>(m&&f.push(y),f),[]),l=[];u.forEach(f=>{e[f].paths.forEach(m=>{const y=n+(n.endsWith("/")?"":"/")+m;l.push(y)})});const c=await t(l),h={};let d=0;return u.forEach(f=>{const m=e[f].paths.length,y=new Yi(c.slice(d,d+m));o[f].forEach(v=>{const w=y.slice(v.groupOffset,v.groupOffset+v.sizeBytes),S=Kz(w,[v.manifestEntry]);for(const k in S)h[k]=S[k]}),d+=m}),h}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hae="application/octet-stream",jae="application/json";class hE{constructor(e,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(O(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=ce().platform.fetch,O(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&O(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{},this.loadOptions=n}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=Qz(e,s);if(n.body.append("model.json",new Blob([JSON.stringify(r)],{type:jae}),"model.json"),e.weightData!=null){const i=Yi.join(e.weightData);n.body.append("model.weights.bin",new Blob([i],{type:Hae}),"model.weights.bin")}const o=await this.fetch(this.path,n);if(o.ok)return{modelArtifactsInfo:y0(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await e.json()}catch{let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}const s=n.modelTopology,r=n.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return n}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return ST(e,n=>this.loadWeights(n))}async loadStream(){const e=await this.loadModelJSON(),n=await this.getWeightUrls(e.weightsManifest),s=JI(e.weightsManifest),r=()=>Uae(n,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:s,getWeightStream:r})}async getWeightUrls(e){const n=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=Kae(n),o=this.weightPathPrefix||s,i=[],a=[];for(const u of e)for(const l of u.paths)this.weightUrlConverter!=null?a.push(this.weightUrlConverter(l)):i.push(o+l+r);return this.weightUrlConverter&&i.push(...await Promise.all(a)),i}async loadWeights(e){const n=await this.getWeightUrls(e),s=JI(e),r=await bV(n,this.loadOptions);return[s,r]}}hE.URL_SCHEME_REGEX=/^https?:\/\//;function Kae(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),s=t.substring(0,e),r=n>e?t.substring(n):"";return[s+"/",r]}function i$(t){return t.match(hE.URL_SCHEME_REGEX)!=null}const CV=(t,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let n=!0;if(Array.isArray(t)?n=t.every(s=>i$(s)):n=i$(t),n)return dE(t,e)}return null};Pn.registerSaveRouter(CV);Pn.registerLoadRouter(CV);function dE(t,e){return new hE(t,e)}function Xae(t,e){return dE(t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sk{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class kV{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class qae{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=n=>Promise.resolve(e.save(n)))}}function Yae(t,e,n,s){const r=arguments;return new qae(IV(...r))}function IV(t,e,n,s){return arguments.length===1?t.modelTopology!=null||t.weightSpecs!=null?new sk(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new sk({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new sk({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:s}))}function Qae(t){return new kV(t)}function Zae(t){return new kV(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $V=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Yi,browserFiles:Wae,browserHTTPRequest:Xae,concatenateArrayBuffers:Yz,copyModel:ete,decodeWeights:Kz,decodeWeightsStream:qz,encodeWeights:ZI,fromMemory:Yae,fromMemorySync:IV,getLoadHandlers:Bee,getModelArtifactsForJSON:ST,getModelArtifactsForJSONSync:Zz,getModelArtifactsInfoForJSON:y0,getSaveHandlers:Jz,getWeightSpecs:JI,http:dE,isHTTPScheme:i$,listModels:Zee,loadWeights:Gae,moveModel:tte,registerLoadRouter:zee,registerSaveRouter:Mee,removeModel:Jee,weightsLoaderFactory:SV,withSaveHandler:Qae,withSaveHandlerSync:Zae},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fc,f3=!1;function Jae(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(t==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,s=!1,r=!1,o=!1,i=!1,a=!1;if(t.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)o=!0;else if(t.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&t instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);if(Ov(Pv,Z.backendName)!=null){const m={pixels:t},y={numChannels:e};return Z.runKernel(Pv,m,y)}const[l,c]=r?[t.videoWidth,t.videoHeight]:[t.width,t.height];let h;if(i)h=t.getContext("2d").getImageData(0,0,l,c).data;else if(s||n)h=t.data;else if(o||r||a){if(fc==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")fc=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else fc=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});fc.canvas.width=l,fc.canvas.height=c,fc.drawImage(t,0,0,l,c),h=fc.getImageData(0,0,l,c).data}let d;if(e===4)d=new Int32Array(h);else{const m=l*c;d=new Int32Array(m*e);for(let y=0;y<m;y++)for(let x=0;x<e;++x)d[y*e+x]=h[y*4+x]}return JB(d,[c,l,e],"int32")}function eue(t){if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);const e=t.rank===2?1:t.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`)}async function pE(t,e){let n=M(t,"img","toPixels");if(!(t instanceof en)){const l=n;n=De(l,"int32"),l.dispose()}eue(n);const[s,r]=n.shape.slice(0,2),o=n.rank===2?1:n.shape[2],i=await n.data(),a=n.dtype==="float32"?255:1,u=new Uint8ClampedArray(r*s*4);for(let l=0;l<s*r;++l){const c=[0,0,0,255];for(let d=0;d<o;d++){const f=i[l*o+d];if(n.dtype==="float32"){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if(n.dtype==="int32"&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);o===1?(c[0]=f*a,c[1]=f*a,c[2]=f*a):c[d]=f*a}const h=l*4;u[h+0]=Math.round(c[0]),u[h+1]=Math.round(c[1]),u[h+2]=Math.round(c[2]),u[h+3]=Math.round(c[3])}if(e!=null){f3||Ov(uT,Z.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),f3=!0),e.width=r,e.height=s;const l=e.getContext("2d"),c=new ImageData(u,r,s);l.putImageData(c,0,0)}return n!==t&&n.dispose(),u}const NV=Q({fromPixels_:Jae});function hS(t,e){const n=t.shape.length,s=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${n}`);if(ie(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const r=e.shape,o=r[r.length-1];let i=1;for(let h=0;h<r.length-1;++h)i*=r[h];const a=t.shape,u=r.slice();u.pop();let l=1;for(let h=o;h<n;++h)l*=a[h],u.push(a[h]);const c=[...et(t.shape).map(h=>h/l),1].slice(0,o);return[u,i,l,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a$=-2,tue=-1;function dS(t,e,n){const s=t.shape.length;O(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),O(s===n.length,()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)O(e[r]+n[r]<=t.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+n[r]}) would overflow input.shape[${r}] (${t.shape[r]})`)}function nue(t){const e=[];let n=0;for(;t>0;)t&1&&e.push(n),t/=2,n++;return e}function pS(t,e,n){const s=[];for(let r=0;r<t.length;r++)s[r]=Math.ceil((e[r]-t[r])/n[r]);return s}function TV(t,e,n,s){const r=[...t];for(let o=r.length;o<s.length;o++)r.push(1);for(let o=0;o<n;o++)o===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function EV(t,e,n){return n<=t?n:n-(e-1)}function RV(t,e){const n=[];for(let s=0;s<t;s++)n.push(e+s);return n}function sue(t,e,n,s,r,o,i,a,u){const l=t.length;let c=new Array(l),h=new Array(l),d=new Array(l);if(e.length&&n>0){const f=e[0],m=n+1;c=AV(i,f,m,s,t),h=_V(a,f,m,r,t),d=TV(o,f,m,t)}else for(let f=0;f<l;f++)c[f]=PV(i,s,o,t,f,u),h[f]=FV(a,r,o,t,f,u),d[f]=DV(o,f,u);return{begin:c,end:h,strides:d}}function AV(t,e,n,s,r){const o=[...r],i=RV(n,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=0;else{const u=EV(e,n,a);let l=s[u];t&1<<u&&(l=0),o[a]=l}return o}function _V(t,e,n,s,r){const o=[...r],i=RV(n,e);for(let a=0;a<o.length;a++)if(i.indexOf(a)>-1)o[a]=Number.MAX_SAFE_INTEGER;else{const u=EV(e,n,a);let l=s[u];t&1<<u&&(l=Number.MAX_SAFE_INTEGER),o[a]=l}for(let a=0;a<o.length;a++){const u=r[a];o[a]<0&&(o[a]+=u),o[a]=Zc(0,o[a],r[a])}return o}function DV(t,e,n){let s=t[e];return(n&1<<e||s==null)&&(s=1),s}function PV(t,e,n,s,r,o){let i=e[r];const a=n[r]||1;(t&1<<r||o&1<<r||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);const u=s[r];return i<0&&(i+=u),i=Zc(0,i,u-1),i}function FV(t,e,n,s,r,o){let i=e[r];const a=n[r]||1;(t&1<<r||o&1<<r||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);const u=s[r];return i<0&&(i+=u),a>0?i=Zc(0,i,u):i=Zc(-1,i,u-1),i}function fE(t,e,n){let s=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){s=r;break}for(let r=s+1;r<n.length;r++)if(e[r]>0||n[r]!==t[r])return!1;return!0}function mE(t,e){let n=t.length>0?t[t.length-1]:1;for(let s=0;s<t.length-1;s++)n+=t[s]*e[s];return n}function k0(t,e,n){let s;const r=t.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(i=>{O(i!==-1,()=>"slice() does not support negative begin indexing.")});let o;return n==null?o=new Array(r).fill(-1):typeof n=="number"?o=[n,...new Array(r-1).fill(-1)]:n.length<r?o=n.concat(new Array(r-n.length).fill(-1)):o=n,o=o.map((i,a)=>i>=0?i:(O(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),t.shape[a]-s[a])),[s,o]}function fS(t,e,n,s,r,o,i,a,u){let l;if(s==null?(l=new Array(e.length),l.fill(1)):l=s,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:l.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:l.slice(),beginMask:r,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};for(let S=0;S<h.dims;S++)c&&1<<S&a&&h.numAddAxisAfterEllipsis++,1<<S&i&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};rue(h,d);let f=!0,m=!0,y=!0;const x=[],v=[];for(let S=0;S<t.length;++S){if(d.strides[S]===0)throw Error(`strides[${S}] must be non-zero`);const k=!!(d.shrinkAxisMask&1<<S),I=t[S];if(I===-1){x.push(k?1:-1);continue}const T=[d.beginMask&1<<S,d.endMask&1<<S],R=[d.strides[S]>0?0:-1,d.strides[S]>0?I:I-1];if(k&&d.strides[S]<=0)throw Error("only stride 1 allowed on non-range indexing.");y=y&&d.strides[S]===1;const _=!!(d.beginMask&1<<S&&d.endMask&1<<S);if(d.beginValid&&d.endValid){if(k){const U=d.begin[S]<0?I+d.begin[S]:d.begin[S];if(d.begin[S]=U,d.end[S]=d.begin[S]+1,U<0||U>=I)throw Error(`slice index ${d.begin[S]} of dimension ${S} out of bounds.`)}else d.begin[S]=m3(d.begin[S],0,d.strides[S],I,T,R),d.end[S]=m3(d.end[S],1,d.strides[S],I,T,R);const V=d.strides[S]===1&&d.begin[S]===0&&d.end[S]===I;f=f&&V,m=m&&(S===0&&d.strides[S]===1||V)}else f=f&&d.strides[S]===1&&_,m=m&&(S===0&&d.strides[S]===1||_);let D,L=!1;if(d.beginValid&&d.endValid?(D=d.end[S]-d.begin[S],L=!0):k?(D=1,L=!0):_&&I>=0&&(d.strides[S]<0?D=-I:D=I,L=!0),L){let V;D===0||D<0!=d.strides[S]<0?V=0:V=Math.trunc(D/d.strides[S])+(D%d.strides[S]!==0?1:0),x.push(V)}else x.push(-1)}for(let S=0;S<d.finalShapeGatherIndices.length;++S){const k=d.finalShapeGatherIndices[S];k>=0?v.push(x[k]):k===a$&&v.push(1)}return{finalShapeSparse:v.filter((S,k)=>d.finalShapeGatherIndices[k]!==a$),finalShape:v,isIdentity:f,sliceDim0:m,isSimpleSlice:y,begin:d.begin,end:d.end,strides:d.strides}}function rue(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=t.begin!=null,e.endValid=t.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<t.dims;s++)if(1<<s&t.ellipsisMask){const r=Math.min(e.dims-(t.dims-s)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<r;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=s}else if(1<<s&t.newAxisMask)e.finalShapeGatherIndices.push(a$),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);t.begin!=null&&(e.begin[n]=t.begin[s]),t.end!=null&&(e.end[n]=t.end[s]),e.strides[n]=t.strides[s],t.beginMask&1<<s&&(e.beginMask|=1<<n),t.endMask&1<<s&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(tue),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[n]=s,n++}}function m3(t,e,n,s,r,o){if(r[e])return n>0?o[e]:o[e+1&1];{const i=t<0?s+t:t;return i<o[0]?o[0]:i>o[1]?o[1]:i}}const oue=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:dS,computeFlatOffset:mE,computeOutShape:pS,getNormalizedAxes:sue,isSliceContinous:fE,maskToAxes:nue,parseSliceParams:k0,sliceInfo:fS,startForAxis:PV,startIndicesWithElidedDims:AV,stopForAxis:FV,stopIndicesWithElidedDims:_V,stridesForAxis:DV,stridesWithElidedDims:TV},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iue{static sgd(e){return new cE(e)}static momentum(e,n,s=!1){return new vV(e,n,s)}static rmsprop(e,n=.9,s=0,r=null,o=!1){return new wV(e,n,s,r,o)}static adam(e=.001,n=.9,s=.999,r=null){return new yV(e,n,s,r)}static adadelta(e=.001,n=.95,s=null){return new mV(e,n,s)}static adamax(e=.002,n=.9,s=.999,r=null,o=0){return new xV(e,n,s,r,o)}static adagrad(e,n=.1){return new gV(e,n)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hd=iue;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aue=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t();function OV(){return new Promise(t=>aue(()=>t()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mS(t,e){const n=t[0].length;t.forEach((r,o)=>{O(r.length===n,()=>`Error in concat${n}D: rank of tensors[${o}] must be the same as the rank of the rest (${n})`)}),O(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const s=t[0];t.forEach((r,o)=>{for(let i=0;i<n;i++)O(i===e||r[i]===s[i],()=>`Error in concat${n}D: Shape of tensors[${o}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${o}.`)})}function Dr(t,e){const n=t[0].slice();for(let s=1;s<t.length;s++)n[e]+=t[s][e];return n}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Fi;(function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"})(Fi||(Fi={}));function LV(t,e,n){let s=new Array;if(n==null&&e==null)return s;if(e==null)for(;s.length<t+n.length;)s.push(-1);else s=e.slice();if(n==null)return s;if(t+n.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${t+n.length}, but shape.rank = ${s.length}`);for(let r=1;r<n.length;++r){const o=n[r],i=s[s.length-n.length+r],a=s[i];if(o>=0)if(a>=0){if(a!==o)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${r+t}] = ${o} but shape[${r+t}] = ${a}`)}else s[i]=o}return s}function MV(t){const e={FIRST_DIM_SIZE:Fi.FIRST_DIM_SIZE,VALUE_ROWIDS:Fi.VALUE_ROWIDS,ROW_LENGTHS:Fi.ROW_LENGTHS,ROW_SPLITS:Fi.ROW_SPLITS,ROW_LIMITS:Fi.ROW_LIMITS,ROW_STARTS:Fi.ROW_STARTS},n=[];for(const s of t)if(s in e)n.push(e[s]);else break;return n}function zV(t){return t.length===0?0:t[0]===Fi.FIRST_DIM_SIZE?t.length-1:t.length}function BV(t,e){if(t==null||e==null)return;const n=t.length,s=e.length;if(n>=s)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(n,s-1);++r){const o=t[r],i=e[r+1];if(o>=0&&i>=0&&o!==1&&o!==i)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${r-t.length}] = ${o} but ragged tensor input.flatValues.shape[${r-t.length}] = ${i}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gE=30;function gS(t){return t<=gE?t:UI(t,Math.floor(Math.sqrt(t)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yS(t,e,n){const s=n*(typeof t=="number"?t:t[0]),r=e*(typeof t=="number"?t:t[1]);return[s,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sh(t,e,n,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(t[0]/n),r=r.concat(t.slice(1));else{r=r.concat(t[0]);const o=e.length;for(let i=0;i<o;++i)r=r.concat([t[i+1]/e[i],e[i]]);r=r.concat(t.slice(o+1))}return r}function Ch(t,e,n=!0){const s=[];if(n){s.push(e);for(let r=e+1;r<t;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],o=[];for(let i=1;i<t;++i)i>=e*2+1||i%2===1?o.push(i):r.push(i);s.push(...r),s.push(0),s.push(...o)}return s}function kh(t,e,n,s=!0){const r=[];s?r.push(t[0]/n):r.push(t[0]*n);for(let o=1;o<t.length;++o)o<=e.length?s?r.push(e[o-1]*t[o]):r.push(t[o]/e[o-1]):r.push(t[o]);return r}function xS(t,e){const n=[0];for(let s=0;s<e;++s)n.push(t[s][0]);return n}function vS(t,e,n){const s=t.slice(0,1);for(let r=0;r<n;++r)s.push(t[r+1]-e[r][0]-e[r][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I0=1.7580993408473768,$0=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wS=.3275911,bS=.254829592,SS=-.284496736,CS=1.421413741,kS=-1.453152027,IS=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gi(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(t.length*2);for(let s=0;s<n.length;s+=2)n[s]=t[s/2],n[s+1]=e[s/2];return n}function VV(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let s=0;s<t.length;s+=2)e[s/2]=t[s],n[s/2]=t[s+1];return{real:e,imag:n}}function WV(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function UV(t){const e=Math.floor(t.length/4),n=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<t.length;r+=4)n[Math.floor(r/4)]=t[r],s[Math.floor(r/4)]=t[r+1];return{real:n,imag:s}}function yE(t,e){const n=t[e*2],s=t[e*2+1];return{real:n,imag:s}}function GV(t,e,n,s){t[s*2]=e,t[s*2+1]=n}function HV(t,e){const n=new Float32Array(t/2),s=new Float32Array(t/2);for(let r=0;r<Math.ceil(t/2);r++){const o=(e?2:-2)*Math.PI*(r/t);n[r]=Math.cos(o),s[r]=Math.sin(o)}return{real:n,imag:s}}function jV(t,e,n){const s=(n?2:-2)*Math.PI*(t/e),r=Math.cos(s),o=Math.sin(s);return{real:r,imag:o}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rk="->",uue=/->/g,g3=",",y3="...";function $S(t,e){t=t.replace(/\s/g,"");const n=(t.length-t.replace(uue,"").length)/rk.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${rk}").`);const[s,r]=t.split(rk);O(s.indexOf(y3)===-1,()=>`The ellipsis notation ("${y3}") is not supported yet.`);const o=s.split(g3),i=o.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let d=0;d<r.length;++d){const f=r[d];if(!o.some(m=>m.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);a.indexOf(f)===-1&&a.push(f)}for(let d=0;d<s.length;++d){const f=s[d];a.indexOf(f)===-1&&f!==g3&&a.push(f)}const u=new Array(o.length);for(let d=0;d<i;++d){if(new Set(o[d].split("")).size!==o[d].length)throw new Error(`Found duplicate axes in input component ${o[d]}. Support for duplicate axes in input is not implemented yet.`);u[d]=[];for(let f=0;f<o[d].length;++f)u[d].push(a.indexOf(o[d][f]))}const l=a.length,c=r.length,h=[];for(let d=c;d<l;++d)h.push(d);return{allDims:a,summedDims:h,idDims:u}}function NS(t,e){let n=new Array(t);n.fill(-1);for(let r=0;r<e.length;++r)n[e[r]]=r;const s=[];for(let r=0;r<t;++r)n[r]===-1&&s.push(r);return n=n.filter(r=>r!==-1),{permutationIndices:n,expandDims:s}}function TS(t,e,n){const s=new Array(t);for(let r=0;r<n.length;++r){const o=n[r].shape;for(let i=0;i<e[r].length;++i)s[e[r][i]]===void 0?s[e[r][i]]=o[i]:O(s[e[r][i]]===o[i],()=>`Expected dimension ${s[e[r][i]]} at axis ${i} of input shaped ${JSON.stringify(o)}, but got dimension ${o[i]}`)}}function ES(t,e){const n=t,s=[];let r=0;t.length===0&&n.push(-1),r=t.length+1;for(let i=0;i<r;++i)s.push([]);const o=[];for(let i=0;i<n.length;++i){const a=n[i],u=lue(e,a);for(const l of u)o.indexOf(l)===-1&&(s[i].push(l),o.push(l))}return{path:n,steps:s}}function RS(t){return t.every((e,n)=>e===n)}function lue(t,e){const n=[];for(let s=0;s<t.length;++s)(t[s].length===0||t[s].indexOf(e)!==-1||e===-1)&&n.push(s);return n}function AS(t,e,n=0){let s=[];if(typeof e=="number")O(t.shape[n]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(t.shape[n]/e);else{const r=e.reduce((i,a)=>(a===-1&&(i+=1),i),0);O(r<=1,()=>"There should be only one negative value in split array.");const o=e.indexOf(-1);if(o!==-1){const i=e.reduce((a,u)=>u>0?a+u:a);e[o]=t.shape[n]-i}O(t.shape[n]===e.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KV(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function XV(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function qV(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YV(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function QV(t,e){return`size ${t} must be non-negative, not ${e}`}function ZV(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function JV(t,e){const n=ie(t),s=ie(e);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${t} outputShape= ${e}`}function e4(t,e){const n=ie(t),s=ie(e);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${s}. inputShape=${t} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u$(){return"segment ids must be >= 0"}function t4(){return"segment ids are not increasing"}function n4(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function s4(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r4(t,e){let n=!1,s;for(t<=gE?(s=t,n=!0):s=UI(t,Math.floor(Math.sqrt(t)));!n;)s>e||s===t?n=!0:s=UI(t,s+1);return s}function xE(t,e,n){const s=[],r=t.length;for(let o=0;o<r;o++)o!==e?s.push(t[o]):s.push(n);return s}function _S(t,e,n,s){const r=e.shape.length,o=t.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>o)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${o}).`);if(n<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);for(let h=0;h<s;++h)if(t.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${t.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const i=t.shape[n],a=[];let u=1,l=1,c=1;for(let h=0;h<s;++h)a.push(t.shape[h]),u*=t.shape[h];for(let h=s;h<n;h++)a.push(t.shape[h]),l*=t.shape[h];for(let h=s;h<r;h++)a.push(e.shape[h]);for(let h=n+1;h<o;h++)a.push(t.shape[h]),c*=t.shape[h];return{batchSize:u,sliceSize:c,outerSize:l,dimSize:i,outputShape:a}}const cue=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:_S,computeOutShape:xE,segOpComputeOptimalWindowSize:r4},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hi(t){try{return t.map(e=>Vi(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function o4(t){return t.map(e=>iu(e))}const hue=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:bS,ERF_A2:SS,ERF_A3:CS,ERF_A4:kS,ERF_A5:IS,ERF_P:wS,PARALLELIZE_THRESHOLD:gE,get RowPartitionType(){return Fi},SELU_SCALE:$0,SELU_SCALEALPHA:I0,applyActivation:aS,assertAndGetBroadcastShape:ut,assertAxesAreInnerMostDims:cs,assertParamsConsistent:mS,assignToTypedArray:GV,axesAreInnerMostDims:AT,calculateShapes:Ra,checkEinsumDimSizes:TS,checkPadOnDimRoundingMode:yr,combineLocations:PB,combineRaggedTensorToTensorShapes:LV,complexWithEvenIndex:WV,complexWithOddIndex:UV,computeConv2DInfo:bn,computeConv3DInfo:Qi,computeDefaultPad:IT,computeDilation2DInfo:zl,computeOptimalWindowSize:gS,computeOutAndReduceShapes:ts,computeOutShape:Dr,computePool2DInfo:Js,computePool3DInfo:Lo,convertConv2DDataFormat:fo,decodeEinsumEquation:$S,eitherStridesOrDilationsAreOne:Ss,expandShapeToKeepDim:qn,exponent:jV,exponents:HV,fromStringArrayToUint8:o4,fromUint8ToStringArray:Hi,getAxesPermutation:cn,getBroadcastDims:Sl,getComplexWithIndex:yE,getEinsumComputePath:ES,getEinsumPermutation:NS,getFusedBiasGradient:iS,getFusedDyActivation:oS,getImageCenter:yS,getInnerMostAxes:Sn,getPermuted:Ch,getRaggedRank:zV,getReductionAxes:bs,getReshaped:Sh,getReshapedPermuted:kh,getRowPartitionTypesHelper:MV,getSliceBeginCoords:xS,getSliceSize:vS,getSparseFillEmptyRowsIndicesDenseShapeMismatch:KV,getSparseFillEmptyRowsNegativeIndexErrorMessage:XV,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:qV,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:ZV,getSparseReshapeInputOutputMismatchErrorMessage:e4,getSparseReshapeInputOutputMultipleErrorMessage:JV,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:YV,getSparseReshapeNegativeOutputDimErrorMessage:QV,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:s4,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:u$,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:t4,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:n4,getUndoAxesPermutation:Ta,isIdentityPermutation:RS,log:tee,mergeRealAndImagArrays:Gi,prepareAndValidate:hS,prepareSplitSize:AS,segment_util:cue,shouldFuse:uS,slice_util:oue,splitRealAndImagArrays:VV,stridesOrDilationsArePositive:oh,tupleValuesAreOne:wl,upcastType:_s,validateDefaultValueShape:BV,validateInput:nE,validateUpdateShape:eV,warn:Io},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Fae();/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const due=ce();due.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Zo;(function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"})(Zo||(Zo={}));var x3;(function(t){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(x3||(x3={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pue={};function i4(t){return pue[t]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E(t,e,n,s,r){const o=e.inputParams[t];if(o&&o.inputIndexStart!==void 0){const a=o.inputIndexStart,u=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?a+1:o.inputIndexEnd,l=a<0?e.inputNames.length+a:a;if(o.type==="tensor")return Ms(e.inputNames[l],n,s,r);if(o.type==="tensors"){const d=e.inputs.slice(a,u);return e.inputNames.slice(a,u).filter((m,y)=>{var x;return((x=d[y])===null||x===void 0?void 0:x.op)!=="NoOp"}).map(m=>Ms(m,n,s,r))}const c=Ms(e.inputNames[l],n,s,r),h=c.dataSync();return o.type==="number"?h[0]:pi(c.shape,h)}const i=e.attrParams[t];return i&&i.value}function Ms(t,e,n,s){const[r,o]=Qr(t,n);if(s!=null){const a=s.getHashTableHandleByName(r);if(a!=null)return a}const i=n.currentContextIds.find(a=>!!e[Wv(r,a)]);return i!==void 0?e[Wv(r,i)][o]:void 0}function v3(t,e,n){return e[Wv(t,n.currentContextId)]}function Qa(t,e){const[n,s,r]=Qr(t,e);return[Wv(n,e&&e.currentContextId),s,r]}function Wv(t,e){return e?`${t}-${e}`:t}function Qr(t,e){if(t==="")return["",0,void 0];const n=e!=null&&e.parseNodeNameCache!=null;if(n){const o=e.parseNodeNameCache.get(t);if(o!=null)return o}const s=t.split(":");let r;if(s.length===1)r=[t,0,void 0];else{const o=s[0],i=s.length===3?s[1]:void 0,a=Number(s[s.length-1]);r=[o,a,i]}return n&&e.parseNodeNameCache.set(t,r),r}function ev(t,e,n){let s=E("pad",t,e,n);if(s==="explicit"){s=E("explicitPaddings",t,e,n);const r=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)r[o][0]=s[o*2],r[o][1]=s[o*2+1];return r}return s}function Za(t){return t.kept?t:au(t)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fue=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],mue=Object.freeze(Object.defineProperty({__proto__:null,json:fue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gue=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],yue=Object.freeze(Object.defineProperty({__proto__:null,json:gue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xue=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],vue=Object.freeze(Object.defineProperty({__proto__:null,json:xue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wue=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],bue=Object.freeze(Object.defineProperty({__proto__:null,json:wue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sue=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Cue=Object.freeze(Object.defineProperty({__proto__:null,json:Sue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kue=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Iue=Object.freeze(Object.defineProperty({__proto__:null,json:kue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ue=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Nue=Object.freeze(Object.defineProperty({__proto__:null,json:$ue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tue=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Eue=Object.freeze(Object.defineProperty({__proto__:null,json:Tue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rue=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Aue=Object.freeze(Object.defineProperty({__proto__:null,json:Rue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ue=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Due=Object.freeze(Object.defineProperty({__proto__:null,json:_ue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pue=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Fue=Object.freeze(Object.defineProperty({__proto__:null,json:Pue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oue=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Lue=Object.freeze(Object.defineProperty({__proto__:null,json:Oue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mue=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],zue=Object.freeze(Object.defineProperty({__proto__:null,json:Mue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bue=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Vue=Object.freeze(Object.defineProperty({__proto__:null,json:Bue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wue=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Uue=Object.freeze(Object.defineProperty({__proto__:null,json:Wue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gue=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Hue=Object.freeze(Object.defineProperty({__proto__:null,json:Gue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jue=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Kue=Object.freeze(Object.defineProperty({__proto__:null,json:jue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xue=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],que=Object.freeze(Object.defineProperty({__proto__:null,json:Xue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yue=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Que=Object.freeze(Object.defineProperty({__proto__:null,json:Yue},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class w3{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[mue,yue,vue,bue,Cue,Iue,Nue,Eue,Aue,Due,Fue,Lue,zue,Vue,Uue,Hue,Kue,que,Que],n=[].concat(...e.map(s=>s.json));this.opMappers=n.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,n={}){const s=e.node,r=[],o=[],i=[],a=s.reduce((y,x)=>(y[x.name]=this.mapNode(x),x.op.startsWith("Placeholder")?r.push(y[x.name]):x.op==="Const"?o.push(y[x.name]):(x.input==null||x.input.length===0)&&i.push(y[x.name]),y),{});let u=[];const l=[];let c={},h={};n!=null&&(c=this.mapSignatureEntries(n.inputs),h=this.mapSignatureEntries(n.outputs));const d=Object.keys(a);d.forEach(y=>{const x=a[y];x.inputNames.forEach((v,w)=>{const[S,,k]=Qa(v),I=a[S];if(I.outputs!=null){const T=I.outputs.indexOf(k);if(T!==-1){const R=`${S}:${T}`;x.inputNames[w]=R}}x.inputs.push(I),I.children.push(x)})}),Object.keys(h).length===0?d.forEach(y=>{const x=a[y];x.children.length===0&&l.push(x)}):Object.keys(h).forEach(y=>{const[x]=Qa(y),v=a[x];v!=null&&(v.signatureKey=h[y],l.push(v))}),Object.keys(c).length>0?Object.keys(c).forEach(y=>{const[x]=Qa(y),v=a[x];v&&(v.signatureKey=c[y],u.push(v))}):u=r;let f={};e.library!=null&&e.library.function!=null&&(f=e.library.function.reduce((y,x)=>(y[x.signature.name]=this.mapFunction(x),y),{}));const m={nodes:a,inputs:u,outputs:l,weights:o,placeholders:r,signature:n,functions:f};return i.length>0&&(m.initNodes=i),m}mapSignatureEntries(e){return Object.keys(e||{}).reduce((n,s)=>(n[e[s].name]=s,n),{})}mapNode(e){const n=i4(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:n.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:n.outputs};return n.inputs!=null&&(s.inputParams=n.inputs.reduce((r,o)=>(r[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},r),{})),n.attrs!=null&&(s.attrParams=n.attrs.reduce((r,o)=>{const i=o.type;let a;switch(o.type){case"string":a=l$(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=l$(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":a=g$(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=g$(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":a=h$(e.attr,o.tfName,o.defaultValue||0),a===void 0&&o.tfDeprecatedName&&(a=h$(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":a=m$(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=m$(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":a=c$(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=c$(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":a=x$(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=x$(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":a=f$(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=f$(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":a=y$(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=y$(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":a=d$(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=d$(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":a=p$(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=p$(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":a=b3(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=b3(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${e.op}`)}return r[o.name]={value:a,type:i},r},{})),s}mapFunction(e){const n=e.nodeDef,s=[],r=[];let o={};n!=null&&(o=n.reduce((h,d)=>(h[d.name]=this.mapNode(d),d.op==="Const"&&r.push(h[d.name]),h),{}));const i=[],a=[];e.signature.inputArg.forEach(h=>{const[d]=Qa(h.name),f={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:vE(h.type),type:"dtype"}},children:[]};f.signatureKey=h.name,i.push(f),o[d]=f}),Object.keys(o).forEach(h=>{const d=o[h];d.inputNames.forEach((f,m)=>{const[y,,x]=Qa(f),v=o[y];if(v.outputs!=null){const w=v.outputs.indexOf(x);if(w!==-1){const S=`${y}:${w}`;d.inputNames[m]=S}}d.inputs.push(v),v.children.push(d)})});const l=e.ret;e.signature.outputArg.forEach(h=>{const[d,f]=Qa(l[h.name]),m=o[d];m!=null&&(m.defaultOutput=f,a.push(m))});const c=this.mapArgsToSignature(e);return{nodes:o,inputs:i,outputs:a,weights:r,placeholders:s,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((n,s)=>(n[s.name]=this.mapArgToTensorInfo(s),n),{}),outputs:e.signature.outputArg.reduce((n,s)=>(n[s.name]=this.mapArgToTensorInfo(s,e.ret),n),{})}}mapArgToTensorInfo(e,n){let s=e.name;return n!=null&&(s=n[s]),{name:s,dtype:e.type}}}function Zue(t){const e=ce().global;if(typeof e.atob<"u")return e.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function a4(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):Zue(t);return e?n:n.toLowerCase()}function l$(t,e,n,s=!1){const r=t[e];return r!=null?a4(r.s,s):n}function c$(t,e,n){const s=t[e];return s?s.b:n}function h$(t,e,n){const s=t[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:n;return typeof r=="number"?r:parseInt(r,10)}function vE(t){switch(typeof t=="string"&&(t=Zo[t]),t){case Zo.DT_FLOAT:case Zo.DT_HALF:return"float32";case Zo.DT_INT32:case Zo.DT_INT64:case Zo.DT_INT8:case Zo.DT_UINT8:return"int32";case Zo.DT_BOOL:return"bool";case Zo.DT_DOUBLE:return"float32";case Zo.DT_STRING:return"string";default:return null}}function b3(t,e,n){const s=t[e];return s&&s.func?s.func.name:n}function d$(t,e,n){const s=t[e];return s&&s.type?vE(s.type):n}function p$(t,e,n){const s=t[e];return s&&s.list&&s.list.type?s.list.type.map(r=>vE(r)):n}function u4(t){if(!t.unknownRank)return t.dim!=null?t.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function f$(t,e,n){const s=t[e];return s&&s.shape?u4(s.shape):n}function m$(t,e,n){const s=t[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):n}function g$(t,e,n,s=!1){const r=t[e];return r&&r.list&&r.list.s?r.list.s.map(o=>a4(o,s)):n}function y$(t,e,n){const s=t[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>u4(r)):n}function x$(t,e,n){const s=t[e];return s&&s.list&&s.list.b?s.list.b:n}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jue{constructor(e,n,s){this.node=e,this.tensorMap=n,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,o)=>(r[o]=this.getAttr(o),r),{}))}getInput(e){return Ms(e,this.tensorMap,this.context)}getAttr(e,n){const s=this.node.rawAttrs[e];if(s.tensor!=null)return Ms(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return h$(this.node.rawAttrs,e,n);if(s.s!=null)return l$(this.node.rawAttrs,e,n);if(s.b!=null)return c$(this.node.rawAttrs,e,n);if(s.shape!=null)return f$(this.node.rawAttrs,e,n);if(s.type!=null)return d$(this.node.rawAttrs,e,n);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return m$(this.node.rawAttrs,e,n);if(s.list.s!=null)return g$(this.node.rawAttrs,e,n);if(s.list.shape!=null)return y$(this.node.rawAttrs,e,n);if(s.list.b!=null)return x$(this.node.rawAttrs,e,n);if(s.list.type!=null)return p$(this.node.rawAttrs,e,n)}return n}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ws=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:jz,abs:ps,acos:uB,acosh:lB,add:we,addN:gte,all:kT,any:Bv,argMax:rh,argMin:cB,asin:hB,asinh:dB,atan:pB,atan2:fB,atanh:mB,avgPool:Vb,avgPool3d:gB,basicLSTMCell:zte,batchNorm:x0,batchNorm2d:yB,batchNorm3d:xB,batchNorm4d:vB,batchToSpaceND:Wb,bincount:wB,bitwiseAnd:Xte,booleanMaskAsync:Roe,broadcastArgs:Yte,broadcastTo:Kd,buffer:xt,cast:De,ceil:bB,clipByValue:Or,clone:au,complex:xl,concat:Ln,concat1d:SB,concat2d:CB,concat3d:kB,concat4d:IB,conv1d:$T,conv2d:bl,conv2dTranspose:TT,conv3d:$B,conv3dTranspose:TB,cos:Ub,cosh:ET,cosineWindow:iE,cumprod:Vv,cumsum:RT,denseBincount:r$,depthToSpace:EB,depthwiseConv2d:v0,diag:vne,dilation2d:RB,div:Ge,divNoNan:AB,dot:_B,dropout:oV,einsum:wd,elu:w0,enclosingPowerOfTwo:iV,ensureShape:Ene,equal:Wi,erf:DB,euclideanNorm:OB,exp:mr,expandDims:us,expm1:LB,eye:_T,fft:sS,fill:$f,floor:S0,floorDiv:CT,fused:Zoe,gather:C0,gatherND:Boe,greater:mo,greaterEqual:Bl,ifft:Yg,imag:Gb,image:Xs,inTopKAsync:Goe,irfft:eE,isFinite:MB,isInf:zB,isNaN:BB,leakyRelu:Hb,less:Kg,lessEqual:vh,linalg:fV,linspace:tse,localResponseNormalization:VB,log:Ao,log1p:jb,logSigmoid:WB,logSoftmax:DT,logSumExp:Kb,logicalAnd:Ca,logicalNot:Xb,logicalOr:PT,logicalXor:UB,losses:Eae,lowerBound:yse,matMul:Dt,max:fi,maxPool:qb,maxPool3d:GB,maxPoolWithArgmax:bse,maximum:Su,mean:Un,meshgrid:kse,min:jg,minimum:kl,mirrorPad:OT,mod:HB,moments:Yb,movingAverage:Doe,mul:Y,multiRNNCell:Rse,multinomial:_se,neg:$n,norm:b0,notEqual:cp,oneHot:LT,ones:no,onesLike:_o,op:Q,outerProduct:Lse,pad:Ui,pad1d:Bse,pad2d:Wse,pad3d:Gse,pad4d:jse,pool:jB,pow:Cl,prelu:Zb,print:aB,prod:KB,raggedGather:ere,raggedRange:nre,raggedTensorToTensor:rre,rand:ire,randomGamma:$re,randomNormal:HT,randomStandardNormal:Ere,randomUniform:bh,randomUniformInt:_re,range:hp,real:Xg,reciprocal:qB,relu:Ea,relu6:jT,reshape:ee,reverse:vi,reverse1d:zre,reverse2d:Vre,reverse3d:Ure,reverse4d:Hre,rfft:rS,round:KT,rsqrt:XT,scalar:nt,scatterND:Foe,searchSorted:FT,selu:qT,separableConv2d:YT,setdiff1dAsync:Qre,sigmoid:Eo,sign:YB,signal:Tae,sin:QT,sinh:ZT,slice:mt,slice1d:eS,slice2d:JT,slice3d:tS,slice4d:qg,softmax:nS,softplus:Nf,spaceToBatchND:Qb,sparse:Rae,sparseToDense:Moe,spectral:Nae,split:io,sqrt:Zs,square:an,squaredDifference:tE,squeeze:Yt,stack:ao,step:Tf,stridedSlice:QB,string:Aae,sub:Be,sum:Qe,tan:ZB,tanh:lp,tensor:Mi,tensor1d:ls,tensor2d:mi,tensor3d:JB,tensor4d:yoe,tensor5d:xoe,tensor6d:voe,tensorScatterUpdate:boe,tile:li,topk:tV,transpose:Vt,truncatedNormal:sE,unique:nV,unsortedSegmentSum:rE,unstack:wi,upperBound:Noe,variable:sV,where:Ys,whereAsync:rV,zeros:Zn,zerosLike:Wt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ele=(t,e,n,s=Ws)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(E("a",t,e,n),E("b",t,e,n))];case"AddN":return[s.addN(E("tensors",t,e,n))];case"FloorMod":case"Mod":return[s.mod(E("a",t,e,n),E("b",t,e,n))];case"Mul":return[s.mul(E("a",t,e,n),E("b",t,e,n))];case"RealDiv":case"Div":return[s.div(E("a",t,e,n),E("b",t,e,n))];case"DivNoNan":return[s.divNoNan(E("a",t,e,n),E("b",t,e,n))];case"FloorDiv":return[s.floorDiv(E("a",t,e,n),E("b",t,e,n))];case"Sub":return[s.sub(E("a",t,e,n),E("b",t,e,n))];case"Minimum":return[s.minimum(E("a",t,e,n),E("b",t,e,n))];case"Maximum":return[s.maximum(E("a",t,e,n),E("b",t,e,n))];case"Pow":return[s.pow(E("a",t,e,n),E("b",t,e,n))];case"SquaredDifference":return[s.squaredDifference(E("a",t,e,n),E("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tle=(t,e,n,s=Ws)=>{switch(t.op){case"Abs":case"ComplexAbs":return[s.abs(E("x",t,e,n))];case"Acos":return[s.acos(E("x",t,e,n))];case"Acosh":return[s.acosh(E("x",t,e,n))];case"Asin":return[s.asin(E("x",t,e,n))];case"Asinh":return[s.asinh(E("x",t,e,n))];case"Atan":return[s.atan(E("x",t,e,n))];case"Atan2":return[s.atan2(E("x",t,e,n),E("y",t,e,n))];case"Atanh":return[s.atanh(E("x",t,e,n))];case"Ceil":return[s.ceil(E("x",t,e,n))];case"Complex":return[s.complex(E("real",t,e,n),E("imag",t,e,n))];case"Cos":return[s.cos(E("x",t,e,n))];case"Cosh":return[s.cosh(E("x",t,e,n))];case"Elu":return[s.elu(E("x",t,e,n))];case"Erf":return[s.erf(E("x",t,e,n))];case"Exp":return[s.exp(E("x",t,e,n))];case"Expm1":return[s.expm1(E("x",t,e,n))];case"Floor":return[s.floor(E("x",t,e,n))];case"Log":return[s.log(E("x",t,e,n))];case"Log1p":return[s.log1p(E("x",t,e,n))];case"Imag":return[s.imag(E("x",t,e,n))];case"Neg":return[s.neg(E("x",t,e,n))];case"Reciprocal":return[s.reciprocal(E("x",t,e,n))];case"Real":return[s.real(E("x",t,e,n))];case"Relu":return[s.relu(E("x",t,e,n))];case"Round":return[s.round(E("x",t,e,n))];case"Selu":return[s.selu(E("x",t,e,n))];case"Sigmoid":return[s.sigmoid(E("x",t,e,n))];case"Sin":return[s.sin(E("x",t,e,n))];case"Sign":return[s.sign(E("x",t,e,n))];case"Sinh":return[s.sinh(E("x",t,e,n))];case"Softplus":return[s.softplus(E("x",t,e,n))];case"Sqrt":return[s.sqrt(E("x",t,e,n))];case"Square":return[s.square(E("x",t,e,n))];case"Tanh":return[s.tanh(E("x",t,e,n))];case"Tan":return[s.tan(E("x",t,e,n))];case"ClipByValue":return[s.clipByValue(E("x",t,e,n),E("clipValueMin",t,e,n),E("clipValueMax",t,e,n))];case"Relu6":return[s.relu6(E("x",t,e,n))];case"Rsqrt":return[s.rsqrt(Ms(t.inputNames[0],e,n))];case"LeakyRelu":return[s.leakyRelu(E("x",t,e,n),E("alpha",t,e,n))];case"Prelu":return[s.prelu(E("x",t,e,n),E("alpha",t,e,n))];case"IsNan":return[s.isNaN(Ms(t.inputNames[0],e,n))];case"IsInf":return[s.isInf(Ms(t.inputNames[0],e,n))];case"IsFinite":return[s.isFinite(Ms(t.inputNames[0],e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ti(t,e,n=""){if(!(typeof t=="number"||typeof e=="number")){O(t.length===e.length,()=>n+` Shapes ${t} and ${e} must match`);for(let s=0;s<t.length;s++){const r=t[s],o=e[s];O(r<0||o<0||r===o,()=>n+` Shapes ${t} and ${e} must match`)}}}function S3(t){return!(typeof t=="number"||t.some(e=>e<0))}function Wm(t,e,n){let s=v$(t,n);const r=!S3(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(o=>{s=v$(o.shape,s)}),!S3(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function v$(t,e){if(typeof t=="number")return e;if(typeof e=="number")return t;if(t.length!==e.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);const n=[];for(let s=0;s<t.length;++s){const r=t[s],o=e[s];if(r>=0&&o>=0&&r!==o)throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);n[s]=r>=0?r:o}return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nle{constructor(e,n,s,r,o,i,a){this.name=e,this.dtype=n,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=o,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=nt(0),Rs(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const n=this.tensors[e];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(e){return e.map(n=>this.read(n))}write(e,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),ti(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=n,Rs(n),s.written=!0,this.tensors[e]=s}writeMany(e,n){if(e.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${n.length}.`);e.forEach((s,r)=>this.write(s,n[r]))}gather(e,n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return Mi([],[0].concat(this.elementShape));const s=this.readMany(e);return ti(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),ao(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Mi([],[0].concat(this.elementShape));const n=[];for(let r=0;r<this.size();r++)n.push(r);const s=this.readMany(n);return ti(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),Ln(s,0)}scatter(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,wi(n,0))}split(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let s=0;const r=e.map(u=>(s+=u,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const o=s===0?0:n.size/s,i=[];ae(()=>{n=ee(n,[1,s,o]);for(let u=0;u<e.length;++u){const c=[0,u===0?0:r[u-1],0],h=[1,e[u],o];i[u]=ee(mt(n,c,h),this.elementShape)}return i});const a=[];for(let u=0;u<e.length;u++)a[u]=u;this.writeMany(a,i)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ah{get id(){return this.idTensor.id}constructor(e,n,s,r=-1){this.tensors=e,this.elementShape=n,this.elementDtype=s,e!=null&&e.forEach(o=>{if(s!==o.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${o.dtype}`);ti(n,o.shape,"TensorList shape mismatch: "),Rs(o)}),this.idTensor=nt(0),this.maxNumElements=r,Rs(this.idTensor)}copy(){return new ah([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,n,s=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);ti(e,this.elementShape,"TensorList shape mismatch: ");const r=Wm(this.elementShape,this.tensors,e);return ae(()=>{const o=this.tensors.map(i=>ee(i,r));return ao(o,0)})}popBack(e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=Wm(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,ti(r.shape,e,"TensorList shape mismatch: "),ee(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(ti(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Rs(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const n=new ah([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)n.tensors[s]=this.tensors[s];return n}getItem(e,n,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);ti(this.tensors[e].shape,n,"TensorList shape mismatch: ");const r=Wm(this.elementShape,this.tensors,n);return ee(this.tensors[e],r)}setItem(e,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);ti(this.elementShape,n.shape,"TensorList shape mismatch: "),Rs(n),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=n}gather(e,n,s){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);ti(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=Wm(this.elementShape,this.tensors,s);return e.length===0?Mi([],[0].concat(r)):ae(()=>{const o=e.map(i=>ee(this.tensors[i],r));return ao(o,0)})}concat(e,n){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);ti(this.elementShape,n,"TensorList shape mismatch: ");const s=Wm(this.elementShape,this.tensors,n);return this.size()===0?Mi([],[0].concat(s)):ae(()=>{const r=this.tensors.map(o=>ee(o,s));return Ln(r,0)})}}function sle(t,e,n){const s=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);const r=t.shape.slice(1);ti(r,e,"TensorList shape mismatch: ");const o=wi(t);return new ah(o,e,s)}function rle(t,e,n,s){return new ah([],t,e,s)}function ole(t,e,n,s){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const o=new ah([],n,t.dtype,s),i=wi(t,0);return e.forEach((a,u)=>{o.setItem(a,i[u])}),o}function ile(t,e,n){let s=0;const r=e.map(c=>(s+=c,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);const o=t.shape.slice(1),i=v$(o,n),a=s===0?0:t.size/s,u=ae(()=>{const c=[];t=ee(t,[1,s,a]);for(let h=0;h<e.length;++h){const f=[0,h===0?0:r[h-1],0],m=[1,e[h],a];c[h]=ee(mt(t,f,m),i)}return t.dispose(),c}),l=new ah([],n,t.dtype,e.length);for(let c=0;c<u.length;c++)l.setItem(c,u[c]);return l}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ale=async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const s=E("thenBranch",t,e,n),r=E("elseBranch",t,e,n),o=E("cond",t,e,n),i=E("args",t,e,n);return(await o.data())[0]?n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const s=E("body",t,e,n),r=E("cond",t,e,n),o=E("args",t,e,n),i=await n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap),a=o.map(c=>c.id);let u=await i[0].data();i.forEach(c=>{!c.kept&&a.indexOf(c.id)===-1&&c.dispose()});let l=o;for(;u[0];){const c=l;l=await n.functionMap[s].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const h=l.map(f=>f.id);c.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&h.indexOf(f.id)===-1&&f.dispose()});const d=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);u=await d[0].data(),d.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&h.indexOf(f.id)===-1&&f.dispose()})}return l}case"LoopCond":{const s=E("pred",t,e,n);return[Za(s)]}case"Switch":{const s=E("pred",t,e,n);let r=E("data",t,e,n);return r.kept||(r=Za(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=t.inputNames.find(r=>Ms(r,e,n)!==void 0);if(s){const r=Ms(s,e,n);return[Za(r)]}return}case"Enter":{const s=E("frameName",t,e,n),r=E("tensor",t,e,n);return n.enterFrame(s),[Za(r)]}case"Exit":{const s=E("tensor",t,e,n);return n.exitFrame(),[Za(s)]}case"NextIteration":{const s=E("tensor",t,e,n);return n.nextIteration(),[Za(s)]}case"TensorArrayV3":{const s=E("size",t,e,n),r=E("dtype",t,e,n),o=E("elementShape",t,e,n),i=E("dynamicSize",t,e,n),a=E("clearAfterRead",t,e,n),u=E("identicalElementShapes",t,e,n),l=E("name",t,e,n),c=new nle(l,r,s,o,u,i,a);return n.addTensorArray(c),[c.idTensor,nt(1)]}case"TensorArrayWriteV3":{const s=E("tensorArrayId",t,e,n),r=E("index",t,e,n),o=E("tensor",t,e,n),i=n.getTensorArray(s.id);return i.write(r,o),[i.idTensor]}case"TensorArrayReadV3":{const s=E("tensorArrayId",t,e,n),r=E("index",t,e,n);return[n.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=E("tensorArrayId",t,e,n),r=E("indices",t,e,n),o=E("dtype",t,e,n);return[n.getTensorArray(s.id).gather(r,o)]}case"TensorArrayScatterV3":{const s=E("tensorArrayId",t,e,n),r=E("indices",t,e,n),o=E("tensor",t,e,n),i=n.getTensorArray(s.id);return i.scatter(r,o),[i.idTensor]}case"TensorArrayConcatV3":{const s=E("tensorArrayId",t,e,n),r=n.getTensorArray(s.id),o=E("dtype",t,e,n);return[r.concat(o)]}case"TensorArraySplitV3":{const s=E("tensorArrayId",t,e,n),r=E("tensor",t,e,n),o=E("lengths",t,e,n),i=n.getTensorArray(s.id);return i.split(o,r),[i.idTensor]}case"TensorArraySizeV3":{const s=E("tensorArrayId",t,e,n),r=n.getTensorArray(s.id);return[nt(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=E("tensorArrayId",t,e,n),r=n.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=E("tensorListId",t,e,n),r=E("index",t,e,n),o=E("tensor",t,e,n),i=n.getTensorList(s.id);return i.setItem(r,o),[i.idTensor]}case"TensorListGetItem":{const s=E("tensorListId",t,e,n),r=E("index",t,e,n),o=E("elementShape",t,e,n),i=E("elementDType",t,e,n);return[n.getTensorList(s.id).getItem(r,o,i)]}case"TensorListScatterV2":case"TensorListScatter":{const s=E("indices",t,e,n),r=E("tensor",t,e,n),o=E("elementShape",t,e,n),i=E("numElements",t,e,n),a=ole(r,s,o,i);return n.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=E("elementShape",t,e,n),r=E("elementDType",t,e,n);let o;t.op==="TensorListReserve"?o="numElements":o="maxNumElements";const i=E(o,t,e,n),a=t.op==="TensorListReserve"?-1:i,u=rle(s,r,i,a);return n.addTensorList(u),[u.idTensor]}case"TensorListGather":{const s=E("tensorListId",t,e,n),r=E("indices",t,e,n),o=E("elementShape",t,e,n),i=E("elementDType",t,e,n);return[n.getTensorList(s.id).gather(r,i,o)]}case"TensorListStack":{const s=E("tensorListId",t,e,n),r=E("elementShape",t,e,n),o=E("elementDType",t,e,n),i=E("numElements",t,e,n);return[n.getTensorList(s.id).stack(r,o,i)]}case"TensorListFromTensor":{const s=E("tensor",t,e,n),r=E("elementShape",t,e,n),o=E("elementDType",t,e,n),i=sle(s,r,o);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=E("tensorListId",t,e,n),r=n.getTensorList(s.id),o=E("dtype",t,e,n),i=E("elementShape",t,e,n);return[r.concat(o,i)]}case"TensorListPushBack":{const s=E("tensorListId",t,e,n),r=E("tensor",t,e,n),o=n.getTensorList(s.id);return o.pushBack(r),[o.idTensor]}case"TensorListPopBack":{const s=E("tensorListId",t,e,n),r=E("elementShape",t,e,n),o=E("elementDType",t,e,n);return[n.getTensorList(s.id).popBack(r,o)]}case"TensorListSplit":{const s=E("tensor",t,e,n),r=E("elementShape",t,e,n),o=E("lengths",t,e,n),i=ile(s,o,r);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{const s=E("tensorListId",t,e,n),r=n.getTensorList(s.id);return[nt(r.size(),"int32")]}case"TensorListResize":{const s=E("tensorListId",t,e,n),r=E("size",t,e,n),i=n.getTensorList(s.id).resize(r);return n.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C3(t,e,n){const[s,r]=E("fusedOps",t,e,n),o=s==="biasadd",i=!o,a=r==="prelu",u=s==="fusedbatchnorm",l=E("numArgs",t,e,n);if(o){if(a&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&o&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=E("strides",t,e,n),h=ev(t,e,n),d=E("dataFormat",t,e,n).toUpperCase(),f=E("dilations",t,e,n);let[m,y]=E("args",t,e,n);i&&(y=m,m=void 0);const x=E("leakyreluAlpha",t,e,n);return{stride:c,pad:h,dataFormat:d,dilations:f,biasArg:m,preluArg:y,activationFunc:r,leakyreluAlpha:x}}const ule=(t,e,n,s=Ws)=>{switch(t.op){case"Conv1D":{const r=E("stride",t,e,n),o=E("pad",t,e,n),i=E("dataFormat",t,e,n).toUpperCase(),a=E("dilation",t,e,n);return[s.conv1d(E("x",t,e,n),E("filter",t,e,n),r,o,i,a)]}case"Conv2D":{const r=E("strides",t,e,n),o=ev(t,e,n),i=E("dataFormat",t,e,n).toUpperCase(),a=E("dilations",t,e,n);return[s.conv2d(E("x",t,e,n),E("filter",t,e,n),[r[1],r[2]],o,i,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:r,pad:o,dataFormat:i,dilations:a,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:h}=C3(t,e,n);return[s.fused.conv2d({x:E("x",t,e,n),filter:E("filter",t,e,n),strides:[r[1],r[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:o,dataFormat:i,dilations:a,biasArg:u,preluArg:l,activationFunc:c,leakyreluAlpha:h}=C3(t,e,n);return[s.fused.depthwiseConv2d({x:E("x",t,e,n),filter:E("filter",t,e,n),strides:[r[1],r[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:u,activation:c,preluActivationWeights:l,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=E("outputShape",t,e,n),o=E("strides",t,e,n),i=ev(t,e,n);return[s.conv2dTranspose(E("x",t,e,n),E("filter",t,e,n),r,[o[1],o[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=E("strides",t,e,n),o=ev(t,e,n),i=E("dilations",t,e,n),a=E("dataFormat",t,e,n).toUpperCase();return[s.depthwiseConv2d(E("input",t,e,n),E("filter",t,e,n),[r[1],r[2]],o,a,[i[1],i[2]])]}case"Conv3D":{const r=E("strides",t,e,n),o=E("pad",t,e,n),i=E("dataFormat",t,e,n).toUpperCase(),a=E("dilations",t,e,n);return[s.conv3d(E("x",t,e,n),E("filter",t,e,n),[r[1],r[2],r[3]],o,i,[a[1],a[2],a[3]])]}case"AvgPool":{const r=E("strides",t,e,n),o=E("pad",t,e,n),i=E("kernelSize",t,e,n);return[s.avgPool(E("x",t,e,n),[i[1],i[2]],[r[1],r[2]],o)]}case"MaxPool":{const r=E("strides",t,e,n),o=E("pad",t,e,n),i=E("kernelSize",t,e,n);return[s.maxPool(E("x",t,e,n),[i[1],i[2]],[r[1],r[2]],o)]}case"MaxPoolWithArgmax":{const r=E("strides",t,e,n),o=E("pad",t,e,n),i=E("kernelSize",t,e,n),a=E("includeBatchInIndex",t,e,n),{result:u,indexes:l}=s.maxPoolWithArgmax(E("x",t,e,n),[i[1],i[2]],[r[1],r[2]],o,a);return[u,l]}case"AvgPool3D":{const r=E("strides",t,e,n),o=E("pad",t,e,n),i=E("kernelSize",t,e,n);return[s.avgPool3d(E("x",t,e,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],o)]}case"MaxPool3D":{const r=E("strides",t,e,n),o=E("pad",t,e,n),i=E("kernelSize",t,e,n);return[s.maxPool3d(E("x",t,e,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],o)]}case"Dilation2D":{const r=E("strides",t,e,n),o=E("pad",t,e,n),i=E("dilations",t,e,n),a=r[1],u=r[2],l=i[1],c=i[2];return[s.dilation2d(E("x",t,e,n),E("filter",t,e,n),[a,u],o,[l,c],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lle=(t,e,n,s=Ws)=>{switch(t.op){case"Fill":{const r=E("shape",t,e,n),o=E("dtype",t,e,n),i=E("value",t,e,n);return[s.fill(r,i,o)]}case"LinSpace":{const r=E("start",t,e,n),o=E("stop",t,e,n),i=E("num",t,e,n);return[s.linspace(r,o,i)]}case"Multinomial":{const r=E("logits",t,e,n),o=E("numSamples",t,e,n),i=E("seed",t,e,n);return[s.multinomial(r,o,i)]}case"OneHot":{const r=E("indices",t,e,n),o=E("depth",t,e,n),i=E("onValue",t,e,n),a=E("offValue",t,e,n),u=E("dtype",t,e,n);return[s.oneHot(r,o,i,a,u)]}case"Ones":return[s.ones(E("shape",t,e,n),E("dtype",t,e,n))];case"OnesLike":return[s.onesLike(E("x",t,e,n))];case"RandomStandardNormal":return[s.randomStandardNormal(E("shape",t,e,n),E("dtype",t,e,n),E("seed",t,e,n))];case"RandomUniform":return[s.randomUniform(E("shape",t,e,n),E("minval",t,e,n),E("maxval",t,e,n),E("dtype",t,e,n))];case"RandomUniformInt":return[s.randomUniformInt(E("shape",t,e,n),E("minval",t,e,n),E("maxval",t,e,n),E("seed",t,e,n))];case"Range":{const r=E("start",t,e,n),o=E("stop",t,e,n),i=E("step",t,e,n);return[s.range(r,o,i,E("dtype",t,e,n))]}case"TruncatedNormal":{const r=E("shape",t,e,n),o=E("mean",t,e,n),i=E("stdDev",t,e,n),a=E("seed",t,e,n);return[s.truncatedNormal(r,o,i,E("dtype",t,e,n),a)]}case"Zeros":return[s.zeros(E("shape",t,e,n),E("dtype",t,e,n))];case"ZerosLike":return[s.zerosLike(E("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ok(t,e,n){const s=E("boxes",t,e,n),r=E("scores",t,e,n),o=E("maxOutputSize",t,e,n),i=E("iouThreshold",t,e,n),a=E("scoreThreshold",t,e,n),u=E("softNmsSigma",t,e,n);return{boxes:s,scores:r,maxOutputSize:o,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}}const cle=async(t,e,n,s,r=Ws)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:u,scoreThreshold:l,softNmsSigma:c}=ok(t,e,n),h=await r.image.nonMaxSuppressionWithScoreAsync(o,i,a,u,l,c);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:u,scoreThreshold:l}=ok(t,e,n),c=E("padToMaxOutputSize",t,e,n),h=await r.image.nonMaxSuppressionPaddedAsync(o,i,a,u,l,c);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:u,scoreThreshold:l}=ok(t,e,n);return[await r.image.nonMaxSuppressionAsync(o,i,a,u,l)]}case"Where":{const o=r.cast(E("condition",t,e,n),"bool"),i=[await r.whereAsync(o)];return o.dispose(),i}case"ListDiff":return r.setdiff1dAsync(E("x",t,e,n),E("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hle=(t,e,n,s=Ws)=>{switch(t.op){case"LowerBound":{const r=E("sortedSequence",t,e,n),o=E("values",t,e,n);return[s.lowerBound(r,o)]}case"TopKV2":{const r=E("x",t,e,n),o=E("k",t,e,n),i=E("sorted",t,e,n),a=s.topk(r,o,i);return[a.values,a.indices]}case"UpperBound":{const r=E("sortedSequence",t,e,n),o=E("values",t,e,n);return[s.upperBound(r,o)]}case"Unique":{const r=E("x",t,e,n),o=s.unique(r);return[o.values,o.indices]}case"UniqueV2":{const r=E("x",t,e,n),o=E("axis",t,e,n),i=s.unique(r,o);return[i.values,i.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dle=(t,e,n,s=Ws)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const r=E("default",t,e,n);return[Ms(t.name,e,n)||r];case"Placeholder":return[Ms(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=E("x",t,e,n);return[Za(c)]}case"IdentityN":return E("x",t,e,n).map(c=>Za(c));case"Snapshot":const o=E("x",t,e,n);return[Za(o)];case"Shape":return[s.tensor1d(E("x",t,e,n).shape,"int32")];case"ShapeN":return E("x",t,e,n).map(c=>s.tensor1d(c.shape));case"Size":return[s.scalar(E("x",t,e,n).size,"int32")];case"Rank":return[s.scalar(E("x",t,e,n).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const i=E("x",t,e,n),a=E("data",t,e,n),u=E("message",t,e,n),l=E("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let c=0;c<a.length;c++)console.log(Array.prototype.slice.call(a[c].dataSync()).slice(0,l));return[i];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ple{get id(){return this.handle.id}constructor(e,n){this.keyDType=e,this.valueDType=n,this.handle=nt(0),this.tensorMap=new Map,Rs(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return nt(this.size(),"int32")}async import(e,n){this.checkKeyAndValueTensor(e,n);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),ae(()=>{const r=wi(n),o=s.length,i=r.length;O(o===i,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${i} elements.`);for(let a=0;a<o;a++){const u=s[a],l=r[a];Rs(l),this.tensorMap.set(u,l)}return this.handle})}async find(e,n){this.checkKeyAndValueTensor(e,n);const s=await e.data();return ae(()=>{const r=[];for(let o=0;o<s.length;o++){const i=s[o],a=this.findWithDefault(i,n);r.push(a)}return ao(r)})}findWithDefault(e,n){const s=this.tensorMap.get(e);return s??n}checkKeyAndValueTensor(e,n){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fle=async(t,e,n,s)=>{switch(t.op){case"HashTable":case"HashTableV2":{const r=s.getHashTableHandleByName(t.name);if(r!=null)return[r];{const o=E("keyDType",t,e,n),i=E("valueDType",t,e,n),a=new ple(o,i);return s.addHashTable(t.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=E("tableHandle",t,e,n,s),o=E("keys",t,e,n),i=E("values",t,e,n);return[await s.getHashTableById(r.id).import(o,i)]}case"LookupTableFind":case"LookupTableFindV2":{const r=E("tableHandle",t,e,n,s),o=E("keys",t,e,n),i=E("defaultValue",t,e,n);return[await s.getHashTableById(r.id).find(o,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=E("tableHandle",t,e,n,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mle=(t,e,n,s=Ws)=>{switch(t.op){case"ResizeBilinear":{const r=E("images",t,e,n),o=E("size",t,e,n),i=E("alignCorners",t,e,n),a=E("halfPixelCenters",t,e,n);return[s.image.resizeBilinear(r,[o[0],o[1]],i,a)]}case"ResizeNearestNeighbor":{const r=E("images",t,e,n),o=E("size",t,e,n),i=E("alignCorners",t,e,n),a=E("halfPixelCenters",t,e,n);return[s.image.resizeNearestNeighbor(r,[o[0],o[1]],i,a)]}case"CropAndResize":{const r=E("image",t,e,n),o=E("boxes",t,e,n),i=E("boxInd",t,e,n),a=E("cropSize",t,e,n),u=E("method",t,e,n),l=E("extrapolationValue",t,e,n);return[s.image.cropAndResize(r,o,i,a,u,l)]}case"ImageProjectiveTransformV3":{const r=E("images",t,e,n),o=E("transforms",t,e,n),i=E("outputShape",t,e,n),a=E("fillValue",t,e,n),u=E("interpolation",t,e,n),l=E("fillMode",t,e,n);return[s.image.transform(r,o,u.toLowerCase(),l.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gle=(t,e,n,s=Ws)=>{switch(t.op){case"Equal":return[s.equal(E("a",t,e,n),E("b",t,e,n))];case"NotEqual":return[s.notEqual(E("a",t,e,n),E("b",t,e,n))];case"Greater":return[s.greater(E("a",t,e,n),E("b",t,e,n))];case"GreaterEqual":return[s.greaterEqual(E("a",t,e,n),E("b",t,e,n))];case"Less":return[s.less(E("a",t,e,n),E("b",t,e,n))];case"LessEqual":return[s.lessEqual(E("a",t,e,n),E("b",t,e,n))];case"LogicalAnd":return[s.logicalAnd(E("a",t,e,n),E("b",t,e,n))];case"LogicalNot":return[s.logicalNot(E("a",t,e,n))];case"LogicalOr":return[s.logicalOr(E("a",t,e,n),E("b",t,e,n))];case"Select":case"SelectV2":return[s.where(E("condition",t,e,n),E("a",t,e,n),E("b",t,e,n))];case"BitwiseAnd":return[s.bitwiseAnd(E("a",t,e,n),E("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yle=(t,e,n,s=Ws)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(E("a",t,e,n),E("b",t,e,n),E("transposeA",t,e,n),E("transposeB",t,e,n))];case"Einsum":return[s.einsum(E("equation",t,e,n),...E("tensors",t,e,n))];case"Transpose":return[s.transpose(E("x",t,e,n),E("perm",t,e,n))];case"_FusedMatMul":const[r,o]=E("fusedOps",t,e,n),i=r==="biasadd",a=o==="prelu",u=E("numArgs",t,e,n),l=E("leakyreluAlpha",t,e,n);if(i){if(a&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,h]=E("args",t,e,n);return[s.fused.matMul({a:E("a",t,e,n),b:E("b",t,e,n),transposeA:E("transposeA",t,e,n),transposeB:E("transposeB",t,e,n),bias:c,activation:o,preluActivationWeights:h,leakyreluAlpha:l})];case"MatrixBandPart":return[s.linalg.bandPart(E("a",t,e,n),E("numLower",t,e,n),E("numUpper",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xle=(t,e,n,s=Ws)=>{switch(t.op){case"EuclideanNorm":return[s.euclideanNorm(E("x",t,e,n),E("axis",t,e,n),E("keepDims",t,e,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(E("x",t,e,n),E("mean",t,e,n),E("variance",t,e,n),E("offset",t,e,n),E("scale",t,e,n),E("epsilon",t,e,n))];case"FusedBatchNormV3":return[s.batchNorm(E("x",t,e,n),E("mean",t,e,n),E("variance",t,e,n),E("offset",t,e,n),E("scale",t,e,n),E("epsilon",t,e,n))];case"LRN":return[s.localResponseNormalization(E("x",t,e,n),E("radius",t,e,n),E("bias",t,e,n),E("alpha",t,e,n),E("beta",t,e,n))];case"Softmax":return[s.softmax(E("x",t,e,n))];case"LogSoftmax":return[s.logSoftmax(E("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vle=(t,e,n,s=Ws)=>{switch(t.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:o}=s.raggedGather(E("paramsNestedSplits",t,e,n),E("paramsDenseValues",t,e,n),E("indices",t,e,n),E("outputRaggedRank",t,e,n));return r.concat(o)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:o}=s.raggedRange(E("starts",t,e,n),E("limits",t,e,n),E("splits",t,e,n));return[r,o]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(E("shape",t,e,n),E("values",t,e,n),E("defaultValue",t,e,n),E("rowPartitionTensors",t,e,n),E("rowPartitionTypes",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wle=(t,e,n,s=Ws)=>{switch(t.op){case"Max":{const a=E("axis",t,e,n),u=E("keepDims",t,e,n);return[s.max(E("x",t,e,n),a,u)]}case"Mean":{const a=E("axis",t,e,n),u=E("keepDims",t,e,n);return[s.mean(E("x",t,e,n),a,u)]}case"Min":{const a=E("axis",t,e,n),u=E("keepDims",t,e,n);return[s.min(E("x",t,e,n),a,u)]}case"Sum":{const a=E("axis",t,e,n),u=E("keepDims",t,e,n);return[s.sum(E("x",t,e,n),a,u)]}case"All":{const a=E("axis",t,e,n),u=E("keepDims",t,e,n);return[s.all(E("x",t,e,n),a,u)]}case"Any":{const a=E("axis",t,e,n),u=E("keepDims",t,e,n);return[s.any(E("x",t,e,n),a,u)]}case"ArgMax":{const a=E("axis",t,e,n);return[s.argMax(E("x",t,e,n),a)]}case"ArgMin":{const a=E("axis",t,e,n);return[s.argMin(E("x",t,e,n),a)]}case"Prod":{const a=E("axis",t,e,n),u=E("keepDims",t,e,n);return[s.prod(E("x",t,e,n),a,u)]}case"Cumprod":{const a=E("axis",t,e,n),u=E("exclusive",t,e,n),l=E("reverse",t,e,n);return[s.cumprod(E("x",t,e,n),a,u,l)]}case"Cumsum":{const a=E("axis",t,e,n),u=E("exclusive",t,e,n),l=E("reverse",t,e,n);return[s.cumsum(E("x",t,e,n),a,u,l)]}case"Bincount":const r=E("x",t,e,n),o=E("weights",t,e,n),i=E("size",t,e,n);return[s.bincount(r,o,i)];case"DenseBincount":{const a=E("x",t,e,n),u=E("weights",t,e,n),l=E("size",t,e,n),c=E("binaryOutput",t,e,n);return[s.denseBincount(a,u,l,c)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ble=(t,e,n,s=Ws)=>{switch(t.op){case"ConcatV2":case"Concat":{const r=E("n",t,e,n),o=E("axis",t,e,n);let i=E("tensors",t,e,n);return i=i.slice(0,r),[s.concat(i,o)]}case"Gather":{const r=E("x",t,e,n),o=E("indices",t,e,n);return[s.gather(r,s.cast(o,"int32"),0)]}case"GatherV2":{const r=E("axis",t,e,n),o=E("batchDims",t,e,n),i=E("x",t,e,n),a=E("indices",t,e,n);return[s.gather(i,s.cast(a,"int32"),r,o)]}case"Reverse":{const r=E("dims",t,e,n),o=[];for(let a=0;a<r.length;a++)r[a]&&o.push(a);const i=E("x",t,e,n);return[s.reverse(i,o)]}case"ReverseV2":{const r=E("axis",t,e,n),o=E("x",t,e,n);return[s.reverse(o,r)]}case"Slice":{const r=E("begin",t,e,n),o=E("size",t,e,n);return[s.slice(E("x",t,e,n),r,o)]}case"StridedSlice":{const r=E("begin",t,e,n),o=E("end",t,e,n),i=E("strides",t,e,n),a=E("beginMask",t,e,n),u=E("endMask",t,e,n),l=E("ellipsisMask",t,e,n),c=E("newAxisMask",t,e,n),h=E("shrinkAxisMask",t,e,n),d=E("x",t,e,n);return[s.stridedSlice(d,r,o,i,a,u,l,c,h)]}case"Pack":return ae(()=>{const r=E("axis",t,e,n),o=E("tensors",t,e,n),i=o[0].shape,a=s.squeeze(o[0]).shape,u=o.map(l=>{const c=kt(l.shape,i);if(!c&&!kt(s.squeeze(l).shape,a))throw new Error("the input tensors shape does not match");return c?l:s.reshape(l,i)});return[s.stack(u,r)]});case"Unpack":{const r=E("axis",t,e,n),o=E("tensor",t,e,n);return s.unstack(o,r)}case"Tile":{const r=E("reps",t,e,n);return[s.tile(E("x",t,e,n),r)]}case"Split":case"SplitV":{const r=E("axis",t,e,n),o=E("numOrSizeSplits",t,e,n),i=E("x",t,e,n);return s.split(i,o,r)}case"ScatterNd":{const r=E("indices",t,e,n),o=E("values",t,e,n),i=E("shape",t,e,n);return[s.scatterND(r,o,i)]}case"GatherNd":{const r=E("x",t,e,n),o=E("indices",t,e,n);return[s.gatherND(r,o)]}case"SparseToDense":{const r=E("sparseIndices",t,e,n),o=E("outputShape",t,e,n),i=E("sparseValues",t,e,n),a=E("defaultValue",t,e,n);return[s.sparseToDense(r,i,o,i.dtype===a.dtype?a:s.cast(a,i.dtype))]}case"TensorScatterUpdate":{const r=E("indices",t,e,n),o=E("values",t,e,n),i=E("tensor",t,e,n);return[s.tensorScatterUpdate(i,r,o)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sle=(t,e,n,s=Ws)=>{switch(t.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:o,emptyRowIndicator:i,reverseIndexMap:a}=s.sparse.sparseFillEmptyRows(E("indices",t,e,n),E("values",t,e,n),E("denseShape",t,e,n),E("defaultValue",t,e,n));return[r,o,i,a]}case"SparseReshape":{const{outputIndices:r,outputShape:o}=s.sparse.sparseReshape(E("inputIndices",t,e,n),E("inputShape",t,e,n),E("newShape",t,e,n));return[r,o]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(E("data",t,e,n),E("indices",t,e,n),E("segmentIds",t,e,n))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(E("data",t,e,n),E("indices",t,e,n),E("segmentIds",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cle=(t,e,n,s=Ws)=>{switch(t.op){case"FFT":return[s.fft(E("x",t,e,n))];case"IFFT":return[s.ifft(E("x",t,e,n))];case"RFFT":return[s.rfft(E("x",t,e,n))];case"IRFFT":return[s.irfft(E("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kle=(t,e,n,s=Ws)=>{switch(t.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(E("input",t,e,n),E("pattern",t,e,n),E("rewrite",t,e,n),E("replaceGlobal",t,e,n))];case"StringNGrams":{const{nGrams:r,nGramsSplits:o}=s.string.stringNGrams(E("data",t,e,n),E("dataSplits",t,e,n),E("separator",t,e,n),E("nGramWidths",t,e,n),E("leftPad",t,e,n),E("rightPad",t,e,n),E("padWidth",t,e,n),E("preserveShortSequences",t,e,n));return[r,o]}case"StringSplit":{const{indices:r,values:o,shape:i}=s.string.stringSplit(E("input",t,e,n),E("delimiter",t,e,n),E("skipEmpty",t,e,n));return[r,o,i]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(E("input",t,e,n),E("numBuckets",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ile=(t,e,n,s=Ws)=>{switch(t.op){case"Cast":return[s.cast(E("x",t,e,n),E("dtype",t,e,n))];case"ExpandDims":{const r=E("axis",t,e,n);return[s.expandDims(E("x",t,e,n),r)]}case"Squeeze":{const r=E("axis",t,e,n);return[s.squeeze(E("x",t,e,n),r)]}case"Reshape":return[s.reshape(E("x",t,e,n),E("shape",t,e,n))];case"EnsureShape":return[s.ensureShape(E("x",t,e,n),E("shape",t,e,n))];case"MirrorPad":return[s.mirrorPad(E("x",t,e,n),E("padding",t,e,n),E("mode",t,e,n))];case"PadV2":case"Pad":return[s.pad(E("x",t,e,n),E("padding",t,e,n),E("constantValue",t,e,n))];case"SpaceToBatchND":{const r=E("blockShape",t,e,n),o=E("paddings",t,e,n);return[s.spaceToBatchND(E("x",t,e,n),r,o)]}case"BatchToSpaceND":{const r=E("blockShape",t,e,n),o=E("crops",t,e,n);return[s.batchToSpaceND(E("x",t,e,n),r,o)]}case"DepthToSpace":{const r=E("blockSize",t,e,n),o=E("dataFormat",t,e,n).toUpperCase();return[s.depthToSpace(E("x",t,e,n),r,o)]}case"BroadcastTo":return[s.broadcastTo(E("x",t,e,n),E("shape",t,e,n))];case"BroadcastArgs":return[s.broadcastArgs(E("s0",t,e,n),E("s1",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k3(t,e,n,s,r=ae){const o=((i,a,u)=>{switch(i.category){case"arithmetic":return r(()=>ele(i,a,u));case"basic_math":return r(()=>tle(i,a,u));case"control":return ale(i,a,u);case"convolution":return r(()=>ule(i,a,u));case"creation":return r(()=>lle(i,a,u));case"dynamic":return cle(i,a,u);case"evaluation":return r(()=>hle(i,a,u));case"image":return r(()=>mle(i,a,u));case"graph":return r(()=>dle(i,a,u));case"logical":return r(()=>gle(i,a,u));case"matrices":return r(()=>yle(i,a,u));case"normalization":return r(()=>xle(i,a,u));case"ragged":return r(()=>vle(i,a,u));case"reduction":return r(()=>wle(i,a,u));case"slice_join":return r(()=>ble(i,a,u));case"sparse":return r(()=>Sle(i,a,u));case"spectral":return r(()=>Cle(i,a,u));case"string":return r(()=>kle(i,a,u));case"transformation":return r(()=>Ile(i,a,u));case"hash_table":return fle(i,a,u,s);case"custom":const l=i4(i.op);if(l&&l.customExecutor)return l.customExecutor(new Jue(i,a,u));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return Jc(o)?o.then(i=>[].concat(i)):[].concat(o)}class I3{constructor(e={},n={},s={},r={},o){this.weightMap=e,this.tensorArrayMap=n,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,n){return{id:e,frameName:n,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let n=0;n<this.contexts.length-1;n++){const s=this.contexts.slice(0,this.contexts.length-n);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(e);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $3(t,e,n,s){const r=new Set,o=[];let i=null,a=null;const u=new Set,l=new Set(Object.keys(t).map(d=>Qr(d)[0]));s=s||[];const c=new Set(s.map(d=>Qr(d.name)[0])),h=[...e];for(;h.length>0;){const d=h.pop();if((Ic(d)||Dle(d)||Ple(d))&&i==null&&(i=d,a=i.children.map(f=>f.name).filter(f=>r.has(f))),r.add(d.name),n[d.name]==null&&!l.has(d.name)&&!c.has(d.name)){if(d.inputs.length===0){o.push(d.name);continue}d.inputs.forEach(f=>{u.has(f.name)||(u.add(f.name),h.push(f))})}}return{inputs:t,outputs:e,usedNodes:r,missingInputs:o,dynamicNode:i,syncInputs:a}}function $le(t,e){const{usedNodes:n,inputs:s}=e,r=Object.keys(s).map(x=>Qr(x)[0]).map(x=>t.nodes[x]),o=t.initNodes||[],i=x=>n.has(typeof x=="string"?x:x.name);function a(x){return[...new Map(x.map(v=>[v.name,v])).values()]}const u=a([...r,...t.weights,...o]).filter(i),l=a([...u,...Object.values(t.nodes)]).filter(i),c=new Map(l.map(x=>[x.name,x])),h={};for(const x of l){h[x.name]=h[x.name]||0;for(const v of x.children)i(v)||(h[v.name]=Number.POSITIVE_INFINITY),h[v.name]=(h[v.name]||0)+1}const d=Object.entries(h).filter(([,x])=>x===0).map(([x])=>x),f=[...d];for(;d.length>0;){const x=d.pop(),v=c.get(x);for(const w of v.children.filter(i))--h[w.name]===0&&(f.push(w.name),d.push(w.name))}const m=f.map(x=>c.get(x)),y=Nle(m,u);return Tle(y,u),y}function Nle(t,e){const n=new Map(t.map(i=>[i.name,i])),s=e.map(i=>i.name),r=new Set(s);for(;s.length>0;){const i=s.pop(),a=n.get(i);for(const u of a.children)!n.has(u.name)||r.has(u.name)||(r.add(u.name),s.push(u.name))}return t.filter(i=>r.has(i.name))}class b1 extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function Tle(t,e){const n=new Map(t.map((a,u)=>[a.name,u])),s=new Set(e.map(a=>a.name)),r=a=>s.has(typeof a=="string"?a:a.name),o=new Set(t.map(a=>a.name)),i=a=>o.has(typeof a=="string"?a:a.name);for(const a of t){for(const u of a.children.filter(i)){if(!n.has(u.name))throw new b1(`Child ${u.name} of node ${a.name} is unreachable.`);if(n.get(a.name)>n.get(u.name))throw new b1(`Node ${a.name} is scheduled to run after its child ${u.name}.`)}if(!r(a))for(const u of a.inputs){if(!n.has(u.name))throw new b1(`Input ${u.name} of node ${a.name} is unreachable.`);if(n.get(u.name)>n.get(a.name))throw new b1(`Node ${a.name} is scheduled to run before its input ${u.name}.`)}}}function Ele(t){const e=new Map(t.map((a,u)=>[a.name,u])),n=Number.MAX_SAFE_INTEGER,s=t.map((a,u)=>Ic(a)?n:u),r=a=>{const u=s[e.get(a.name)];return u??-1},o=t.map((a,u)=>a.children.map(r).reduce((l,c)=>Math.max(l,c),s[u])),i=new Map;for(let a=0;a<t.length;++a){const u=o[a];if(u===n)continue;const l=t[a],c=t[u];i.has(c.name)||i.set(c.name,[]),i.get(c.name).push(l)}return i}const Rle=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Ale=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),_le=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Ic(t){return Rle.has(t.op)}function Dle(t){return Ale.has(t.op)}function Ple(t){return _le.has(t.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uv{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const n=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...n),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const n=e.signatureKey||e.name;return e.defaultOutput?`${n}:${e.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((e,n)=>(e[n]=this._functions[n].signature,e),{})}constructor(e,n){this.graph=e,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new Uv(e.functions[s],this)})}getCompilationKey(e,n){const s=e.map(o=>o.name).sort(),r=n.map(o=>o.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,n){const s=$3(e,n,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:o,syncInputs:i}=s;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(r.length>0){const l=n.map(h=>h.name),c=Object.keys(e);throw new Error(`Cannot compute the outputs [${l}] from the provided inputs [${c}]. Missing the following inputs: [${r}]`)}const a=$le(this.graph,s),u=Ele(a);return{orderedNodes:a,nodeLiveUntilMap:u}}cloneAndKeepTensor(e){if(e==null)return null;const n=e.clone();return Rs(n),n}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([n,s])=>[n,this.cloneTensorList(s)]))}execute(e,n){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n);const r=s.map(d=>this.graph.nodes[Qr(d)[0]]),o=n.map(d=>Qr(d)[0]),i=new Set(o);let a=o.map(d=>this.graph.nodes[d]);a.length===0&&(a=this._outputs);const u=this.getCompilationKey(r,a);let l=this.compiledMap.get(u);l==null&&(l=this.compile(e,a),this.compiledMap.set(u,l));try{this.keepIntermediateTensors=ce().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const c={},h={};return ae(()=>{const d=new I3(this.weightMap,c,h,this.functionExecutorMap,this.parseNodeNameCache),f=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(v=>{const[w,S]=Qr(v,d),k=[];k[S]=e[v],f[w]=k,this.keepIntermediateTensors&&(this.clonedTensorsMap[w]=this.cloneTensorList(k))});const m=this.getFrozenTensorIds(f),{orderedNodes:y,nodeLiveUntilMap:x}=l;for(const v of y){if(f[v.name])continue;const w=k3(v,f,d,this._resourceManager);if(Jc(w))throw new Error(`The execution of the op '${v.op}' returned a promise. Please use model.executeAsync() instead.`);f[v.name]=w,this.keepIntermediateTensors&&(this.clonedTensorsMap[v.name]=this.cloneTensorList(w)),this.checkTensorForDisposalWithNodeLiveUntilInfo(v,f,d,m,i,x.get(v.name))}return this.parent==null&&d.dispose(m),n.map(v=>Ms(v,f,d))})}getFrozenTensorIds(e){const n=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(n)}checkTensorForDisposal(e,n,s,r,o,i,a){if(!(Ic(n)||i.has(e))){for(const u of s[e])u!=null&&(a[u.id]=(a[u.id]||0)+n.children.length);for(const u of n.inputs){if(Ic(u))continue;const l=v3(u.name,s,r);if(l!=null)for(const c of l){if(!c||c.kept||o.has(c.id))continue;const h=a[c.id];h===1?(c.dispose(),delete a[c.id]):h!=null&&a[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,n,s,r,o,i){function a(u){return Ic(u)||o.has(u.name)}if(!(Ic(e)||i==null))for(const u of i){if(a(u))continue;const l=v3(u.name,n,s);for(const c of l)!c||c.kept||r.has(c.id)||c.dispose()}}async executeAsync(e,n){return this._executeAsync(e,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const n of e)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,n,s=!1,r={},o={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=ce().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const i=new I3(this.weightMap,r,o,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(e,i,n,s),u=n.map(d=>Ms(d,a,i)),l=u.map(d=>d.id),c=Object.keys(e).map(d=>e[d].id),h=new Set([...l,...c,...this.weightIds]);return Object.values(a).forEach(d=>{d.forEach(f=>{f&&!f.isDisposed&&!h.has(f.id)&&f.dispose()})}),this.parent==null&&i.dispose(h),u}async executeFunctionAsync(e,n,s){const r=e.reduce((o,i,a)=>(o[this.inputs[a].name]=i,o),{});return this._executeAsync(r,this.outputNodes,!0,n,s)}async executeWithControlFlow(e,n,s,r){const o=Object.keys(e),i=o.map(k=>this.graph.nodes[Qr(k)[0]]),a=s.map(k=>Qr(k)[0]),u=new Set(a);let l=a.map(k=>this.graph.nodes[k]);l.length===0&&(l=this._outputs);const{usedNodes:c,missingInputs:h,dynamicNode:d,syncInputs:f}=$3(e,l,this.weightMap,this._initNodes),m=[...i,...this.graph.weights,...this._initNodes||[]].map(k=>({node:k,contexts:n.currentContext})),y=Object.assign({},this.weightMap);Object.keys(e).forEach(k=>{const[I,T]=Qr(k),R=[];R[T]=e[k],y[I]=R});const x={},v=this.getFrozenTensorIds(y),w={};for(;m.length>0;){const k=this.processStack(i,m,n,y,w,v,u,x,c);await Promise.all(k)}d==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const S=l.filter(k=>!Ic(k)&&!Ms(k.name,y,n)).map(k=>k.name);if(S.length>0){let k="";throw d!=null&&(k=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${S}] from the provided inputs [${o}]. Consider providing the following inputs: [${h}]. ${k}`)}return y}processStack(e,n,s,r,o,i,a,u,l){const c=[];for(;n.length>0;){const h=n.pop();s.currentContext=h.contexts;let d="";if(h.node.op==="Enter"&&E("isConstant",h.node,r,s)&&([d]=Qa(h.node.name,s)),r[h.node.name]==null){const f=k3(h.node,r,s,this._resourceManager);d||([d]=Qa(h.node.name,s));const m=s.currentContext;Jc(f)?c.push(f.then(y=>(r[d]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(y)),s.currentContext=m,this.checkTensorForDisposal(d,h.node,r,s,i,a,u),this.processChildNodes(h.node,n,s,r,o,l),y))):(r[d]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(f)),this.checkTensorForDisposal(d,h.node,r,s,i,a,u),this.processChildNodes(h.node,n,s,r,o,l))}else this.processChildNodes(h.node,n,s,r,o,l)}return c}processChildNodes(e,n,s,r,o,i){e.children.forEach(a=>{const[u]=Qa(a.name,s);o[u]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(l=>!!Ms(l,r,s))&&(o[u]=!0,n.push({contexts:s.currentContext,node:a})):a.inputNames.every(l=>!!Ms(l,r,s))&&(o[u]=!0,n.push({contexts:s.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(n=>n.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(n=>{const s=e[n],[r]=Qr(n),o=this.graph.nodes[r];if(o.attrParams.shape&&o.attrParams.shape.value){const i=o.attrParams.shape.value,a=i.length===s.shape.length&&s.shape.every((u,l)=>i[l]===-1||i[l]===u);O(a,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${i}], but was [${s.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&O(s.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var n,s;const r={};for(const o in e){const i=(s=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||s===void 0?void 0:s[o];i!=null?r[i.name]=e[o]:r[o]=e[o]}return r}checkInputs(e){const n=Object.keys(e).filter(s=>{const[r]=Qr(s);return this.graph.nodes[r]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(e){return e.map(n=>{var s,r;const o=(r=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||r===void 0?void 0:r[n];return o!=null?o.name:n},{})}checkOutputs(e){e.forEach(n=>{const[s]=Qr(n);if(!this.graph.nodes[s])throw new Error(`The output '${n}' is not found in the graph`)})}}class Fle{constructor(e={},n={}){this.hashTableNameToHandle=e,this.hashTableMap=n}addHashTable(e,n){this.hashTableNameToHandle[e]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ole="?tfjs-format=file",Lle="model.json";class Mle{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,n={},s=$V){this.modelUrl=e,this.loadOptions=n,this.version="n/a",this.io=s,n==null&&(this.loadOptions={}),this.resourceManager=new Fle}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const n=this.io.getLoadHandlers(e,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[e]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Jc(e)?e.then(n=>n.getWeightStream==null?this.loadSync(n):this.loadStreaming(n)):this.loadSync(e)}loadSync(e){const n=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,n)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const n=await qz(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,n)}loadWithWeightMap(e,n){this.artifacts=e;const s=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const o=this.artifacts.userDefinedMetadata;o.signature!=null&&(r=o.signature),o.structuredOutputKeys!=null&&(this.structuredOutputKeys=o.structuredOutputKeys)}if(this.signature=r,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new Uv(w3.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(n),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const o=w3.Instance.transformGraph(e.modelInitializer);this.initializer=new Uv(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,n){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const n=e instanceof en?[e]:e,s={};return n.forEach((r,o)=>s[this.structuredOutputKeys[o]]=r),s}return e}predict(e,n){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,n){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var n;if(!(e instanceof en)&&!Array.isArray(e)){const o=(n=this.signature)===null||n===void 0?void 0:n.inputs;if(o!=null)for(const i in o){const a=o[i];a.resourceId!=null&&(e[i]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((o,i)=>{var a,u,l;const c=(l=(u=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||u===void 0?void 0:u[i])===null||l===void 0?void 0:l.resourceId;return c!=null?o[i]=this.resourceIdToCapturedInput[c]:o[i]=e[r++],o},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const n=this.initializerSignature.outputs,s=Object.keys(n);for(let r=0;r<s.length;r++){const o=s[r],i=n[o];this.resourceIdToCapturedInput[i.resourceId]=e[r]}}}execute(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const s=this.executor.execute(e,n);return s.length>1?s:s[0]}async executeAsync(e,n){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const s=await this.executor.executeAsync(e,n);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((n,s)=>(n[s]=[e[s]],n),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&ot(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function dp(t,e={},n=$V){if(t==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof t=="string"&&(t=zle(t));const s=new Mle(t,e,n);return await s.load(),s}function zle(t){return t.endsWith("/")||(t=t+"/"),`${t}${Lle}${Ole}`}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mo=ce();Mo.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);Mo.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);Mo.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);Mo.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);Mo.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);Mo.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);Mo.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);Mo.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);Mo.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);Mo.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);Mo.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);Mo.registerFlag("WEBGPU_PRINT_SHADER",()=>"");Mo.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ble{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vle{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,n,s=!1,r=!0){let o;const i=N3(e,n);return r?(this.freeBuffers.has(i)||this.freeBuffers.set(i,[]),this.freeBuffers.get(i).length>0?(o=this.freeBuffers.get(i).pop(),this.numFreeBuffers--):(o=this.device.createBuffer({size:e,usage:n,mappedAtCreation:s}),this.numBytesAllocated+=e)):(o=this.device.createBuffer({size:e,usage:n,mappedAtCreation:s}),this.numBytesAllocated+=e),this.usedBuffers.has(i)||this.usedBuffers.set(i,[]),this.usedBuffers.get(i).push(o),this.numUsedBuffers++,this.numBytesUsed+=e,o}releaseBuffer(e,n=!0){if(this.freeBuffers.size===0)return;const s=e.size,r=e.usage,o=N3(s,r),i=this.usedBuffers.get(o),a=i.indexOf(e);if(a<0)throw new Error("Cannot find the buffer in buffer manager");i[a]=i[i.length-1],i.pop(),this.numUsedBuffers--,this.numBytesUsed-=s,n?(this.freeBuffers.get(o).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=s)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,n)=>{e.forEach(s=>{s.destroy()})}),this.usedBuffers.forEach((e,n)=>{e.forEach(s=>{s.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function N3(t,e){return`${t}_${e}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Wle=class{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,n,s,r){const o=E3(s),i=e*n*o,a=T3(e,n,s,r);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=i,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const l=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(l),l}this.numBytesAllocated+=i;const u=this.device.createTexture({size:[e,n],format:s,usage:r});return this.usedTextures.get(a).push(u),u}releaseTexture(e){if(this.freeTextures.size===0)return;const n=e.width,s=e.height,r=e.format,o=e.usage,i=T3(n,s,r,o);this.freeTextures.has(i)||this.freeTextures.set(i,[]),this.freeTextures.get(i).push(e),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(i),u=a.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(u,1);const l=E3(r),c=n*s*l;this.numBytesUsed-=c}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,n)=>{e.forEach(s=>{s.destroy()})}),this.usedTextures.forEach((e,n)=>{e.forEach(s=>{s.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}};function T3(t,e,n,s){return`${t}_${e}_${n}_${s}`}function E3(t){if(t==="rgba8unorm")return 16;throw new Error(`${t} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ule(t,e){if(Math.max(...t)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const n=t.length,s="xyzwuv",r=t.map(i=>`${e}.${s[i]}`),o=new Array(n-1);o[n-2]=r[n-1];for(let i=n-3;i>=0;--i)o[i]=`(${o[i+1]} * ${r[i+1]})`;return o}const Wl=(t,e,n)=>n==="int32"?`atomicAdd(${t}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${t}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var pp;(function(t){t[t.FROM_PIXELS=0]="FROM_PIXELS",t[t.DRAW=1]="DRAW"})(pp||(pp={}));const Gle=(t,e,n,s,r)=>{const o={dtype:s.dtype,shape:s.shape},i=jle(n,o,e),a=t.createShaderModule({code:i,label:e.constructor.name});let u=ce().get("WEBGPU_PRINT_SHADER");if(u!==""){u=u.toLowerCase();const l=u.split(",");(u==="all"||l.some(c=>e.shaderKey.toLowerCase().includes(c)))&&(console.group(e.shaderKey),console.debug(i),console.groupEnd())}return r?t.createComputePipelineAsync({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):t.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},$t=(t,e="f32")=>{switch(t){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${t}-component ${e} is not supported.`)}};function es(t){if(t<=1)return"i32";if(t===2)return"vec2<i32>";if(t===3)return"vec3<i32>";if(t===4)return"vec4<i32>";if(t===5)return"vec5";if(t===6)return"vec6";throw Error(`GPU for rank ${t} is not yet supported`)}function uu(t){if(t===0)return"x";if(t===1)return"y";if(t===2)return"z";if(t===3)return"w";if(t===4)return"u";if(t===5)return"v";throw Error(`Index ${t} is not yet supported`)}function Pe(...t){let e;switch(t.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${t[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function R3(t,e){let n;return n=`
     ${Hle(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${t?"main(getGlobalIndex());":"main();"};
      }
    `,n}function Hle(t){return`
  @compute @workgroup_size(${t.workgroupSize[0]}, ${t.workgroupSize[1]}, ${t.workgroupSize[2]})
`}function jle(t,e,n){const s=[],r=n.workgroupSize[0]*n.workgroupSize[1]*n.workgroupSize[2];if(n.outputComponent=n.outputComponent?n.outputComponent:1,s.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${l4(n)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${r}u +
                localIndex);
        `}
      }
    `),n.pixelsOpType!=null){const m=n.pixelsOpType===pp.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${$c(e.dtype,n.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${$c(t[0].dtype,n.outputComponent)}>;`,y=e.shape.length===3?"vec2<i32>":"i32";s.push(`
        struct Uniform {
          outShapeStrides : ${y},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${m}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const x=_3(n);return[A3,s.join(`
`),tv(e.shape),n.getUserCode(),R3(x,n)].join(`
`)}let o,i,a="struct Uniforms { NAN : f32, INFINITY : f32, ";n.variableNames.forEach((m,y)=>{const x=es(t[y].shape.length);a+=`${m.charAt(0).toLowerCase()+m.slice(1)}Shape : ${x}, `,o=t[y].shape.length-1,i=es(o),a+=`${m.charAt(0).toLowerCase()+m.slice(1)}ShapeStrides: ${i}, `});const u=es(e.shape.length);a+=`outShape : ${u}, `,o=e.shape.length-1,i=es(o),a+=`
         outShapeStrides: ${i}, `,n.size&&(a+="size : i32, "),n.uniforms&&(a+=n.uniforms),a+="};",a=tce(a),s.push(a),n.atomic?s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):s.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${$c(e.dtype,n.outputComponent)}>;
    `),n.variableNames.forEach((m,y)=>{s.push(`
      @group(0) @binding(${1+y}) var<storage, read> ${m}: array<${n.variableComponents?$c(t[y].dtype,n.variableComponents[y]):$c(t[y].dtype,n.outputComponent)}>;
        `)}),a!==""&&s.push(`
      @group(0) @binding(${1+n.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const l=Zle(e.shape,n.dispatchLayout),c=[A3,s.join(`
`)+Xle,tv(e.shape),l,Jle(e.shape.length)];n.atomic||c.push(ece(e.shape,e.dtype,n.outputComponent)),n.variableNames.forEach((m,y)=>{c.push(`${tv(t[y].shape,m)}`)});const h=t.map((m,y)=>Qle(m,e.shape,n.variableComponents?n.variableComponents[y]:n.outputComponent,n.dispatchLayout.x.length===e.shape.length)).join(`
`);c.push(h),c.push(n.getUserCode());const d=_3(n);return c.push(R3(d,n)),c.join(`
`)}function Kle(t,e,n){let s=t.shaderKey;if(t.pixelsOpType!=null)return s;const r=[],o=[];e.forEach(c=>{r.push(c.shape),o.push(c.dtype)}),r.push(n.shape),o.push(n.dtype);const i=e.map(c=>Sl(c.shape,n.shape)),a=e.map(c=>kt(c.shape,n.shape)).join("_"),u=i.map(c=>c.join("_")).join(";"),l=l4(t)?"flatDispatch":"";return s+="_"+(t.workgroupSize?t.workgroupSize.join(","):"")+r.map(c=>c.length).join(",")+o.join(",")+t.variableNames.join(",")+u+a+l,s}const A3=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,Xle=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function tv(t,e=""){const n=t.length,s=e!==""?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",r=e!==""?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(n<=1)return`fn ${s}(index : i32) -> i32 { return index; }`;const o=et(t),i=es(n),a=[];for(let l=0;l<n;l++)a.push(`d${l}`);if(o.length===1)return`    fn ${s}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${r}; let d1 = index - d0 * uniforms.${r};
      return vec2<i32>(d0, d1);
    }`;let u;return u="var index2 = index;"+o.map((l,c)=>{const h=`let ${a[c]} = index2 / uniforms.${r}.${uu(c)}`,d=c===o.length-1?`let ${a[c+1]} = index2 - ${a[c]} * uniforms.${r}.${uu(c)}`:`index2 = index2 - ${a[c]} * uniforms.${r}.${uu(c)}`;return`${h}; ${d};`}).join(""),`
    fn ${s}(index : i32) -> ${i} {
      ${u}
      return ${i}(${a.join(",")});
    }
  `}function qle(t,e){const n=t.name,s=t.shape.length,r=es(s),o="get"+n.charAt(0).toUpperCase()+n.slice(1),i=["d0","d1","d2","d3","d4","d5"].slice(0,s),a=i.map(c=>`${c} : i32`).join(", ");if(s<1)return`
      fn ${o}() -> ${$t(e)} {
        return ${$t(e)}(${n}[0]);
      }
    `;const u=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let l=`${s}D`;return s===0&&(l="1D"),`
    fn ${o}(${a}) -> ${$t(e)} {
      return ${$t(e)}(${n}[getIndexFromCoords${l}(${r}(${i.join(",")}),
        ${u})${e===1?"":` / ${e}`}]);
    }
   `}function Yle(t,e,n,s){const r=t.name,o=r.charAt(0).toUpperCase()+r.slice(1),i="get"+o+"ByOutput",a=t.shape.length,u=e.length,l=es(u);if(kt(t.shape,e)&&s)return`
    fn ${i}Index(globalIndex : i32) -> ${$t(n)} {
      return ${$t(n)}(${r}[globalIndex]);
    }

    fn ${i}Coords(coords : ${l}) -> ${$t(n)} {
      return ${$t(n)}(${r}[${u>1?"getOutputIndexFromCoords(coords)":"coords"}${n===1?"":` / ${n}`}]);
    }
    `;const c=Sl(t.shape,e),h=u-a;let d="";if(a===0)return`
    fn ${i}Index(globalIndex : i32) -> ${$t(n)}{
      return get${o}();
    }

    fn ${i}Coords(coords : ${l}) -> ${$t(n)}{
      return get${o}();
    }
  `;u<2&&c.length>=1?d="coords = 0;":d=c.map(x=>`coords.${uu(x+h)} = 0;`).join(`
`);let f="";if(u<2&&a>0)f="coords";else if(u>1){const x=es(a),v=t.shape.map((w,S)=>`coords.${uu(S+h)}`).join(", ");f=`${x}(${v})`}else f="coords";const m=`uniforms.${r.charAt(0).toLowerCase()+r.slice(1)}Shape`,y=`${a}D`;return`
  fn ${i}Index(globalIndex : i32) -> ${$t(n)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${d}
    return ${$t(n)}(${r}[getIndexFromCoords${y}(${f}, ${m})${n===1?"":` / ${n}`}]);
  }

  fn ${i}Coords(coordsIn : ${l}) -> ${$t(n)} {
    var coords = coordsIn;
    ${d}
    return ${$t(n)}(${r}[getIndexFromCoords${y}(${f}, ${m})${n===1?"":` / ${n}`}]);
  }
`}function Qle(t,e,n,s){let r=qle(t,n);return t.shape.length<=e.length&&(r+=Yle(t,e,n,s)),r}function Zle(t,e){const{x:n,y:s=[],z:r=[]}=e,o=t.length,i=n.length+s.length+r.length;if(i!==o)return"";if(n.length===o)return`fn getOutputCoords() -> ${es(o)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let a="";const u=[n,s,r];for(let d=0;d<u.length;d++){const f=u[d];if(f.length!==0)if(f.length===1)a+=`let d${f[0]} = i32(globalId[${d}]);`;else{const m=Ule(f,"uniforms.outShape");a+=`var index${d} = i32(globalId[${d}]);`;for(let y=0;y<m.length;y++)a+=`let d${f[y]} = index${d} / ${m[y]};`,y===m.length-1?a+=`let d${f[y+1]} = index${d} - d${f[y]} * ${m[y]};`:a+=`index${d} = index${d} - d${f[y]} * ${m[y]};`}}const l=[];for(let d=0;d<i;d++)l.push(`d${d}`);const c=es(i);let h=`fn getOutputCoords() -> ${c} {
  ${a}
`;return l.length===0?h+=`return ${c}(0); }`:h+=`return ${c}(${l.join(",")}); }`,h}function Jle(t){let e="";switch(t){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:O(!1,()=>`Unsupported ${t}D shape`);break}return e}function l4(t){return t.dispatch[1]===1&&t.dispatch[2]===1}function $c(t,e=1){if(t==="float32")return $t(e,"f32");if(t==="int32"||t==="bool")return $t(e,"i32");throw new Error(`type ${t} is not supported.`)}function ece(t,e,n){const s=t.length,r=$c(e,n);let o=`fn setOutputAtIndex(flatIndex : i32, value : ${$t(n)}) {
      result[flatIndex] = ${r}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${$t(n,"i32")}) {
      result[flatIndex] = ${r}(value);
    }
    `;if(s>=2){const i=["d0","d1","d2","d3","d4","d5"].slice(0,s),a=es(s);o+=`
      fn setOutputAtCoords(${i.map(u=>`${u} : i32`).join(", ")}, value : ${$t(n)}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${i.join(", ")}));
        setOutputAtIndex(flatIndex${n===1?"":` / ${n}`}, value);
      }
      fn setOutputAtCoordsI32(${i.map(u=>`${u} : i32`).join(", ")}, value : ${$t(n,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${i.join(", ")}));
        setOutputAtIndexI32(flatIndex${n===1?"":` / ${n}`}, value);
      }
    `}return o}function tce(t){const e=/(\w+)\s*:\s*vec(5|6)/g;t=t.replace(e,s=>"@align(16) "+s);const n=/vec(5|6)\s*,\s*(\w+)/g;return t=t.replace(n,(s,r,o)=>`vec${r}, @align(16) ${o}`),t}function _3(t){return!(t.dispatchLayout.hasOwnProperty("y")&&t.dispatchLayout.y.length!==0||t.dispatchLayout.hasOwnProperty("z")&&t.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uc=t=>{let e=1;for(let n=0;n<t.length;n++)e*=t[n];return e};function Fe(t,e,n=[1,1,1],s=[1,1,1]){const[r,o,i]=[Math.ceil(Uc(t.x.map(a=>e[a]))/(n[0]*s[0])),t.y?Math.ceil(Uc(t.y.map(a=>e[a]))/(n[1]*s[1])):1,t.z?Math.ceil(Uc(t.z.map(a=>e[a]))/(n[2]*s[2])):1];return[r,o,i]}function nce(t,e,n,s=!1){const r=[8,8,1],o=[4,4,1];return s||(t<=8&&(o[1]=1),e<=16&&n<=16&&(r[0]=4)),{workgroupSize:r,elementsPerThread:o}}function c4(t,e,n=!1){if(n)return[8,8,1];const s=Uc(t.x.map(o=>e[o])),r=Uc(t.y.map(o=>e[o]));return s<=4?[4,16,1]:r<=4?[16,4,1]:[16,16,1]}function h4(t,e,n=!1){if(n)return[4,4,1];const s=Uc(t.x.map(o=>e[o])),r=Uc(t.y.map(o=>e[o]));return s<=4?[1,2,1]:r<=4?[2,1,1]:[2,2,1]}function Ve(t){return{x:t.map((e,n)=>n)}}function D3(t){if(t==="float32"||t==="int32"||t==="bool"||t==="string")return 4;if(t==="complex64")return 8;throw new Error(`Unknown dtype ${t}`)}function d4(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function p4(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&O(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var la;(function(t){t[t.MatMulReduceProgram=0]="MatMulReduceProgram",t[t.MatMulSplitKProgram=1]="MatMulSplitKProgram",t[t.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",t[t.MatMulPackedProgram=3]="MatMulPackedProgram",t[t.MatMulMax=4]="MatMulMax"})(la||(la={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sce=ce().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),rce=(t,e)=>{const n=t.limits.maxComputeWorkgroupsPerDimension,s=e.dispatchLayout,r=e.dispatch;if(r.every(i=>i<=n))return r;O(r[0]>n&&s.y===void 0&&s.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let o=Math.ceil(Math.sqrt(r[0]));return o>n?(o=Math.ceil(Math.cbrt(r[0])),O(o<=n,()=>"Total dispatch size exceeds WebGPU maximum."),[o,o,o]):[o,o,1]};class Af extends Vw{nextDataId(){return Af.nextDataId++}constructor(e,n){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!d4())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new Ble(n),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new Vle(this.device),this.textureManager=new Wle(this.device),this.tensorMap=new nT(this,lr()),ce().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,n=!1){if(!this.tensorMap.has(e))return!0;const s=this.tensorMap.get(e);return n?s.refCount=0:s.refCount--,s.refCount>0?!1:(s.complexTensorInfos!=null&&(this.disposeData(s.complexTensorInfos.real.dataId),this.disposeData(s.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const n=this.tensorMap.get(e);if(!(!n||!n.resource)){if(n.external){n.resource=null;return}n.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(n.resource):n.resource instanceof GPUTexture&&this.textureManager.releaseTexture(n.resource),n.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){const n=this.tensorMap.get(e);n.refCount++}decRef(e){if(this.tensorMap.has(e)){const n=this.tensorMap.get(e);n.refCount--}}write(e,n,s){if(s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.tensorMap.set(r,{dtype:s,shape:n,values:e,refCount:1}),r}move(e,n,s,r,o){if(r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:r,shape:s,values:n,refCount:o})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(n){throw new Error(n.message)}Object.keys(this.pipelineCache).map((n,s)=>{this.pipelineCache[n]=e[s]})}async getBufferData(e){if(ce().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const n=e.size,s=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,n),this.submitQueue(),await s.mapAsync(GPUMapMode.READ);const r=s.getMappedRange().slice(0);return s.unmap(),s!=null&&this.bufferManager.releaseBuffer(s),ce().getBool("WEBGPU_USE_PROFILE_TOOL")&&(O(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),r}convertAndCacheOnCPU(e,n){const s=this.tensorMap.get(e);return s.values=n,s.values}readSync(e){const n=this.tensorMap.get(e),{values:s,complexTensorInfos:r}=n;if(s!=null||n.dtype==="string")return s;if(n.dtype==="complex64"){const y=this.readSync(r.real.dataId),x=this.readSync(r.imag.dataId),v=Q1(Gi(y,x).buffer,"float32");return this.convertAndCacheOnCPU(e,v),v}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const o=["opaque","premultiplied"],i=n.resource,a=i.size;O(a%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const u=a/4,l=new ArrayBuffer(a),c=256,h=256,d=o.map(y=>new OffscreenCanvas(c,h)),f=new OffscreenCanvas(c,h);this.endComputePassEncoder(),d.map((y,x)=>{const v=y.getContext("webgpu");return v.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:o[x]}),v.getCurrentTexture()}).map((y,x)=>{const v=c*4,w=(_,D,L)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:i,bytesPerRow:v,offset:L},{texture:y},{width:_,height:D}),this.submitQueue();const V=f.getContext("2d",{willReadFrequently:!0});V.clearRect(0,0,_,D),V.drawImage(d[x],0,0);const U=V.getImageData(0,0,_,D).data,j=o[x],q=new Uint8ClampedArray(l,L,_*D*4);for(let J=0;J<q.length;J+=4)if(j==="premultiplied")q[J+3]=U[J+3];else{const te=U[J];q[J]=U[J+2],q[J+1]=U[J+1],q[J+2]=te}},S=Math.floor(u/(c*h));let k=c,I=h,T=0;for(let _=0;_<S;_++)w(k,I,T),T+=c*h*4;const R=u%(c*h);I=Math.floor(R/c),I>0&&(w(k,I,T),T+=I*(c*4)),k=R%c,k>0&&w(k,1,T)});const m=Q1(l,n.dtype);return this.convertAndCacheOnCPU(e,m),m}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const n=this.tensorMap.get(e),{values:s}=n;if(s!=null)return s;let r;if(n.dtype==="complex64"){const o=await Promise.all([this.read(n.complexTensorInfos.real.dataId),this.read(n.complexTensorInfos.imag.dataId)]),i=o[0],a=o[1];r=Gi(i,a)}else{const o=await this.getBufferData(n.resource);r=Q1(o,n.dtype)}return this.convertAndCacheOnCPU(e,r),r}copyBuffer(e){const n=e.size,s=e.usage,r=this.bufferManager.acquireBuffer(n,s);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,r,0,n),this.submitQueue(),r}createTensorFromGPUData(e,n,s){let r=e.buffer;if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const o={id:this.nextDataId()};this.tensorMap.set(o,{dtype:s,shape:n,values:null,refCount:1,external:e.zeroCopy});const i=this.tensorMap.get(o),a=D3(i.dtype)*ie(i.shape);if(e.buffer.size<a)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${a})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(r=this.copyBuffer(r)),i.resource=r,lr().makeTensorFromDataId(o,n,s,this)}readToGPU(e){const n=this.tensorMap.get(e),{values:s,dtype:r,shape:o,resource:i}=n;if(r==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(i==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const a=i,u=a.size,l=a.usage,c=this.bufferManager.acquireBuffer(u,l);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(i,0,c,0,u),this.submitQueue();const h=this.makeTensorInfo(o,r),d=lr().makeTensorFromTensorInfo(h),f=this.tensorMap.get(h.dataId);return f.resource=c,{tensorRef:d,buffer:c}}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const s=n.map(r=>Vi(r));return xt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return xt(e.shape,e.dtype,n)}async time(e){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const n=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const o=xu(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=xu(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(o);return a.kernelMs=Sz(u),a.getExtraProfileInfo=()=>u.map((l,c)=>({name:i[c],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}makeTensorInfo(e,n,s){return n==="string"&&s!=null&&s.length>0&&Tp(s[0])&&(s=s.map(o=>iu(o))),{dataId:this.write(s,e,n),shape:e,dtype:n}}tensorToBinding(e){if(!e)return null;const s=this.tensorMap.get(e.dataId).resource;return s instanceof GPUBuffer?{buffer:s}:s instanceof GPUTexture?s.createView():s}uploadToGPU(e){const n=this.tensorMap.get(e);if(n.resource!=null)return;const s=D3(n.dtype)*ie(n.shape);let r;const o=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(n.values){if(r=this.bufferManager.acquireBuffer(s,o,!0),r.mapState==="unmapped"){const i=this.bufferManager.acquireBuffer(s,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),a=i.getMappedRange();n.dtype==="int32"||n.dtype==="bool"?new Int32Array(a).set(n.values):new Float32Array(a).set(n.values),i.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(i,0,r,0,s),this.stagingPendingDisposal.push(i)}else{const i=r.getMappedRange();n.dtype==="int32"||n.dtype==="bool"?new Int32Array(i).set(n.values):new Float32Array(i).set(n.values),r.unmap()}n.values=null}else r=this.bufferManager.acquireBuffer(s,o);n.resource=r}makeUniforms(e){let n=0,s=0;const r=[];let o=1;e.forEach(u=>{u.data.length===0&&(u.data=[1]);let l;switch(u.data.length){case 1:l=4;break;case 2:l=8;break;case 3:l=16;break;case 4:l=16;break;case 5:l=16;break;case 6:l=16;break;default:O(!1,()=>`Unsupported ${u.data.length}D shape`)}(s===5||s===6)&&(l=16),l>o&&(o=l),n=Math.ceil(n/l)*l,s=u.data.length,r.push(n),n+=u.data.length*4}),n=Math.ceil(n/o)*o;const i=new ArrayBuffer(n);e.forEach((u,l)=>{const c=r[l];u.type==="int32"?new Int32Array(i,c,u.data.length).set(u.data):u.type==="uint32"?new Uint32Array(i,c,u.data.length).set(u.data):new Float32Array(i,c,u.data.length).set(u.data)});const a=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(a,0,i,0,n),this.uniformPendingDisposal.push(a),{offset:0,size:n,buffer:a}}runWebGPUProgram(e,n,s,r,o){if(o||(o=this.makeTensorInfo(e.outputShape,s)),ie(o.shape)===0)return this.tensorMap.get(o.dataId).values=ws(o.dtype,0),o;this.uploadToGPU(o.dataId),e.dispatch=rce(this.device,e);const i=n.map((u,l)=>{if(u.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(u.dataId),{dtype:this.tensorMap.get(u.dataId).dtype,shape:u.shape,name:e.variableNames[l]}});e.shaderKey=Kle(e,i,o);const a=ce().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=Gle(this.device,e,i,o,a)),e.pipeline=this.pipelineCache[e.shaderKey],a||this.recordAndSubmit(e,o,n,r),o}recordAndSubmit(e,n,s,r){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let o=[],i=[];const a="int32";if(e.pixelsOpType==null){o.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),i=s.concat(n).map(f=>f.shape);const d="int32";i.map(f=>{o.push({type:d,data:f});const m=et(f);o.push({type:d,data:m})})}else{const d=et(n.shape);o.push({type:a,data:d})}if(e.size){const d=ie(e.outputShape);o.push({type:a,data:[e.outputComponent?d/e.outputComponent:d]})}r&&(o=[...o,...r]);const u=[this.tensorToBinding(n),...s.map(d=>this.tensorToBinding(d)),this.makeUniforms(o)];s.forEach(d=>{this.commandQueueOwnedIds.add(d.dataId)}),this.commandQueueOwnedIds.add(n.dataId);const l=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:u.map((d,f)=>({binding:f,resource:d}))}),c=this.activeTimers!=null;this.ensureCommandEncoderReady();const h={};c&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),h.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(h)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(h)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,l),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(c||ce().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===pp.DRAW)&&(this.endComputePassEncoder(),c?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const n=new BigUint64Array(e.getMappedRange()),s=Number(n[1]-n[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),s}shouldExecuteOnCPU(e,n=sce){return ce().getBool("WEBGPU_CPU_FORWARD")&&e.every(s=>this.tensorMap.get(s.dataId).resource==null&&ie(s.shape)<n)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}Af.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */d4()&&wT("webgpu",async()=>{const t={powerPreference:ce().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(t),n={},s=[];e.features.has("timestamp-query")&&s.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&s.push(["bgra8unorm-storage"]),n.requiredFeatures=s;const r=e.limits;n.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize,maxBufferSize:r.maxBufferSize,maxComputeWorkgroupSizeX:r.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:r.maxComputeInvocationsPerWorkgroup};const o=await e.requestDevice(n),i=await e.requestAdapterInfo();return new Af(o,i)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ft;(function(t){t[t.ADD=0]="ADD",t[t.ATAN2=1]="ATAN2",t[t.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",t[t.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",t[t.DIV=4]="DIV",t[t.ELU_DER=5]="ELU_DER",t[t.EQUAL=6]="EQUAL",t[t.FLOOR_DIV=7]="FLOOR_DIV",t[t.GREATER=8]="GREATER",t[t.GREATER_EQUAL=9]="GREATER_EQUAL",t[t.LESS=10]="LESS",t[t.LESS_EQUAL=11]="LESS_EQUAL",t[t.LOGICAL_AND=12]="LOGICAL_AND",t[t.LOGICAL_OR=13]="LOGICAL_OR",t[t.MAX=14]="MAX",t[t.MIN=15]="MIN",t[t.MOD=16]="MOD",t[t.MUL=17]="MUL",t[t.NOT_EQUAL=18]="NOT_EQUAL",t[t.POW=19]="POW",t[t.PRELU=20]="PRELU",t[t.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",t[t.SUB=22]="SUB"})(ft||(ft={}));const oce="let resultTemp = a + b;",ice="let resultTemp = atan2(a, b);",ace="let resultTemp = areal * breal - aimag * bimag;",uce="let resultTemp = areal * bimag + aimag * breal;",lce="let resultTemp = a / b;",cce="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",hce=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,dce=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,pce=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,fce=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,mce=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,gce=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,yce="return f32(a >= 1.0 && b >= 1.0);",xce=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,vce="return f32(a >= 1.0 || b >= 1.0);",wce=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,bce="let resultTemp = max(a, b);",Sce="let resultTemp = min(a, b);",Cce=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,kce=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,Ice="let resultTemp = a * b;",$ce=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,Nce=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,Tce=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,Ece=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,Rce="if (a < 0.0) { return b * a; }  return a;",Ace=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,_ce="let resultTemp = (a - b) * (a - b);",Dce="let resultTemp = a - b;";function wE(t,e){let n;do{switch(t){case ft.ATAN2:n=ice;break;case ft.MAX:n=bce;break;case ft.MIN:n=Sce;break;case ft.MOD:n=e?kce:Cce;break;case ft.NOT_EQUAL:n=e?Nce:$ce;break;case ft.POW:n=e?Ece:Tce;break;default:continue}let s,r,o;return e?(s="isnanVec4",r="vec4<f32>",o="vec4<bool>"):(s="isnan",r="f32",o="bool"),`
      let aIsNaN = ${s}(a);
      let aPostLegalization = select(a, ${r}(42), aIsNaN);
      let bIsNaN = ${s}(b);
      let bPostLegalization = select(b, ${r}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${n}
        return select(
            resultTemp, ${r}(valueForNaN),
            ${o}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(t){case ft.ADD:n=oce;break;case ft.COMPLEX_MULTIPLY_IMAG:n=uce;break;case ft.COMPLEX_MULTIPLY_REAL:n=ace;break;case ft.DIV:n=lce;break;case ft.ELU_DER:n=cce;break;case ft.EQUAL:n=hce;break;case ft.FLOOR_DIV:n=dce;break;case ft.GREATER:n=pce;break;case ft.GREATER_EQUAL:n=fce;break;case ft.LESS:n=mce;break;case ft.LESS_EQUAL:n=gce;break;case ft.LOGICAL_AND:return e?xce:yce;case ft.LOGICAL_OR:return e?wce:vce;case ft.MUL:n=Ice;break;case ft.PRELU:return e?Ace:Rce;case ft.SQUARED_DIFFERENCE:n=_ce;break;case ft.SUB:n=Dce;break}return`
    ${n}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var _e;(function(t){t[t.ABS=0]="ABS",t[t.ACOS=1]="ACOS",t[t.ACOSH=2]="ACOSH",t[t.ASIN=3]="ASIN",t[t.ASINH=4]="ASINH",t[t.ATAN=5]="ATAN",t[t.ATANH=6]="ATANH",t[t.CEIL=7]="CEIL",t[t.COS=8]="COS",t[t.COSH=9]="COSH",t[t.ELU=10]="ELU",t[t.ERF=11]="ERF",t[t.EXP=12]="EXP",t[t.EXPM1=13]="EXPM1",t[t.FLOOR=14]="FLOOR",t[t.IS_FINITE=15]="IS_FINITE",t[t.IS_INF=16]="IS_INF",t[t.IS_NAN=17]="IS_NAN",t[t.LINEAR=18]="LINEAR",t[t.LOG=19]="LOG",t[t.LOG1P=20]="LOG1P",t[t.LOGICAL_NOT=21]="LOGICAL_NOT",t[t.NEG=22]="NEG",t[t.RELU=23]="RELU",t[t.RELU6=24]="RELU6",t[t.LEAKYRELU=25]="LEAKYRELU",t[t.RECIPROCAL=26]="RECIPROCAL",t[t.ROUND=27]="ROUND",t[t.RSQRT=28]="RSQRT",t[t.SELU=29]="SELU",t[t.SIGMOID=30]="SIGMOID",t[t.SIGN=31]="SIGN",t[t.SIN=32]="SIN",t[t.SINH=33]="SINH",t[t.SOFTPLUS=34]="SOFTPLUS",t[t.SQRT=35]="SQRT",t[t.SQUARE=36]="SQUARE",t[t.STEP=37]="STEP",t[t.TAN=38]="TAN",t[t.TANH=39]="TANH",t[t.TO_INT=40]="TO_INT"})(_e||(_e={}));const Pce="return abs(a);",Fce=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,Oce=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,Lce=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,Mce="return asinh(a);",zce=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,Bce=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,Vce="return ceil(a);",Wce="return cos(a);",Uce=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,Gce="return exp(a) - 1.0;",Hce="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",jce=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,Kce=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${wS};
  let a1 = ${bS};
  let a2 = ${SS};
  let a3 = ${CS};
  let a4 = ${kS};
  let a5 = ${IS};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,Xce="return exp(a);",qce="return floor(a);",Yce="return f32(!isnan(a) && !isinf(a));",Qce="return f32(isinf(a));",Zce="return f32(isnan(a));",Jce="return a;",ehe=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,the=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,nhe="return f32(!(a >= 1.0));",she="return -a;",rhe="if (a < 0.0) { return uniforms.alpha * a; } return a;",ohe=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,ihe="return 1.0 / a;",ahe="return select(a, 0.0, a < 0.0);",uhe="return clamp(a, 0.0, 6.0);",lhe="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",che=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,hhe="return round(a);",dhe="return inverseSqrt(a);",phe=`
  if (a >= 0.0) {
    return ${$0} * a;
  } else {
    return ${I0} * (exp(a) - 1.0);
  }
`,fhe="return 1.0 / (1.0 + exp(-1.0 * a));",mhe="return sign(a);",ghe="return sin(a);",yhe=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,xhe=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,vhe="return sqrt(a);",whe="return a * a;",bhe=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,She="return tan(a);",Che=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,khe="return f32(i32((a)));";function bc(t,e){switch(t){case _e.ABS:return Pce;case _e.ACOS:return Fce;case _e.ACOSH:return Oce;case _e.ASIN:return Lce;case _e.ASINH:return Mce;case _e.ATAN:return zce;case _e.ATANH:return Bce;case _e.COS:return Wce;case _e.COSH:return Uce;case _e.CEIL:return Vce;case _e.ELU:return e?jce:Hce;case _e.ERF:return Kce;case _e.EXP:return Xce;case _e.EXPM1:return Gce;case _e.FLOOR:return qce;case _e.IS_FINITE:return Yce;case _e.IS_INF:return Qce;case _e.IS_NAN:return Zce;case _e.LINEAR:return Jce;case _e.LOG:return ehe;case _e.LOG1P:return the;case _e.LOGICAL_NOT:return nhe;case _e.NEG:return she;case _e.LEAKYRELU:return e?ohe:rhe;case _e.RECIPROCAL:return ihe;case _e.RELU:return e?che:ahe;case _e.RELU6:return e?lhe:uhe;case _e.ROUND:return hhe;case _e.RSQRT:return dhe;case _e.SELU:return phe;case _e.SIGMOID:return fhe;case _e.SIGN:return mhe;case _e.SIN:return ghe;case _e.SINH:return yhe;case _e.SOFTPLUS:return xhe;case _e.SQRT:return vhe;case _e.SQUARE:return whe;case _e.STEP:return bhe;case _e.TAN:return She;case _e.TANH:return Che;case _e.TO_INT:return khe;default:throw new Error(`BinaryType ${t} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ku(t,e=!1,n=!1,s=3){if(t===null)return"";let r="";if(t==="linear")r=bc(_e.LINEAR);else if(t==="relu")r=bc(_e.RELU,n);else if(t==="elu")r=bc(_e.ELU,n);else if(t==="relu6")r=bc(_e.RELU6,n);else if(t==="prelu")r=wE(ft.PRELU,n);else if(t==="sigmoid")r=bc(_e.SIGMOID,n);else if(t==="leakyrelu")r=bc(_e.LEAKYRELU,n);else throw new Error(`Activation ${t} has not been implemented for the WebGPU backend.`);const i=$t(n?4:1);let a="";return e?a=`
      fn activation(a : ${i}, coords : vec${s}<i32>) -> ${i} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${r}
      }`:a=`
      fn activation(a : ${i}, coords : vec${s}<i32>) -> ${i} {
        ${r}
      }`,a}function Ih(t,e){return`
      ${t?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f4(t,e,n=!1,s=!1,r=!1,o=1){O(t&&o===1||!t,()=>`transposeA ${t} is not compatible with component size ${o}`);const i=`
      ${t?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,a=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${$t(o)} {
    var value = ${$t(o)}(0.0);
    ${n&&r?i:`
    ${t?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${i}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${$t(o)} {
    var value = ${$t(o)}(0.0);
    ${a}
    return value;
  }
  `}function bE(t,e,n,s,r=!1,o=!1,i=!1,a=1){return`
  ${f4(n,s,r,o,i,a)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${$t(a)}) {
    ${r&&o?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${Ih(t,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const Ihe=(t,e)=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `,$he=(t,e,n,s)=>{if(t)return`
      for (var k = 0; k < ${s}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${n}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let r="",o="";for(let i=0;i<e;i++)r+=`let BCached${i} = mm_Bsub[k * ${e} + ${i}][tileCol];`,o+=`acc[i] = fma(BCached${i}, vec4<f32>(ACached[${i}]), acc[i]);`;return`
      for (var k = 0; k < ${s/e}; k++) {
        ${r}
        for (var i = 0; i < ${n}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${o}
        }
      }`}};function DS(t,e,n=!1,s=32,r=!1,o=32,i=!1){const a=e[1]*t[1],u=e[0]*t[0],l=n?a:s,c=n?s:a,h=l/e[0],d=s/e[1],f=t[1],m=t[0];return O((n&&h===4&&t[1]===4||!n&&(h===3||h===4))&&l%e[0]===0&&s%e[1]===0&&t[0]===4,()=>`If transposeA ${n} is true, innerElementSize ${h} and workPerThread[1] ${t[1]} must be 4.
          Otherwise, innerElementSize ${h} must be 3 or 4.
      tileAWidth ${l} must be divisible by workgroupSize[0]${e[0]}. tileInner ${s} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${t[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${h}<f32>, ${l/h}>, ${c}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${u/t[0]}>, ${s}>;

  ${Pe()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${f};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${f};
    let globalCol = i32(globalId.x) * ${m};
    let batch = ${r?"0":"i32(globalId.z)"};
    let batchA = ${r||!i?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${r||!i?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${a};

    let numTiles = ${r?`${Math.ceil(o/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
    var kStart = ${r?`i32(globalId.z) * ${o}`:"0"};

    var acc: array<vec4<f32>, ${f}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${d};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${f}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${Ihe(n,h)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${d}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${$he(n,h,f,s)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${f}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const P3=t=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,Nhe=t=>t?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function PS(t,e,n=!1,s=32,r=!1,o=32,i=!1,a=!1){const u=t[1]*e[1],l=t[0]*e[0],c=n?u:s,h=n?s:u;O(h%e[1]===0&&c%e[0]===0&&s%e[1]===0,()=>`tileAHight ${h} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${e[0]}, tileInner ${s} must be divisible by workgroupSize[1]${e[1]}`);const d=h/e[1],f=c/e[0],m=s/e[1],y=t[1],x=t[0],v=i?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${u};
      let globalColStart = i32(workgroupId.x) * ${l};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${e[0]}) {
            ${P3(n)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${s};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${x}>;
        for (var k = 0; k < ${s}; k++) {
          for (var inner = 0; inner < ${x}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${y}; innerRow++) {
            let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${x}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${y}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${x}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${y};
  let tileCol = i32(localId.x) * ${x};

  let globalRow = i32(globalId.y) * ${y};
  let globalCol = i32(globalId.x) * ${x};
  let globalRowStart = i32(workgroupId.y) * ${u};

  let tileRowA = i32(localId.y) * ${d};
  let tileColA = i32(localId.x) * ${f};
  let tileRowB = i32(localId.y) * ${m};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${d}; innerRow++) {
      for (var innerCol = 0; innerCol < ${f}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${P3(n)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${m}; innerRow++) {
      for (var innerCol = 0; innerCol < ${x}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${s};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${x}>;
    for (var k = 0; k < ${s}; k++) {
      for (var inner = 0; inner < ${x}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${y}; innerRow++) {
        ${Nhe(n)}
        for (var innerCol = 0; innerCol < ${x}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${y}; innerRow++) {
    for (var innerCol = 0; innerCol < ${x}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${c}>, ${h}>;
    var<workgroup> mm_Bsub : array<array<f32, ${l}>, ${s}>;

    ${Pe()} {
      let batch = ${r?"0":"i32(globalId.z)"};
      let batchA = ${r||!a?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${r||!a?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${r?`${Math.ceil(o/s)}`:`(uniforms.dimInner - 1) / ${s} + 1`};
      var kStart = ${r?`i32(globalId.z) * ${o}`:"0"};

      var acc : array<array<f32, ${x}>, ${y}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${y}; innerRow++) {
        for (var innerCol = 0; innerCol < ${x}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${v}
    }
  `}const The=t=>t?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function Ehe(t,e=!1){O(t[1]===1&&t[2]===1,()=>`A linear work group size is required. But got ${t}.`);const n=t[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${t[0]}>;

    ${Pe()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${n} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${n} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${The(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${n/4}; k++) {
          let rowB = t * ${n} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}let Rhe=class{constructor(e,n,s=!1,r=!1,o=null,i=null,a=null,u=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]};const l=s?e[1]:e[2];if(this.isVec4=(l%4===0&&!s||n[1]%4===0&&s)&&n[2]%4===0&&!r,this.outputComponent=this.isVec4?4:1,this.isVectorA=n[1]===1&&!s,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const d=nce(n[1],l,n[2],s);this.workgroupSize=d.workgroupSize,this.elementsPerThread=d.elementsPerThread}this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const c=o!=null,h=a!=null;c&&this.variableNames.push("bias"),h&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=u,this.transposeA=s,this.transposeB=r,this.addBias=c,this.activation=i,this.hasPreluActivationWeights=h,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(n[1],n[2],l),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${s}_${r}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,n,s){const r=this.workgroupSize[1]*this.elementsPerThread[1],o=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=o;const i=e%r===0,a=n%o===0,u=s%this.tileInner===0;return[i,a,u]}getUserCode(){return`
      ${ku(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${bE(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?DS(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?Ehe(this.workgroupSize,this.transposeA):PS(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ahe(t){return`
    var<workgroup> sumValues : array<f32, ${t}>;
    ${Pe()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${t}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${t/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class _he{constructor(e,n=!1,s=!1,r=null,o=null,i=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize);const a=r!=null,u=i!=null;a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),this.transposeA=n,this.transposeB=s,this.addBias=a,this.activation=o,this.hasPreluActivationWeights=u,this.shaderKey=`matMulReduce_${this.activation}_${n}_${s}`}getUserCode(){return`
      ${ku(this.activation,this.hasPreluActivationWeights)}
      ${bE(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${Ahe(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dhe(t){const e=t[1],n=t[0],s=e>n?e:n;return`
  var<workgroup> mm_Asub : array<array<f32, ${s}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${s}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${Pe()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${s} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${s};
    globalRowB = globalRowB + ${s};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${s};
      globalRowB = globalRowB + ${s};

      for (var k = 0; k < ${s}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class Phe{constructor(e,n,s,r=!1,o=!1,i=null,a=null,u=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=s,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(s[2]/this.workgroupSize[0]),Math.ceil(s[1]/this.workgroupSize[1]),s[0]];const l=i!=null;l&&this.variableNames.push("bias");const c=u!=null;c&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=o,this.addBias=l,this.activation=a,this.hasPreluActivationWeights=c,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${r}_${o}`}getUserCode(){return`
      ${ku(this.activation,this.hasPreluActivationWeights)}
      ${bE(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${Dhe(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fhe{constructor(e,n,s=!1,r=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,O(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const o=(s&&this.outputShape[1]%4===0||!s&&n%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=o?4:1,o||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=Fe(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],n],this.workgroupSize,this.elementsPerThread),this.transposeA=s,this.transposeB=r,this.shaderKey=`matMulSplitK_${s}_${r}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`
      ${f4(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${$t(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${Wl("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${e===4?DS(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):PS(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class Ohe{constructor(e,n=null,s=null,r=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=n!=null,this.hasPreluActivationWeights=r!=null,this.activation=s,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${s}`}getUserCode(){return`
    ${ku(this.activation,this.hasPreluActivationWeights)}
    ${Pe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${Ih(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Lhe=class{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${Pe("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pr(t){const{backend:e,attrs:n}=t,{shape:s,value:r}=n;let{dtype:o}=n;if(o=o||mh(r),o==="string"){const i=Hn(o,ie(s));return i.fill(r),e.makeTensorInfo(s,o,i)}else{const i=new Lhe(s),a=[{type:"float32",data:[r]}];return e.runWebGPUProgram(i,[],o,a)}}const Mhe={kernelName:lb,backendName:"webgpu",kernelFunc:Pr};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ye(t){const{inputs:e,attrs:n}=t,{x:s}=e,{shape:r}=n,o=ie(s.shape),i=rT(r,o),a=ie(i);return O(o===a,()=>`The new shape (${i}) has ${a} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.backend.incRef(s.dataId),{dataId:s.dataId,shape:i,dtype:s.dtype}}const zhe={kernelName:r0,backendName:"webgpu",kernelFunc:Ye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FS({a:t,b:e,transposeA:n,transposeB:s,backend:r,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){const l=t.shape.length,c=e.shape.length,h=n?t.shape[l-2]:t.shape[l-1],d=s?e.shape[c-1]:e.shape[c-2],f=n?t.shape[l-1]:t.shape[l-2],m=s?e.shape[c-2]:e.shape[c-1],y=t.shape.slice(0,-2),x=e.shape.slice(0,-2),v=ie(y),w=ie(x),k=ut(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([f,m]);O(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${s} must match.`);const I=n?[v,h,f]:[v,f,h],T=s?[w,m,d]:[w,d,m],R=Ye({inputs:{x:t},backend:r,attrs:{shape:I}}),_=Ye({inputs:{x:e},backend:r,attrs:{shape:T}}),D=[R,_],L=Math.max(v,w),V=[R,_],U=[{type:"int32",data:[f]},{type:"int32",data:[m]},{type:"int32",data:[h]}];let j,q;const J=[L,f,m];let te=ce().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(te<0){const K=ce().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),re=K>0?K:r.thresholdToIncreaseWorkgroups,pe=L*Math.ceil(f/32)*Math.ceil(m/32);pe<=re||f<=8&&pe<=re*2?L*f*m<=128?te=la.MatMulReduceProgram:L===1&&d>=2e3?te=la.MatMulSplitKProgram:te=la.MatMulSmallOutputSizeProgram:te=la.MatMulPackedProgram}switch(te){case la.MatMulReduceProgram:j=new _he(J,n,s,o,u,i);break;case la.MatMulSplitKProgram:{if(q=Pr({backend:r,attrs:{shape:J,value:0,dtype:t.dtype}}),j=new Fhe(J,d,n,s),o||u){q=r.runWebGPUProgram(j,V,t.dtype,U,q);const re=new Ohe(q.shape,o,u,i);let pe=null;const he=[q];o&&he.push(o),i&&he.push(i),u==="leakyrelu"&&(pe=[{type:"float32",data:[a]}],re.uniforms+=" alpha : f32,");const xe=r.runWebGPUProgram(re,he,q.dtype,pe);D.push(q);const Ce=Ye({inputs:{x:xe},backend:r,attrs:{shape:k}});D.push(xe);for(const Ee of D)r.disposeData(Ee.dataId);return Ce}break}case la.MatMulSmallOutputSizeProgram:j=new Phe(I,T,J,n,s,o,u,i);break;case la.MatMulPackedProgram:const K=r.adapterInfo.isIntel();j=new Rhe(I,J,n,s,o,u,i,K);break;default:throw new Error(`Unsupported MatMulProgramType ${te}.`)}o&&V.push(o),i&&V.push(i),u==="leakyrelu"&&(U.push({type:"float32",data:[a]}),j.uniforms+=" alpha : f32,"),q=r.runWebGPUProgram(j,V,t.dtype,U,q);const le=Ye({inputs:{x:q},backend:r,attrs:{shape:k}});D.push(q);for(const K of D)r.disposeData(K.dataId);return le}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bhe(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:o,bias:i,preluActivationWeights:a}=e,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:h}=s;return FS({a:r,b:o,transposeA:u,transposeB:l,backend:n,bias:i,preluActivationWeights:a,leakyreluAlpha:h,activation:c})}const Vhe={kernelName:Bg,backendName:"webgpu",kernelFunc:Bhe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let F3=class{constructor(e,n,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=ut(n,s),this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${wE(this.op,!1)}
      }

      ${Pe("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Gv=class{constructor(e,n,s){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=ut(n,s),this.dispatchLayout=Ve(this.outputShape),this.op=e,this.useSharedMemoryWithA=n.length<=1&&s.length>1&&n[0]<128,this.useSharedMemoryWithB=s.length<=1&&n.length>1&&s[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?s[0]:n[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const r=n.length>0&&n[n.length-1]%4===0,o=s.length>0&&s[s.length-1]%4===0;r&&o?(this.outputComponent=4,this.variableComponents=[4,4]):r&&(jD(s)||s[s.length-1]===1)||o&&(jD(n)||n[n.length-1]===1)?(this.outputComponent=4,this.variableComponents=r?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const n=this.outputComponent===4?"vec4<f32>":"f32",s=`
    fn binaryOperation(a : ${n}, b : ${n}) -> ${n} {
      ${wE(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const r=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",o=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${r}];`:`let a = sharedBuf[${r}];
          let b = getBByOutputIndex(index);`;e=`
        ${s}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${Pe("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${o}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${s}
       ${Pe("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${n}(getAByOutputCoords(coords));
           let b = ${n}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uo(t){const{inputs:e}=t,{x:n}=e;return t.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const Whe={kernelName:Yp,backendName:"webgpu",kernelFunc:uo};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $h(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,o=n.makeTensorInfo(s.shape,"complex64"),i=n.tensorMap.get(o.dataId),a=uo({inputs:{x:s},backend:n}),u=uo({inputs:{x:r},backend:n});return i.complexTensorInfos={real:a,imag:u},o}const Uhe={kernelName:qw,backendName:"webgpu",kernelFunc:$h};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let _f=class{constructor(e,n,s=""){this.variableNames=["A"],this.size=!0;const r=128;this.workgroupSize=[r,1,1],this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=n,s!==""&&(this.uniforms=s),this.shaderKey=`unary_${n}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${bc(this.op,!1)}
      }
      ${Pe("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ht({opType:t,cpuKernelImpl:e,dtype:n}){return({inputs:s,backend:r})=>{const{x:o}=s,i=r,a=n||o.dtype;if(i.shouldExecuteOnCPU([o])&&e!=null){const l=i.tensorMap.get(o.dataId),c=e(l.values,a);return i.makeTensorInfo(o.shape,a,c)}const u=new _f(o.shape,t);return i.runWebGPUProgram(u,[o],a)}}function Ds({opType:t,cpuKernelImpl:e,supportsComplex:n=!1,dtype:s}){return({inputs:r,backend:o})=>{const{a:i,b:a}=r,u=o;if(n&&i.dtype==="complex64"){const h=u.tensorMap.get(i.dataId),d=u.tensorMap.get(a.dataId);let f,m;if(t!==ft.MUL)[f,m]=[[h.complexTensorInfos.real,d.complexTensorInfos.real],[h.complexTensorInfos.imag,d.complexTensorInfos.imag]].map(x=>{const[v,w]=x,S={dataId:v.dataId,dtype:v.dtype,shape:i.shape},k={dataId:w.dataId,dtype:w.dtype,shape:a.shape},I=new Gv(t,i.shape,a.shape);return u.runWebGPUProgram(I,[S,k],_s(v.dtype,w.dtype))});else{const x=new F3(ft.COMPLEX_MULTIPLY_REAL,i.shape,a.shape),v=new F3(ft.COMPLEX_MULTIPLY_IMAG,i.shape,a.shape),w=[{dataId:h.complexTensorInfos.real.dataId,dtype:h.complexTensorInfos.real.dtype,shape:i.shape},{dataId:h.complexTensorInfos.imag.dataId,dtype:h.complexTensorInfos.imag.dtype,shape:i.shape},{dataId:d.complexTensorInfos.real.dataId,dtype:d.complexTensorInfos.real.dtype,shape:a.shape},{dataId:d.complexTensorInfos.imag.dataId,dtype:d.complexTensorInfos.imag.dtype,shape:a.shape}];f=u.runWebGPUProgram(x,w,"float32"),m=u.runWebGPUProgram(v,w,"float32")}const y=$h({inputs:{real:f,imag:m},backend:u});return u.disposeData(f.dataId),u.disposeData(m.dataId),y}const l=s||_s(i.dtype,a.dtype);if((i.dtype==="string"||a.dtype==="string"||u.shouldExecuteOnCPU([i,a]))&&e!=null){const h=u.tensorMap.get(i.dataId).values,d=u.tensorMap.get(a.dataId).values,f=i.dtype==="string"?Hi(h):h,m=i.dtype==="string"?Hi(d):d,[y,x]=e(i.shape,a.shape,f,m,l);return u.makeTensorInfo(x,l,y)}const c=new Gv(t,i.shape,a.shape);return u.runWebGPUProgram(c,[i,a],l)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ze(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&O(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m4(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}const Ghe=t=>{const{x:e}=t.inputs,n=t.backend;Ze(e,"abs");let s=new Float32Array(ie(e.shape));const r=n.data.get(e.dataId).values;return s=m4(r),n.makeOutput(s,e.shape,e.dtype)},Hhe={kernelName:gy,backendName:"cpu",kernelFunc:Ghe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ns(t){return(e,n,s,r,o)=>{const i=ut(e,n),a=i.length,u=et(i),l=ie(i),c=ws(o,l),h=e.length,d=n.length,f=et(e),m=et(n),y=Sl(e,i),x=Sl(n,i);if(y.length+x.length===0)for(let v=0;v<c.length;++v)c[v]=t(s[v%s.length],r[v%r.length]);else for(let v=0;v<c.length;++v){const w=Ep(v,a,u),S=w.slice(-h);y.forEach(R=>S[R]=0);const k=xa(S,h,f),I=w.slice(-d);x.forEach(R=>I[R]=0);const T=xa(I,d,m);c[v]=t(s[k],r[T])}return[c,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jr(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,o=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values,a=n.makeTensorInfo(s.shape,"complex64"),u=n.data.get(a.dataId);return u.complexTensorInfos={real:n.makeTensorInfo(s.shape,"float32",o),imag:n.makeTensorInfo(r.shape,"float32",i)},a}const jhe={kernelName:qw,backendName:"cpu",kernelFunc:Jr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hv(t,e,n="float32"){if(n==="complex64"){const r=Hv(t,e,"float32"),o=Hv(t,e,"float32");return Jr({inputs:{real:r,imag:o},backend:t})}const s=Vs(ie(e),n);return t.makeTensorInfo(e,n,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ka(t){const{inputs:e,backend:n}=t,{x:s}=e;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const Khe={kernelName:Yp,backendName:"cpu",kernelFunc:ka};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uh(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.data.get(s.dataId).complexTensorInfos.real,o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}const Xhe={kernelName:Cb,backendName:"cpu",kernelFunc:uh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g4(t,e,n,s){if(s==="int32"){const r=Int32Array.from(t);return[e,"int32",r]}if(s==="bool"){const r=xh([0],n),[o,i]=ns((a,u)=>a!==u?1:0)(e,[],t,r,"bool");return[i,"bool",o]}throw new Error(`Error in Cast: failed to cast ${n} to ${s}`)}function Il(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dtype:o}=s;if(o==="complex64"){if(r.dtype==="complex64")return ka({inputs:{x:r},backend:n});const c=Hv(n,r.shape,r.dtype),h=Il({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),d=Jr({inputs:{real:h,imag:c},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),d}if(r.dtype==="complex64"){const c=uh({inputs:{input:r},backend:n}),h=Il({inputs:{x:c},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(c),h}if(!oT(r.dtype,o)){const c=ka({inputs:{x:r},backend:n});return{dataId:c.dataId,shape:c.shape,dtype:o}}const i=n.data.get(r.dataId).values,[a,u,l]=g4(i,r.shape,r.dtype,o);return n.makeTensorInfo(a,u,l)}const qhe={kernelName:Lp,backendName:"cpu",kernelFunc:Il};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cs(t,e,n,s){return n==null?({inputs:r,backend:o})=>{const{a:i,b:a}=r,u=o;Ze([i,a],t);const l=u.data.get(i.dataId).values,c=u.data.get(a.dataId).values,h=i.dtype==="string"?Hi(l):l,d=i.dtype==="string"?Hi(c):c,f=s||i.dtype,[m,y]=e(i.shape,a.shape,h,d,f);return u.makeTensorInfo(y,f,m)}:({inputs:r,backend:o})=>{const{a:i,b:a}=r,u=o;if(i.dtype==="complex64"||a.dtype==="complex64"){const l=Il({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),c=u.data.get(l.dataId),h=c.complexTensorInfos.real,d=c.complexTensorInfos.imag,f=u.data.get(h.dataId).values,m=u.data.get(d.dataId).values,y=Il({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),x=u.data.get(y.dataId),v=x.complexTensorInfos.real,w=x.complexTensorInfos.imag,S=u.data.get(v.dataId).values,k=u.data.get(w.dataId).values,[I,T,R]=n(i.shape,a.shape,f,m,S,k),_=u.makeTensorInfo(R,"float32",I),D=u.makeTensorInfo(R,"float32",T),L=Jr({inputs:{real:_,imag:D},backend:u});return u.disposeIntermediateTensorInfo(l),u.disposeIntermediateTensorInfo(y),u.disposeIntermediateTensorInfo(_),u.disposeIntermediateTensorInfo(D),L}else{const l=u.data.get(i.dataId).values,c=u.data.get(a.dataId).values,h=s||i.dtype,[d,f]=e(i.shape,a.shape,l,c,h);return u.makeTensorInfo(f,h,d)}}}function SE(t){return(e,n,s,r,o,i)=>{const a=ut(e,n),u=ie(a),l=a.length,c=et(a),h=ws("float32",u),d=ws("float32",u),f=Sl(e,a),m=Sl(n,a),y=Gi(s,r),x=Gi(o,i),v=e.length,w=et(e),S=n.length,k=et(n);if(f.length+m.length===0)for(let I=0;I<h.length;I++){const T=I%y.length,R=I%x.length,_=t(y[T*2],y[T*2+1],x[R*2],x[R*2+1]);h[I]=_.real,d[I]=_.imag}else for(let I=0;I<h.length;I++){const T=Ep(I,l,c),R=T.slice(-v);f.forEach(U=>R[U]=0);const _=xa(R,v,w),D=T.slice(-S);m.forEach(U=>D[U]=0);const L=xa(D,S,k),V=t(y[_*2],y[_*2+1],x[L*2],x[L*2+1]);h[I]=V.real,d[I]=V.imag}return[h,d,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y4=ns((t,e)=>t+e),Yhe=SE((t,e,n,s)=>({real:t+n,imag:e+s})),fp=Cs(gh,y4,Yhe),Qhe={kernelName:gh,backendName:"cpu",kernelFunc:fp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CE(t,e,n,s,r){const o=ie(s),i=Vs(r,n);for(let a=0;a<t.length;a++){const u=t[a];if(u<0)throw new Error("Input x must be non-negative!");u>=r||(o>0?i[u]+=e[a]:i[u]+=1)}return i}function x4(t,e,n,s=!1){const r=t.shape[0],o=t.shape[1],i=xt([r,n],e.dtype);for(let a=0;a<r;a++)for(let u=0;u<o;u++){const l=t.get(a,u);if(l<0)throw new Error("Input x must be non-negative!");l>=n||(s?i.set(1,a,l):e.size>0?i.set(i.get(a,l)+e.get(a,u),a,l):i.set(i.get(a,l)+1,a,l))}return i}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v4=ns((t,e)=>t&e),Zhe=Cs(Kw,v4),Jhe={kernelName:Kw,backendName:"cpu",kernelFunc:Zhe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aa(t){return(e,n,s)=>{const r=Hn(n,e.length);for(let o=0;o<e.length;++o)r[o]=t(e[o],s);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sn(t,e,n){const s=Aa(e);return Ul(t,s,n)}function Ul(t,e,n){return({inputs:s,attrs:r,backend:o})=>{const{x:i}=s;Ze(i,t);const a=o,u=a.data.get(i.dataId).values;let l;if(i.dtype==="string"){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");l=Hi(u)}else l=u;const c=n||i.dtype,h=e(l,c,r);return a.makeTensorInfo(i.shape,c,h)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w4=Aa(t=>Math.ceil(t)),ede=Ul(Mp,w4),tde={kernelName:Mp,backendName:"cpu",kernelFunc:ede};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b4(t,e,n,s){const r=Hn(n,ie(e));if(s&&n!=="string"){let o=0;t.forEach(i=>{const a=ie(i.shape);r.set(i.vals,o),o+=a})}else{let o=0;t.forEach(i=>{const a=n==="string"?Hi(i.vals):i.vals;let u=0;for(let l=0;l<i.shape[0];++l){const c=l*e[1]+o;for(let h=0;h<i.shape[1];++h)r[c+h]=a[u++]}o+=i.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S4=ns((t,e)=>t===e?1:0),C4=Cs(_y,S4,null,"bool"),nde={kernelName:_y,backendName:"cpu",kernelFunc:C4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k4=Aa(t=>Math.exp(t)),I4=Ul(Hp,k4,"float32"),sde={kernelName:Hp,backendName:"cpu",kernelFunc:I4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $4=Aa(t=>Math.expm1(t)),rde=Ul(jp,$4),ode={kernelName:jp,backendName:"cpu",kernelFunc:rde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N4=Aa(t=>Math.floor(t)),ide=Ul(Kp,N4),ade={kernelName:Kp,backendName:"cpu",kernelFunc:ide};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T4=ns((t,e)=>Math.floor(t/e)),ude=Cs(Xp,T4,null,"int32"),lde={kernelName:Xp,backendName:"cpu",kernelFunc:ude};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E4(t,e,n,s,r,o,i,a,u){const l=xt([s,o],n);for(let c=0;c<s;c++){const h=[];let d=0;for(let f=0;f<r;f++){const m=t[c*r+f];d+=m*i[f],h.push(m)}if(d<0||d>=u/o)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let f=0;f<o;f++)l.values[c*o+f]=e.get(...e.indexToLoc(d*o+f))}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R4(t,e,n){const s=xt(n,t.dtype);for(let r=0;r<s.size;++r){const i=s.indexToLoc(r).slice(),a=i[0],u=i[2],l=e.locToIndex([a,u]);i[2]=e.values[l];const c=t.locToIndex(i);0<=c&&c<t.values.length&&(s.values[r]=t.values[c])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A4=ns((t,e)=>t>e?1:0),cde=Cs(Oy,A4,null,"bool"),hde={kernelName:Oy,backendName:"cpu",kernelFunc:cde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _4=ns((t,e)=>t>=e?1:0),dde=Cs(qp,_4,null,"bool"),pde={kernelName:qp,backendName:"cpu",kernelFunc:dde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D4=ns((t,e)=>t<e?1:0),fde=Cs(My,D4,null,"bool"),mde={kernelName:My,backendName:"cpu",kernelFunc:fde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P4=ns((t,e)=>t<=e?1:0),gde=Cs(zy,P4,null,"bool"),yde={kernelName:zy,backendName:"cpu",kernelFunc:gde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F4(t,e,n){const s=(e-t)/(n-1),r=Vs(n,"float32");r[0]=t;for(let o=1;o<r.length;o++)r[o]=r[o-1]+s;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O4=Aa(t=>Math.log(t)),xde=Ul(ef,O4),vde={kernelName:ef,backendName:"cpu",kernelFunc:xde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L4(t,e,n,s){const r=ws(s,ie(n));for(let o=0;o<r.length;++o){const i=o*e;let a=t[i];for(let u=0;u<e;++u){const l=t[i+u];(Number.isNaN(l)||l>a)&&(a=l)}r[o]=a}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M4=ns((t,e)=>Math.max(t,e)),wde=Cs(nf,M4),bde={kernelName:nf,backendName:"cpu",kernelFunc:wde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z4=ns((t,e)=>Math.min(t,e)),Sde=Cs(sf,z4),Cde={kernelName:sf,backendName:"cpu",kernelFunc:Sde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kE=ns((t,e)=>t*e),kde=SE((t,e,n,s)=>({real:t*n-e*s,imag:t*s+e*n})),OS=Cs(of,kE,kde),Ide={kernelName:of,backendName:"cpu",kernelFunc:OS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B4(t,e,n){const s=Ol(-1,n);return kE([],e,s,t,n)}function $de(t){const{inputs:e,backend:n}=t,{x:s}=e;Ze(s,"neg");const r=n.data.get(s.dataId).values,[o,i]=B4(r,s.shape,s.dtype);return n.makeTensorInfo(i,s.dtype,o)}const Nde={kernelName:Yy,backendName:"cpu",kernelFunc:$de};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V4=ns((t,e)=>t!==e?1:0),Tde=Cs(Qy,V4,null,"bool"),Ede={kernelName:Qy,backendName:"cpu",kernelFunc:Tde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IE(t,e,n,s,r){const o=e.length,i=ie(e),a=et(e),u=et(r),l=ws(n,ie(r));for(let c=0;c<i;++c){const h=Ep(c,o,a),d=new Array(h.length);for(let m=0;m<d.length;m++)d[m]=h[s[m]];const f=xa(d,o,u);l[f]=t[c]}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lr(t){const{inputs:e,attrs:n,backend:s}=t,{x:r}=e,{perm:o}=n;Ze(r,"transpose");const i=r.shape.length,a=new Array(i);for(let h=0;h<a.length;h++)a[h]=r.shape[o[h]];const u=s.data.get(r.dataId).values,l=IE(u,r.shape,r.dtype,o,a);return{dataId:s.write(l,a,r.dtype),shape:a,dtype:r.dtype}}const Rde={kernelName:Wc,backendName:"cpu",kernelFunc:Lr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W4(t,e,n,s){const[r,o]=ts(t,s),i=_s(e,"int32"),a=Vs(ie(r),i),u=ie(o);for(let l=0;l<a.length;++l){const c=l*u;let h=1;for(let d=0;d<u;++d)h*=n[c+d];a[l]=h}return{outVals:a,outShape:r,outDtype:i}}function Ade(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:i}=s;Ze(r,"prod");const a=r.shape.length,u=vt(o,r.shape),l=cn(u,a);let c=u,h=r;const d=[];l!=null&&(h=Lr({inputs:{x:r},backend:n,attrs:{perm:l}}),d.push(h),c=Sn(c.length,a));const f=n.data.get(h.dataId).values,{outVals:m,outShape:y,outDtype:x}=W4(h.shape,h.dtype,f,c);let v=y;return i&&(v=qn(y,u)),d.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.makeTensorInfo(v,x,m)}const _de={kernelName:s0,backendName:"cpu",kernelFunc:Ade};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dde(t,e,n){t.forEach((s,r)=>{if(s<0||s>=n){const o=Ep(r,e.length,et(e)).join(",");throw new Error(`indices[${o}] = ${s} is not in [0, ${n})`)}})}function Pde(t,e){for(let n=0;n<t.length;++n){const s=t[n],r=n===t.length-1?e:t[n+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let o=1;o<s.length;++o)if(s[o-1]>s[o])throw new Error("Ragged splits must be sorted in ascending order")}}function Fde(t,e,n,s){const r=[];let o=0;const i=e.length-1+n.length,a=new Array(i).fill(null).map(()=>[0]);Pde(n,s);let u=1;for(let l=0;l<e.length-1;++l){u*=e[l];const c=e[l+1];for(let h=1;h<u+1;++h)a[l].push(h*c)}for(let l=0;l<t.length;++l){let c=t[l],h=t[l]+1;for(let d=0;d<n.length;++d){const f=n[d],m=d+e.length-1;if(m>=0){const y=a[m],x=y[y.length-1]-f[c];for(let v=c;v<h;++v)a[m].push(f[v+1]+x)}c=f[c],h=f[h]}h!==c&&(r.push([c,h]),o+=h-c)}return{outSplits:a,valueSlices:r,numValues:o}}function Ode(t){const e=[];for(let n=0;n<t.length;++n){const s=t[n].length,r=Hn("int32",s);e.push(r),t[n].forEach((o,i)=>r[i]=o)}return e}function O3(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let s=e;s<t.length;s++)n[e-1]*=t[s];return n}function Lde(t,e,n,s,r,o){const i=O3(e,2)[1],a=O3(o,2)[1];let u=0;for(const l of n)for(let c=l[0];c<l[1];++c){for(let h=0;h<s;++h)r[u*a+h]=t[c*i+h];++u}}function Mde(t,e,n,s,r){const o=e.slice();o[0]=r;const i=Hn(n,ie(o)),a=t.length,u=a===0?0:a/e[0];return Lde(t,e,s,u,i,o),[i,o]}function U4(t,e,n,s,r,o,i,a){if(t.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const u=e[0][0]-1;if(Dde(o,i,u),s.length===0)throw new Error("params.rank must be nonzero");const l=s[0],{outSplits:c,valueSlices:h,numValues:d}=Fde(o,i,t,l),f=Ode(c),m=Mde(n,s,r,h,d);return[f,m[0],m[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L3=2147483647;function G4(t,e,n,s,r,o,i){if(e.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,u=r.length===0,l=i.length===0,c=[];a||c.push(e[0]),u||c.push(r[0]),l||c.push(i[0]);for(let x=1;x<c.length;++x)if(c[x]!==c[x-1])throw new Error("starts, limits, and deltas must have the same shape");const h=c.length===0?1:c[0],d=Hn("int32",h+1);d[0]=0;for(let x=0;x<h;++x){const v=a?t[0]:t[x],w=u?s[0]:s[x],S=l?o[0]:o[x];if(S===0)throw new Error("Requires delta != 0");let k;if(S>0&&w<v||S<0&&w>v)k=0;else if(k=Math.ceil(Math.abs((w-v)/S)),k>L3)throw new Error(`Requires ((limit - start) / delta) <= ${L3}`);d[x+1]=d[x]+k}const f=d[h],m=Hn(n,f);let y=0;for(let x=0;x<h;++x){const v=d[x+1]-d[x];let w=a?t[0]:t[x];const S=l?o[0]:o[x];for(let k=0;k<v;++k)m[y++]=w,w+=S}return[d,m]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var qo=Fi;class jv{constructor(e,n,s,r,o,i,a,u,l,c){this.shape=e,this.shapeShape=n,this.values=s,this.valuesShape=r,this.valuesDType=o,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=u,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=MV(c),this.raggedRank=zV(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===qo.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===qo.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const n=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case qo.VALUE_ROWIDS:return jv.getMaxWidthValueRowID(n);case qo.ROW_SPLITS:return jv.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${qo[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const n=e.length;if(n===0||n===1)return 0;let s=0;for(let r=0;r<n-1;++r){const o=e[r+1]-e[r];o>s&&(s=o)}return s}static getMaxWidthValueRowID(e){const n=e.length;if(n===0)return 0;let s=0,r=e[0],o=0;for(let i=1;i<n;++i){const a=e[i];a!==r&&(r=a,o=Math.max(i-s,o),s=i)}return Math.max(n-s,o)}tensorShapeFromTensor(e,n,s=!0){if(n.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return z3(e,s)}calculateOutputSize(e){const n=this.valuesShape,s=this.defaultValueShape;BV(s,n);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=LV(this.raggedRank,r,n);i[0]<0&&(i[0]=e);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(e,n,s){const r=Math.min(e,s),o=[];let i=0;for(let a=0;a<r;++a,i+=n)o.push(i);for(let a=r;a<e;++a)o.push(-1);return O(o.length===e,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(e,n,s,r){const o=e.length,i=[];for(let a=0;a<o-1;++a){const u=e[a+1]-e[a];let l=Math.min(r,u),c=n[a];c===-1&&(l=0);for(let h=0;h<l;++h)i.push(c),c+=s;for(let h=0;h<u-l;++h)i.push(-1)}if(o>0&&i.length!==e[o-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,n,s,r){const o=e.length,i=[];if(o===0)return[];let a=0,u=e[0];if(u>=n.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${n.length}`);let l=n[u];i.push(l);for(let c=1;c<o;++c){const h=e[c];if(h===u)l>=0&&(++a,a<r?l+=s:l=-1);else{if(a=0,u=h,h>=n.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${n.length}`);l=n[h]}i.push(l)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,n,s,r){const o=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case qo.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,n,s,r);case qo.ROW_SPLITS:if(o.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(o,n,s,r);default:throw new Error(`Unsupported partition type: ${qo[i]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case qo.FIRST_DIM_SIZE:return e[0];case qo.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case qo.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${qo[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),s=this.calculateOutputSize(n),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let u=r.length-2;u>=0;--u)r[u]=r[u+1]*s[u+1];const o=z3(s,!1),i=Hn(this.valuesDType,ie(o));if(r[0]*s[0]>0){let u=this.calculateFirstParentOutputIndex(n,r[0],s[0]);for(let l=1;l<=this.raggedRank;++l)u=this.calculateOutputIndex(l-1,u,r[l],s[l]);this.setOutput(this.raggedRank,u,i,o)}return[o,i]}setOutput(e,n,s,r){if(s.length===0)return;const o=this.values,i=s;let a=r.slice();a=a.slice(e+1);const u=ie(a),l=n.length;let c=this.defaultValue;if(c.length!==u&&c.length!==1){const m=this.defaultValueShape;ae(()=>{const y=ee(c,m);c=Kd(y,a).dataSync()})}let h=0,d=0,f=0;for(let m=0;m<=l;++m){let y=m<l?n[m]:-1;if(y===f){++f;continue}if(d<f){const x=o.subarray(h*u),v=i.subarray(d*u),w=(f-d)*u;M3(v,x,w)}if(m>=l){const x=s.length;y=Math.floor(x/u)}if(y>f)if(this.defaultValue.length===1)i.subarray(f*u,y*u).fill(this.defaultValue[0]),f=y;else for(;y>f;){const x=i.slice(f*u);M3(x,c,u),++f}y<0?(h=m+1,d=f):(h=m,d=f,f=d+1)}}}function M3(t,e,n){for(let s=0;s<n;s++)t[s]=e[s]}function z3(t,e){const n=[];for(let s of t){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}n.push(s)}return n}function H4(t,e,n,s,r,o,i,a,u,l){return new jv(t,e,n,s,r,o,i,a,u,l).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j4(t,e,n,s){const r=t===e,o=t<e&&n<0,i=e<t&&n>1;if(r||o||i)return Vs(0,s);const a=Math.abs(Math.ceil((e-t)/n)),u=Vs(a,s);e<t&&n===1&&(n=-1),u[0]=t;for(let l=1;l<u.length;l++)u[l]=u[l-1]+n;return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K4=Aa(t=>1/Math.sqrt(t)),zde=Ul(df,K4),Bde={kernelName:df,backendName:"cpu",kernelFunc:zde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oc(t,e,n,s,r,o,i,a,u,l){const c=[s/r,r],h=t.values,d=e.values;if(s===0)return xt(n,e.dtype);const f=u instanceof ys?u:xt(c,e.dtype);typeof u=="string"||typeof u=="number"?f.values.fill(u):typeof u=="boolean"&&f.values.fill(+u);for(let m=0;m<o;m++){const y=[];let x=0;for(let v=0;v<i;v++){const w=h[m*i+v];y.push(w),x+=w*a[v]}if(x<0||x>=s/r)throw new Error(`Invalid indices: ${y} does not index into ${n}`);for(let v=0;v<r;v++)l?f.values[x*r+v]+=d[m*r+v]:f.values[x*r+v]=e.rank===0?d[0]:d[m*r+v]}return f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vde=Aa(t=>1/(1+Math.exp(-t))),X4=sn(yf,t=>1/(1+Math.exp(-t))),Wde={kernelName:yf,backendName:"cpu",kernelFunc:X4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q4(t,e,n,s,r){const o=fE(s,e,n),i=ie(n),a=et(s);if(o){const h=mE(e,a);return r==="string"?t.slice(h,h+i):t.subarray(h,h+i)}const u=r==="string"?Hi(t):t,l=xt(s,r,u),c=xt(n,r);for(let h=0;h<c.size;++h){const d=c.indexToLoc(h),f=d.map((m,y)=>m+e[y]);c.set(l.get(...f),...d)}return r==="string"?o4(c.values):c.values}function lh(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:o,size:i}=s;Ze(r,"slice");const[a,u]=k0(r,o,i);dS(r,a,u);const l=n.data.get(r.dataId).values,c=q4(l,a,u,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,c)}const Ude={kernelName:l0,backendName:"cpu",kernelFunc:lh};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y4(t,e,n,s,r,o,i){const a=e[0],u=o[0],l=new Array(u),c=new Array(a),h=e[1];if(u===0){if(a!==0)throw new Error(KV(a));const x=Hn(n,0),v=Hn(r,0);return[x,[0,h],v,l,c]}let d=!0,f=0;const m=new Array(u).fill(0);for(let x=0;x<a;++x){const v=t[x*h];if(v<0)throw new Error(XV(x,v));if(v>=u)throw new Error(qV(x,v,u));++m[v],d=d&&v>=f,f=v}let y=!0;for(let x=0;x<u;++x){const v=m[x]===0;l[x]=v,y=y&&!v,m[x]=Math.max(m[x],1),x>0&&(m[x]+=m[x-1])}if(y&&d){const x=t,v=s;for(let w=0;w<a;++w)c[w]=w;return[x,[a,h],v,l,c]}else{const x=m[u-1],v=Hn(n,x*h),w=Hn(r,x),S=new Array(u).fill(0);for(let k=0;k<a;++k){const I=t[k*h],T=S[I],R=(I===0?0:m[I-1])+T;S[I]++;for(let _=0;_<h;++_)v[R*h+_]=t[k*h+_];w[R]=s[k],c[k]=R}for(let k=0;k<u;++k)if(S[k]===0){const T=k===0?0:m[k-1];v[T*h+0]=k;for(let R=1;R<h;++R)v[T*h+R]=0;w[T]=i}return[v,[x,h],w,l,c]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q4(t,e,n,s,r){const o=ie(s),i=e[0],a=r.length,u=[];let l=1,c=-1;for(let x=0;x<a;++x){const v=r[x];if(v===-1){if(c!==-1)throw new Error(YV(c,x));c=x,u.push(1)}else{if(v<0)throw new Error(QV(x,v));l*=v,u.push(v)}}if(c!==-1){if(l<=0)throw new Error(ZV());const x=Math.trunc(o/l);if(l*x!==o)throw new Error(JV(s,u));u[c]=x}if(ie(u)!==o)throw new Error(e4(s,u));const d=s.length,f=[];if(d>0){f[d-1]=1;for(let x=d-2;x>=0;--x)f[x]=f[x+1]*s[x+1]}const m=[];if(a>0){m[a-1]=1;for(let x=a-2;x>=0;--x)m[x]=m[x+1]*u[x+1]}const y=Hn(n,i*a);for(let x=0;x<i;++x){let v=0;for(let w=0;w<d;++w)v+=t[x*d+w]*f[w];for(let w=0;w<a;++w)y[x*a+w]=Math.trunc(v/m[w]),v%=m[w]}return[y,[i,a],u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $E(t,e,n,s,r,o=!1,i=0){const a=s.length,u=[e[0],t.length/e[0]],l=u[1],h=a>0?r[a-1]+1:0;if(h<0)throw new Error(u$());const d=e.slice();d[0]=h;const f=d.reduce((S,k)=>S*k,1),m=Hn(n,f);if(a===0)return h>0&&m.fill(i),[m,d];if(h<=0)throw new Error(u$());let y=0,x=1,v=0,w=r[y];for(;;){let S=0;if(x<a){if(S=r[x],w===S){++x;continue}if(w>=S)throw new Error(t4())}if(w<0||w>=h)throw new Error(n4(w,h));w>v&&m.fill(i,v*l,w*l);for(let k=y;k<x;++k){const I=s[k];if(I<0||I>=u[0])throw new Error(s4(k,s[k],u[0]));for(let T=0;T<l;T++)m[w*l+T]+=t[I*l+T]}if(o)for(let k=0;k<l;k++)m[w*l+k]/=x-y;if(y=x,++x,v=w+1,w=S,x>a)break}return v<h&&m.fill(i,v*l,h*l),[m,d]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gde=Aa(t=>Math.sqrt(t)),Hde=sn(vf,t=>Math.sqrt(t)),jde={kernelName:vf,backendName:"cpu",kernelFunc:Hde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z4=ns((t,e)=>{const n=t-e;return n*n}),Kde=Cs(wf,Z4),Xde={kernelName:wf,backendName:"cpu",kernelFunc:Kde};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J4=Aa((t,e)=>{const{pattern:n,replaceGlobal:s,rewrite:r}=e;return t.replace(new RegExp(n,s?"g":""),r)}),qde=Ul(Db,J4),Yde={kernelName:Db,backendName:"cpu",kernelFunc:qde};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eW(t,e,n,s){const r=xt(t,e.dtype);for(let o=0;o<r.size;o++){const i=r.indexToLoc(o),a=new Array(i.length);for(let u=0;u<a.length;u++)a[u]=i[u]*n[u]+s[u];r.set(e.get(...a),...i)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qde{constructor(e,n,s,r,o,i){this.separator=iu(e),this.nGramWidths=n,this.leftPad=iu(s),this.rightPad=iu(r),this.padWidth=o,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,n){const s=this.getPadWidth(n);return Math.max(0,e+2*s-n+1)}createNGrams(e,n,s,r,o,i){for(let a=0;a<o;++a){const u=this.getPadWidth(i),l=Math.max(0,u-a),c=Math.max(0,u-(o-(a+1))),h=i-(l+c),d=n+(l>0?0:a-u);let f=0;f+=l*this.leftPad.length;for(let w=0;w<h;++w)f+=e[d+w].length;f+=c*this.rightPad.length;const m=l+c+h-1;f+=m*this.separator.length,s[r+a]=new Uint8Array(f);const y=s[r+a];let x=0;const v=w=>w.forEach(S=>y[x++]=S);for(let w=0;w<l;++w)v(this.leftPad),v(this.separator);for(let w=0;w<h-1;++w)v(e[d+w]),v(this.separator);if(h>0){v(e[d+h-1]);for(let w=0;w<c;++w)v(this.separator),v(this.rightPad)}else{for(let w=0;w<c-1;++w)v(this.rightPad),v(this.separator);v(this.rightPad)}}}compute(e,n){const s=e.length,r=n.length;if(r>0){let u=n[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let l=1;l<r;++l){let c=n[l]>=u;if(c=c&&n[l]<=s,!c)throw new Error(`Invalid split value ${n[l]}, must be in [${u}, ${s}]`);u=n[l]}if(u!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${u}`)}const o=r-1,i=Hn("int32",r);if(s===0||r===0){const u=new Array(s);for(let l=0;l<=o;++l)i[l]=0;return[u,i]}i[0]=0;for(let u=1;u<=o;++u){const l=n[u]-n[u-1];let c=0;this.nGramWidths.forEach(h=>{c+=this.getNumNGrams(l,h)}),this.preserveShort&&l>0&&c===0&&(c=1),i[u]=i[u-1]+c}const a=new Array(i[o]);for(let u=0;u<o;++u){const l=n[u];let c=i[u];if(this.nGramWidths.forEach(h=>{const d=n[u+1]-n[u],f=this.getNumNGrams(d,h);this.createNGrams(e,l,a,c,f,h),c+=f}),this.preserveShort&&c===i[u]){const h=n[u+1]-n[u];if(h===0)continue;const d=h+2*this.padWidth,f=1;this.createNGrams(e,l,a,c,f,d)}}return[a,i]}}function tW(t,e,n,s,r,o,i,a){return new Qde(n,s,r,o,i,a).compute(t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zde(t,e,n,s){if(!t.length)return;if(e.length===0){for(let o=0;o<t.length;++o)s.push(t.subarray(o,o+1));return}if(e.length===1){const o=e[0];let i=t.indexOf(o);for(;i!==-1;){const a=t.subarray(0,i);(!n||a.length!==0)&&s.push(a),t=t.subarray(i+1),i=t.indexOf(o)}(!n||t.length!==0)&&s.push(t);return}let r=0;for(let o=0;o<t.length+1;o++)if(o===t.length||e.indexOf(t[o])!==-1){const i=t.subarray(r,o);(!n||i.length!==0)&&s.push(i),r=o+1}}function nW(t,e,n){const s=t.length,r=[];let o=0,i=0;const a=new Array(s);for(let d=0;d<s;++d){const f=r.length;Zde(t[d],e,n,r);const m=r.length-f;a[d]=m,o+=m,i=Math.max(i,m)}const u=Hn("int32",o*2),l=new Array(o),c=[s,i];let h=0;for(let d=0;d<s;++d)for(let f=0;f<a[d];++f)u[h*2]=d,u[h*2+1]=f,l[h]=r[h],++h;return[u,l,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sW(t,e){const n=Hn("int32",t.length);for(let s=0;s<t.length;++s)n[s]=lee(t[s]).modulo(e).getLowBitsUnsigned();return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rW=ns((t,e)=>t-e),Jde=SE((t,e,n,s)=>({real:t-n,imag:e-s})),NE=Cs(bf,rW,Jde),epe={kernelName:bf,backendName:"cpu",kernelFunc:NE};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oW(t,e){const n=new Array(t.rank);for(let r=0;r<n.length;r++)n[r]=t.shape[r]*e[r];const s=xt(n,t.dtype);for(let r=0;r<s.values.length;++r){const o=s.indexToLoc(r),i=new Array(t.rank);for(let u=0;u<i.length;u++)i[u]=o[u]%t.shape[u];const a=t.locToIndex(i);s.values[r]=t.values[a]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eg=(t,e)=>{const n=e.value-t.value;return n===0?t.index-e.index:n};function iW(t,e,n=0,s=t.length-1){for(;s>n;){if(s-n>600){const a=s-n+1,u=e-n+1,l=Math.log(a),c=.5*Math.exp(2*l/3),h=.5*Math.sqrt(l*c*(a-c)/a)*Math.sign(u-a/2),d=Math.max(n,Math.floor(e-u*c/a+h)),f=Math.min(s,Math.floor(e+(a-u)*c/a+h));iW(t,e,d,f)}const r=t[e];let o=n,i=s;for(yd(t,n,e),eg(t[s],r)>0&&yd(t,n,s);o<i;){for(yd(t,o,i),o++,i--;eg(t[o],r)<0;)o=o+1;for(;eg(t[i],r)>0;)i=i-1}eg(t[n],r)===0?yd(t,n,i):(i=i+1,yd(t,i,s)),i<=e&&(n=i+1),e<=i&&(s=i-1)}}function aW(t,e,n,s,r){const o=e[e.length-1],[i,a]=[t.length/o,o],u=ws(n,i*s),l=ws("int32",i*s);for(let h=0;h<i;h++){const d=h*a,f=t.subarray(d,d+a);let m=new Array(f.length);f.forEach((w,S)=>m[S]={value:w,index:S}),s<m.length&&(iW(m,s),m=m.slice(0,s)),r&&m.sort(eg);const y=h*s,x=u.subarray(y,y+s),v=l.subarray(y,y+s);for(let w=0;w<s;w++)x[w]=m[w].value,v[w]=m[w].index}const c=e.slice();return c[c.length-1]=s,[xt(c,n,u),xt(c,"int32",l)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uW(t,e,n,s){const r=vt(e,n)[0],o=[1,n[0],1];for(let m=0;m<r;m++)o[0]*=n[m];o[1]=n[r];for(let m=r+1;m<n.length;m++)o[2]*=n[m];const i=new Map,a=new Int32Array(n[r]),u=new ys(o,s,t),l=[],c=o[0]===1&&o[2]===1;for(let m=0;m<n[r];m++){let y;if(c)y=t[m].toString();else{const v=[];for(let w=0;w<o[0];w++)for(let S=0;S<o[2];S++)v.push(u.get(w,m,S));y=v.join(",")}const x=i.get(y);if(x!=null)a[m]=x;else{const v=i.size;i.set(y,v),a[m]=v,l.push(m)}}const h=o.slice();h[1]=i.size;const d=new ys(h,s);l.forEach((m,y)=>{for(let x=0;x<o[0];x++)for(let v=0;v<o[2];v++)d.set(u.get(x,m,v),x,y,v)});const f=n.slice();return f[r]=h[1],{outputValues:d.values,outputShape:f,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lW=Object.freeze(Object.defineProperty({__proto__:null,addImpl:y4,bincountImpl:CE,bincountReduceImpl:x4,bitwiseAndImpl:v4,castImpl:g4,ceilImpl:w4,concatImpl:b4,equalImpl:S4,expImpl:k4,expm1Impl:$4,floorDivImpl:T4,floorImpl:N4,gatherNdImpl:E4,gatherV2Impl:R4,greaterEqualImpl:_4,greaterImpl:A4,lessEqualImpl:P4,lessImpl:D4,linSpaceImpl:F4,logImpl:O4,maxImpl:L4,maximumImpl:M4,minimumImpl:z4,multiplyImpl:kE,negImpl:B4,notEqualImpl:V4,prodImpl:W4,raggedGatherImpl:U4,raggedRangeImpl:G4,raggedTensorToTensorImpl:H4,rangeImpl:j4,rsqrtImpl:K4,scatterImpl:Oc,sigmoidImpl:Vde,simpleAbsImpl:m4,sliceImpl:q4,sparseFillEmptyRowsImpl:Y4,sparseReshapeImpl:Q4,sparseSegmentReductionImpl:$E,sqrtImpl:Gde,squaredDifferenceImpl:Z4,staticRegexReplaceImpl:J4,stridedSliceImpl:eW,stringNGramsImpl:tW,stringSplitImpl:nW,stringToHashBucketFastImpl:sW,subImpl:rW,tileImpl:oW,topKImpl:aW,transposeImpl:IE,uniqueImpl:uW},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:tpe,castImpl:npe,ceilImpl:spe,concatImpl:rpe,equalImpl:ope,expImpl:ipe,expm1Impl:ape,floorImpl:upe,floorDivImpl:lpe,gatherNdImpl:cpe,gatherV2Impl:hpe,greaterEqualImpl:dpe,greaterImpl:ppe,lessEqualImpl:fpe,lessImpl:mpe,logImpl:gpe,maxImpl:ype,maximumImpl:xpe,minimumImpl:vpe,multiplyImpl:wpe,negImpl:bpe,notEqualImpl:Spe,prodImpl:Cpe,rangeImpl:kpe,rsqrtImpl:Ipe,scatterImpl:$pe,simpleAbsImpl:Npe,sliceImpl:Tpe,stridedSliceImpl:Epe,stringNGramsImpl:Rpe,subImpl:Ape,tileImpl:_pe,topKImpl:Dpe,transposeImpl:Ppe,uniqueImpl:pWe}=lW;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fpe=Ht({opType:_e.ABS,cpuKernelImpl:Npe}),Ope={kernelName:gy,backendName:"webgpu",kernelFunc:Fpe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lpe=Ht({opType:_e.ACOS}),Mpe={kernelName:Rp,backendName:"webgpu",kernelFunc:Lpe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zpe=Ht({opType:_e.ACOSH}),Bpe={kernelName:Ap,backendName:"webgpu",kernelFunc:zpe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vpe=Ds({opType:ft.ADD,cpuKernelImpl:tpe,supportsComplex:!0}),Wpe={kernelName:gh,backendName:"webgpu",kernelFunc:Vpe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Upe=class{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((n,s)=>`T${s}`),this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(r=>{e.push(`let v${r} = get${r}ByOutputCoords(coords);`)});const n=this.variableNames.map(r=>`v${r}`).join(" + ");return`
      ${Pe("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${n});
          }
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gpe(t){const{inputs:e,backend:n}=t,s=e;if(s.length===1)return uo({inputs:{x:s[0]},backend:n});const r=s.map(a=>a.dtype).reduce((a,u)=>_s(a,u)),o=s.map(a=>a.shape),i=new Upe(o);return n.runWebGPUProgram(i,s,r)}const Hpe={kernelName:yy,backendName:"webgpu",kernelFunc:Gpe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jpe{constructor(e,n){this.variableNames=["A"],this.workgroupSize=[16,16,1];const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[n[r]];this.outputShape=s,this.dispatchLayout={x:[0],y:[1]},this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){O(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${Pe()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Kpe=class{constructor(e,n){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[n[r]];this.outputShape=s,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=n,this.shaderKey=`transpose_${n}`}getUserCode(){const e=es(this.outputShape.length),n=cW(this.newDim);return`
      ${Pe("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${n}), uniforms.aShape)]);
          }
        }
      }
    `}};function cW(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=new Array(e);for(let s=0;s<t.length;s++)n[t[s]]=`coords.${uu(s)}`;return n.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ia(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{perm:o}=s,i=n,a=r.shape.length,u=new Array(a);for(let c=0;c<u.length;c++)u[c]=r.shape[o[c]];if(n.shouldExecuteOnCPU([r])){const h=i.tensorMap.get(r.dataId).values,d=Ppe(h,r.shape,r.dtype,o,u);return n.makeTensorInfo(u,r.dtype,d)}if(r.shape.length===2&&kt(o,[1,0])){const c=new jpe(r.shape,o);return i.runWebGPUProgram(c,[r],r.dtype)}const l=new Kpe(r.shape,o);return i.runWebGPUProgram(l,[r],r.dtype)}const Xpe={kernelName:Wc,backendName:"webgpu",kernelFunc:Ia};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let qpe=class{constructor(e,n,s){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[r]=ts(this.inputShape,[1]);this.outputShape=r.length===0?[1]:r,e.inSize>=32768&&s>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=n,this.shaderKey=`reduce_${n}`}getUserCode(){let e="",n="0.0";const s=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,n="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",n="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",n="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",n="0.0");const r=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${s}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${Pe("index")} {
         let outputIndex = index / ${s};
         let offset = getOffset(outputIndex);
         var bestValue = ${n};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${s}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${s}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${s}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${r}
        }
       }
     `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ype={mean:"float32",all:"bool",any:"bool"};function Nh(t,e,n,s,r){const o=t.shape.length,i=[],a=vt(e,t.shape);let u=a;const l=cn(u,o);let c=t;l!=null&&(c=Ia({inputs:{x:t},attrs:{perm:l},backend:r}),u=Sn(u.length,o),i.push(c)),cs(s,u,o);const[h,d]=ts(c.shape,u);let f=h;n&&(f=qn(h,a));let m;if((s==="max"||s==="prod")&&r.shouldExecuteOnCPU([c])){const y=r.tensorMap.get(c.dataId).values;switch(s){case"max":const x=ype(y,ie(d),f,t.dtype);m=r.makeTensorInfo(f,t.dtype,x);break;case"prod":const{outVals:v,outShape:w,outDtype:S}=Cpe(c.shape,c.dtype,y,u);m=r.makeTensorInfo(w,S,v);break;default:throw new Error(`${s} CPU implementation is not yet supported.`)}}else{const y=ie(d),v=ie(c.shape)/y,w={windowSize:y,inSize:y,batchSize:v,outSize:1},S=Ype[s]||Bb(t.dtype),k=[{type:"int32",data:[y]}],I=new qpe(w,s,r.device.limits.maxComputeWorkgroupSizeX),T=r.runWebGPUProgram(I,[c],S,k);i.push(T),m=Ye({inputs:{x:T},attrs:{shape:f},backend:r})}return i.forEach(y=>r.disposeData(y.dataId)),m}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qpe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{keepDims:o,axis:i}=s;return Nh(r,i,o,"all",n)}const Zpe={kernelName:Ww,backendName:"webgpu",kernelFunc:Qpe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jpe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{keepDims:o,axis:i}=s;return Nh(r,i,o,"any",n)}const efe={kernelName:Uw,backendName:"webgpu",kernelFunc:Jpe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hW=class{constructor(e,n,s){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const r=[n];this.op=s==="min"?"<":">";const[o,i]=ts(e,r);this.outputShape=o.length===0?[1]:o,this.dispatchLayout=Ve(this.outputShape),ie(i)<32?(this.type="plain",this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=Fe(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],n=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${uu(this.inputShape.length-1)}`,s=()=>{let r="";if(this.outputShape.length===1)this.inputShape.length!==1&&(r+="outputCoords,");else for(let o=0;o<this.outputShape.length;o++)r+=`outputCoords.${uu(o)},`;return r};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${Pe("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${n()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${s()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${Pe("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${s()} 0);
          let reduceLength = ${n()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${s()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tfe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o}=s;let i=vt(o,r.shape);const a=cn(i,r.shape.length);let u=r;const l=[];a!=null&&(u=Ia({inputs:{x:r},backend:n,attrs:{perm:a}}),l.push(u),i=Sn(i.length,u.shape.length)),cs("argMax",[i[0]],u.shape.length);const c=new hW(u.shape,i[0],"max"),h=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],d=n.runWebGPUProgram(c,[u],"int32",h);return l.forEach(f=>n.disposeData(f.dataId)),d}const nfe={kernelName:xy,backendName:"webgpu",kernelFunc:tfe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sfe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o}=s;let i=vt(o,r.shape);const a=cn(i,r.shape.length);let u=r;const l=[];a!=null&&(u=Ia({inputs:{x:r},backend:n,attrs:{perm:a}}),l.push(u),i=Sn(i.length,u.shape.length)),cs("argMin",[i[0]],u.shape.length);const c=new hW(u.shape,i[0],"min"),h=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],d=n.runWebGPUProgram(c,[u],"int32",h);return l.forEach(f=>n.disposeData(f.dataId)),d}const rfe={kernelName:vy,backendName:"webgpu",kernelFunc:sfe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ofe=Ht({opType:_e.ASIN}),ife={kernelName:_p,backendName:"webgpu",kernelFunc:ofe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const afe=Ht({opType:_e.ASINH}),ufe={kernelName:Dp,backendName:"webgpu",kernelFunc:afe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lfe=Ht({opType:_e.ATAN}),cfe={kernelName:Pp,backendName:"webgpu",kernelFunc:lfe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hfe=Ds({opType:ft.ATAN2}),dfe={kernelName:Op,backendName:"webgpu",kernelFunc:hfe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pfe=Ht({opType:_e.ATANH}),ffe={kernelName:Fp,backendName:"webgpu",kernelFunc:pfe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mfe{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${Pe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Qg=class{constructor(e,n,s=!1,r=!1,o=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,n==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=n,this.computePositions=s,this.flattenPositions=r,this.includeBatchIndex=o,this.shaderKey=`pool2D_${n}_${s}_${r}_${o}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:e="resultValue = max(value, resultValue);";let n="resultValue";return this.poolType==="avg"&&(n="resultValue / max(count, 1.0)"),`
      ${Pe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${n});`}
        }
      }
    `}},TE=class{constructor(e,n,s=!1,r=!1,o=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,n==="avg"&&s)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=n,this.computePositions=s,this.flattenPositions=r,this.includeBatchIndex=o,this.shaderKey=`pool3D_${n}_${s}_${r}_${o}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue += value; count += 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:e="resultValue = max(value, resultValue);";let n="resultValue";return this.poolType==="avg"&&(n="resultValue / max(count, 1.0)"),`
      ${Pe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${n});`}
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dW(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reductionIndices:o,keepDims:i}=s;return Nh(r,o,i,"max",n)}const gfe={kernelName:Gy,backendName:"webgpu",kernelFunc:dW};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pW(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{keepDims:o,axis:i}=s;return Nh(r,i,o,"mean",n)}const yfe={kernelName:Ky,backendName:"webgpu",kernelFunc:pW};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fW(t,e,n,s){if(e.filterWidth===1&&e.filterHeight===1&&kt(e.inShape,e.outShape))return uo({inputs:{x:t},backend:s});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const i=t.shape.length,a=Ye({inputs:{x:t},backend:s,attrs:{shape:[t.shape[i-3]*t.shape[i-2],t.shape[i-1]]}});let u;n==="avg"?u=pW({inputs:{x:a},backend:s,attrs:{axis:0,keepDims:!1}}):(O(n==="max",()=>`Invalid pool type ${n}`),u=dW({inputs:{x:a},backend:s,attrs:{reductionIndices:0,keepDims:!1}}));const l=Ye({inputs:{x:u},backend:s,attrs:{shape:e.outShape}});return s.disposeData(a.dataId),s.disposeData(u.dataId),l}let r;const o=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?r=new mfe(e):(n==="avg"?r=new Qg(e,"avg"):(O(n==="max",()=>`Invalid pool type ${n}`),r=new Qg(e,"max")),o.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),s.runWebGPUProgram(r,[t],t.dtype,o)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xfe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=s,l=1,c=Js(r.shape,o,i,l,a,u);return fW(r,c,"avg",n)}const vfe={kernelName:wy,backendName:"webgpu",kernelFunc:xfe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wfe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:o,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=s,c=[1,1,1],h=Lo(r.shape,o,i,c,a,l,u),d=new TE(h,"avg"),f=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return n.runWebGPUProgram(d,[r],r.dtype,f)}const bfe={kernelName:by,backendName:"webgpu",kernelFunc:wfe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Sfe=class{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${Pe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}},Cfe=class{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${Pe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kfe(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o}=e,i=o,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=s,h=Lo(i.shape,a,u,1,l,c),d=new Cfe(h),f=1/(h.filterDepth*h.filterHeight*h.filterWidth),m=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterDepth-1-h.padInfo.front,h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outDepth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[f]}];return n.runWebGPUProgram(d,[r],i.dtype,m)}const Ife={kernelName:Hw,backendName:"webgpu",kernelFunc:kfe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $fe(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o}=e,i=o;p4([r,o],"avgPoolGrad");const{filterSize:a,strides:u,pad:l}=s,c=Js(i.shape,a,u,1,l),h=new Sfe(c),d=1/(c.filterHeight*c.filterWidth),f=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.effectiveFilterHeight-1-c.padInfo.top,c.effectiveFilterWidth-1-c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"float32",data:[d]}];return n.runWebGPUProgram(h,[r],i.dtype,f)}const Nfe={kernelName:Gw,backendName:"webgpu",kernelFunc:$fe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tfe(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:o}=e,{transposeA:i,transposeB:a}=s;return FS({a:r,b:o,transposeA:i,transposeB:a,backend:n})}const Efe={kernelName:Sy,backendName:"webgpu",kernelFunc:Tfe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Rfe=class{constructor(e,n){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.rank=n.length,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${es(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=es(this.rank),n=Afe(this.rank);let s;return this.start.length===1?s=this.outputShape.map((o,i)=>"sourceLoc = uniforms.start + coords;"):s=this.outputShape.map((o,i)=>`sourceLoc.${w$[i]} = uniforms.start.${uu(i)} + coords.${w$[i]};`),`
      ${Pe("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${s.join(`
`)}
          setOutputAtIndex(index, getSource(${n}));
        }
      }
    `}};const w$=["x","y","z","w","u","v"];function Afe(t){if(t===1)return"sourceLoc";if(t<=6)return w$.slice(0,t).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Df(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:o,size:i}=s,[a,u]=k0(r,o,i);if(dS(r,a,u),n.shouldExecuteOnCPU([r])||r.dtype==="string"){const h=n.tensorMap.get(r.dataId),d=Tpe(h.values,a,u,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,d)}if(ie(u)===0)return n.makeTensorInfo(u,r.dtype,[]);const l=new Rfe(a,u),c=[{type:"int32",data:a}];return n.runWebGPUProgram(l,[r],r.dtype,c)}const _fe={kernelName:l0,backendName:"webgpu",kernelFunc:Df};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dfe=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:o,crops:i}=s;O(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const a=o.reduce((w,S)=>w*S),u=Sh(r.shape,o,a),l=Ch(u.length,o.length),c=kh(r.shape,o,a),h=xS(i,o.length),d=vS(c,i,o.length),f=[],m=Ye({inputs:{x:r},backend:n,attrs:{shape:u}}),y=Ia({inputs:{x:m},backend:n,attrs:{perm:l}}),x=Ye({inputs:{x:y},backend:n,attrs:{shape:c}}),v=Df({inputs:{x},backend:n,attrs:{begin:h,size:d}});return f.push(m),f.push(y),f.push(x),f.forEach(w=>n.disposeData(w.dataId)),v},Pfe={kernelName:Cy,backendName:"webgpu",kernelFunc:Dfe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ffe=`
  fn bincount_write(index: i32, value: f32) {
    ${Wl("&result[index]","value","float32")}
  }
`,Ofe=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class mW{constructor(e,n,s=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=s,s&&(this.atomic=!1),this.hasWeights=n,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?Ofe:Ffe}
  ${Pe("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lfe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:o}=e,{size:i}=s,a=ie(r.shape),l=ie(o.shape)>0,c=[i],h=o.dtype,d=Pr({backend:n,attrs:{shape:c,value:0,dtype:h}}),f=new mW([a],l),m=[{type:"int32",data:[i]}],y=l?[r,o]:[r];return n.runWebGPUProgram(f,y,h,m,d)}const Mfe={kernelName:jw,backendName:"webgpu",kernelFunc:Lfe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zfe{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${Pe("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bfe(t){const{inputs:e,backend:n}=t,{s0:s,s1:r}=e;if(n.shouldExecuteOnCPU([s,r])){const c=n.tensorMap.get(s.dataId),h=n.tensorMap.get(r.dataId),d=c.values,f=h.values,m=ut(Array.from(d),Array.from(f));return n.makeTensorInfo([m.length],"int32",Int32Array.from(m))}const o=ie(s.shape),i=ie(r.shape),a=Math.max(o,i),u=new zfe(a),l=[{type:"int32",data:[o]},{type:"int32",data:[i]}];return n.runWebGPUProgram(u,[s,r],"int32",l)}const Vfe={kernelName:Xw,backendName:"webgpu",kernelFunc:Bfe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gW=Ds({opType:ft.NOT_EQUAL,dtype:"bool",cpuKernelImpl:Spe}),Wfe={kernelName:Qy,backendName:"webgpu",kernelFunc:gW};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N0(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.tensorMap.get(s.dataId);return uo({inputs:{x:r.complexTensorInfos.real},backend:n})}const Ufe={kernelName:Cb,backendName:"webgpu",kernelFunc:N0};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gfe(t,e){const n=new _f(t.shape,_e.TO_INT),s=e.runWebGPUProgram(n,[t],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b$(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dtype:o}=s;if(o==="complex64"){if(r.dtype==="complex64")return uo({inputs:{x:r},backend:n});const i=Zn(r.shape),a=b$({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),u=$h({inputs:{real:a,imag:i},backend:n});return i.dispose(),n.disposeData(a.dataId),u}if(r.dtype==="complex64"){const i=N0({inputs:{input:r},backend:n}),a=b$({inputs:{x:i},backend:n,attrs:{dtype:o}});return n.disposeData(i.dataId),a}if(!oT(r.dtype,o)){const i=uo({inputs:{x:r},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(n.shouldExecuteOnCPU([r])){const i=n.tensorMap.get(r.dataId).values,[a,u,l]=npe(i,r.shape,r.dtype,o);return n.makeTensorInfo(a,u,l)}if(o==="int32")return Gfe(r,n);if(o==="bool"){const i=n.makeTensorInfo([],"bool",ws("bool",1)),u=gW({inputs:{a:r,b:i},backend:n});return n.disposeData(i.dataId),u}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${o}`)}const Hfe={kernelName:Lp,backendName:"webgpu",kernelFunc:b$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jfe=Ht({opType:_e.CEIL,cpuKernelImpl:spe}),Kfe={kernelName:Mp,backendName:"webgpu",kernelFunc:jfe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xfe{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${Pe("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let qfe=class{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${Pe("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yfe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{clipValueMin:o,clipValueMax:i}=s;let a;const u=[{type:"float32",data:[o]},{type:"float32",data:[i]}];return ie(r.shape)%4===0?a=new Xfe(r.shape):a=new qfe(r.shape),n.runWebGPUProgram(a,[r],r.dtype,u)}const Qfe={kernelName:zp,backendName:"webgpu",kernelFunc:Yfe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Zfe=class{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${Pe("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B3(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function Jfe(t){const{inputs:e,backend:n}=t,{x:s}=e,r=n.tensorMap.get(s.dataId),o=new Zfe(s.shape),i=[B3(s,r.complexTensorInfos.real),B3(s,r.complexTensorInfos.imag)];return n.runWebGPUProgram(o,i,i[0].dtype)}const eme={kernelName:ky,backendName:"webgpu",kernelFunc:Jfe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tme=class{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=Dr(e,1),this.variableNames=e.map((n,s)=>`T${s}`),this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let n=0;n<this.offsetLength;n++)this.uniforms+=`offset${n} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let o=1;o<this.offsetLength;o++)e.push(`else if (yC < uniforms.offset${[o]}){ setOutputAtCoords(coords.x, coords.y, getT${o}(yR, yC - uniforms.offset${o-1})); }`);const s=this.offsetLength,r=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${r})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${Pe("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LS(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.tensorMap.get(s.dataId);return uo({inputs:{x:r.complexTensorInfos.imag},backend:n})}const nme={kernelName:pb,backendName:"webgpu",kernelFunc:LS};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tg(t,e,n){const s=t[0].dtype;if(s==="complex64"){const m=t.map(S=>N0({inputs:{input:S},backend:n})),y=t.map(S=>LS({inputs:{input:S},backend:n})),x=tg(m,e,n),v=tg(y,e,n),w=$h({inputs:{real:x,imag:v},backend:n});return m.forEach(S=>n.disposeData(S.dataId)),y.forEach(S=>n.disposeData(S.dataId)),n.disposeData(x.dataId),n.disposeData(v.dataId),w}let r=n.shouldExecuteOnCPU(t);if(s==="string"&&(r=!0),r){const m=t.map(I=>{const R=[-1,ie(I.shape.slice(e))];return Ye({inputs:{x:I},backend:n,attrs:{shape:R}})}),y=m.map(I=>({vals:n.readSync(I.dataId),shape:I.shape})),x=Dr(m.map(I=>I.shape),1),v=m[0].shape[0]===1,w=rpe(y,x,s,v),S=Dr(t.map(I=>I.shape),e),k=n.makeTensorInfo(S,s,w);return m.forEach(I=>n.disposeData(I.dataId)),k}const o=n.device.limits.maxStorageBuffersPerShaderStage-1;if(t.length>o){const m=[];for(let x=0;x<t.length;x+=o){const v=t.slice(x,x+o);m.push(tg(v,e,n))}const y=tg(m,e,n);for(const x of m)n.disposeData(x.dataId);return y}const{tensors2D:i,outShape:a}=sme(t,e,n),u=i.map(m=>m.shape),l=new tme(u),c=[],h=new Array(u.length-1);if(h.length>0){h[0]=u[0][1],c.push({type:"int32",data:[h[0]]});for(let m=1;m<h.length;m++)h[m]=h[m-1]+u[m][1],c.push({type:"int32",data:[h[m]]})}const d=n.runWebGPUProgram(l,i,i[0].dtype,c);i.forEach(m=>n.disposeData(m.dataId));const f=Ye({inputs:{x:d},backend:n,attrs:{shape:a}});return n.disposeData(d.dataId),f}function sme(t,e,n){const s=Dr(t.map(o=>o.shape),e);return{tensors2D:t.map(o=>Ye({inputs:{x:o},backend:n,attrs:{shape:[ie(o.shape.slice(0,e)),ie(o.shape.slice(e))]}})),outShape:s}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yW(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s,o=vt(r,e[0].shape)[0],i=e.map(l=>l.shape);mS(i,o);const a=Dr(e.map(l=>l.shape),o);if(ie(a)===0)return n.makeTensorInfo(a,e[0].dtype,[]);const u=e.filter(l=>ie(l.shape)>0);return u.length===1?uo({inputs:{x:u[0]},backend:n}):tg(u,o,n)}const rme={kernelName:Iy,backendName:"webgpu",kernelFunc:yW};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ome(t,e,n,s,r=!1,o=null,i=!1,a=4,u=4,l=4){const c=D=>{switch(D){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${D} is not supported.`)}},h=D=>{switch(D){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${D} is not supported.`)}},d=t?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,f=t?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,m=t?"uniforms.xShape[1]":"uniforms.xShape[2]",y=t?"uniforms.xShape[2]":"uniforms.xShape[3]",x=t?"row":"col",v=t?"col":"row",w=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${t?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${x} / outWidth;
      let outCol = ${x} % outWidth;

      let WRow = ${v} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${v} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${v} % inChannels;
      var resData = ${$t(a)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${m} && xCol >= 0 && xCol < ${y}) {
        ${d}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${c(a)}
      }
      return resData;`,S=t?e&&s?`
      ${w}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${w}
      }
      return ${$t(a)}(0.0);`:s&&n?`
      ${w}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${w}
      }
      return ${$t(a)}(0.0);`,k=`${h(u)}`,I=$t(l),T=$t(t?a:u),R=$t(t?u:a);return`
      ${ku(o,i,l===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${T} {
        ${t?S:k}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${R} {
        ${t?k:S}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${I}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${t?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${f}
        ${Ih(r,o)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class ime{constructor(e,n,s,r,o=!1,i=null,a=!1,u=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=c4(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=h4(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),o&&(this.variableNames.push("bias"),this.variableComponents.push(4)),a&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],o&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=u,this.addBias=o,this.activation=i,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=n%this.tileAOuter===0,this.fitBOuter=s%this.tileBOuter===0,this.fitInner=r%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?DS(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):PS(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),n=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${ome(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,n[0],n[1],n[2])}
    ${e}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ame{constructor(e,n=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=n,this.activation=s,this.hasPreluActivationWeights=r,n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${ku(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${Ih(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${Pe("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ume{constructor(e,n){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=n,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,n=this.isChannelsLast?2:3,s=this.isChannelsLast?"coords[1]":"coords[2]",r=this.isChannelsLast?"coords[2]":"coords[1]",o=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${Pe("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${s};
        let col = ${r};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${n}] && xCol >= 0) {
            value = ${o};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kv(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function lme({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const u=n.dataFormat==="channelsLast",l=!u,c=!1,h=u&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&n.padInfo.type==="VALID",d=[];let f,m;if(h){const v=n.inHeight*n.inWidth*n.inChannels;f=Ye({inputs:{x:t},backend:s,attrs:{shape:[1,n.batchSize,v]}}),m=Ye({inputs:{x:e},backend:s,attrs:{shape:[1,v,n.outChannels]}})}else f=Ye({inputs:{x:t},backend:s,attrs:{shape:u?[n.batchSize,n.inHeight*n.inWidth,n.inChannels]:[n.batchSize,n.inChannels,n.inHeight*n.inWidth]}}),m=Ye({inputs:{x:e},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}});if(d.push(f),d.push(m),o!=null){const v=Kv(o.shape,u);v!=null&&(o=Ye({inputs:{x:o},backend:s,attrs:{shape:v}}),d.push(o))}if(r!=null){const v=Kv(r.shape,u);v!=null&&(r=Ye({inputs:{x:r},backend:s,attrs:{shape:v}}),d.push(r))}const y=FS({a:u?f:m,b:u?m:f,transposeA:l,transposeB:c,backend:s,bias:r,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),x=Ye({inputs:{x:y},backend:s,attrs:{shape:n.outShape}});d.push(y);for(const v of d)s.disposeData(v.dataId);return x}function cme({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:u,filterHeight:l,inChannels:c,strideWidth:h,strideHeight:d,padInfo:f,outWidth:m,outHeight:y,dilationWidth:x,dilationHeight:v,dataFormat:w}=n,S=w==="channelsLast",k=u*l*c,I=y*m,T=S?[n.batchSize,I,k]:[n.batchSize,k,I],R=new ume(T,S),_=[{type:"int32",data:[f.top,f.left]},{type:"int32",data:[d,h]},{type:"int32",data:[v,x]},{type:"int32",data:[m]},{type:"int32",data:[c*u]},{type:"int32",data:[c]}],D=s.runWebGPUProgram(R,[t],t.dtype,_),L=[];L.push(D);const V=Ye({inputs:{x:e},backend:s,attrs:{shape:[1,k,-1]}});if(L.push(V),o!=null){const te=Kv(o.shape,S);te!=null&&(o=Ye({inputs:{x:o},backend:s,attrs:{shape:te}}),L.push(o))}if(r!=null){const te=Kv(r.shape,S);te!=null&&(r=Ye({inputs:{x:r},backend:s,attrs:{shape:te}}),L.push(r))}const q=FS({a:S?D:V,b:S?V:D,transposeA:!S,transposeB:!1,backend:s,bias:r,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),J=Ye({inputs:{x:q},backend:s,attrs:{shape:n.outShape}});L.push(q);for(const te of L)s.disposeData(te.dataId);return J}function xW({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const u=r!=null,l=o!=null,c=n.dataFormat==="channelsLast",h=c&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&n.padInfo.type==="VALID",d=ce().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!d&&(h||n.filterHeight===1&&n.filterWidth===1&&n.dilationHeight===1&&n.dilationWidth===1&&n.strideHeight===1&&n.strideWidth===1&&(n.padInfo.type==="SAME"||n.padInfo.type==="VALID")))return lme({x:t,filter:e,convInfo:n,backend:s,bias:r,activation:a,preluActivationWeights:o,leakyreluAlpha:i});const f=ce().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),m=f>-1?f:s.thresholdToIncreaseWorkgroups,y=n.batchSize*Math.ceil(n.outHeight*n.outWidth/32)*Math.ceil(n.outChannels/32);if(ce().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||y<=m)return cme({x:t,filter:e,convInfo:n,backend:s,bias:r,preluActivationWeights:o,leakyreluAlpha:i,activation:a});let x;const v=[n.padInfo.top,n.padInfo.left],w=[{type:"int32",data:[n.filterHeight,n.filterWidth]},{type:"int32",data:[...v]},{type:"int32",data:[n.strideHeight,n.strideWidth]},{type:"int32",data:[n.dilationHeight,n.dilationWidth]}];if(d)x=new ame(n,u,a,l);else{const T=c?n.outHeight*n.outWidth:n.outChannels,R=c?n.outChannels:n.outHeight*n.outWidth,_=n.filterHeight*n.filterWidth*n.inChannels;w.push({type:"int32",data:[T]},{type:"int32",data:[R]},{type:"int32",data:[_]});const D=s.adapterInfo.isIntel();x=new ime(n,T,R,_,u,a,l,D)}const S=[],k=[t,e];u&&(!c&&r.shape.length===1&&(r=Ye({inputs:{x:r},backend:s,attrs:{shape:[r.shape[0],1,1]}}),S.push(r)),k.push(r)),l&&(!c&&o.shape.length===1&&(o=Ye({inputs:{x:o},backend:s,attrs:{shape:[o.shape[0],1,1]}}),S.push(o)),k.push(o)),a==="leakyrelu"&&(w.push({type:"float32",data:[i]}),x.uniforms+=" alpha : f32,");const I=s.runWebGPUProgram(x,k,t.dtype,w);for(const T of S)s.disposeData(T.dataId);return I}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hme(t){const{inputs:e,attrs:n,backend:s}=t,{x:r,filter:o}=e,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=n,h=fo(u),d=bn(r.shape,o.shape,i,l,a,c,!1,h);return xW({x:r,filter:o,convInfo:d,backend:s})}const dme={kernelName:$y,backendName:"webgpu",kernelFunc:hme};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let pme=class{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,n=this.isChannelsLast?2:3,s=this.isChannelsLast?3:1,r=`
    ${Pe()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${r}
    `:`
    ${Pe("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${s}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${n}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}},fme=class{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${Pe("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}},mme=class{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${Pe("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}},gme=class{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${Pe("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yme(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:o}=e,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=s,h=fo(u),d=bn(r.shape,c,i,1,a,l,!1,h),f=new fme(d),m=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.inHeight]},{type:"int32",data:[d.inWidth]}];return n.runWebGPUProgram(f,[r,o],r.dtype,m)}const xme={kernelName:Yw,backendName:"webgpu",kernelFunc:yme};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vme(t=4){const e=o=>{switch(o){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${o} is not supported.`)}},s=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${$t(t)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${$t(t)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${t}];`}
      }
      return ${$t(t)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${$t(t)} {
    ${s}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${$t(t)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(t)}
    }
    return ${$t(t)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${$t(t)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${t}] = value;
    }
  }`}class wme{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,O(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=c4(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=h4(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?DS(this.elementsPerThread,this.workgroupSize):PS(this.elementsPerThread,this.workgroupSize);return`
    ${vme(this.isVec4?4:1)}
    ${e}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bme(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:o}=e,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=s,h=fo(l),d=bn(i,o.shape,a,1,u,c,!1,h),f=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.filterHeight-1-d.padInfo.top,d.filterWidth-1-d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize,d.outHeight,d.outWidth,d.outChannels]}];let m;if(ce().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||d.dataFormat!=="channelsLast")m=new pme(d);else{m=new wme(d);const y=d.inHeight*d.inWidth,x=d.inChannels,v=d.filterHeight*d.filterWidth*d.outChannels;f.push({type:"uint32",data:[y]},{type:"uint32",data:[x]},{type:"uint32",data:[v]})}return n.runWebGPUProgram(m,[r,o],"float32",f)}const Sme={kernelName:Ny,backendName:"webgpu",kernelFunc:bme};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cme{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${Pe("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kme(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o}=e,{strides:i,pad:a,dilations:u}=s,l=Qi(r.shape,o.shape,i,u,a),c=[l.padInfo.front,l.padInfo.top,l.padInfo.left],h=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[...c]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationDepth,l.dilationHeight,l.dilationWidth]}],d=new Cme(l),f=_s(r.dtype,o.dtype);return n.runWebGPUProgram(d,[r,o],f,h)}const Ime={kernelName:Ty,backendName:"webgpu",kernelFunc:kme};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $me(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:o}=e,{strides:i,pad:a,filterShape:u}=s,l=Qi(r.shape,u,i,1,a),c=new mme(l),h=[{type:"int32",data:[l.padInfo.front,l.padInfo.top,l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.batchSize]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.inDepth]},{type:"int32",data:[l.inHeight]},{type:"int32",data:[l.inWidth]}];return n.runWebGPUProgram(c,[r,o],o.dtype,h)}const Nme={kernelName:Qw,backendName:"webgpu",kernelFunc:$me};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tme(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:o}=e,{strides:i,pad:a,inputShape:u}=s,l=Qi(u,o.shape,i,1,a),c=new gme(l),h=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[l.filterDepth-1-l.padInfo.front,l.filterHeight-1-l.padInfo.top,l.filterWidth-1-l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.outChannels]}];return n.runWebGPUProgram(c,[r,o],r.dtype,h)}const Eme={kernelName:Zw,backendName:"webgpu",kernelFunc:Tme};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rme=Ht({opType:_e.COS}),Ame={kernelName:Bp,backendName:"webgpu",kernelFunc:Rme};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _me=Ht({opType:_e.COSH}),Dme={kernelName:Vp,backendName:"webgpu",kernelFunc:_me};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Pme=class{constructor(e,n,s,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[o]=n;this.outputShape=[o,s[0],s[1],e],this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=r==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,n]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[s,r,o]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[i,a,u]=this.cropWidthBiggerThan1?[`(${n} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${n} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${n}`];return`
    ${Pe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${s});
        let width_ratio = f32(${i});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${r};
        let width_scale = ${a};
        let in_y = ${o};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${u};
        if( in_x < 0.0 || in_x > ${n} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fme=t=>{const{inputs:e,backend:n,attrs:s}=t,{image:r,boxes:o,boxInd:i}=e,{cropSize:a,method:u,extrapolationValue:l}=s,c=new Pme(r.shape[3],o.shape,a,u),h=[{type:"float32",data:[l]}];return n.runWebGPUProgram(c,[r,o,i],"float32",h)},Ome={kernelName:eb,backendName:"webgpu",kernelFunc:Fme};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Zg;(function(t){t.Prod="*",t.Sum="+"})(Zg||(Zg={}));let V3=class{constructor(e,n,s,r){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=n,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=s,this.reverse=r,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,n=this.op===Zg.Prod?"1.0":"0.0",s=this.exclusive?n:`getX(${W3(e,"coords",this.op)})`,r=this.outputShape[this.outputShape.length-1];let o="",i="";return this.exclusive?(o=this.reverse?`end != ${r-1}`:"end != 0",i=this.reverse?"end + 1":"end - 1"):(o=this.reverse?`end + pow2 < ${r}`:"end >= pow2",i=this.reverse?"end + pow2":"end - pow2"),`
      ${Pe("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${U3(e,"coords",this.op)};
         var val = ${s};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${o}) {
           let idx = ${i};
           ${U3(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${W3(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}};function W3(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function U3(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw Error(`Cumulative ${n} for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vW(t,e,n,s,r,o){const i=e.shape.length,a=cn([s],i);let u=e;a!=null&&(u=Ia({inputs:{x:e},backend:n,attrs:{perm:a}}));const l=Sn(1,i)[0];if(l!==i-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const c=u.shape[l];let h=uo({inputs:{x:u},backend:n});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){const f=new V3(t,u.shape,!1,o),m=h,y=[{type:"float32",data:[d]}];h=n.runWebGPUProgram(f,[h],h.dtype,y),n.disposeData(m.dataId)}if(r){const d=new V3(t,u.shape,r,o),f=h,m=[{type:"float32",data:[0]}];h=n.runWebGPUProgram(d,[h],h.dtype,m),n.disposeData(f.dataId)}if(a!=null){const d=Ta(a),f=Ia({inputs:{x:h},backend:n,attrs:{perm:d}});return n.disposeData(h.dataId),n.disposeData(u.dataId),f}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lme(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,exclusive:i,reverse:a}=s;return vW(Zg.Prod,r,n,o,i,a)}const Mme={kernelName:Jw,backendName:"webgpu",kernelFunc:Lme};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zme(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,exclusive:i,reverse:a}=s;return vW(Zg.Sum,r,n,o,i,a)}const Bme={kernelName:Ey,backendName:"webgpu",kernelFunc:zme};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vme(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:o}=e,{size:i,binaryOutput:a}=s,u=r.shape.length===1,c=ie(o.shape)>0,h=o.dtype,d=u?[r.shape[0]]:[r.shape[0],r.shape[1]],f=u?[i]:[r.shape[0],i],m=Pr({backend:n,attrs:{shape:f,value:0,dtype:h}}),y=new mW(d,c,a),x=[{type:"int32",data:[i]}],v=c?[r,o]:[r];return n.runWebGPUProgram(y,v,h,x,m)}const Wme={kernelName:tb,backendName:"webgpu",kernelFunc:Vme};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ume=class{constructor(e,n){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${n}`,this.dataFormat=n}getUserCode(){return`
      ${Pe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gme(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockSize:o,dataFormat:i}=s,a=r.shape[0],u=i==="NHWC"?r.shape[1]:r.shape[2],l=i==="NHWC"?r.shape[2]:r.shape[3],c=i==="NHWC"?r.shape[3]:r.shape[1],h=u*o,d=l*o,f=c/(o*o),m=i==="NHWC"?[a,h,d,f]:[a,f,h,d],y=[{type:"int32",data:[o]}],x=new Ume(m,i);return n.runWebGPUProgram(x,[r],r.dtype,y)}const Hme={kernelName:nb,backendName:"webgpu",kernelFunc:Gme};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jme{constructor(e,n,s,r=!1,o=null,i=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),r&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.addBias=r,this.activation=o,this.hasPreluActivation=i,this.filterHeight=n,this.filterWidth=s,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,n=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],s=this.workgroupSize[1]+this.filterHeight-1,r=this.workgroupSize[0]+this.filterWidth-1;return`
      ${ku(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${r}>, ${s}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${Pe()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${s}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${r}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<n?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${n})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${Ih(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wW{constructor(e,n=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const o=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=Ve(o),this.dispatch=Fe(this.dispatchLayout,o,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),O(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=n,this.activation=s,this.hasPreluActivation=r,this.shaderKey=`depthwiseVec4_${s}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,n=this.convInfo.strideHeight,s=this.convInfo.strideWidth;return`
      ${ku(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${Pe("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${n}, ${s}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${s} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${Ih(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let bW=class{constructor(e,n=!1,s=null,r=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=n,this.activation=s,this.hasPreluActivation=r,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${ku(this.activation,this.hasPreluActivation,!1,4)}

      ${Pe("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${Ih(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kme(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o}=e,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=s,h=fo(u);let d=l;d==null&&(d=[1,1]);const f=bn(r.shape,o.shape,i,d,a,c,!0,h),m=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inHeight,f.inWidth]}],y=f.dataFormat==="channelsLast";let x;return!y&&f.inHeight>16&&f.inWidth>16&&f.strideHeight===1&&f.strideWidth===1&&f.dilationWidth===1&&f.dilationHeight===1&&f.inChannels===f.outChannels?x=new jme(f.outShape,f.filterHeight,f.filterWidth):y&&f.outHeight>4&&f.outWidth>4&&f.strideWidth<=2&&f.inChannels===f.outChannels&&f.dilationHeight===1&&f.dilationWidth===1&&f.inChannels%4===0?(x=new wW(f),m.push({type:"int32",data:[x.virtualWidth]})):(x=new bW(f),m.push({type:"int32",data:[f.filterHeight]},{type:"int32",data:[f.filterWidth]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]})),n.runWebGPUProgram(x,[r,o],r.dtype,m)}const Xme={kernelName:Ry,backendName:"webgpu",kernelFunc:Kme};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let qme=class{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${Pe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}},Yme=class{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${Pe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qme(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:o}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=s,h=bn(r.shape,c,i,a,u,l,!0),d=new qme(h),f=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outChannels/h.inChannels]}];return n.runWebGPUProgram(d,[r,o],"float32",f)}const Zme={kernelName:sb,backendName:"webgpu",kernelFunc:Qme};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jme(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:o}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=s,h=bn(c,o.shape,i,a,u,l,!0),d=new Yme(h),f=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.outChannels/h.inChannels]}];return n.runWebGPUProgram(d,[r,o],r.dtype,f)}const ege={kernelName:rb,backendName:"webgpu",kernelFunc:Jme};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tge=class{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${Pe("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nge(t){const{inputs:e,backend:n}=t,{x:s}=e,r=[...s.shape,...s.shape],o=ie(s.shape),i=Ye({inputs:{x:s},backend:n,attrs:{shape:[o]}}),a=new tge(o),u=n.runWebGPUProgram(a,[i],i.dtype),l=Ye({inputs:{x:u},backend:n,attrs:{shape:r}});return n.disposeData(i.dataId),n.disposeData(u.dataId),l}const sge={kernelName:ob,backendName:"webgpu",kernelFunc:nge};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rge=class{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${Pe("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oge(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o}=e,{strides:i,pad:a,dilations:u}=s,l=zl(r.shape,o.shape,i,a,"NHWC",u),c=[l.padInfo.top,l.padInfo.left],h=[{type:"int32",data:[l.filterHeight,l.filterWidth]},{type:"int32",data:[...c]},{type:"int32",data:[l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationHeight,l.dilationWidth]}],d=new rge(l);return n.runWebGPUProgram(d,[r,o],r.dtype,h)}const ige={kernelName:Ay,backendName:"webgpu",kernelFunc:oge};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class age{constructor(e,n){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=Ve(e.outShape),this.dispatch=Fe(this.dispatchLayout,e.outShape,this.workgroupSize),n!=="float32"&&n!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${n} type.`);this.type=n,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${Pe("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${Wl("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class uge{constructor(e,n,s){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=Ve(e.outShape),this.dispatch=Fe(this.dispatchLayout,e.outShape,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${s} type.`);this.type=s,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${Pe("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${Wl("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lge(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o,dy:i}=e,{strides:a,pad:u,dilations:l}=s,c=zl(r.shape,o.shape,a,u,"NHWC",l),h=o.dtype,d=new uge(c,o.shape,h),f=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[ie(c.outShape)]}],m=Pr({backend:n,attrs:{shape:o.shape,value:0,dtype:h}});return n.runWebGPUProgram(d,[r,o,i],h,f,m)}const cge={kernelName:Dv,backendName:"webgpu",kernelFunc:lge};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hge(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o,dy:i}=e,{strides:a,pad:u,dilations:l}=s,c=zl(r.shape,o.shape,a,u,"NHWC",l),h=r.dtype,d=new age(c,h),f=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[ie(c.outShape)]}],m=Pr({backend:n,attrs:{shape:c.inShape,value:0,dtype:h}});return n.runWebGPUProgram(d,[r,o,i],h,f,m)}const dge={kernelName:_v,backendName:"webgpu",kernelFunc:hge};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pge{constructor(e,n,s){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=pp.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=n,this.textureFormat=s,this.shaderKey=`draw_${n}_${s}`}getUserCode(){let e;const n=this.type==="float32"?"value":"value / 255.0";return e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${n};
        rgba[1] = ${n};
        rgba[2] = ${n};
      } else {
        rgba[d] = ${n};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${Pe("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fge(t){const{inputs:e,backend:n,attrs:s}=t,{image:r}=e,{canvas:o,options:i}=s,[a,u]=r.shape.slice(0,2),{imageOptions:l}=i||{},c=(l==null?void 0:l.alpha)||1,h=n.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",d=[a,u],f=new pge(d,r.dtype,h);o.width=u,o.height=a;const m="webgpu";let y=o.getContext(m),x;y||(x=new OffscreenCanvas(u,a),y=x.getContext(m));const v=r.shape.length===3?r.shape[2]:1;y.configure({device:n.device,format:h,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const w="int32",S=n.makeTensorInfo(d,w),k=n.tensorMap.get(S.dataId);k.resource=y.getCurrentTexture(),k.external=!0;const I=[{type:"uint32",data:[v]},{type:"float32",data:[c]}];if(n.runWebGPUProgram(f,[r],w,I,S),x){const T=o.getContext("2d");if(!T)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");T.drawImage(x,0,0)}return n.disposeData(S.dataId),r}const mge={kernelName:uT,backendName:"webgpu",kernelFunc:fge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SW=Ds({opType:ft.MUL,cpuKernelImpl:wpe,supportsComplex:!0}),gge={kernelName:of,backendName:"webgpu",kernelFunc:SW};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CW(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:i}=s;return Nh(r,o,i,"sum",n)}const yge={kernelName:c0,backendName:"webgpu",kernelFunc:CW};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xge(t){const{inputs:e,backend:n,attrs:s}=t,{equation:r}=s,o=e,{allDims:i,summedDims:a,idDims:u}=$S(r,o.length);TS(i.length,u,o);const{path:l,steps:c}=ES(a,u),h=c.length;let d=null,f=i.length;const m=[];for(let y=0;y<h;++y){for(const x of c[y]){const{permutationIndices:v,expandDims:w}=NS(f,u[x]);let S;RS(v)?S=o[x]:(S=Ia({inputs:{x:o[x]},backend:n,attrs:{perm:v}}),m.push(S));const k=S.shape.slice();for(let I=0;I<w.length;++I)k.splice(w[I],0,1);kt(S.shape,k)||(S=Ye({inputs:{x:S},backend:n,attrs:{shape:k}}),m.push(S)),d===null?d=S:(d=SW({inputs:{a:S,b:d},backend:n}),m.push(d))}y<h-1&&(l[y]>=0&&(d=CW({inputs:{x:d},backend:n,attrs:{axis:l[y]-(i.length-f),keepDims:!1}}),m.push(d)),f--)}for(const y of m)y!==d&&n.disposeData(y.dataId);return d}const vge={kernelName:ib,backendName:"webgpu",kernelFunc:xge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wge=Ht({opType:_e.ELU}),bge={kernelName:Up,backendName:"webgpu",kernelFunc:wge};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sge=t=>{const{inputs:e,backend:n}=t,{dy:s,y:r}=e,o=new Gv(ft.ELU_DER,s.shape,r.shape);return n.runWebGPUProgram(o,[s,r],s.dtype)},Cge={kernelName:ab,backendName:"webgpu",kernelFunc:Sge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kge=Ds({opType:ft.EQUAL,dtype:"bool",cpuKernelImpl:ope}),Ige={kernelName:_y,backendName:"webgpu",kernelFunc:kge};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ge=Ht({opType:_e.ERF}),Nge={kernelName:Gp,backendName:"webgpu",kernelFunc:$ge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tge=Ht({opType:_e.EXP,cpuKernelImpl:ipe,dtype:"float32"}),Ege={kernelName:Hp,backendName:"webgpu",kernelFunc:Tge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S$(t){const{inputs:e,attrs:n,backend:s}=t,{dim:r}=n,{input:o}=e,i=o.shape.length,a=o.shape.slice();let u=r;return r<0&&(O(-(i+1)<=r,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+r+1),a.splice(u,0,1),Ye({inputs:{x:o},backend:s,attrs:{shape:a}})}const Rge={kernelName:Dy,backendName:"webgpu",kernelFunc:S$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Age=Ht({opType:_e.EXPM1,cpuKernelImpl:ape}),_ge={kernelName:jp,backendName:"webgpu",kernelFunc:Age};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let G3=class{constructor(e,n){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${Pe("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kW(t,e,n){const s=n.tensorMap.get(t.dataId),r=ie(t.shape),o=t.shape[t.shape.length-1],i=r/o,a=[],u=Ye({inputs:{x:t},backend:n,attrs:{shape:[i,o]}});a.push(u);const l=u.shape,c=new G3("real",l),h=new G3("imag",l),d=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],f=e?2*Math.PI:-2*Math.PI,m=e?l[1]:1,y=[{type:"float32",data:[f]},{type:"float32",data:[m]}],x=n.runWebGPUProgram(c,d,"float32",y);a.push(x);const v=n.runWebGPUProgram(h,d,"float32",y);a.push(v);const w=$h({inputs:{real:x,imag:v},backend:n});a.push(w);const S=Ye({inputs:{x:w},backend:n,attrs:{shape:t.shape}});return a.forEach(k=>n.disposeData(k.dataId)),S}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dge(t){const{inputs:e,backend:n}=t,{input:s}=e;return kW(s,!1,n)}const Pge={kernelName:ub,backendName:"webgpu",kernelFunc:Dge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Fge=class{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${Pe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oge={kernelName:cb,backendName:"webgpu",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,s=e,r=new Fge(n.shape);return s.runWebGPUProgram(r,[n],n.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lge=Ht({opType:_e.FLOOR,cpuKernelImpl:upe}),Mge={kernelName:Kp,backendName:"webgpu",kernelFunc:Lge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zge=Ds({opType:ft.FLOOR_DIV,cpuKernelImpl:lpe,dtype:"int32"}),Bge={kernelName:Xp,backendName:"webgpu",kernelFunc:zge};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Vge=class{constructor(e,n,s=!1){this.pixelsOpType=pp.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize,[n,1,1]),this.importVideo=s,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${Pe("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wge={kernelName:Pv,backendName:"webgpu",kernelFunc:Uge};let dd,ik=ce().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Uge(t){const{inputs:e,backend:n,attrs:s}=t;let{pixels:r}=e;const{numChannels:o}=s;if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const i=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,u=typeof HTMLCanvasElement<"u"&&r instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&r instanceof OffscreenCanvas,l=typeof ImageBitmap<"u"&&r instanceof ImageBitmap,[c,h]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],d=[h,c,o],f=ce().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&i,m=i||a;if(l||u||m){let w;if(f)w=n.device.importExternalTexture({source:r});else{if(m){const j=ce().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(dd==null||j!==ik)&&(ik=j,dd=document.createElement("canvas").getContext("2d",{willReadFrequently:ik})),dd.canvas.width=c,dd.canvas.height=h,dd.drawImage(r,0,0,c,h),r=dd.canvas}const L=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,V="rgba8unorm",U=n.textureManager.acquireTexture(d[1],d[0],V,L);n.queue.copyExternalImageToTexture({source:r},{texture:U},[d[1],d[0]]),w=U}const S=ie(d),k=et(d),I=new Vge(d,o,f),T=[{type:"uint32",data:[S]},{type:"uint32",data:[o]},{type:"uint32",data:[...k]}],R=n.makeTensorInfo([h,c],"int32"),_=n.tensorMap.get(R.dataId);_.resource=w;const D=n.runWebGPUProgram(I,[R],"int32",T);return n.disposeData(R.dataId),D}const y=r.data;let x=y;if(o!=null&&o!==4){x=new Uint8Array(r.width*r.height*o);const w=y.length;let S=0;for(let k=0;k<w;k++)k%4<o&&(x[S++]=y[k])}const v=n.makeTensorInfo(d,"int32",new Int32Array(x));return n.uploadToGPU(v.dataId),v}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Gge=class{constructor(e,n,s,r,o){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],ut(e,n),ut(e,s),this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),r!=null&&(ut(e,r),this.variableNames.push("offset")),o!=null&&(ut(e,o),this.variableNames.push("scale")),this.offsetShape=r,this.scaleShape=o,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let n="1.0";return this.scaleShape!=null&&(n="getScaleByOutputIndex(index)"),`
      ${Pe("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${n};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hge={kernelName:Py,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s,scale:r,offset:o,mean:i,variance:a}=t,{varianceEpsilon:u}=e,l=n,c=[s,i,a];let h=null;o!=null&&(h=o.shape,c.push(o));let d=null;r!=null&&(d=r.shape,c.push(r));const f=new Gge(s.shape,i.shape,a.shape,h,d),m=[{type:"float32",data:[u]}];return l.runWebGPUProgram(f,c,s.dtype,m)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jge(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d,activation:f,leakyreluAlpha:m}=s,y=fo(c),x=bn(r.shape,o.shape,u,h,l,d,!1,y);return xW({x:r,filter:o,convInfo:x,backend:n,bias:i,preluActivationWeights:a,leakyreluAlpha:m,activation:f})}const Kge={kernelName:Vg,backendName:"webgpu",kernelFunc:jge};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xge(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:f}=s;let m=c;m==null&&(m=[1,1]),O(Ss(u,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`);const y=bn(r.shape,o.shape,u,m,l,h,!0),x=[r,o],v=i!=null,w=a!=null;v&&x.push(i),w&&x.push(a);const S=[{type:"int32",data:[y.padInfo.top,y.padInfo.left]},{type:"int32",data:[y.inHeight,y.inWidth]}];let k;return y.outHeight>4&&y.outWidth>4&&y.strideWidth<=2&&y.inChannels===y.outChannels&&y.dilationHeight===1&&y.dilationWidth===1&&y.inChannels%4===0?(k=new wW(y,v,d,w),S.push({type:"int32",data:[k.virtualWidth]})):(k=new bW(y,v,d,w),S.push({type:"int32",data:[y.filterHeight]},{type:"int32",data:[y.filterWidth]},{type:"int32",data:[y.strideHeight,y.strideWidth]},{type:"int32",data:[y.dilationHeight,y.dilationWidth]})),d==="leakyrelu"&&(S.push({type:"float32",data:[f]}),k.uniforms+=" alpha : f32,"),n.runWebGPUProgram(k,x,"float32",S)}const qge={kernelName:Wg,backendName:"webgpu",kernelFunc:Xge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Yge=class{constructor(e,n){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${es(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${Pe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qge(t){const{inputs:e,backend:n}=t,{params:s,indices:r}=e,o=r.shape,i=o[o.length-1],a=ie(s.shape),[u,l,c,h]=hS(s,r),d=Ye({inputs:{x:r},backend:n,attrs:{shape:[l,i]}}),f=Ye({inputs:{x:s},backend:n,attrs:{shape:[ie(s.shape)/c,c]}});if(n.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const w=n.readSync(r.dataId),S=n.bufferSync(s),k=cpe(w,S,s.dtype,l,i,c,h,s.shape,a);return n.makeTensorInfo(u,s.dtype,k.values)}const m=new Yge(i,[l,c]),y=[{type:"int32",data:[i]},{type:"int32",data:h}],x=n.runWebGPUProgram(m,[f,d],f.dtype,y),v=Ye({inputs:{x},backend:n,attrs:{shape:u}});return n.disposeData(d.dataId),n.disposeData(f.dataId),n.disposeData(x.dataId),v}const Zge={kernelName:hb,backendName:"webgpu",kernelFunc:Qge};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Jge=class{constructor(e,n){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=n,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=eye(this.aShape);return`
      ${Pe("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}};function eye(t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let s=0;s<t.length;s++)s===2?n.push("indexZ"):n.push(`${e[s]}`);return n.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IW(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,indices:o}=e,{axis:i,batchDims:a}=s,u=vt(i,r.shape)[0],l=_S(r,o,u,a),c=ie(o.shape),h=[],d=Ye({inputs:{x:r},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),f=Ye({inputs:{x:o},backend:n,attrs:{shape:[l.batchSize,c/l.batchSize]}});h.push(d),h.push(f);const m=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([r,o])){const S=n.tensorMap.get(f.dataId).values,k=xt(f.shape,f.dtype,S),T=n.tensorMap.get(d.dataId).values,R=xt(d.shape,d.dtype,T),_=hpe(R,k,m);return h.forEach(D=>n.disposeData(D.dataId)),n.makeTensorInfo(l.outputShape,_.dtype,_.values)}const y=new Jge(d.shape,m),x=n.runWebGPUProgram(y,[d,f],d.dtype);h.push(x);const v=Ye({inputs:{x},backend:n,attrs:{shape:l.outputShape}});return h.forEach(w=>n.disposeData(w.dataId)),v}const tye={kernelName:Fy,backendName:"webgpu",kernelFunc:IW};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nye=Ds({opType:ft.GREATER,cpuKernelImpl:ppe,dtype:"bool"}),sye={kernelName:Oy,backendName:"webgpu",kernelFunc:nye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rye=Ds({opType:ft.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:dpe}),oye={kernelName:qp,backendName:"webgpu",kernelFunc:rye};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iye(t){const{inputs:e,backend:n}=t,{input:s}=e;return kW(s,!0,n)}const aye={kernelName:db,backendName:"webgpu",kernelFunc:iye};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uye=Ht({opType:_e.IS_FINITE,dtype:"bool"}),lye={kernelName:Qp,backendName:"webgpu",kernelFunc:uye};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cye=Ht({opType:_e.IS_INF,dtype:"bool"}),hye={kernelName:Zp,backendName:"webgpu",kernelFunc:cye};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dye=Ht({opType:_e.IS_NAN,dtype:"bool"}),pye={kernelName:Jp,backendName:"webgpu",kernelFunc:dye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fye(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{alpha:o}=s,i=[{type:"float32",data:[o]}],a=new _f(r.shape,_e.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(a,[r],"float32",i)}const mye={kernelName:Ly,backendName:"webgpu",kernelFunc:fye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gye=Ds({opType:ft.LESS,dtype:"bool",cpuKernelImpl:mpe}),yye={kernelName:My,backendName:"webgpu",kernelFunc:gye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xye=Ds({opType:ft.LESS_EQUAL,dtype:"bool",cpuKernelImpl:fpe}),vye={kernelName:zy,backendName:"webgpu",kernelFunc:xye};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wye{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${Pe("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bye(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:o}=n,i=(r-s)/(o-1),a=new wye(o),u=[{type:"float32",data:[s]},{type:"float32",data:[i]}];return e.runWebGPUProgram(a,[],"float32",u)}const Sye={kernelName:fb,backendName:"webgpu",kernelFunc:bye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cye=Ht({opType:_e.LOG,cpuKernelImpl:gpe}),kye={kernelName:ef,backendName:"webgpu",kernelFunc:Cye};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iye=Ht({opType:_e.LOG1P}),$ye={kernelName:tf,backendName:"webgpu",kernelFunc:Iye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nye=Ds({opType:ft.LOGICAL_AND,dtype:"bool"}),Tye={kernelName:By,backendName:"webgpu",kernelFunc:Nye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eye=Ht({opType:_e.LOGICAL_NOT}),Rye={kernelName:Vy,backendName:"webgpu",kernelFunc:Eye};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aye=Ds({opType:ft.LOGICAL_OR}),_ye={kernelName:Wy,backendName:"webgpu",kernelFunc:Aye};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $W=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;let Dye=class{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${Pe("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${$W}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}};class Pye{constructor(e,n){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,O(n<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${n}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Fe(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${Pe()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${$W}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fye(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{depthRadius:o,bias:i,alpha:a,beta:u}=s;let l;o>16?l=new Dye(r.shape):l=new Pye(r.shape,o);const c=[{type:"int32",data:[o]},{type:"float32",data:[i]},{type:"float32",data:[a]},{type:"float32",data:[u]}];return n.runWebGPUProgram(l,[r],r.dtype,c)}const Oye={kernelName:Uy,backendName:"webgpu",kernelFunc:Fye};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Lye=class{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${Pe("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mye(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,y:o,dy:i}=e,{depthRadius:a,bias:u,alpha:l,beta:c}=s,h=new Lye(r.shape),d=[{type:"int32",data:[a]},{type:"float32",data:[u]},{type:"float32",data:[l]},{type:"float32",data:[c]}];return n.runWebGPUProgram(h,[r,o,i],r.dtype,d)}const zye={kernelName:mb,backendName:"webgpu",kernelFunc:Mye};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bye=Ds({opType:ft.MAX,cpuKernelImpl:xpe}),Vye={kernelName:nf,backendName:"webgpu",kernelFunc:Bye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wye(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=s,l=1,c=Js(r.shape,o,i,l,a,u);return fW(r,c,"max",n)}const Uye={kernelName:Hy,backendName:"webgpu",kernelFunc:Wye};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gye(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:o,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=s,c=[1,1,1],h=Lo(r.shape,o,i,c,a,l,u),d=new TE(h,"max"),f=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return n.runWebGPUProgram(d,[r],r.dtype,f)}const Hye={kernelName:jy,backendName:"webgpu",kernelFunc:Gye};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let jye=class{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${Pe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}},Kye=class{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${Pe("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xye(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o}=e,i=o,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=s,h=[1,1,1],d=Lo(i.shape,a,u,h,l,c),f=new TE(d,"max",!0);let m=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inDepth,d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]}];const y=n.runWebGPUProgram(f,[i],"int32",m),x=new Kye(d);m=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterDepth-1-d.padInfo.front,d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outDepth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];const v=n.runWebGPUProgram(x,[r,y],i.dtype,m);return n.disposeData(y.dataId),v}const qye={kernelName:yb,backendName:"webgpu",kernelFunc:Xye};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yye(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o,output:i}=e,a=o;p4([o,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=s,d=Js(a.shape,u,l,1,c,h),f=new Qg(d,"max",!0);let m=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}];const y=n.runWebGPUProgram(f,[a],"int32",m),x=new jye(d);m=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];const v=n.runWebGPUProgram(x,[r,y],a.dtype,m);return n.disposeData(y.dataId),v}const Qye={kernelName:gb,backendName:"webgpu",kernelFunc:Yye};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zye(t){const{inputs:e,backend:n,attrs:s}=t,{filterSize:r,strides:o,pad:i,includeBatchInIndex:a}=s,{x:u}=e;O(u.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${u.shape.length}.`);const l=[1,1];O(Ss(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const c=Js(u.shape,r,o,l,i),h=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.inHeight,c.inWidth]},{type:"int32",data:[c.effectiveFilterHeight,c.effectiveFilterWidth]}];let d=new Qg(c,"max",!1);const f=n.runWebGPUProgram(d,[u],u.dtype,h);d=new Qg(c,"max",!0,!0,a);const m=n.runWebGPUProgram(d,[u],"int32",h);return[f,m]}const Jye={kernelName:xb,backendName:"webgpu",kernelFunc:Zye};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e0e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:i}=s;return Nh(r,o,i,"min",n)}const t0e={kernelName:Xy,backendName:"webgpu",kernelFunc:e0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n0e=Ds({opType:ft.MIN,cpuKernelImpl:vpe}),s0e={kernelName:sf,backendName:"webgpu",kernelFunc:n0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let r0e=class{constructor(e,n,s){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n.map((r,o)=>r[0]+e[o]+r[1]),this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,n.map((r,o)=>{this.uniforms+=` pad${o} : vec2<i32>,`}),this.offset=s==="reflect"?0:1,this.shaderKey=`mirrorPad_${s}`}getUserCode(){const e=this.xShape.length,n=this.xShape.map((l,c)=>`uniforms.pad${c}[0]`).join(","),s=this.xShape.map((l,c)=>`uniforms.pad${c}[0] + uniforms.xShape${e>1?`[${c}]`:""}`).join(","),r=e===1?"start":"start[i]",o=e===1?"end":"end[i]",i=e===1?"outC":"outC[i]",a=es(e),u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${Pe("index")} {
        if (index < uniforms.size) {
          let start = ${a}(${n});
          let end = ${a}(${s});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${i} < ${r}) {
              ${i} = ${r} * 2 - ${i} - ${this.offset};
            } else if(${i} >= ${o}) {
              ${i} = (${o} - 1) * 2 - ${i} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${u}));
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o0e={kernelName:qy,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{paddings:r,mode:o}=e,i=n,a=r.map(c=>({type:"int32",data:[c[0],c[1]]})),u=new r0e(s.shape,r,o);return i.runWebGPUProgram(u,[s],s.dtype,a)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i0e=Ds({opType:ft.MOD}),a0e={kernelName:rf,backendName:"webgpu",kernelFunc:i0e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let u0e=class{constructor(e,n){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,n],this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Pe("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class l0e{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${Pe("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NW(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{dim:o}=s,i=Ye({inputs:{x:r},backend:n,attrs:{shape:[ie(r.shape)/r.shape[o],r.shape[o]]}}),a=new l0e(i.shape),u=n.runWebGPUProgram(a,[i],r.dtype),l=Ye({inputs:{x:u},backend:n,attrs:{shape:r.shape}});return n.disposeData(i.dataId),n.disposeData(u.dataId),l}const c0e={kernelName:p0,backendName:"webgpu",kernelFunc:NW};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h0e(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{numSamples:o,seed:i,normalized:a}=s,u=a?r:NW({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),l=u.shape[0],c=u.shape[1],h=new u0e(l,o),d=[{type:"float32",data:[i]},{type:"int32",data:[c]}],f=n.runWebGPUProgram(h,[u],"int32",d);return a||n.disposeData(u.dataId),f}const d0e={kernelName:vb,backendName:"webgpu",kernelFunc:h0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p0e(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])){const o=n.tensorMap.get(s.dataId),[i,a]=bpe(o.values,s.shape,s.dtype);return n.makeTensorInfo(a,s.dtype,i)}const r=new _f(s.shape,_e.NEG);return n.runWebGPUProgram(r,[s],s.dtype)}const f0e={kernelName:Yy,backendName:"webgpu",kernelFunc:p0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m0e(t){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=s,l=n.readSync(r.dataId),c=n.readSync(o.dataId),{selectedIndices:h}=lS(l,c,i,a,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}const g0e={kernelName:wb,backendName:"webgpu",kernelFunc:m0e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y0e(t){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=s,c=n.readSync(r.dataId),h=n.readSync(o.dataId),d=i,f=a,m=u,y=l,{selectedIndices:x,selectedScores:v}=cS(c,h,d,f,m,y);return[n.makeTensorInfo([x.length],"int32",new Int32Array(x)),n.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const x0e={kernelName:bb,backendName:"webgpu",kernelFunc:y0e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let v0e=class{constructor(e,n){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,n],this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${Pe("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w0e(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r}=e,{dtype:o,depth:i,onValue:a,offValue:u}=s,l=ie(r.shape),c=new v0e(l,i),h=Ye({inputs:{x:r},backend:n,attrs:{shape:[l]}}),d=[{type:"float32",data:[a]},{type:"float32",data:[u]}],f=n.runWebGPUProgram(c,[h],o,d);n.disposeData(h.dataId);const m=[...r.shape,i],y=Ye({inputs:{x:f},backend:n,attrs:{shape:m}});return n.disposeData(f.dataId),y}const b0e={kernelName:Jy,backendName:"webgpu",kernelFunc:w0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xv(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="complex64"){const r=N0({inputs:{input:s},backend:n}),o=Xv({inputs:{x:r},backend:n}),i=LS({inputs:{input:s},backend:n}),a=Xv({inputs:{x:i},backend:n}),u=$h({inputs:{real:o,imag:a},backend:n});return n.disposeData(r.dataId),n.disposeData(o.dataId),n.disposeData(i.dataId),n.disposeData(a.dataId),u}else return Pr({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:n})}const S0e={kernelName:g0,backendName:"webgpu",kernelFunc:Xv};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TW(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=N0({inputs:{input:s},backend:n}),o=TW({inputs:{x:r},backend:n}),i=LS({inputs:{input:s},backend:n}),a=Xv({inputs:{x:i},backend:n}),u=$h({inputs:{real:o,imag:a},backend:n});return n.disposeData(r.dataId),n.disposeData(o.dataId),n.disposeData(i.dataId),n.disposeData(a.dataId),u}else return Pr({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:n})}const C0e={kernelName:Zy,backendName:"webgpu",kernelFunc:TW};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k0e(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s;if(e.length===1)return S$({inputs:{input:e[0]},backend:n,attrs:{dim:r}});const o=e[0].shape,i=e[0].dtype;e.forEach(c=>{Br(o,c.shape,"All tensors passed to stack must have matching shapes"),O(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=e.map(c=>{const h=S$({inputs:{input:c},backend:n,attrs:{dim:r}});return a.push(h),h}),l=yW({inputs:u,backend:n,attrs:{axis:r}});return a.forEach(c=>n.disposeData(c.dataId)),l}const I0e={kernelName:e0,backendName:"webgpu",kernelFunc:k0e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EW(t,e=!1){const n=t.length,s=es(n),r=t.map((h,d)=>`uniforms.pad${d}[0]`).join(","),o=t.map((h,d)=>`uniforms.pad${d}[0] + uniforms.xShape${n>1?`[${d}]`:""}`).join(","),i=n>1?`${s}(${r})`:`${r}`,a=n>1?`${s}(${o})`:`${o}`,u=n>1?"any(paddedCoords < start)":"paddedCoords < start",l=n>1?"any(paddedCoords >= end)":"paddedCoords >= end",c=n>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n):"coords";return`
        let start = ${i};
        let end = ${a};
        if (${u} || ${l}) {
          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${c}));
        }
  `}let $0e=class{constructor(e,n){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n.map((s,r)=>s[0]+e[r]+s[1]),this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),n.map((s,r)=>{this.uniforms+=` pad${r} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`
      ${Pe("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${EW(this.xShape)}
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N0e=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:o,constantValue:i}=s;if(o.every(l=>kt(l,[0,0])))return uo({inputs:{x:r},backend:n});if(ie(r.shape)===0){const l=o.map((c,h)=>c[0]+r.shape[h]+c[1]);return Pr({backend:n,attrs:{shape:l,value:i,dtype:r.dtype}})}const a=[{type:"float32",data:[i]}];o.map(l=>a.push({type:"int32",data:[l[0],l[1]]}));const u=new $0e(r.shape,o);return n.runWebGPUProgram(u,[r],r.dtype,a)},T0e={kernelName:t0,backendName:"webgpu",kernelFunc:N0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E0e=Ds({opType:ft.POW}),R0e={kernelName:af,backendName:"webgpu",kernelFunc:E0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A0e(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e,o=new Gv(ft.PRELU,s.shape,r.shape);return n.runWebGPUProgram(o,[s,r],"float32")}const _0e={kernelName:n0,backendName:"webgpu",kernelFunc:A0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D0e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:i}=s;return Nh(r,o,i,"prod",n)}const P0e={kernelName:s0,backendName:"webgpu",kernelFunc:D0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F0e=t=>{const{backend:e,attrs:n}=t,{start:s,stop:r,step:o,dtype:i}=n,a=kpe(s,r,o,i);return e.makeTensorInfo([a.length],i,a)},O0e={kernelName:Sb,backendName:"webgpu",kernelFunc:F0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L0e=Ds({opType:ft.DIV}),M0e={kernelName:Wp,backendName:"webgpu",kernelFunc:L0e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z0e=Ht({opType:_e.RECIPROCAL}),B0e={kernelName:uf,backendName:"webgpu",kernelFunc:z0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V0e=Ht({opType:_e.RELU}),W0e={kernelName:lf,backendName:"webgpu",kernelFunc:V0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U0e=Ht({opType:_e.RELU6}),G0e={kernelName:cf,backendName:"webgpu",kernelFunc:U0e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let H0e=class{constructor(e,n,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],n,s,e[3]],this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${Pe("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j0e(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:o,size:i,halfPixelCenters:a}=s,[u,l]=i,c=o&&u>1?1:0,h=o&&l>1?1:0,f=[{type:"float32",data:[c,h]},{type:"float32",data:[a?.5:0]}],m=new H0e(r.shape,u,l);return n.runWebGPUProgram(m,[r],"float32",f)}const K0e={kernelName:i0,backendName:"webgpu",kernelFunc:j0e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let X0e=class{constructor(e,n){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=n,this.shaderKey=`resizeBilinearBackprop_${n}`}getUserCode(){return`
      ${Pe("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q0e(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:o}=e,{alignCorners:i}=s,[,a,u]=r.shape,[,l,c]=o.shape,h=[i&&l>1?a-1:a,i&&c>1?u-1:u],d=[i&&l>1?l-1:l,i&&c>1?c-1:c],f=h[0]/d[0],m=h[1]/d[1],y=1/f,x=1/m,v=Math.ceil(y)*2+2,w=Math.ceil(x)*2+2,S=new X0e(r.shape,i),k=[{type:"int32",data:h},{type:"int32",data:d},{type:"float32",data:[f]},{type:"float32",data:[m]},{type:"float32",data:[y]},{type:"float32",data:[x]},{type:"int32",data:[v]},{type:"int32",data:[w]}];return n.runWebGPUProgram(S,[o],o.dtype,k)}const Y0e={kernelName:Ib,backendName:"webgpu",kernelFunc:q0e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Q0e=class{constructor(e,n,s,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],n,s,e[3]],this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=r,this.shaderKey=`resizeNearest_${r}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${Pe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z0e(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:o,halfPixelCenters:i,size:a}=s,[u,l]=a,c=o&&u>1?1:0,h=o&&l>1?1:0,f=[{type:"float32",data:[c,h]},{type:"float32",data:[o?.5:0]}],m=new Q0e(r.shape,u,l,i);return n.runWebGPUProgram(m,[r],r.dtype,f)}const J0e={kernelName:o0,backendName:"webgpu",kernelFunc:Z0e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let exe=class{constructor(e,n){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=n,this.shaderKey=`resizeNearestNeigborBackprop_${n}`}getUserCode(){return`
      ${Pe("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function txe(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:o}=e,{alignCorners:i}=s,[,a,u]=r.shape,[,l,c]=o.shape,h=[i&&l>1?a-1:a,i&&c>1?u-1:u],d=[i&&l>1?l-1:l,i&&c>1?c-1:c],f=h[0]/d[0],m=h[1]/d[1],y=1/f,x=1/m,v=Math.ceil(y)*2+2,w=Math.ceil(x)*2+2,S=new exe(r.shape,i),k=[{type:"int32",data:h},{type:"int32",data:d},{type:"float32",data:[y]},{type:"float32",data:[x]},{type:"int32",data:[v]},{type:"int32",data:[w]}];return n.runWebGPUProgram(S,[o],o.dtype,k)}const nxe={kernelName:kb,backendName:"webgpu",kernelFunc:txe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let sxe=class{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${Pe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rxe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dims:o}=s,i=r.shape.length;if(i===0)return uo({inputs:{x:r},backend:n});const a=r.shape,u=[1,1,1,1];a.forEach((x,v)=>{const w=v+4-i;u[w]=x});const l=vt(o,r.shape),c=[0,0,0,0];l.forEach(x=>{const v=x+4-i;c[v]=1});const h=[{type:"int32",data:c}],d=Ye({inputs:{x:r},backend:n,attrs:{shape:u}}),f=new sxe(u),m=n.runWebGPUProgram(f,[d],d.dtype,h);n.disposeData(d.dataId);const y=Ye({inputs:{x:m},backend:n,attrs:{shape:a}});return n.disposeData(m.dataId),y}const oxe={kernelName:a0,backendName:"webgpu",kernelFunc:rxe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ixe=class{constructor(e,n){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof n=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${Pe("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const axe={kernelName:Mb,backendName:"webgpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,{radians:r,fillValue:o,center:i}=e,a=n,u=new ixe(s.shape,o),[l,c]=yS(i,s.shape[1],s.shape[2]),h=[{type:"float32",data:[l]},{type:"float32",data:[c]},{type:"float32",data:[Math.sin(r)]},{type:"float32",data:[Math.cos(r)]}];return typeof o=="number"?h.push({type:"float32",data:[Number.parseFloat(o.toFixed(2))]}):h.push({type:"float32",data:o}),a.runWebGPUProgram(u,[s],s.dtype,h)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uxe=Ht({opType:_e.ROUND}),lxe={kernelName:hf,backendName:"webgpu",kernelFunc:uxe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cxe=Ht({opType:_e.RSQRT,cpuKernelImpl:Ipe}),hxe={kernelName:df,backendName:"webgpu",kernelFunc:cxe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let gg=class{constructor(e,n,s,r,o,i,a,u=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=i,this.type=a,this.sumDupeIndices=u,this.dispatchLayout=Ve(e),this.dispatch=Fe(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=n>1,this.shaderKey=`scatter_${s}_${r}_${this.sliceDimGreaterThanOne}_${a}_${u}_${o.length}`;const l=es(o.length);this.uniforms=`sliceDim : i32, strides: ${l}, updatesSize: i32,`,this.updatesRank=r,this.indicesRank=s}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const n=`getIndices(${e})`,s=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let r="",o="";this.dispatchLayout.x.length===1?(r="flattenedIndex",o=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(r="vec2<i32>(flattenedIndex, coords[1])",o=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const a=`getUpdates(${Array.from({length:this.updatesRank},(l,c)=>`coords[${c}]`).join(", ")})`;return`
    ${o}
      ${Pe("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${n}));
            flattenedIndex = flattenedIndex + indexInside * ${s};
          }
          let updateValue =
              ${$c(this.type)}(${a});
          let flatIndex = getOutputIndexFromCoords(${r});

          ${this.sumDupeIndices?Wl("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dxe(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:o}=e,{shape:i}=s,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=Ra(o,r,i),d=[h/l,l];if(h===0)return n.makeTensorInfo(i,r.dtype);const f=Ye({inputs:{x:r},backend:n,attrs:{shape:[u,a]}}),m=Ye({inputs:{x:o},backend:n,attrs:{shape:[u,l]}}),y=m.dtype,x=Pr({backend:n,attrs:{shape:d,value:0,dtype:y}}),v=ie(m.shape),w=[{type:"int32",data:[a]},{type:"int32",data:c},{type:"int32",data:[v]}],S=new gg(m.shape,a,f.shape.length,m.shape.length,c,d,y),k=n.runWebGPUProgram(S,[m,f],y,w,x),I=Ye({inputs:{x:k},backend:n,attrs:{shape:i}});return n.disposeData(f.dataId),n.disposeData(m.dataId),n.disposeData(k.dataId),I}const pxe={kernelName:$b,backendName:"webgpu",kernelFunc:dxe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let fxe=class{constructor(e,n){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=n,this.shaderKey=`search_sorted_${n}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${Pe("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mxe(t){const{inputs:e,backend:n,attrs:s}=t,{sortedSequence:r,values:o}=e,{side:i}=s,a=new fxe([o.shape[0],o.shape[1]],i),u=[{type:"int32",data:[r.shape[1]]}];return n.runWebGPUProgram(a,[r,o],"int32",u)}const gxe={kernelName:Tb,backendName:"webgpu",kernelFunc:mxe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let yxe=class{constructor(e,n,s){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=n,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=s,this.shaderKey="select"}getUserCode(){let e,n;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)n="resRC",e="resRC";else{const r=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],i=[];for(let a=0;a<this.outputShape.length;a++)i.push(`${r[a]}`),a<this.cRank&&o.push(`${r[a]}`);e=o.join(),n=i.join()}return`
      ${Pe("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${n}));
          } else {
            setOutputAtIndex(index, getB(${n}));
          }
        }
      }
    `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xxe(t){const{inputs:e,backend:n}=t,{condition:s,t:r,e:o}=e,i=new yxe(s.shape.length,r.shape,r.shape.length);return n.runWebGPUProgram(i,[s,r,o],_s(r.dtype,o.dtype))}const vxe={kernelName:u0,backendName:"webgpu",kernelFunc:xxe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wxe=Ht({opType:_e.SELU}),bxe={kernelName:pf,backendName:"webgpu",kernelFunc:wxe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sxe=Ht({opType:_e.SIGMOID}),Cxe={kernelName:yf,backendName:"webgpu",kernelFunc:Sxe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kxe=Ht({opType:_e.SIGN}),Ixe={kernelName:gf,backendName:"webgpu",kernelFunc:kxe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $xe=Ht({opType:_e.SIN}),Nxe={kernelName:ff,backendName:"webgpu",kernelFunc:$xe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Txe=Ht({opType:_e.SINH}),Exe={kernelName:mf,backendName:"webgpu",kernelFunc:Txe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rxe=Ht({opType:_e.SOFTPLUS}),Axe={kernelName:xf,backendName:"webgpu",kernelFunc:Rxe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _xe{constructor(e,n,s,r,o,i){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const a=new Array(r.length);for(let u=0;u<a.length;u++)a[u]=r[o[u]];this.outputShape=a,this.newDim=o,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=n,this.uniforms+=`reshapedPaddedXShape : ${es(r.length)}, paddedXShapeStrides : ${es(i)}, `,s.map((u,l)=>{this.uniforms+=` pad${l} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${o}`}getUserCode(){const e=es(this.outputShape.length),n=cW(this.newDim);return`
      ${tv(this.paddedXShape,"PaddedX")}
      ${Pe("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${n}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${EW(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dxe=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:o,paddings:i}=s;O(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const a=o.reduce((w,S)=>w*S),u=[[0,0]];u.push(...i);for(let w=1+o.length;w<r.shape.length;++w)u.push([0,0]);const l=u.map((w,S)=>w[0]+r.shape[S]+w[1]),c=Sh(l,o,a,!1),h=Ch(c.length,o.length,!1),d=kh(l,o,a,!1),f=et(l),m=new _xe(r.shape,l,u,c,h,f.length),y=[{type:"int32",data:c},{type:"int32",data:f}];u.map(w=>y.push({type:"int32",data:[w[0],w[1]]}));const x=n.runWebGPUProgram(m,[r],r.dtype,y),v=Ye({inputs:{x},backend:n,attrs:{shape:d}});return n.disposeData(x.dataId),v},Pxe={kernelName:h0,backendName:"webgpu",kernelFunc:Dxe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fxe{constructor(e,n,s){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=s,this.dispatchLayout=Ve([n]),this.dispatch=Fe(this.dispatchLayout,[n],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${Pe("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${Wl("&result[outIndex]","value",this.type)}
      }
    }
  `}}class Oxe{constructor(e,n){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=Ve(n),this.dispatch=Fe(this.dispatchLayout,n,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${Pe("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${Wl("&result[segmentId]","1","int32")}
      }
    }
  `}}class Lxe{constructor(e,n){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=n,this.dispatchLayout=Ve(e),this.dispatch=Fe(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${Pe("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RW(t,e,n,s=!1,r){const i=ie(t.shape)/t.shape[0],a=t.dtype,u=ie(e.shape),l=r.readSync(n.dataId),h=u>0?l[u-1]+1:0;let d;const f=t.shape.slice();f[0]=h;const m=u*i,y=Pr({backend:r,attrs:{shape:f,value:0,dtype:a}});d=new Fxe(f,m,a);let x=[{type:"int32",data:[i]},{type:"int32",data:[m]}];const v=r.runWebGPUProgram(d,[t,e,n],a,x,y);if(s)return v;const w=Pr({backend:r,attrs:{shape:[h],value:0,dtype:"int32"}});d=new Oxe(h,n.shape);const S=r.runWebGPUProgram(d,[n],"int32",null,w),k=Pr({backend:r,attrs:{shape:f,value:0,dtype:a}});d=new Lxe(f,a),x=[{type:"int32",data:[i]}];const I=r.runWebGPUProgram(d,[v,S],a,x,k);return r.disposeData(v.dataId),r.disposeData(S.dataId),I}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mxe(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:o}=e;return RW(s,r,o,!1,n)}const zxe={kernelName:Eb,backendName:"webgpu",kernelFunc:Mxe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bxe(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:o}=e;return RW(s,r,o,!0,n)}const Vxe={kernelName:Rb,backendName:"webgpu",kernelFunc:Bxe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Wxe=class{constructor(e,n){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const s=new Array(e.length);for(let r=0;r<s.length;r++)s[r]=e[r]*n[r];this.outputShape=s,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=Uxe(this.rank,"uniforms.");return`
      ${Pe("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}};function Uxe(t,e=""){if(t>=5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`(resRC % ${e}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<t;r++)s.push(`(${n[r]} % ${e}aShape[${r}])`);return s.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EE(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reps:o}=s;if(n.shouldExecuteOnCPU([r])||r.dtype==="string"||r.shape.length>=5){const u=n.readSync(r.dataId),l=r.dtype==="string"?u.map(d=>Vi(d)):u,c=xt(r.shape,r.dtype,l),h=_pe(c,o);return n.makeTensorInfo(h.shape,h.dtype,h.values)}const i=new Wxe(r.shape,o);return n.runWebGPUProgram(i,[r],r.dtype)}const Gxe={kernelName:kf,backendName:"webgpu",kernelFunc:EE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hxe(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:o,defaultValue:i}=e,{outputShape:a}=s,{sliceRank:u,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=Ra(o,r,a),f=!1;if(o.dtype==="string"){const _=n.bufferSync(r),D=n.bufferSync(o),L=Vi(n.readSync(i.dataId)[0]),V=$pe(_,D,a,d,c,l,u,h,L,f);return n.makeTensorInfo(a,V.dtype,V.values)}const m=[d/c,c],y=Ye({inputs:{x:r},backend:n,attrs:{shape:[l,u]}}),x=o.shape.length?Ye({inputs:{x:o},backend:n,attrs:{shape:[l,c]}}):uo({inputs:{x:o},backend:n}),v=x.dtype,w=n.makeTensorInfo([],v,Vs(1,v)),S=Ye({inputs:{x:i},backend:n,attrs:{shape:Array(m.length).fill(1)}}),k=EE({inputs:{x:S},backend:n,attrs:{reps:m}}),I=ie([l,c]),T=[{type:"int32",data:[u]},{type:"int32",data:h},{type:"int32",data:[I]}];switch(l){case 0:break;case 1:{const _=new gg([l,c],u,y.shape.length,x.shape.length,h,m,v,f);n.runWebGPUProgram(_,[x,y],v,T,k)}break;default:{const _=new gg([l,c],u,y.shape.length,w.shape.length,h,m,v,f);n.runWebGPUProgram(_,[w,y],v,T,k)}{const _=new gg([l,c],u,y.shape.length,x.shape.length,h,m,v);n.runWebGPUProgram(_,[x,y],v,T,k)}}const R=Ye({inputs:{x:k},backend:n,attrs:{shape:a}});return n.disposeData(y.dataId),n.disposeData(x.dataId),n.disposeData(S.dataId),n.disposeData(w.dataId),n.disposeData(k.dataId),R}const jxe={kernelName:Ab,backendName:"webgpu",kernelFunc:Hxe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kxe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{numOrSizeSplits:o,axis:i}=s,a=vt(i,r.shape)[0],u=AS(r,o,a),l=r.shape.length,c=new Array(l).fill(0),h=r.shape.slice();return u.map(d=>{const f=[...h];f[a]=d;const m=Df({inputs:{x:r},backend:n,attrs:{begin:c,size:f}});return c[a]+=d,m})}const Xxe={kernelName:d0,backendName:"webgpu",kernelFunc:Kxe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qxe=Ht({opType:_e.SQRT}),Yxe={kernelName:vf,backendName:"webgpu",kernelFunc:qxe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qxe={kernelName:_b,backendName:"webgpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,s=e,r=new _f(n.shape,_e.SQUARE);return s.runWebGPUProgram(r,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zxe=Ds({opType:ft.SQUARED_DIFFERENCE}),Jxe={kernelName:wf,backendName:"webgpu",kernelFunc:Zxe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e1e({inputs:t,attrs:e,backend:n}){const{x:s}=t,r=new _f(s.shape,_e.STEP,"stepAlpha : f32,"),o=[{type:"float32",data:[e.alpha]}];return n.runWebGPUProgram(r,[s],s.dtype,o)}const t1e={kernelName:If,backendName:"webgpu",kernelFunc:e1e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let n1e=class{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const n=es(this.outputShape.length);this.uniforms=`begin : ${n},  strides : ${n}, `,this.shaderKey="stridedSlice"}getUserCode(){const e=this.outputShape.length;let n="";if(e===1)n="coords * uniforms.strides + uniforms.begin";else{let r=0;n=this.outputShape.map((o,i)=>(r++,this.outputShape.length===1?`coords * uniforms.strides[${i}] + uniforms.begin[${i}]`:`coords[${r-1}] * uniforms.strides[${i}] + uniforms.begin[${i}]`)).join(",")}return`
       ${Pe("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${n}));
         }
       }
     `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s1e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:o,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s,{finalShapeSparse:f,finalShape:m,isIdentity:y,sliceDim0:x,isSimpleSlice:v,begin:w,end:S,strides:k}=fS(r.shape,o,i,a,u,l,c,h,d);let I;if(y)I=Ye({inputs:{x:r},backend:n,attrs:{shape:m}});else if(x||v){O(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const T=pS(w,S,k),R=Df({inputs:{x:r},backend:n,attrs:{begin:w,size:T}});I=Ye({inputs:{x:R},backend:n,attrs:{shape:m}}),n.disposeData(R.dataId)}else if(n.shouldExecuteOnCPU([r])){const R=n.readSync(r.dataId),_=xt(r.shape,r.dtype,R),D=Epe(f,_,k,w);I=n.makeTensorInfo(m,r.dtype,D.values)}else{const R=new n1e(f),_=[{type:"int32",data:w},{type:"int32",data:k}],D=n.runWebGPUProgram(R,[r],r.dtype,_);I=Ye({inputs:{x:D},backend:n,attrs:{shape:m}}),n.disposeData(D.dataId)}return I}const r1e={kernelName:Pb,backendName:"webgpu",kernelFunc:s1e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o1e(t){const{inputs:e,backend:n,attrs:s}=t,{separator:r,nGramWidths:o,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=s,{data:c,dataSplits:h}=e,d=n.readSync(c.dataId),f=n.readSync(h.dataId),[m,y]=Rpe(d,f,r,o,i,a,u,l);return[n.makeTensorInfo([m.length],"string",m),n.makeTensorInfo(h.shape,"int32",y)]}const i1e={kernelName:Fb,backendName:"webgpu",kernelFunc:o1e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a1e=Ds({opType:ft.SUB,cpuKernelImpl:Ape,supportsComplex:!0}),u1e={kernelName:bf,backendName:"webgpu",kernelFunc:a1e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l1e=Ht({opType:_e.TAN}),c1e={kernelName:Sf,backendName:"webgpu",kernelFunc:l1e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h1e=Ht({opType:_e.TANH}),d1e={kernelName:Cf,backendName:"webgpu",kernelFunc:h1e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p1e(t){const{inputs:e,backend:n,attrs:s}=t,{tensor:r,indices:o,updates:i}=e,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=Ra(i,o,r.shape),d=[h/l,l];if(h===0)return n.makeTensorInfo(r.shape,o.dtype);const f=[],m=Ye({inputs:{x:o},backend:n,attrs:{shape:[u,a]}});f.push(m);const y=Ye({inputs:{x:i},backend:n,attrs:{shape:[u,l]}});f.push(y);const x=Ye({inputs:{x:r},backend:n,attrs:{shape:d}});f.push(x);const v=EE({inputs:{x},backend:n,attrs:{reps:Array(d.length).fill(1)}}),w=new gg([u,l],a,m.shape.length,y.shape.length,c,d,r.dtype,!1),S=ie([u,l]),k=[{type:"int32",data:[a]},{type:"int32",data:c},{type:"int32",data:[S]}],I=n.runWebGPUProgram(w,[y,m],x.dtype,k,v);f.push(I);const T=Ye({inputs:{x:I},backend:n,attrs:{shape:r.shape}});return f.forEach(R=>n.disposeData(R.dataId)),T}const f1e={kernelName:Nb,backendName:"webgpu",kernelFunc:p1e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let m1e=class{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${Pe("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}},g1e=class{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${Pe("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pd(t,e){e!==null&&t.disposeData(e.dataId)}function H3(t){let e=1;for(;e<t;)e*=2;return e}function y1e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:o,sorted:i}=s,a=r.shape,u=a[a.length-1];if(n.shouldExecuteOnCPU([r])){const I=n.readSync(r.dataId),[T,R]=Dpe(I,a,r.dtype,o,i);return[n.makeTensorInfo(T.shape,T.dtype,T.values),n.makeTensorInfo(R.shape,R.dtype,R.values)]}if(o===0)return a[a.length-1]=0,[n.makeTensorInfo(a,r.dtype,[]),n.makeTensorInfo(a,"int32",[])];if(u===1)return[r,Pr({attrs:{shape:a,dtype:"int32",value:0},backend:n})];const c=ie(a)/u,h=Ye({inputs:{x:r},attrs:{shape:[c,u]},backend:n}),d=H3(o),f=H3(u);let m=null;const y=()=>m===null?[h,h]:[h,m],x=(I,T,R)=>{const _=y(),D=new m1e(R),V=[{type:"int32",data:[u]},{type:"int32",data:[m===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[I]},{type:"int32",data:[T]}],U=m;m=n.runWebGPUProgram(D,_,"int32",V),pd(n,U)};for(let I=1;I<d;I*=2){const T=I*2;for(let R=I;R>=1;R/=2)x(T,R,[c,f])}for(let I=f;I>d;I/=2){const T=y(),R=new g1e([c,I/2]),D=[{type:"int32",data:[u]},{type:"int32",data:[m===null?1:0]},{type:"int32",data:[d]}],L=m;m=n.runWebGPUProgram(R,T,"int32",D),pd(n,L);const V=d/2,U=V*2;for(let j=V;j>=1;j/=2)x(U,j,m.shape)}let v=m;m=Df({inputs:{x:m},backend:n,attrs:{begin:0,size:[c,o]}}),pd(n,v);let w=IW({inputs:{x:h,indices:m},backend:n,attrs:{axis:1,batchDims:1}});pd(n,h);const S=a.slice(0,-1);S.push(o),v=m,m=Ye({inputs:{x:m},attrs:{shape:S},backend:n}),pd(n,v);const k=w;return w=Ye({inputs:{x:w},attrs:{shape:S},backend:n}),pd(n,k),[w,m]}const x1e={kernelName:Ob,backendName:"webgpu",kernelFunc:y1e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let v1e=class{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${Pe("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w1e(t){const{inputs:e,backend:n,attrs:s}=t,{image:r,transforms:o}=e,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=s,[c,h,d,f]=r.shape,[m,y]=l??[h,d],x=[c,m,y,f],v=new v1e(x),w=i==="nearest"?1:2;let S;switch(a){case"constant":S=1;break;case"reflect":S=2;break;case"wrap":S=3;break;case"nearest":S=4;break;default:S=1;break}const k=[{type:"int32",data:[w]},{type:"int32",data:[S]},{type:"float32",data:[u]}];return n.runWebGPUProgram(v,[r,o],"float32",k)}const b1e={kernelName:Lb,backendName:"webgpu",kernelFunc:w1e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S1e(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:o}=s;o<0&&(o+=r.shape.length);const i=r,a=i.shape.length,u=r.shape[o],l=new Array(a-1);let c=0;for(let y=0;y<a;y++)y!==o&&(l[c++]=i.shape[y]);const h=[],d=new Array(a).fill(0),f=i.shape.slice();f[o]=1;const m=new Array(u);for(let y=0;y<m.length;y++){d[o]=y;const x=Df({inputs:{x:i},backend:n,attrs:{begin:d,size:f}}),v=Ye({inputs:{x},backend:n,attrs:{shape:l}});m[y]=v,h.push(x)}return h.forEach(y=>n.disposeData(y.dataId)),m}const C1e={kernelName:f0,backendName:"webgpu",kernelFunc:S1e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class k1e{constructor(e,n,s){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=n,this.dispatchLayout=Ve(e),this.dispatch=Fe(this.dispatchLayout,e,this.workgroupSize),s!=="float32"&&s!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${s} type.`);this.type=s,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${Pe("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${Wl("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I1e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,segmentIds:o}=e,{numSegments:i}=s,a=r.shape.length,u=[];let l=0;const c=cn([l],a);let h=r;c!=null&&(h=Ia({inputs:{x:r},backend:n,attrs:{perm:c}}),u.push(h),l=Sn(1,a)[0]);const d=xE(h.shape,l,i),f=ie([h.shape[l]]),m=Ye({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}});u.push(m);const y=r.dtype,x=[m.shape[0],i],v=Pr({backend:n,attrs:{shape:x,value:0,dtype:y}}),w=new k1e(m.shape,x,y),S=[{type:"int32",data:[i]},{type:"int32",data:[ie(m.shape)]}],k=n.runWebGPUProgram(w,[m,o],y,S,v),I=Ye({inputs:{x:k},backend:n,attrs:{shape:d}});u.push(k);let T=I;if(c!=null){u.push(I);const R=Ta(c);T=Ia({inputs:{x:T},backend:n,attrs:{perm:R}})}return u.forEach(R=>n.disposeData(R.dataId)),T}const $1e={kernelName:m0,backendName:"webgpu",kernelFunc:I1e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N1e=[Vhe,Ope,Mpe,Bpe,Wpe,Hpe,Zpe,efe,nfe,rfe,ife,ufe,cfe,dfe,ffe,vfe,bfe,Ife,Nfe,Efe,Pfe,Mfe,Vfe,Hfe,Kfe,Qfe,Uhe,eme,rme,dme,xme,Sme,Ime,Nme,Eme,Ame,Dme,Ome,Mme,Bme,Wme,Hme,Zme,ege,Xme,sge,ige,cge,dge,mge,vge,bge,Cge,Ige,Nge,Ege,Rge,_ge,Pge,Mhe,Oge,Wge,Mge,Bge,Hge,Kge,qge,Zge,tye,sye,oye,Whe,aye,nme,lye,hye,pye,mye,yye,vye,Sye,$ye,kye,Tye,Rye,_ye,Oye,zye,gfe,Vye,Uye,Qye,Hye,qye,Jye,yfe,t0e,s0e,o0e,a0e,d0e,gge,f0e,g0e,x0e,Wfe,b0e,C0e,I0e,T0e,R0e,_0e,P0e,O0e,Ufe,M0e,B0e,W0e,G0e,zhe,K0e,Y0e,J0e,nxe,oxe,axe,lxe,hxe,pxe,gxe,vxe,bxe,Cxe,Ixe,Nxe,Exe,_fe,t1e,r1e,i1e,c0e,Axe,Pxe,zxe,Vxe,jxe,Xxe,Yxe,Qxe,Jxe,u1e,yge,c1e,d1e,f1e,Gxe,x1e,b1e,Xpe,C1e,$1e,S0e];for(const t of N1e)xT(t);/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var AW=function(t,e){return(AW=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,s){n.__proto__=s}||function(n,s){for(var r in s)Object.prototype.hasOwnProperty.call(s,r)&&(n[r]=s[r])})(t,e)};function _W(t,e){if(typeof e!="function"&&e!==null)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function n(){this.constructor=t}AW(t,e),t.prototype=e===null?Object.create(e):(n.prototype=e.prototype,new n)}var mn=function(){return(mn=Object.assign||function(t){for(var e,n=1,s=arguments.length;n<s;n++)for(var r in e=arguments[n])Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t}).apply(this,arguments)};function zt(t,e,n,s){return new(n||(n=Promise))(function(r,o){function i(l){try{u(s.next(l))}catch(c){o(c)}}function a(l){try{u(s.throw(l))}catch(c){o(c)}}function u(l){var c;l.done?r(l.value):(c=l.value,c instanceof n?c:new n(function(h){h(c)})).then(i,a)}u((s=s.apply(t,e||[])).next())})}function Bt(t,e){var n,s,r,o,i={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(u){return function(l){return function(c){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,s&&(r=2&c[0]?s.return:c[0]?s.throw||((r=s.return)&&r.call(s),0):s.next)&&!(r=r.call(s,c[1])).done)return r;switch(s=0,r&&(c=[2&c[0],r.value]),c[0]){case 0:case 1:r=c;break;case 4:return i.label++,{value:c[1],done:!1};case 5:i.label++,s=c[1],c=[0];continue;case 7:c=i.ops.pop(),i.trys.pop();continue;default:if(r=i.trys,!((r=r.length>0&&r[r.length-1])||c[0]!==6&&c[0]!==2)){i=0;continue}if(c[0]===3&&(!r||c[1]>r[0]&&c[1]<r[3])){i.label=c[1];break}if(c[0]===6&&i.label<r[1]){i.label=r[1],r=c;break}if(r&&i.label<r[2]){i.label=r[2],i.ops.push(c);break}r[2]&&i.ops.pop(),i.trys.pop();continue}c=e.call(t,i)}catch(h){c=[6,h],s=0}finally{n=r=0}if(5&c[0])throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}([u,l])}}}function Lc(t,e,n){if(n||arguments.length===2)for(var s,r=0,o=e.length;r<o;r++)!s&&r in e||(s||(s=Array.prototype.slice.call(e,0,r)),s[r]=e[r]);return t.concat(s||Array.prototype.slice.call(e))}var $a=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],Jg=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"];function qv(t){return t instanceof SVGAnimatedLength?t.baseVal.value:t}function DW(t){return zt(this,void 0,void 0,function(){var e,n;return Bt(this,function(s){switch(s.label){case 0:return e=document.createElement("canvas"),t instanceof en?[4,pE(t,e)]:[3,2];case 1:return s.sent(),[3,3];case 2:e.width=qv(t.width),e.height=qv(t.height),n=e.getContext("2d"),t instanceof ImageData?n.putImageData(t,0,0):n.drawImage(t,0,0),s.label=3;case 3:return[2,e]}})})}function PW(t){return zt(this,void 0,void 0,function(){var e,n,s,r,o,i;return Bt(this,function(a){switch(a.label){case 0:return t instanceof en?(e=t.shape.slice(0,2),n=e[0],s=e[1],r=ImageData.bind,[4,pE(t)]):[3,2];case 1:return[2,new(r.apply(ImageData,[void 0,a.sent(),s,n]))];case 2:return o=document.createElement("canvas"),i=o.getContext("2d"),o.width=qv(t.width),o.height=qv(t.height),i.drawImage(t,0,0),[2,i.getImageData(0,0,o.width,o.height)]}})})}function T1e(t){return zt(this,void 0,void 0,function(){var e,n;return Bt(this,function(s){switch(s.label){case 0:return t instanceof SVGImageElement||t instanceof OffscreenCanvas?[4,DW(t)]:[3,2];case 1:return n=s.sent(),[3,3];case 2:n=t,s.label=3;case 3:return e=n,[2,NV(e,4)]}})})}function FW(t){if(t<0||t>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(t));if(!Number.isInteger(t))throw new Error("Mask value must be an integer but got ".concat(t))}var Um={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},E1e=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return zt(this,void 0,void 0,function(){return Bt(this,function(e){return[2,this.mask]})})},t.prototype.toImageData=function(){return zt(this,void 0,void 0,function(){return Bt(this,function(e){return[2,PW(this.mask)]})})},t.prototype.toTensor=function(){return zt(this,void 0,void 0,function(){return Bt(this,function(e){return[2,T1e(this.mask)]})})},t.prototype.getUnderlyingType=function(){return"canvasimagesource"},t}();function R1e(t){return FW(t),"person"}var A1e=function(){function t(e){var n,s=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new MJ.Pose({locateFile:function(r,o){if(e.solutionPath){var i=e.solutionPath.replace(/\/+$/,"");return"".concat(i,"/").concat(r)}return"".concat(o,"/").concat(r)}}),e.modelType){case"lite":n=0;break;case"heavy":n=2;break;case"full":default:n=1}this.poseSolution.setOptions({modelComplexity:n,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults(function(r){if(s.height=r.image.height,s.width=r.image.width,r.poseLandmarks==null)s.poses=[];else{var o=s.translateOutput(r.poseLandmarks,r.poseWorldLandmarks);r.segmentationMask&&(o.segmentation={maskValueToLabel:R1e,mask:new E1e(r.segmentationMask)}),s.poses=[o]}})}return t.prototype.translateOutput=function(e,n){var s=this,r={keypoints:e.map(function(o,i){return{x:o.x*s.width,y:o.y*s.height,z:o.z,score:o.visibility,name:Jg[i]}})};return n!=null&&(r.keypoints3D=n.map(function(o,i){return{x:o.x,y:o.y,z:o.z,score:o.visibility,name:Jg[i]}})),r},t.prototype.estimatePoses=function(e,n,s){return zt(this,void 0,void 0,function(){var r,o;return Bt(this,function(i){switch(i.label){case 0:return n&&n.flipHorizontal&&n.flipHorizontal!==this.selfieMode&&(this.selfieMode=n.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof en?(o=ImageData.bind,[4,pE(e)]):[3,2];case 1:return r=new(o.apply(ImageData,[void 0,i.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:r=e,i.label=3;case 3:return e=r,[4,this.poseSolution.send({image:e},s)];case 4:return i.sent(),[2,this.poses]}})})},t.prototype.dispose=function(){this.poseSolution.close()},t.prototype.reset=function(){this.poseSolution.reset()},t.prototype.initialize=function(){return this.poseSolution.initialize()},t}();function _1e(t){return zt(this,void 0,void 0,function(){var e,n;return Bt(this,function(s){switch(s.label){case 0:return e=function(r){if(r==null)return mn({},Um);var o=mn({},r);return o.runtime="mediapipe",o.enableSegmentation==null&&(o.enableSegmentation=Um.enableSegmentation),o.enableSmoothing==null&&(o.enableSmoothing=Um.enableSmoothing),o.smoothSegmentation==null&&(o.smoothSegmentation=Um.smoothSegmentation),o.modelType==null&&(o.modelType=Um.modelType),o}(t),[4,(n=new A1e(e)).initialize()];case 1:return s.sent(),[2,n]}})})}function mp(t){return t instanceof en?{height:t.shape[0],width:t.shape[1]}:{height:t.height,width:t.width}}function OW(t){return t-2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}function RE(t){return t instanceof en?t:NV(t)}function LW(t,e,n){return C$(n,"inputResolution"),[1/n.width*t[0][0]*e.width,1/n.height*t[0][1]*e.width,t[0][3]*e.width,1/n.width*t[1][0]*e.height,1/n.height*t[1][1]*e.height,t[1][3]*e.height,0,0]}function C$(t,e){O(t.width!==0,function(){return"".concat(e," width cannot be 0.")}),O(t.height!==0,function(){return"".concat(e," height cannot be 0.")})}function ak(t,e,n){var s=n.rotationVectorStartKeypointIndex,r=n.rotationVectorEndKeypointIndex,o=t.locationData,i=o.relativeKeypoints[s].x*e.width,a=o.relativeKeypoints[s].y*e.height,u=o.relativeKeypoints[r].x*e.width,l=o.relativeKeypoints[r].y*e.height,c=2*Math.sqrt((u-i)*(u-i)+(l-a)*(l-a)),h=function(d,f,m){var y,x=d.locationData,v=m.rotationVectorStartKeypointIndex,w=m.rotationVectorEndKeypointIndex;y=m.rotationVectorTargetAngle?m.rotationVectorTargetAngle:Math.PI*m.rotationVectorTargetAngleDegree/180;var S=x.relativeKeypoints[v].x*f.width,k=x.relativeKeypoints[v].y*f.height,I=x.relativeKeypoints[w].x*f.width,T=x.relativeKeypoints[w].y*f.height;return OW(y-Math.atan2(-(T-k),I-S))}(t,e,n);return{xCenter:i/e.width,yCenter:a/e.height,width:c/e.width,height:c/e.height,rotation:h}}function MW(t){if(t.length!==16)throw new Error("Array length must be 16 but got ".concat(t.length));return[[t[0],t[1],t[2],t[3]],[t[4],t[5],t[6],t[7]],[t[8],t[9],t[10],t[11]],[t[12],t[13],t[14],t[15]]]}function uk(t,e,n,s,r,o,i){return t[e][r]*(t[n][o]*t[s][i]-t[n][i]*t[s][o])}function ar(t,e,n){var s=(e+1)%4,r=(e+2)%4,o=(e+3)%4,i=(n+1)%4,a=(n+2)%4,u=(n+3)%4;return uk(t,s,r,o,i,a,u)+uk(t,r,o,s,i,a,u)+uk(t,o,s,r,i,a,u)}function j3(t,e,n){n===void 0&&(n={ignoreRotation:!1});for(var s=[],r=0,o=t;r<o.length;r++){var i=o[r],a=i.x-.5,u=i.y-.5,l=n.ignoreRotation?0:e.rotation,c=Math.cos(l)*a-Math.sin(l)*u,h=Math.sin(l)*a+Math.cos(l)*u;c=c*e.width+e.xCenter,h=h*e.height+e.yCenter;var d=i.z*e.width,f=mn({},i);f.x=c,f.y=h,f.z=d,s.push(f)}return s}function zW(t,e){var n=function(s,r,o,i){var a=r-s,u=i-o;if(a===0)throw new Error("Original min and max are both ".concat(s,", range cannot be 0."));var l=u/a;return{scale:l,offset:o-s*l}}(0,255,e[0],e[1]);return ae(function(){return we(Y(t,n.scale),n.offset)})}function k$(t,e,n){var s,r,o,i,a,u,l,c,h,d,f,m,y,x,v=e.outputTensorSize,w=e.keepAspectRatio,S=e.borderMode,k=e.outputTensorFloatRange,I=mp(t),T=function(D,L){return L?{xCenter:L.xCenter*D.width,yCenter:L.yCenter*D.height,width:L.width*D.width,height:L.height*D.height,rotation:L.rotation}:{xCenter:.5*D.width,yCenter:.5*D.height,width:D.width,height:D.height,rotation:0}}(I,n),R=function(D,L,V){if(V===void 0&&(V=!1),!V)return{top:0,left:0,right:0,bottom:0};var U=L.height,j=L.width;C$(L,"targetSize"),C$(D,"roi");var q,J,te=U/j,le=D.height/D.width,K=0,re=0;return te>le?(q=D.width,J=D.width*te,re=(1-le/te)/2):(q=D.height/te,J=D.height,K=(1-te/le)/2),D.width=q,D.height=J,{top:re,left:K,right:K,bottom:re}}(T,v,w),_=(s=T,r=I.width,o=I.height,i=!1,a=s.width,u=s.height,l=i?-1:1,c=Math.cos(s.rotation),h=Math.sin(s.rotation),d=s.xCenter,f=s.yCenter,m=1/r,y=1/o,(x=new Array(16))[0]=a*c*l*m,x[1]=-u*h*m,x[2]=0,x[3]=(-.5*a*c*l+.5*u*h+d)*m,x[4]=a*h*l*y,x[5]=u*c*y,x[6]=0,x[7]=(-.5*u*c-.5*a*h*l+f)*y,x[8]=0,x[9]=0,x[10]=a*m,x[11]=0,x[12]=0,x[13]=0,x[14]=0,x[15]=1,MW(x));return{imageTensor:ae(function(){var D=RE(t),L=mi(LW(_,I,v),[1,8]),V=S==="zero"?"constant":"nearest",U=Xs.transform(us(De(D,"float32")),L,"bilinear",V,0,[v.height,v.width]);return k!=null?zW(U,k):U}),padding:R,transformationMatrix:_}}function K3(t,e,n,s){return s===1?.5*(t+e):t+(e-t)*n/(s-1)}function D1e(t){return ae(function(){var e=function(r){return ae(function(){return[mt(r,[0,0,0],[1,-1,1]),mt(r,[0,0,1],[1,-1,-1])]})}(t),n=e[0],s=e[1];return{boxes:Yt(s),logits:Yt(n)}})}function BW(t){return t!=null&&t.currentTime!=null}function X3(t){for(var e={locationData:{relativeKeypoints:[]}},n=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,r=Number.MAX_SAFE_INTEGER,o=Number.MIN_SAFE_INTEGER,i=0;i<t.length;++i){var a=t[i];n=Math.min(n,a.x),s=Math.max(s,a.x),r=Math.min(r,a.y),o=Math.max(o,a.y),e.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return e.locationData.relativeBoundingBox={xMin:n,yMin:r,xMax:s,yMax:o,width:s-n,height:o-r},e}function P1e(t,e,n,s){return zt(this,void 0,void 0,function(){var r,o,i,a,u;return Bt(this,function(l){switch(l.label){case 0:return t.sort(function(c,h){return Math.max.apply(Math,h.score)-Math.max.apply(Math,c.score)}),r=mi(t.map(function(c){return[c.locationData.relativeBoundingBox.yMin,c.locationData.relativeBoundingBox.xMin,c.locationData.relativeBoundingBox.yMax,c.locationData.relativeBoundingBox.xMax]})),o=ls(t.map(function(c){return c.score[0]})),[4,Xs.nonMaxSuppressionAsync(r,o,e,n)];case 1:return[4,(i=l.sent()).array()];case 2:return a=l.sent(),u=t.filter(function(c,h){return a.indexOf(h)>-1}),ot([r,o,i]),[2,u]}})})}function VW(t,e){return t.map(function(n){var s=mn(mn({},n),{x:n.x*e.width,y:n.y*e.height});return n.z!=null&&(s.z=n.z*e.width),s})}function F1e(t,e,n){return zt(this,void 0,void 0,function(){var s,r,o,i,a,u,l,c,h,d,f,m,y,x,v,w,S,k,I,T,R,_,D,L;return Bt(this,function(V){switch(V.label){case 0:if(s=Yt(e,[0]),r=s.shape,o=r[0],i=r[1],a=r[2],t.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(t.length,", heatmap length: ").concat(a));return u=[],[4,s.buffer()];case 1:for(l=V.sent(),c=0;c<t.length;c++)if(h=t[c],d=mn({},h),u.push(d),f=Math.trunc(d.x*i),m=Math.trunc(d.y*o),!(f<0||f>=i||m<0||f>=o)){for(y=Math.trunc((n.kernelSize-1)/2),x=Math.max(0,f-y),v=Math.min(i,f+y+1),w=Math.max(0,m-y),S=Math.min(o,m+y+1),k=0,I=0,T=0,R=0,_=w;_<S;++_)for(D=x;D<v;++D)L=l.get(_,D,c),k+=L,R=Math.max(R,L),I+=D*L,T+=_*L;R>=n.minConfidenceToRefine&&k>0&&(d.x=I/i/k,d.y=T/o/k)}return s.dispose(),[2,u]}})})}function q3(t,e){var n=e.left,s=e.top,r=e.left+e.right,o=e.top+e.bottom;return t.map(function(i){return mn(mn({},i),{x:(i.x-n)/(1-r),y:(i.y-s)/(1-o),z:i.z/(1-r)})})}function O1e(t,e,n){return Ug()==="webgl"?function(s,r,o){var i=o.combineWithPreviousRatio.toFixed(2),a={variableNames:["prevMask","newMask"],outputShape:s.shape,userCode:`
  void main() {
      ivec2 coords = getOutputCoords();
      int height = coords[0];
      int width = coords[1];

      float prevMaskValue = getPrevMask(height, width);
      float newMaskValue = getNewMask(height, width);

      /*
      * Assume p := newMaskValue
      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)
      * uncertainty alpha(p) =
      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the
      * uncertainty]
      *
      * The following polynomial approximates uncertainty alpha as a
      * function of (p + 0.5):
      */
      const float c1 = 5.68842;
      const float c2 = -0.748699;
      const float c3 = -57.8051;
      const float c4 = 291.309;
      const float c5 = -624.717;
      float t = newMaskValue - 0.5;
      float x = t * t;

      float uncertainty =
        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));

      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *
                             (uncertainty * `.concat(i,`);

      setOutput(outputValue);
    }
`)},u=th();return ae(function(){var l=u.compileAndRun(a,[s,r]);return lr().makeTensorFromDataId(l.dataId,l.shape,l.dtype)})}(t,e,n):ae(function(){var s=Be(e,.5),r=an(s),o=Be(1,kl(1,Y(r,we(5.68842,Y(r,we(-.748699,Y(r,we(-57.8051,Y(r,we(291.309,Y(r,-624.717)))))))))));return we(e,Y(Be(t,e),Y(o,n.combineWithPreviousRatio)))})}function L1e(t,e,n){return zt(this,void 0,void 0,function(){var s,r,o,i,a;return Bt(this,function(u){switch(u.label){case 0:return s=t[0],r=t[1],o=function(l,c,h){return ae(function(){var d,f,m,y;h.reverseOutputOrder?(f=Yt(mt(l,[0,h.boxCoordOffset+0],[-1,1])),d=Yt(mt(l,[0,h.boxCoordOffset+1],[-1,1])),y=Yt(mt(l,[0,h.boxCoordOffset+2],[-1,1])),m=Yt(mt(l,[0,h.boxCoordOffset+3],[-1,1]))):(d=Yt(mt(l,[0,h.boxCoordOffset+0],[-1,1])),f=Yt(mt(l,[0,h.boxCoordOffset+1],[-1,1])),m=Yt(mt(l,[0,h.boxCoordOffset+2],[-1,1])),y=Yt(mt(l,[0,h.boxCoordOffset+3],[-1,1]))),f=we(Y(Ge(f,h.xScale),c.w),c.x),d=we(Y(Ge(d,h.yScale),c.h),c.y),h.applyExponentialOnBoxSize?(m=Y(mr(Ge(m,h.hScale)),c.h),y=Y(mr(Ge(y,h.wScale)),c.w)):(m=Y(Ge(m,h.hScale),c.h),y=Y(Ge(y,h.wScale),c.h));var x=Be(d,Ge(m,2)),v=Be(f,Ge(y,2)),w=we(d,Ge(m,2)),S=we(f,Ge(y,2)),k=Ln([ee(x,[h.numBoxes,1]),ee(v,[h.numBoxes,1]),ee(w,[h.numBoxes,1]),ee(S,[h.numBoxes,1])],1);if(h.numKeypoints)for(var I=0;I<h.numKeypoints;++I){var T=h.keypointCoordOffset+I*h.numValuesPerKeypoint,R=void 0,_=void 0;h.reverseOutputOrder?(R=Yt(mt(l,[0,T],[-1,1])),_=Yt(mt(l,[0,T+1],[-1,1]))):(_=Yt(mt(l,[0,T],[-1,1])),R=Yt(mt(l,[0,T+1],[-1,1])));var D=we(Y(Ge(R,h.xScale),c.w),c.x),L=we(Y(Ge(_,h.yScale),c.h),c.y);k=Ln([k,ee(D,[h.numBoxes,1]),ee(L,[h.numBoxes,1])],1)}return k})}(r,e,n),i=ae(function(){var l=s;return n.sigmoidScore?(n.scoreClippingThresh!=null&&(l=Or(s,-n.scoreClippingThresh,n.scoreClippingThresh)),l=Eo(l)):l}),[4,M1e(o,i,n)];case 1:return a=u.sent(),ot([o,i]),[2,a]}})})}function M1e(t,e,n){return zt(this,void 0,void 0,function(){var s,r,o,i,a,u,l,c,h,d,f,m;return Bt(this,function(y){switch(y.label){case 0:return s=[],[4,t.data()];case 1:return r=y.sent(),[4,e.data()];case 2:for(o=y.sent(),i=0;i<n.numBoxes;++i)if(!(n.minScoreThresh!=null&&o[i]<n.minScoreThresh||(a=i*n.numCoords,u=z1e(r[a+0],r[a+1],r[a+2],r[a+3],o[i],n.flipVertically,i),(l=u.locationData.relativeBoundingBox).width<0||l.height<0))){if(n.numKeypoints>0)for((c=u.locationData).relativeKeypoints=[],h=n.numKeypoints*n.numValuesPerKeypoint,d=0;d<h;d+=n.numValuesPerKeypoint)f=a+n.keypointCoordOffset+d,m={x:r[f+0],y:n.flipVertically?1-r[f+1]:r[f+1]},c.relativeKeypoints.push(m);s.push(u)}return[2,s]}})})}function z1e(t,e,n,s,r,o,i){return{score:[r],ind:i,locationData:{relativeBoundingBox:{xMin:e,yMin:o?1-n:t,xMax:s,yMax:o?1-t:n,width:s-e,height:n-t}}}}function B1e(t,e){return t==="none"?e:function(n){return 1/(1+Math.exp(-n))}(e)}function Y3(t,e,n,s){return zt(this,void 0,void 0,function(){var r,o,i,a,u,l,c,h;return Bt(this,function(d){switch(d.label){case 0:return n=n||e.flipHorizontally||!1,s=s||e.flipVertically||!1,r=t.size,o=r/e.numLandmarks,[4,t.data()];case 1:for(i=d.sent(),a=[],u=0;u<e.numLandmarks;++u)l=u*o,(h={x:0,y:0}).x=n?e.inputImageWidth-i[l]:i[l],o>1&&(h.y=s?e.inputImageHeight-i[l+1]:i[l+1]),o>2&&(h.z=i[l+2]),o>3&&(h.score=B1e(e.visibilityActivation,i[l+3])),a.push(h);for(c=0;c<a.length;++c)(h=a[c]).x=h.x/e.inputImageWidth,h.y=h.y/e.inputImageHeight,h.z=h.z/e.inputImageWidth/(e.normalizeZ||1);return[2,a]}})})}function Q3(t,e,n){var s=t.width,r=t.height,o=t.rotation;if(n.rotation==null&&n.rotationDegree==null||(o=function(c,h){return h.rotation!=null?c+=h.rotation:h.rotationDegree!=null&&(c+=Math.PI*h.rotationDegree/180),OW(c)}(o,n)),o===0)t.xCenter=t.xCenter+s*n.shiftX,t.yCenter=t.yCenter+r*n.shiftY;else{var i=(e.width*s*n.shiftX*Math.cos(o)-e.height*r*n.shiftY*Math.sin(o))/e.width,a=(e.width*s*n.shiftX*Math.sin(o)+e.height*r*n.shiftY*Math.cos(o))/e.height;t.xCenter=t.xCenter+i,t.yCenter=t.yCenter+a}if(n.squareLong){var u=Math.max(s*e.width,r*e.height);s=u/e.width,r=u/e.height}else if(n.squareShort){var l=Math.min(s*e.width,r*e.height);s=l/e.width,r=l/e.height}return t.width=s*n.scaleX,t.height=r*n.scaleY,t}function WW(t,e){return t.map(function(n){var s=mn(mn({},n),{x:n.x/e.width,y:n.y/e.height});return n.z!=null&&(n.z=n.z/e.width),s})}var Ju=function(){function t(e){this.alpha=e,this.initialized=!1}return t.prototype.apply=function(e,n){var s;return this.initialized?s=n==null?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*n*Math.asinh((e-this.storedValue)/n):(s=e,this.initialized=!0),this.rawValue=e,this.storedValue=s,s},t.prototype.applyWithAlpha=function(e,n,s){return this.alpha=n,this.apply(e,s)},t.prototype.hasLastRawValue=function(){return this.initialized},t.prototype.lastRawValue=function(){return this.rawValue},t.prototype.reset=function(){this.initialized=!1},t}(),lk=function(){function t(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new Ju(this.getAlpha(this.minCutOff)),this.dx=new Ju(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return t.prototype.apply=function(e,n,s){if(e==null)return e;var r=Math.trunc(n);if(this.lastTimestamp>=r)return e;this.lastTimestamp!==0&&r!==0&&(this.frequency=1/(1e-6*(r-this.lastTimestamp))),this.lastTimestamp=r;var o=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*s*this.frequency:0,i=this.dx.applyWithAlpha(o,this.getAlpha(this.derivateCutOff)),a=this.minCutOff+this.beta*Math.abs(i),u=this.thresholdCutOff!=null?this.thresholdCutOff+this.thresholdBeta*Math.abs(i):null;return this.x.applyWithAlpha(e,this.getAlpha(a),u)},t.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},t}(),I$=function(){function t(e){this.config=e}return t.prototype.apply=function(e,n,s){var r=this;if(e==null)return this.reset(),null;this.initializeFiltersIfEmpty(e);var o=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return Lc([],e,!0);o=1/s}return e.map(function(i,a){var u=mn(mn({},i),{x:r.xFilters[a].apply(i.x,n,o),y:r.yFilters[a].apply(i.y,n,o)});return i.z!=null&&(u.z=r.zFilters[a].apply(i.z,n,o)),u})},t.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},t.prototype.initializeFiltersIfEmpty=function(e){var n=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(s){return new lk(n.config)}),this.yFilters=e.map(function(s){return new lk(n.config)}),this.zFilters=e.map(function(s){return new lk(n.config)}))},t}(),ck=function(){function t(e){this.config=e,this.window=[],this.lowPassFilter=new Ju(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return t.prototype.apply=function(e,n,s){if(e==null)return e;var r,o=Math.trunc(n);if(this.lastTimestamp>=o)return e;if(this.lastTimestamp===-1)r=1;else{for(var i=e*s-this.lastValue*this.lastValueScale,a=o-this.lastTimestamp,u=i,l=a,c=(1+this.window.length)*(1e6/30),h=0,d=this.window;h<d.length;h++){var f=d[h];if(l+f.duration>c)break;u+=f.distance,l+=f.duration}var m=u/(1e-6*l);r=1-1/(1+this.config.velocityScale*Math.abs(m)),this.window.unshift({distance:i,duration:a}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=s,this.lastTimestamp=o,this.lowPassFilter.applyWithAlpha(e,r)},t}(),V1e=function(){function t(e){this.config=e}return t.prototype.apply=function(e,n,s){var r=this;if(e==null)return this.reset(),null;var o=1;if(!this.config.disableValueScaling){if(s<this.config.minAllowedObjectScale)return Lc([],e,!0);o=1/s}return this.initializeFiltersIfEmpty(e),e.map(function(i,a){var u=mn(mn({},i),{x:r.xFilters[a].apply(i.x,n,o),y:r.yFilters[a].apply(i.y,n,o)});return i.z!=null&&(u.z=r.zFilters[a].apply(i.z,n,o)),u})},t.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},t.prototype.initializeFiltersIfEmpty=function(e){var n=this;this.xFilters!=null&&this.xFilters.length===e.length||(this.xFilters=e.map(function(s){return new ck(n.config)}),this.yFilters=e.map(function(s){return new ck(n.config)}),this.zFilters=e.map(function(s){return new ck(n.config)}))},t}(),hk=function(){function t(e){if(e.velocityFilter!=null)this.keypointsFilter=new V1e(e.velocityFilter);else{if(e.oneEuroFilter==null)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new I$(e.oneEuroFilter)}}return t.prototype.apply=function(e,n,s,r,o){if(r===void 0&&(r=!1),e==null)return this.keypointsFilter.reset(),null;var i=o!=null?function(l,c){return(l.width*c.width+l.height*c.height)/2}(o,s):1,a=r?VW(e,s):e,u=this.keypointsFilter.apply(a,n,i);return r?WW(u,s):u},t}(),Z3=function(){function t(e){this.alpha=e.alpha}return t.prototype.apply=function(e){var n=this;if(e==null)return this.visibilityFilters=null,null;this.visibilityFilters!=null&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map(function(a){return new Ju(n.alpha)}));for(var s=[],r=0;r<e.length;++r){var o=e[r],i=mn({},o);i.score=this.visibilityFilters[r].apply(o.score),s.push(i)}return s},t}(),W1e={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},fd={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},U1e={maxPoses:1,flipHorizontal:!1},G1e={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},H1e=.3,J3={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},j1e={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},K1e={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},X1e={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},q1e={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},Y1e={kernelSize:7,minConfidenceToRefine:.5},eP={alpha:.1},Q1e={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},Z1e={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},J1e={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},eve={activation:"none"},tve={combineWithPreviousRatio:.7},nve=function(){function t(e){this.mask=e}return t.prototype.toCanvasImageSource=function(){return zt(this,void 0,void 0,function(){return Bt(this,function(e){return[2,DW(this.mask)]})})},t.prototype.toImageData=function(){return zt(this,void 0,void 0,function(){return Bt(this,function(e){return[2,PW(this.mask)]})})},t.prototype.toTensor=function(){return zt(this,void 0,void 0,function(){return Bt(this,function(e){return[2,this.mask]})})},t.prototype.getUnderlyingType=function(){return"tensor"},t}();function sve(t){return FW(t),"person"}var rve=function(){function t(e,n,s,r,o,i){this.detectorModel=e,this.landmarkModel=n,this.enableSmoothing=s,this.enableSegmentation=r,this.smoothSegmentation=o,this.modelType=i,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(h){h.reduceBoxesInLowestLayer==null&&(h.reduceBoxesInLowestLayer=!1),h.interpolatedScaleAspectRatio==null&&(h.interpolatedScaleAspectRatio=1),h.fixedAnchorSize==null&&(h.fixedAnchorSize=!1);for(var d=[],f=0;f<h.numLayers;){for(var m=[],y=[],x=[],v=[],w=f;w<h.strides.length&&h.strides[w]===h.strides[f];){var S=K3(h.minScale,h.maxScale,w,h.strides.length);if(w===0&&h.reduceBoxesInLowestLayer)x.push(1),x.push(2),x.push(.5),v.push(.1),v.push(S),v.push(S);else{for(var k=0;k<h.aspectRatios.length;++k)x.push(h.aspectRatios[k]),v.push(S);if(h.interpolatedScaleAspectRatio>0){var I=w===h.strides.length-1?1:K3(h.minScale,h.maxScale,w+1,h.strides.length);v.push(Math.sqrt(S*I)),x.push(h.interpolatedScaleAspectRatio)}}w++}for(var T=0;T<x.length;++T){var R=Math.sqrt(x[T]);m.push(v[T]/R),y.push(v[T]*R)}var _=0,D=0;if(h.featureMapHeight.length>0)_=h.featureMapHeight[f],D=h.featureMapWidth[f];else{var L=h.strides[f];_=Math.ceil(h.inputSizeHeight/L),D=Math.ceil(h.inputSizeWidth/L)}for(var V=0;V<_;++V)for(var U=0;U<D;++U)for(var j=0;j<m.length;++j){var q={xCenter:(U+h.anchorOffsetX)/D,yCenter:(V+h.anchorOffsetY)/_,width:0,height:0};h.fixedAnchorSize?(q.width=1,q.height=1):(q.width=y[j],q.height=m[j]),d.push(q)}f=w}return d}(W1e);var a=ls(this.anchors.map(function(h){return h.width})),u=ls(this.anchors.map(function(h){return h.height})),l=ls(this.anchors.map(function(h){return h.xCenter})),c=ls(this.anchors.map(function(h){return h.yCenter}));this.anchorTensor={x:l,y:c,w:a,h:u},this.prevFilteredSegmentationMask=this.enableSegmentation?mi([],[0,0]):null}return t.prototype.estimatePoses=function(e,n,s){return zt(this,void 0,void 0,function(){var r,o,i,a,u,l,c,h,d,f,m,y,x,v,w,S,k,I,T,R,_,D,L;return Bt(this,function(V){switch(V.label){case 0:return r=function(U){var j;if((j=U==null?U1e:mn({},U)).maxPoses==null&&(j.maxPoses=1),j.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(j.maxPoses,". Should be > 0."));if(j.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return j}(n),e==null?(this.reset(),[2,[]]):(this.maxPoses=r.maxPoses,this.timestamp=s!=null?1e3*s:BW(e)?1e6*e.currentTime:null,o=mp(e),i=ae(function(){return De(RE(e),"float32")}),(a=this.regionOfInterest)!=null?[3,2]:[4,this.detectPose(i)]);case 1:if((u=V.sent()).length===0)return this.reset(),i.dispose(),[2,[]];l=u[0],a=this.poseDetectionToRoi(l,o),V.label=2;case 2:return[4,this.poseLandmarksByRoi(a,i)];case 3:return c=V.sent(),i.dispose(),c==null?(this.reset(),[2,[]]):(h=c.landmarks,d=c.auxiliaryLandmarks,f=c.poseScore,m=c.worldLandmarks,y=c.segmentationMask,x=this.poseLandmarkFiltering(h,d,m,o),v=x.actualLandmarksFiltered,w=x.auxiliaryLandmarksFiltered,S=x.actualWorldLandmarksFiltered,k=this.poseLandmarksToRoi(w,o),this.regionOfInterest=k,I=this.smoothSegmentation&&y!=null?this.poseSegmentationFiltering(y):y,(T=v!=null?VW(v,o):null)!=null&&T.forEach(function(U,j){U.name=Jg[j]}),(R=S)!=null&&R.forEach(function(U,j){U.name=Jg[j]}),_={score:f,keypoints:T,keypoints3D:R},I!==null&&(D=ae(function(){var U=us(I,2),j=Ui(U,[[0,0],[0,0],[0,1]]);return OT(j,[[0,0],[0,0],[0,2]],"symmetric")}),this.smoothSegmentation||ot(I),L={maskValueToLabel:sve,mask:new nve(D)},_.segmentation=L),[2,[_]])}})})},t.prototype.poseSegmentationFiltering=function(e){var n=this.prevFilteredSegmentationMask;return n.size===0?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=O1e(n,e,tve),ot(e)),ot(n),this.prevFilteredSegmentationMask},t.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),ot([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},t.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(ot(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=mi([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},t.prototype.detectPose=function(e){return zt(this,void 0,void 0,function(){var n,s,r,o,i,a,u,l,c,h;return Bt(this,function(d){switch(d.label){case 0:return n=k$(e,j1e),s=n.imageTensor,r=n.padding,o=this.detectorModel.predict(s),i=D1e(o),a=i.boxes,[4,L1e([u=i.logits,a],this.anchorTensor,G1e)];case 1:return(l=d.sent()).length===0?(ot([s,o,u,a]),[2,l]):[4,P1e(l,this.maxPoses,H1e)];case 2:return c=d.sent(),h=function(f,m){f===void 0&&(f=[]);for(var y=m.left,x=m.top,v=m.left+m.right,w=m.top+m.bottom,S=0;S<f.length;S++){var k=f[S],I=k.locationData.relativeBoundingBox,T=(I.xMin-y)/(1-v),R=(I.yMin-x)/(1-w),_=I.width/(1-v),D=I.height/(1-w);I.xMin=T,I.yMin=R,I.width=_,I.height=D,I.xMax=T+_,I.yMax=R+D;var L=k.locationData.relativeKeypoints;L&&L.forEach(function(V){var U=(V.x-y)/(1-v),j=(V.y-x)/(1-w);V.x=U,V.y=j})}return f}(c,r),ot([s,o,u,a]),[2,h]}})})},t.prototype.poseDetectionToRoi=function(e,n){return Q3(ak(e,n,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),n,J3)},t.prototype.poseLandmarksByRoi=function(e,n){return zt(this,void 0,void 0,function(){var s,r,o,i,a,u,l,c,h,d,f,m,y,x;return Bt(this,function(v){switch(v.label){case 0:if(s=mp(n),r=k$(n,K1e,e),o=r.imageTensor,i=r.padding,a=r.transformationMatrix,this.modelType!=="lite"&&this.modelType!=="full"&&this.modelType!=="heavy")throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return u=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&u.push("activation_segmentation"),l=this.landmarkModel.execute(o,u),[4,this.tensorsToPoseLandmarksAndSegmentation(l)];case 1:return(c=v.sent())==null?(ot(l),ot(o),[2,null]):(h=c.landmarks,d=c.auxiliaryLandmarks,f=c.poseScore,m=c.worldLandmarks,y=c.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(s,e,i,a,h,d,m,y)]);case 2:return x=v.sent(),ot(l),ot(o),[2,mn({poseScore:f},x)]}})})},t.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,n,s,r,o,i,a,u){return zt(this,void 0,void 0,function(){var l,c,h,d,f,m;return Bt(this,function(y){return l=q3(o,s),c=q3(i,s),h=j3(l,n),d=j3(c,n),f=function(x,v){for(var w=[],S=0,k=x;S<k.length;S++){var I=k[S],T=I.x,R=I.y,_=v.rotation,D=Math.cos(_)*T-Math.sin(_)*R,L=Math.sin(_)*T+Math.cos(_)*R,V=mn({},I);V.x=D,V.y=L,w.push(V)}return w}(a,n),m=null,this.enableSegmentation&&(m=ae(function(){var x=u.shape,v=x[0],w=x[1],S=function(T){var R=MW(new Array(16).fill(0));R[0][0]=ar(T,0,0),R[1][0]=-ar(T,0,1),R[2][0]=ar(T,0,2),R[3][0]=-ar(T,0,3),R[0][2]=ar(T,2,0),R[1][2]=-ar(T,2,1),R[2][2]=ar(T,2,2),R[3][2]=-ar(T,2,3),R[0][1]=-ar(T,1,0),R[1][1]=ar(T,1,1),R[2][1]=-ar(T,1,2),R[3][1]=ar(T,1,3),R[0][3]=-ar(T,3,0),R[1][3]=ar(T,3,1),R[2][3]=-ar(T,3,2),R[3][3]=ar(T,3,3);for(var _=T[0][0]*R[0][0]+T[1][0]*R[0][1]+T[2][0]*R[0][2]+T[3][0]*R[0][3],D=0;D<R.length;D++)for(var L=0;L<R.length;L++)R[D][L]/=_;return R}(r),k=mi(LW(S,{width:w,height:v},e),[1,8]),I=[1,v,w,1];return Yt(Xs.transform(ee(u,I),k,"bilinear","constant",0,[e.height,e.width]),[0,3])}),ot(u)),[2,{landmarks:h,auxiliaryLandmarks:d,worldLandmarks:f,segmentationMask:m}]})})},t.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return zt(this,void 0,void 0,function(){var n,s,r,o,i,a,u,l,c,h,d,f,m;return Bt(this,function(y){switch(y.label){case 0:return n=e[0],s=e[1],r=e[2],o=e[3],i=this.enableSegmentation?e[4]:null,[4,s.data()];case 1:return(a=y.sent()[0])<.5?[2,null]:[4,Y3(n,X1e)];case 2:return[4,F1e(y.sent(),r,Y1e)];case 3:return u=y.sent(),l=u.slice(0,33),c=u.slice(33,35),[4,Y3(o,q1e)];case 4:return h=y.sent(),d=h.slice(0,33),f=function(x,v,w){w===void 0&&(w=!0);for(var S=[],k=0;k<x.length;k++){var I=mn({},v[k]);w&&(I.score=x[k].score),S.push(I)}return S}(l,d,!0),m=this.enableSegmentation?function(x,v,w){return ae(function(){var S=Yt(x,[0]),k=S.shape[2];if(k===1){var I=S;switch(v.activation){case"none":break;case"sigmoid":I=Eo(I);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(v.activation,")"))}var T=w?Xs.resizeBilinear(I,[w.height,w.width]):I;return Yt(T,[2])}throw new Error("Unsupported number of tensor channels ".concat(k))})}(i,eve):null,[2,{landmarks:l,auxiliaryLandmarks:c,poseScore:a,worldLandmarks:f,segmentationMask:m}]}})})},t.prototype.poseLandmarksToRoi=function(e,n){return Q3(ak(X3(e),n,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),n,J3)},t.prototype.poseLandmarkFiltering=function(e,n,s,r){var o,i,a;if(this.timestamp!=null&&this.enableSmoothing){var u=ak(X3(n),r,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});this.visibilitySmoothingFilterActual==null&&(this.visibilitySmoothingFilterActual=new Z3(eP)),o=this.visibilitySmoothingFilterActual.apply(e),this.visibilitySmoothingFilterAuxiliary==null&&(this.visibilitySmoothingFilterAuxiliary=new Z3(eP)),i=this.visibilitySmoothingFilterAuxiliary.apply(n),a=this.visibilitySmoothingFilterActual.apply(s),this.landmarksSmoothingFilterActual==null&&(this.landmarksSmoothingFilterActual=new hk(Q1e)),o=this.landmarksSmoothingFilterActual.apply(o,this.timestamp,r,!0,u),this.landmarksSmoothingFilterAuxiliary==null&&(this.landmarksSmoothingFilterAuxiliary=new hk(Z1e)),i=this.landmarksSmoothingFilterAuxiliary.apply(i,this.timestamp,r,!0,u),this.worldLandmarksSmoothingFilterActual==null&&(this.worldLandmarksSmoothingFilterActual=new hk(J1e)),a=this.worldLandmarksSmoothingFilterActual.apply(s,this.timestamp)}else o=e,i=n,a=s;return{actualLandmarksFiltered:o,auxiliaryLandmarksFiltered:i,actualWorldLandmarksFiltered:a}},t}();function ove(t){return zt(this,void 0,void 0,function(){var e,n,s,r,o,i;return Bt(this,function(a){switch(a.label){case 0:return e=function(u){var l=mn({},u??fd);if(l.enableSmoothing==null&&(l.enableSmoothing=fd.enableSmoothing),l.enableSegmentation==null&&(l.enableSegmentation=fd.enableSegmentation),l.smoothSegmentation==null&&(l.smoothSegmentation=fd.smoothSegmentation),l.modelType==null&&(l.modelType=fd.modelType),l.detectorModelUrl==null&&(l.detectorModelUrl=fd.detectorModelUrl),l.landmarkModelUrl==null)switch(l.modelType){case"lite":l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;case"full":default:l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return l}(t),n=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,s=typeof e.landmarkModelUrl=="string"&&e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([dp(e.detectorModelUrl,{fromTFHub:n}),dp(e.landmarkModelUrl,{fromTFHub:s})])];case 1:return r=a.sent(),o=r[0],i=r[1],[2,new rve(o,i,e.enableSmoothing,e.enableSegmentation,e.smoothSegmentation,e.modelType)]}})})}var Gc,va,UW=function(){function t(e){(function(n){if(n.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(n.maxTracks));if(n.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(n.maxAge));if(n.keypointTrackerParams!==void 0){if(n.keypointTrackerParams.keypointConfidenceThreshold<0||n.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(n.keypointTrackerParams.keypointConfidenceThreshold));if(n.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(n.keypointTrackerParams.minNumberOfKeypoints));for(var s=0,r=n.keypointTrackerParams.keypointFalloff;s<r.length;s++){var o=r[s];if(o<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(o))}}})(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return t.prototype.apply=function(e,n){this.filterOldTracks(n);var s=this.computeSimilarity(e);return this.assignTracks(e,s,n),this.updateTracks(n),e},t.prototype.getTracks=function(){return this.tracks.slice()},t.prototype.getTrackIDs=function(){return new Set(this.tracks.map(function(e){return e.id}))},t.prototype.filterOldTracks=function(e){var n=this;this.tracks=this.tracks.filter(function(s){return e-s.lastTimestamp<=n.maxAge})},t.prototype.assignTracks=function(e,n,s){for(var r=Array.from(Array(n[0].length).keys()),o=[],i=0,a=Array.from(Array(e.length).keys());i<a.length;i++){var u=a[i];if(r.length!==0){for(var l=-1,c=-1,h=0,d=r;h<d.length;h++){var f=d[h],m=n[u][f];m>=this.minSimilarity&&m>c&&(l=f,c=m)}if(l>=0){var y=this.tracks[l];y=Object.assign(y,this.createTrack(e[u],s,y.id)),e[u].id=y.id;var x=r.indexOf(l);r.splice(x,1)}else o.push(u)}else o.push(u)}for(var v=0,w=o;v<w.length;v++){u=w[v];var S=this.createTrack(e[u],s);this.tracks.push(S),e[u].id=S.id}},t.prototype.updateTracks=function(e){this.tracks.sort(function(n,s){return s.lastTimestamp-n.lastTimestamp}),this.tracks=this.tracks.slice(0,this.maxTracks)},t.prototype.createTrack=function(e,n,s){var r={id:s||this.nextTrackID(),lastTimestamp:n,keypoints:Lc([],e.keypoints,!0).map(function(o){return mn({},o)})};return e.box!==void 0&&(r.box=mn({},e.box)),r},t.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},t.prototype.remove=function(){for(var e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];this.tracks=this.tracks.filter(function(s){return!e.includes(s.id)})},t.prototype.reset=function(){this.tracks=[]},t}(),ive=function(t){function e(n){return t.call(this,n)||this}return _W(e,t),e.prototype.computeSimilarity=function(n){var s=this;return n.length===0||this.tracks.length===0?[[]]:n.map(function(r){return s.tracks.map(function(o){return s.iou(r,o)})})},e.prototype.iou=function(n,s){var r=Math.max(n.box.xMin,s.box.xMin),o=Math.max(n.box.yMin,s.box.yMin),i=Math.min(n.box.xMax,s.box.xMax),a=Math.min(n.box.yMax,s.box.yMax);if(r>=i||o>=a)return 0;var u=(i-r)*(a-o);return u/(n.box.width*n.box.height+s.box.width*s.box.height-u)},e}(UW),ave=function(t){function e(n){var s=t.call(this,n)||this;return s.keypointThreshold=n.keypointTrackerParams.keypointConfidenceThreshold,s.keypointFalloff=n.keypointTrackerParams.keypointFalloff,s.minNumKeyoints=n.keypointTrackerParams.minNumberOfKeypoints,s}return _W(e,t),e.prototype.computeSimilarity=function(n){if(n.length===0||this.tracks.length===0)return[[]];for(var s=[],r=0,o=n;r<o.length;r++){for(var i=o[r],a=[],u=0,l=this.tracks;u<l.length;u++){var c=l[u];a.push(this.oks(i,c))}s.push(a)}return s},e.prototype.oks=function(n,s){for(var r=this.area(s.keypoints)+1e-6,o=0,i=0,a=0;a<n.keypoints.length;++a){var u=n.keypoints[a],l=s.keypoints[a];if(!(u.score<this.keypointThreshold||l.score<this.keypointThreshold)){i+=1;var c=Math.pow(u.x-l.x,2)+Math.pow(u.y-l.y,2),h=2*this.keypointFalloff[a];o+=Math.exp(-1*c/(2*r*Math.pow(h,2)))}}return i<this.minNumKeyoints?0:o/i},e.prototype.area=function(n){var s=this,r=n.filter(function(u){return u.score>s.keypointThreshold}),o=Math.min.apply(Math,Lc([1],r.map(function(u){return u.x}),!1)),i=Math.max.apply(Math,Lc([0],r.map(function(u){return u.x}),!1)),a=Math.min.apply(Math,Lc([1],r.map(function(u){return u.y}),!1));return(i-o)*(Math.max.apply(Math,Lc([0],r.map(function(u){return u.y}),!1))-a)},e}(UW);function uve(t){switch(t){case va.BlazePose:return Jg.reduce(function(e,n,s){return e[n]=s,e},{});case va.PoseNet:case va.MoveNet:return $a.reduce(function(e,n,s){return e[n]=s,e},{});default:throw new Error("Model ".concat(t," is not supported."))}}(function(t){t.Keypoint="keypoint",t.BoundingBox="boundingBox"})(Gc||(Gc={})),function(t){t.MoveNet="MoveNet",t.BlazePose="BlazePose",t.PoseNet="PoseNet"}(va||(va={}));var tP=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],GW={modelType:"SinglePose.Lightning",enableSmoothing:!0},nP={},sP={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},dk={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},rP={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function lve(t,e,n,s){for(var r={},o=0,i=$a;o<i.length;o++){var a=i[o];r[a]=[e[n[a]].y*s.height,e[n[a]].x*s.width]}if(function(w,S){return(w[S.left_hip].score>.2||w[S.right_hip].score>.2)&&(w[S.left_shoulder].score>.2||w[S.right_shoulder].score>.2)}(e,n)){var u=(r.left_hip[0]+r.right_hip[0])/2,l=(r.left_hip[1]+r.right_hip[1])/2,c=function(w,S,k,I,T){for(var R=["left_shoulder","right_shoulder","left_hip","right_hip"],_=0,D=0,L=0;L<R.length;L++)(J=Math.abs(I-k[R[L]][0]))>_&&(_=J),(te=Math.abs(T-k[R[L]][1]))>D&&(D=te);for(var V=0,U=0,j=0,q=Object.keys(k);j<q.length;j++){var J,te,le=q[j];w[S[le]].score<.2||((J=Math.abs(I-k[le][0]))>V&&(V=J),(te=Math.abs(T-k[le][1]))>U&&(U=te))}return[_,D,V,U]}(e,n,r,u,l),h=c[0],d=c[1],f=c[2],m=c[3],y=Math.max(1.9*d,1.9*h,1.2*f,1.2*m),x=[u-(y=Math.min(y,Math.max(l,s.width-l,u,s.height-u))),l-y];if(y>Math.max(s.width,s.height)/2)return $$(t==null,s);var v=2*y;return{yMin:x[0]/s.height,xMin:x[1]/s.width,yMax:(x[0]+v)/s.height,xMax:(x[1]+v)/s.width,height:(x[0]+v)/s.height-x[0]/s.height,width:(x[1]+v)/s.width-x[1]/s.width}}return $$(t==null,s)}function $$(t,e){var n,s,r,o;return t?e.width>e.height?(n=1,s=e.height/e.width,r=0,o=(e.width/2-e.height/2)/e.width):(n=e.width/e.height,s=1,r=(e.height/2-e.width/2)/e.height,o=0):e.width>e.height?(n=e.width/e.height,s=1,r=(e.height/2-e.width/2)/e.height,o=0):(n=1,s=e.height/e.width,r=0,o=(e.width/2-e.height/2)/e.width),{yMin:r,xMin:o,yMax:r+n,xMax:o+s,height:n,width:s}}function cve(t){var e,n=t==null?GW:mn({},t);if(n.modelType==null)n.modelType="SinglePose.Lightning";else if(tP.indexOf(n.modelType)<0)throw new Error("Invalid architecture ".concat(n.modelType,". ")+"Should be one of ".concat(tP));if(n.enableSmoothing==null&&(n.enableSmoothing=!0),n.minPoseScore!=null&&(n.minPoseScore<0||n.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(n.multiPoseMaxDimension!=null&&(n.multiPoseMaxDimension%32!=0||n.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if(n.modelType==="MultiPose.Lightning"&&n.enableTracking==null&&(n.enableTracking=!0),n.modelType==="MultiPose.Lightning"&&n.enableTracking===!0)if(n.trackerType==null&&(n.trackerType=Gc.BoundingBox),n.trackerType===Gc.Keypoint)n.trackerConfig!=null?n.trackerConfig=function(s){var r=oP(dk,s);return r.keypointTrackerParams=mn({},dk.keypointTrackerParams),s.keypointTrackerParams!=null&&(s.keypointTrackerParams.keypointConfidenceThreshold!=null&&(r.keypointTrackerParams.keypointConfidenceThreshold=s.keypointTrackerParams.keypointConfidenceThreshold),s.keypointTrackerParams.keypointFalloff!=null&&(r.keypointTrackerParams.keypointFalloff=s.keypointTrackerParams.keypointFalloff),s.keypointTrackerParams.minNumberOfKeypoints!=null&&(r.keypointTrackerParams.minNumberOfKeypoints=s.keypointTrackerParams.minNumberOfKeypoints)),r}(n.trackerConfig):n.trackerConfig=dk;else{if(n.trackerType!==Gc.BoundingBox)throw new Error("Tracker type not supported by MoveNet");n.trackerConfig!=null?n.trackerConfig=(e=n.trackerConfig,oP(rP,e)):n.trackerConfig=rP}return n}function oP(t,e){var n={maxTracks:t.maxTracks,maxAge:t.maxAge,minSimilarity:t.minSimilarity};return e.maxTracks!=null&&(n.maxTracks=e.maxTracks),e.maxAge!=null&&(n.maxAge=e.maxAge),e.minSimilarity!=null&&(n.minSimilarity=e.minSimilarity),n}var hve=function(){function t(e,n){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=uve(va.MoveNet),n.modelType==="SinglePose.Lightning"?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):n.modelType==="SinglePose.Thunder"&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel=n.modelType==="MultiPose.Lightning",this.multiPoseModel||(this.keypointFilter=new I$(sP),this.cropRegionFilterYMin=new Ju(.9),this.cropRegionFilterXMin=new Ju(.9),this.cropRegionFilterYMax=new Ju(.9),this.cropRegionFilterXMax=new Ju(.9)),this.enableSmoothing=n.enableSmoothing,n.minPoseScore?this.minPoseScore=n.minPoseScore:this.minPoseScore=.25,n.multiPoseMaxDimension?this.multiPoseMaxDimension=n.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=n.enableTracking,this.multiPoseModel&&this.enableTracking&&(n.trackerType===Gc.Keypoint?this.tracker=new ave(n.trackerConfig):n.trackerType===Gc.BoundingBox&&(this.tracker=new ive(n.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return t.prototype.runSinglePersonPoseModel=function(e){return zt(this,void 0,void 0,function(){var n,s,r,o,i;return Bt(this,function(a){switch(a.label){case 0:if((n=this.moveNetModel.execute(e)).shape.length!==4||n.shape[0]!==1||n.shape[1]!==1||n.shape[2]!==17||n.shape[3]!==3)throw n.dispose(),new Error("Unexpected output shape from model: [".concat(n.shape,"]"));return Ug()==="webgpu"?[3,1]:(s=n.dataSync(),[3,3]);case 1:return[4,n.data()];case 2:s=a.sent(),a.label=3;case 3:for(n.dispose(),r={keypoints:[],score:0},o=0,i=0;i<17;++i)r.keypoints[i]={y:s[3*i],x:s[3*i+1],score:s[3*i+2]},r.keypoints[i].score>.2&&(++o,r.score+=r.keypoints[i].score);return o>0&&(r.score/=o),[2,r]}})})},t.prototype.runMultiPersonPoseModel=function(e){return zt(this,void 0,void 0,function(){var n,s,r,o,i,a,u,l;return Bt(this,function(c){switch(c.label){case 0:if((n=this.moveNetModel.execute(e)).shape.length!==3||n.shape[0]!==1||n.shape[2]!==56)throw n.dispose(),new Error("Unexpected output shape from model: [".concat(n.shape,"]"));return Ug()==="webgpu"?[3,1]:(s=n.dataSync(),[3,3]);case 1:return[4,n.data()];case 2:s=c.sent(),c.label=3;case 3:for(n.dispose(),r=[],o=s.length/56,i=0;i<o;++i)for(r[i]={keypoints:[]},a=56*i+51,r[i].box={yMin:s[a],xMin:s[a+1],yMax:s[a+2],xMax:s[a+3],width:s[a+3]-s[a+1],height:s[a+2]-s[a]},u=56*i+55,r[i].score=s[u],r[i].keypoints=[],l=0;l<17;++l)r[i].keypoints[l]={y:s[56*i+3*l],x:s[56*i+3*l+1],score:s[56*i+3*l+2]};return[2,r]}})})},t.prototype.estimatePoses=function(e,n,s){return n===void 0&&(n=nP),zt(this,void 0,void 0,function(){var r,o,i,a,u,l;return Bt(this,function(c){switch(c.label){case 0:return n=function(h){return h==null?nP:mn({},h)}(n),e==null?(this.reset(),[2,[]]):(s==null?BW(e)&&(s=1e6*e.currentTime):s*=1e3,r=RE(e),o=mp(r),i=us(r,0),e instanceof en||r.dispose(),a=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(i,o,s)]);case 1:return a=c.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(i,o,s)];case 3:a=c.sent(),c.label=4;case 4:for(u=0;u<a.length;++u)for(l=0;l<a[u].keypoints.length;++l)a[u].keypoints[l].name=$a[l],a[u].keypoints[l].y*=o.height,a[u].keypoints[l].x*=o.width;return[2,a]}})})},t.prototype.estimateSinglePose=function(e,n,s){return zt(this,void 0,void 0,function(){var r,o,i,a,u=this;return Bt(this,function(l){switch(l.label){case 0:return this.cropRegion||(this.cropRegion=$$(this.cropRegion==null,n)),r=ae(function(){var c=mi([[u.cropRegion.yMin,u.cropRegion.xMin,u.cropRegion.yMax,u.cropRegion.xMax]]),h=Zn([1],"int32"),d=[u.modelInputResolution.height,u.modelInputResolution.width];return De(Xs.cropAndResize(e,c,h,d,"bilinear",0),"int32")}),e.dispose(),[4,this.runSinglePersonPoseModel(r)];case 1:if(o=l.sent(),r.dispose(),o.score<this.minPoseScore)return this.reset(),[2,[]];for(i=0;i<o.keypoints.length;++i)o.keypoints[i].y=this.cropRegion.yMin+o.keypoints[i].y*this.cropRegion.height,o.keypoints[i].x=this.cropRegion.xMin+o.keypoints[i].x*this.cropRegion.width;return s!=null&&this.enableSmoothing&&(o.keypoints=this.keypointFilter.apply(o.keypoints,s,1)),a=lve(this.cropRegion,o.keypoints,this.keypointIndexByName,n),this.cropRegion=this.filterCropRegion(a),[2,[o]]}})})},t.prototype.estimateMultiplePoses=function(e,n,s){return zt(this,void 0,void 0,function(){var r,o,i,a,u,l,c,h,d,f,m,y=this;return Bt(this,function(x){switch(x.label){case 0:return n.width>n.height?(o=this.multiPoseMaxDimension,i=Math.round(this.multiPoseMaxDimension*n.height/n.width),r=Xs.resizeBilinear(e,[i,o]),u=o,l=32*Math.ceil(i/32),a=Ui(r,[[0,0],[0,l-i],[0,0],[0,0]])):(o=Math.round(this.multiPoseMaxDimension*n.width/n.height),i=this.multiPoseMaxDimension,r=Xs.resizeBilinear(e,[i,o]),u=32*Math.ceil(o/32),l=i,a=Ui(r,[[0,0],[0,0],[0,u-o],[0,0]])),r.dispose(),e.dispose(),c=De(a,"int32"),a.dispose(),[4,this.runMultiPersonPoseModel(c)];case 1:for(h=x.sent(),c.dispose(),h=h.filter(function(v){return v.score>=y.minPoseScore}),f=0;f<h.length;++f)for(d=0;d<h[f].keypoints.length;++d)h[f].keypoints[d].y*=l/i,h[f].keypoints[d].x*=u/o;if(this.enableTracking&&(this.tracker.apply(h,s),this.enableSmoothing)){for(f=0;f<h.length;++f)this.keypointFilterMap.has(h[f].id)||this.keypointFilterMap.set(h[f].id,new I$(sP)),h[f].keypoints=this.keypointFilterMap.get(h[f].id).apply(h[f].keypoints,s,1);m=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach(function(v,w){m.has(w)||y.keypointFilterMap.delete(w)})}return[2,h]}})})},t.prototype.filterCropRegion=function(e){if(e){var n=this.cropRegionFilterYMin.apply(e.yMin),s=this.cropRegionFilterXMin.apply(e.xMin),r=this.cropRegionFilterYMax.apply(e.yMax),o=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:n,xMin:s,yMax:r,xMax:o,height:r-n,width:o-s}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},t.prototype.dispose=function(){this.moveNetModel.dispose()},t.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},t.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},t}();function dve(t){return t===void 0&&(t=GW),zt(this,void 0,void 0,function(){var e,n,s,r;return Bt(this,function(o){switch(o.label){case 0:return e=cve(t),s=!0,e.modelUrl?(s=typeof e.modelUrl=="string"&&e.modelUrl.indexOf("https://tfhub.dev")>-1,[4,dp(e.modelUrl,{fromTFHub:s})]):[3,2];case 1:return n=o.sent(),[3,4];case 2:return r=void 0,e.modelType==="SinglePose.Lightning"?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":e.modelType==="SinglePose.Thunder"?r="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":e.modelType==="MultiPose.Lightning"&&(r="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,dp(r,{fromTFHub:s})];case 3:n=o.sent(),o.label=4;case 4:return Ug()==="webgl"&&ce().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new hve(n,e)]}})})}var iP={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},aP=["MobileNetV1","ResNet50"],uP={MobileNetV1:[8,16],ResNet50:[16]},pve=[8,16,32],lP={MobileNetV1:[.5,.75,1],ResNet50:[1]},cP=[1,2,4],hP={maxPoses:1,flipHorizontal:!1},fve={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},mve=[-123.15,-115.9,-103.06];function pk(t){return Math.floor(t/2)}var gve=function(){function t(e,n){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=n}return t.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},t.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},t.prototype.empty=function(){return this.numberOfElements===-1},t.prototype.size=function(){return this.numberOfElements+1},t.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},t.prototype.max=function(){return this.priorityQueue[0]},t.prototype.swim=function(e){for(;e>0&&this.less(pk(e),e);)this.exchange(e,pk(e)),e=pk(e)},t.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var n=2*e;if(n<this.numberOfElements&&this.less(n,n+1)&&n++,!this.less(e,n))break;this.exchange(e,n),e=n}},t.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},t.prototype.less=function(e,n){return this.getValueAt(e)<this.getValueAt(n)},t.prototype.exchange=function(e,n){var s=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[n],this.priorityQueue[n]=s},t}();function yve(t,e,n,s,r,o){for(var i=o.shape,a=i[0],u=i[1],l=!0,c=Math.max(n-r,0),h=Math.min(n+r+1,a),d=c;d<h;++d){for(var f=Math.max(s-r,0),m=Math.min(s+r+1,u),y=f;y<m;++y)if(o.get(d,y,t)>e){l=!1;break}if(!l)break}return l}function xve(t){return zt(this,void 0,void 0,function(){return Bt(this,function(e){return[2,Promise.all(t.map(function(n){return n.buffer()}))]})})}function HW(t,e,n,s){return{y:s.get(t,e,n),x:s.get(t,e,n+17)}}function jW(t,e,n){var s=HW(t.heatmapY,t.heatmapX,t.id,n),r=s.y,o=s.x;return{x:t.heatmapX*e+o,y:t.heatmapY*e+r}}function KW(t,e,n,s){var r=n.x,o=n.y;return t.some(function(i){var a,u,l,c,h,d,f=i.keypoints;return a=o,u=r,l=f[s].y,c=f[s].x,(h=l-a)*h+(d=c-u)*d<=e})}var dP=$a.reduce(function(t,e,n){return t[e]=n,t},{}),XW=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map(function(t){var e=t[0],n=t[1];return[dP[e],dP[n]]}),fk=XW.map(function(t){return t[1]}),pP=XW.map(function(t){return t[0]});function fP(t,e,n){return t<e?e:t>n?n:t}function mk(t,e,n,s){return{y:fP(Math.round(t.y/e),0,n-1),x:fP(Math.round(t.x/e),0,s-1)}}function mP(t,e){return{x:t.x+e.x,y:t.y+e.y}}function gP(t,e,n,s,r,o,i,a){a===void 0&&(a=2);for(var u=s.shape,l=u[0],c=u[1],h={y:e.y,x:e.x},d=mP(h,function(w,S,k){var I=k.shape[2]/2;return{y:k.get(S.y,S.x,w),x:k.get(S.y,S.x,I+w)}}(t,mk(h,o,l,c),i)),f=0;f<a;f++){var m=mk(d,o,l,c),y=HW(m.y,m.x,n,r);d=mP({x:m.x*o,y:m.y*o},{x:y.x,y:y.y})}var x=mk(d,o,l,c),v=s.get(x.y,x.x,n);return{y:d.y,x:d.x,name:$a[n],score:v}}function vve(t,e,n,s,r,o){var i=e.shape[2],a=fk.length,u=new Array(i),l=t.part,c=t.score,h=jW(l,s,n);u[l.id]={score:c,name:$a[l.id],y:h.y,x:h.x};for(var d=a-1;d>=0;--d){var f=fk[d],m=pP[d];u[f]&&!u[m]&&(u[m]=gP(d,u[f],m,e,n,s,o))}for(d=0;d<a;++d)f=pP[d],m=fk[d],u[f]&&!u[m]&&(u[m]=gP(d,u[f],m,e,n,s,r));return u}function wve(t,e,n){return n.reduce(function(s,r,o){var i=r.y,a=r.x,u=r.score;return KW(t,e,{y:i,x:a},o)||(s+=u),s},0)/n.length}function bve(t,e,n,s,r,o,i,a){return i===void 0&&(i=.5),a===void 0&&(a=20),zt(this,void 0,void 0,function(){var u,l,c,h,d,f,m,y,x,v,w,S;return Bt(this,function(k){switch(k.label){case 0:return[4,xve([t,e,n,s])];case 1:for(u=k.sent(),l=u[0],c=u[1],h=u[2],d=u[3],f=[],m=function(I,T,R){for(var _=R.shape,D=_[0],L=_[1],V=_[2],U=new gve(D*L*V,function(le){return le.score}),j=0;j<D;++j)for(var q=0;q<L;++q)for(var J=0;J<V;++J){var te=R.get(j,q,J);te<I||yve(J,te,j,q,T,R)&&U.enqueue({score:te,part:{heatmapY:j,heatmapX:q,id:J}})}return U}(i,1,l),y=a*a;f.length<o&&!m.empty();)x=m.dequeue(),v=jW(x.part,r,c),KW(f,y,v,x.part.id)||(w=vve(x,l,c,r,h,d),S=wve(f,y,w),f.push({keypoints:w,score:S}));return[2,f]}})})}function qW(){for(var t,e=[],n=0;n<arguments.length;n++)e[n]=arguments[n];switch(e.length){case 0:t="fn main() ";break;case 1:t="fn main(".concat(e[0]," : i32)");break;default:throw Error("Unreachable")}return t}var Sve=function(){function t(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=Ve(this.outputShape),this.dispatch=Fe(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return t.prototype.getUserCode=function(){return`
        `.concat(qW("index"),` {
          if (index < uniforms.size) {
            let y = B[index * 2];
            let x = B[index * 2 + 1];
            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;
            result[index] = A[outIndex];
          }
        }
        `)},t}();function Cve(t,e){if(th()instanceof Af)return function(n,s){var r=th(),o=new Sve(s.shape),i=r.runWebGPUProgram(o,[n,s],"float32");return lr().makeTensorFromTensorInfo(i)}(t,e);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}var kve=function(){function t(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,e.length!==2||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var n=[e[0],1];this.dispatchLayout=Ve(n),this.dispatch=Fe(this.dispatchLayout,n,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return t.prototype.getUserCode=function(){return`
    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {
      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;
      let outIndexX = outIndexY + uniforms.bShape.z;
      let outY = i32(B[outIndexY]);
      let outX = i32(B[outIndexX]);
      return vec2<i32>(outY, outX);
    }

    `.concat(qW("index"),` {
      if (index < uniforms.size) {
        let indexY = index * `).concat(this.supportedLastDimension,`;
        let indexX = indexY + 1;
        let heatmapY = A[indexY];
        let heatmapX = A[indexX];
        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);
        result[indexY] = f32(out[0]);
        result[indexX] = f32(out[1]);
      }
    }
    `)},t}();function Ive(t,e){if(th()instanceof Af)return function(n,s){var r=th(),o=new kve(n.shape),i=r.runWebGPUProgram(o,[n,s],"float32");return lr().makeTensorFromTensorInfo(i)}(t,e);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}function YW(t){var e=t.shape,n=e[0],s=e[1],r=e[2];return ae(function(){var o,i,a=ee(t,[n*s,r]),u=rh(a,0),l=us(Ge(u,nt(s,"int32")),1),c=us((o=u,i=s,ae(function(){var h=Ge(o,nt(i,"int32"));return Be(o,Y(h,nt(i,"int32")))})),1);return Ln([l,c],1)})}function $ve(t,e,n){return ae(function(){var s=function(r,o){for(var i=[],a=0;a<$a.length;a++){var u=r.get(a,0).valueOf(),l=r.get(a,1).valueOf(),c=Nve(u,l,a,o),h=c.x,d=c.y;i.push(d),i.push(h)}return mi(i,[$a.length,2])}(t,n);return we(De(Y(t.toTensor(),nt(e,"int32")),"float32"),s)})}function Nve(t,e,n,s){return{y:s.get(t,e,n),x:s.get(t,e,n+$a.length)}}function Tve(t,e,n){return zt(this,void 0,void 0,function(){var s,r,o,i,a,u,l,c,h,d;return Bt(this,function(f){switch(f.label){case 0:return s=0,r=YW(t),[4,Promise.all([t.buffer(),e.buffer(),r.buffer()])];case 1:return o=f.sent(),i=o[0],a=o[1],u=o[2],[4,(l=$ve(u,n,a)).buffer()];case 2:return c=f.sent(),h=Array.from(function(m,y){for(var x=y.shape[0],v=new Float32Array(x),w=0;w<x;w++){var S=y.get(w,0),k=y.get(w,1);v[w]=m.get(S,k,w)}return v}(i,u)),d=h.map(function(m,y){return s+=m,{y:c.get(y,0),x:c.get(y,1),score:m,name:$a[y]}}),r.dispose(),l.dispose(),[2,{keypoints:d,score:s/d.length}]}})})}function Eve(t,e,n){return zt(this,void 0,void 0,function(){var s,r,o;return Bt(this,function(i){return s=YW(t),r=function(a,u,l){return ae(function(){var c=Ive(a,l);return we(De(Y(a,nt(u,"int32")),"float32"),c)})}(s,n,e),o=Cve(t,s),[2,[r,o]]})})}function yP(t,e){return(t-1)%e==0}var xP="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",vP="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function wP(t,e){return function(n,s){return(n-1)%s==0}(t,e)?t:Math.floor(t/e)*e+1}var bP=function(){function t(e,n){this.posenetModel=e;var s=this.posenetModel.inputs[0].shape;O(s[1]===-1&&s[2]===-1,function(){return"Input shape [".concat(s[1],", ").concat(s[2],"] ")+"must both be equal to or -1"});var r,o,i=(r=n.inputResolution,o=n.outputStride,{height:wP(r.height,o),width:wP(r.width,o)});(function(a){O(pve.indexOf(a)>=0,function(){return"outputStride of ".concat(a," is invalid. ")+"It must be either 8 or 16."})})(n.outputStride),function(a,u){O(yP(a.height,u),function(){return"height of ".concat(a.height," is invalid for output stride ")+"".concat(u,".")}),O(yP(a.width,u),function(){return"width of ".concat(a.width," is invalid for output stride ")+"".concat(u,".")})}(i,n.outputStride),this.inputResolution=i,this.outputStride=n.outputStride,this.architecture=n.architecture}return t.prototype.estimatePoses=function(e,n){return n===void 0&&(n=hP),zt(this,void 0,void 0,function(){return Bt(this,function(s){return[2,this.estimatePosesGPU(e,n,!1)]})})},t.prototype.estimatePosesGPU=function(e,n,s){return n===void 0&&(n=hP),s===void 0&&(s=!1),zt(this,void 0,void 0,function(){var r,o,i,a,u,l,c,h,d,f,m,y,x,v,w,S,k,I;return Bt(this,function(T){switch(T.label){case 0:return r=function(R){var _=R;if(_.maxPoses==null&&(_.maxPoses=1),_.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(_.maxPoses,". Should be > 0."));if(_.maxPoses>1){if((_=mn(mn({},fve),_)).scoreThreshold<0||_.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(_.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(_.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(_.nmsRadius,"."))}return _}(n),e==null?[2,s?[[],[]]:[]]:(this.maxPoses=r.maxPoses,o=k$(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),i=o.imageTensor,a=o.padding,u=this.architecture==="ResNet50"?we(i,mve):zW(i,[-1,1]),l=this.posenetModel.predict(u),this.architecture==="ResNet50"?(c=Yt(l[2],[0]),h=Yt(l[3],[0]),d=Yt(l[0],[0]),f=Yt(l[1],[0])):(c=Yt(l[0],[0]),h=Yt(l[1],[0]),d=Yt(l[2],[0]),f=Yt(l[3],[0])),m=Eo(h),this.maxPoses!==1?[3,5]:s?[4,Eve(m,c,this.outputStride)]:[3,2]);case 1:return x=T.sent(),w=x[0],v=x[1],y=[w,v],[3,4];case 2:return[4,Tve(m,c,this.outputStride)];case 3:w=T.sent(),y=[w],T.label=4;case 4:return[3,7];case 5:if(s)throw new Error("GPU renderer only supports single pose!");return[4,bve(m,c,d,f,this.outputStride,this.maxPoses,r.scoreThreshold,r.nmsRadius)];case 6:y=T.sent(),T.label=7;case 7:if(s){if(r.flipHorizontal===!0)throw new Error("flipHorizontal is not supported!");S=this.getCanvasInfo(mp(e),this.inputResolution,a)}else I=mp(e),k=function(R,_,D,L){var V=_.height,U=_.width,j=V/(D.height*(1-L.top-L.bottom)),q=U/(D.width*(1-L.left-L.right)),J=-L.top*D.height,te=-L.left*D.width;if(q===1&&j===1&&J===0&&te===0)return R;for(var le=0,K=R;le<K.length;le++)for(var re=0,pe=K[le].keypoints;re<pe.length;re++){var he=pe[re];he.x=(he.x+te)*q,he.y=(he.y+J)*j}return R}(y,I,this.inputResolution,a),r.flipHorizontal&&(k=function(R,_){for(var D=0,L=R;D<L.length;D++)for(var V=0,U=L[D].keypoints;V<U.length;V++){var j=U[V];j.x=_.width-1-j.x}return R}(k,I));return i.dispose(),u.dispose(),ot(l),c.dispose(),h.dispose(),d.dispose(),f.dispose(),m.dispose(),[2,s?[y,S]:k]}})})},t.prototype.getCanvasInfo=function(e,n,s){var r=e.height,o=e.width,i=r/(n.height*(1-s.top-s.bottom)),a=o/(n.width*(1-s.left-s.right)),u=-s.top*n.height;return[-s.left*n.width,u,a,i,e.width,e.height]},t.prototype.dispose=function(){this.posenetModel.dispose()},t.prototype.reset=function(){},t}();function Rve(t){return t===void 0&&(t=iP),zt(this,void 0,void 0,function(){var e,n,s,r,o;return Bt(this,function(i){switch(i.label){case 0:return(e=function(c){var h=c||iP;if(h.architecture==null&&(h.architecture="MobileNetV1"),aP.indexOf(h.architecture)<0)throw new Error("Invalid architecture ".concat(h.architecture,". ")+"Should be one of ".concat(aP));if(h.inputResolution==null&&(h.inputResolution={height:257,width:257}),h.outputStride==null&&(h.outputStride=16),uP[h.architecture].indexOf(h.outputStride)<0)throw new Error("Invalid outputStride ".concat(h.outputStride,". ")+"Should be one of ".concat(uP[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.multiplier==null&&(h.multiplier=1),lP[h.architecture].indexOf(h.multiplier)<0)throw new Error("Invalid multiplier ".concat(h.multiplier,". ")+"Should be one of ".concat(lP[h.architecture]," ")+"for architecture ".concat(h.architecture,"."));if(h.quantBytes==null&&(h.quantBytes=4),cP.indexOf(h.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(h.quantBytes,". ")+"Should be one of ".concat(cP," ")+"for architecture ".concat(h.architecture,"."));if(h.architecture==="MobileNetV1"&&h.outputStride===32&&h.multiplier!==1)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return h}(t)).architecture!=="ResNet50"?[3,2]:(a=e.outputStride,u=e.quantBytes,l="model-stride".concat(a,".json"),n=u===4?vP+"float/"+l:vP+"quant".concat(u,"/")+l,[4,dp(e.modelUrl||n)]);case 1:return s=i.sent(),[2,new bP(s,e)];case 2:return r=function(c,h,d){var f={1:"100",.75:"075",.5:"050"},m="model-stride".concat(c,".json");return d===4?xP+"float/".concat(f[h],"/")+m:xP+"quant".concat(d,"/").concat(f[h],"/")+m}(e.outputStride,e.multiplier,e.quantBytes),[4,dp(e.modelUrl||r)];case 3:return o=i.sent(),[2,new bP(o,e)]}var a,u,l})})}function Ave(t,e){return zt(this,void 0,void 0,function(){var n,s;return Bt(this,function(r){switch(t){case va.PoseNet:return[2,Rve(e)];case va.BlazePose:if(s=void 0,(n=e)!=null){if(n.runtime==="tfjs")return[2,ove(e)];if(n.runtime==="mediapipe")return[2,_1e(e)];s=n.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(s));case va.MoveNet:return[2,dve(e)];default:throw new Error("".concat(t," is not a supported model name."))}})})}var _ve={keypointsToNormalizedKeypoints:WW};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QW={kernelName:gy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Y(t,Tf(De(n,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dve={kernelName:Rp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=an(De(n,"float32")),r=Zs(Be(nt(1),s));return $n(Ge(t,r))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pve={kernelName:Ap,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=Zs(Be(an(De(n,"float32")),1));return Ge(t,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fve={kernelName:gh,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=ut(n.shape,s.shape);return{a:()=>{let a=t;const u=bs(n.shape,r);return u.length>0&&(a=Qe(a,u)),ee(a,n.shape)},b:()=>{let a=t;const u=bs(s.shape,r);return u.length>0&&(a=Qe(a,u)),ee(a,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ove={kernelName:yy,saveAllInputs:!0,gradFunc:(t,e)=>{const n={};return e.forEach((s,r)=>{n[r]=()=>t.clone()}),n}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lve={kernelName:xy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Wt(n)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mve={kernelName:vy,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Wt(n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zve={kernelName:_p,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ge(t,Zs(Be(nt(1),an(De(n,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bve={kernelName:Dp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=Zs(we(nt(1),an(De(n,"float32"))));return Ge(t,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vve={kernelName:Op,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=ut(n.shape,s.shape);return{a:()=>{const a=we(an(n),an(s));let u=Y(t,Ge(s,a));const l=bs(n.shape,r);return l.length>0&&(u=Qe(u,l)),ee(u,n.shape)},b:()=>{const a=we(an(n),an(s));let u=$n(Y(t,Ge(n,a)));const l=bs(s.shape,r);return l.length>0&&(u=Qe(u,l)),ee(u,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wve={kernelName:Pp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ge(t,we(an(De(n,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uve={kernelName:Fp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ge(t,Be(nt(1),an(De(n,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gve(t,e,n,s,r,o){const i=M(t,"dy","avgPool3dGrad"),a=M(e,"input","avgPool3dGrad");let u=i,l=a,c=!1;a.rank===4&&(c=!0,u=ee(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),l=ee(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),O(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),O(l.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),yr("avgPool3dGrad",r,o);const h={dy:u,input:l},d={filterSize:n,strides:s,pad:r,dimRoundingMode:o},f=Z.runKernel(Hw,h,d);return c?ee(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const Hve=Q({avgPool3dGrad_:Gve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jve={kernelName:by,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{filterSize:r,strides:o,pad:i,dimRoundingMode:a}=n;return{x:()=>Hve(t,s,r,o,i,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kve(t,e,n,s,r){const o=M(t,"dy","avgPoolGrad"),i=M(e,"input","avgPoolGrad");O(i.rank===o.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${o.rank})`);let a=i,u=o,l=!1;i.rank===3&&(l=!0,a=ee(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=ee(o,[1,o.shape[0],o.shape[1],o.shape[2]])),O(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),O(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);const c={dy:u,input:a},h={filterSize:n,strides:s,pad:r},d=Z.runKernel(Gw,c,h);return l?ee(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Xve=Q({avgPoolGrad_:Kve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qve={kernelName:wy,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{filterSize:r,strides:o,pad:i}=n;return{x:()=>Xve(t,s,r,o,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yve={kernelName:Sy,inputsToSave:["a","b"],gradFunc:(t,e,n)=>{const[s,r]=e,{transposeA:o,transposeB:i}=n;return!o&&!i?{a:()=>Dt(t,r,!1,!0),b:()=>Dt(s,t,!0,!1)}:!o&&i?{a:()=>Dt(t,r,!1,!1),b:()=>Dt(t,s,!0,!1)}:o&&!i?{a:()=>Dt(r,t,!1,!0),b:()=>Dt(s,t,!1,!1)}:{a:()=>Dt(r,t,!0,!0),b:()=>Dt(t,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qve={kernelName:Cy,gradFunc:(t,e,n)=>{const{blockShape:s,crops:r}=n;return{x:()=>Qb(t,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zve={kernelName:JJ,gradFunc:(t,e,n)=>{const s=n,r=s.inputShape,o=s.shape,i=Array.from(o);for(let u=r.length-1;u>=0;u--)if(r[u]===o[u])i[u]=1;else if(r[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${o}].`);const a=[];for(let u=0;u<i.length;u++)i[u]>1&&a.push(u);return{x:()=>Qe(t,a,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jve={kernelName:Lp,gradFunc:t=>({x:()=>t.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ewe={kernelName:Mp,gradFunc:t=>({x:()=>Wt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const twe={kernelName:zp,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{clipValueMin:r,clipValueMax:o}=n;return{x:()=>Ys(Ca(Bl(s,r),vh(s,o)),t,Wt(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nwe={kernelName:ky,inputsToSave:["x"],gradFunc:QW.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const swe={kernelName:Iy,saveAllInputs:!0,gradFunc:(t,e,n)=>{const s=e.map(u=>u.shape),{axis:r}=n,o=vt(r,e[0].shape)[0],i=s.map(u=>u[o]);return io(t,i,o).map(u=>()=>u)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rwe={kernelName:$y,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,{dilations:o,strides:i,pad:a,dataFormat:u}=n;return O(wl(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>NT(s.shape,t,r,i,a,u),filter:()=>aE(s,t,r.shape,i,a,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const owe={kernelName:Ny,inputsToSave:["dy","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,{strides:o,pad:i,dataFormat:a,dimRoundingMode:u}=n;return{dy:()=>bl(t,r,o,i,a,1,u),filter:()=>aE(t,s,r.shape,o,i,a,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iwe(t,e,n,s,r){let o=t;t.rank===4&&(o=ee(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]));let i=e;i.rank===4&&(i=ee(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),O(o.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),O(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),O(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),O(o.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${n[3]}.`),O(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);const a={x:o,dy:i},u={strides:s,pad:r,filterShape:n};return Z.runKernel(Qw,a,u)}const awe=Q({conv3DBackpropFilter_:iwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uwe={kernelName:Ty,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:s,strides:r,pad:o}=n;O(wl(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[i,a]=e;return{x:()=>NB(i.shape,t,a,r,o),filter:()=>awe(i,t,a.shape,r,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lwe={kernelName:Bp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Y($n(QT(De(n,"float32"))),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cwe={kernelName:Vp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Y(ZT(De(n,"float32")),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hwe={kernelName:Ey,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r,exclusive:o,reverse:i}=n;return{x:()=>{const a=cn([r],s.rank);let u=RT(t,r,o,!i);return a!=null&&(u=Vt(u,a)),u}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dwe={kernelName:Ry,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const{dilations:s,strides:r,pad:o,dimRoundingMode:i}=n,a=s??[1,1];O(wl(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[u,l]=e;return O(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),O(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),O(u.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),O(Ss(r,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${a}'.`),yr("depthwiseConv2d",o,i),{x:()=>lV(u.shape,t,l,r,o,a,i),filter:()=>uV(u,t,l.shape,r,o,a,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pwe={kernelName:Ay,inputsToSave:["x","filter"],gradFunc:(t,e,n)=>{const[s,r]=e,o={x:s,filter:r,dy:t},i={x:s,filter:r,dy:t};return{x:()=>Z.runKernel(_v,o,n),filter:()=>Z.runKernel(Dv,i,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fwe={kernelName:Up,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e,s={dy:t,y:n};return{x:()=>Z.runKernel(ab,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mwe={kernelName:Gp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,s=Y(mr($n(an(n))),2/Math.sqrt(Math.PI));return{x:()=>Y(t,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gwe={kernelName:Hp,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Y(t,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ywe={kernelName:Dy,inputsToSave:["input"],gradFunc:(t,e)=>{const[n]=e;return{input:()=>ee(t,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xwe={kernelName:jp,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Y(t,mr(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vwe={kernelName:Kp,gradFunc:t=>({x:()=>Wt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wwe={kernelName:Xp,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=ut(n.shape,s.shape);return{a:()=>{const a=Ge(t,De(s,"float32")),u=bs(n.shape,r);return u.length>0?ee(Qe(a,u),n.shape):a},b:()=>{let a=Y(t,De(n,"float32"));const u=bs(s.shape,r);u.length>0&&(a=ee(Qe(a,u),s.shape));const l=an(s);return $n(Ge(a,De(l,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bwe={kernelName:Py,inputsToSave:["x","mean","variance","scale"],gradFunc:(t,e,n)=>{const{varianceEpsilon:s}=n,[r,o,i,a]=e,u=a??nt(1),l=bs(o.shape,r.shape),c=[];if(o.rank===1){for(let k=0;k<r.shape.length-1;++k)c.push(r.shape[k]);c.push(1)}const h=Be(r,o),d=Y(t,u),f=XT(we(i,nt(s))),m=Y(Y(Y(f,f),f),nt(-.5));return{x:()=>o.rank===1?ee(Y(Y(t,li(ee(f,[1,1,1,o.shape[0]]),c)),u),r.shape):ee(Y(Y(t,f),u),r.shape),mean:()=>{let k=Y(Y(f,nt(-1)),d);return o.rank===1&&(k=Qe(k,l)),ee(k,o.shape)},variance:()=>{let k=Y(Y(m,h),d);return o.rank===1&&(k=Qe(k,l)),ee(k,o.shape)},scale:()=>{const k=Y(h,f);let I=Y(t,k);return o.rank===1&&(I=Qe(I,l)),ee(I,o.shape)},offset:()=>{let k=t;return o.rank===1&&(k=Qe(k,l)),ee(k,o.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Swe={kernelName:Fy,inputsToSave:["x","indices"],gradFunc:(t,e,n)=>{const[s,r]=e,{axis:o,batchDims:i}=n,a=vt(o,s.shape)[0],u=(l,c,h)=>()=>{const d=l.shape,f=c.size,m=d.slice(0,a),y=m.length,x=d.slice(o,d.length).slice(1),v=x.length,w=SP(0,y),S=SP(y+1,y+1+v),k=CP([m,[f],x]),I=ee(h,k),T=ee(c,[f]),R=CP([[y],w,S]),_=Vt(I,R);let D=rE(_,T,l.shape[a]);const L=Ta(R);return D=Vt(D,L),D};if(i===1){const l=s.shape[0],c=s.split(l,0);return{x:()=>ao(c.map((f,m)=>u(f,r.slice(m,1),t.slice(m,1))())).reshape(s.shape),indices:()=>r}}else return{x:u(s,r,t),indices:()=>r}}};function SP(t,e){const n=[];for(let s=t;s<e;++s)n.push(s);return n}function CP(t){const e=[];for(let n=0;n<t.length;++n)for(let s=0;s<t[n].length;++s)e.push(t[n][s]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cwe={kernelName:qp,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>Wt(n),b:()=>Wt(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kwe={kernelName:Yp,gradFunc:t=>({x:()=>De(t,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iwe={kernelName:Qp,gradFunc:t=>({x:()=>Wt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $we={kernelName:Zp,gradFunc:t=>({x:()=>Wt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nwe={kernelName:Jp,gradFunc:t=>({x:()=>Wt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Twe={kernelName:Ly,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{alpha:r}=n,o=mo(s,0);return{x:()=>Ys(o,t,Y(t,r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ewe={kernelName:tf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ge(t,we(n,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rwe={kernelName:ef,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ge(t,De(n,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Awe={kernelName:eee,inputsToSave:[],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n;return{logits:()=>{const i=mr(s);return Be(t,Y(Qe(t,r,!0),i))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _we(t,e,n,s=5,r=1,o=1,i=.5){const a={x:t,y:e,dy:n},u={depthRadius:s,bias:r,alpha:o,beta:i};return Z.runKernel(mb,a,u)}const Dwe=Q({localResponseNormalizationBackprop_:_we});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pwe={kernelName:Uy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{depthRadius:o,bias:i,alpha:a,beta:u}=n;return{x:()=>Dwe(s,r,t,o,i,a,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZW(t,e,n,s){return e.rank<n.rank&&(e=ee(e,qn(e.shape,s))),t.rank<n.rank&&(t=ee(t,qn(t.shape,s))),{x:()=>Y(t,De(Wi(n,e),t.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kP={kernelName:Gy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const s=n,{reductionIndices:r}=s,o=e[0],i=e[1],a=vt(r,o.shape),u=ZW(t,i,o,a);return{x:()=>u.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fwe={kernelName:nf,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>Y(t,De(Bl(n,s),"float32")),b:()=>Y(t,De(Kg(n,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Owe(t,e,n,s,r,o,i){const a=M(t,"dy","maxPool3dGrad"),u=M(e,"input","maxPool3dGrad"),l=M(n,"output","maxPool3dGrad");let c=a,h=u,d=l,f=!1;u.rank===4&&(f=!0,c=ee(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),h=ee(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),d=ee(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),O(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),O(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),O(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),yr("maxPool3dGrad",o,i);const m={dy:c,input:h,output:d},y={filterSize:s,strides:r,pad:o,dimRoundingMode:i},x=Z.runKernel(yb,m,y);return f?ee(x,[x.shape[1],x.shape[2],x.shape[3],x.shape[4]]):x}const Lwe=Q({maxPool3dGrad_:Owe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mwe={kernelName:jy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=n;return{x:()=>Lwe(t,s,r,o,i,a,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zwe(t,e,n,s,r,o,i){const a=M(t,"dy","maxPoolGrad"),u=M(e,"input","maxPoolGrad"),l=M(n,"output","maxPoolGrad");O(u.rank===a.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${a.rank})`),O(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),O(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),yr("maxPoolGrad",o,i);const c={dy:a,input:u,output:l},h={filterSize:s,strides:r,pad:o,dimRoundingMode:i};return Z.runKernel(gb,c,h)}const Bwe=Q({maxPoolGrad_:zwe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vwe={kernelName:Hy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s,r]=e,{filterSize:o,strides:i,pad:a}=n;return{x:()=>Bwe(t,s,r,o,i,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wwe={kernelName:Ky,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n,o=vt(r,s.shape),a=ts(s.shape,o)[1],u=ie(a);return{x:()=>{const c=s.shape.slice();o.forEach(f=>{c[f]=1});const h=ee(t,c);return Ge(Y(h,no(s.shape,"float32")),u)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uwe={kernelName:Xy,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(t,e,n)=>{const s=n,{axis:r}=s,[o,i]=e,a=vt(r,o.shape),u=ZW(t,i,o,a);return{x:()=>u.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gwe={kernelName:sf,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e;return{a:()=>Y(t,De(vh(n,s),"float32")),b:()=>Y(t,De(mo(n,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hwe={kernelName:qy,inputsToSave:["x"],gradFunc:(t,e,n)=>{const s=e[0],{paddings:r}=n,o=r.map(i=>i[0]);return{x:()=>mt(t,o,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jwe={kernelName:rf,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=ut(n.shape,s.shape);return{a:()=>{const a=bs(n.shape,r);return a.length>0?ee(Qe(t,a),n.shape):t},b:()=>{const a=Y(t,$n(S0(Ge(n,s)))),u=bs(s.shape,r);return u.length>0?ee(Qe(a,u),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kwe={kernelName:of,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=ut(n.shape,s.shape);return{a:()=>{const a=Y(t,De(s,"float32")),u=bs(n.shape,r);return u.length>0?ee(Qe(a,u),n.shape):a},b:()=>{const a=Y(t,De(n,"float32")),u=bs(s.shape,r);return u.length>0?ee(Qe(a,u),s.shape):a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xwe={kernelName:Yy,gradFunc:t=>({x:()=>$n(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qwe={kernelName:Jy,inputsToSave:["indices"],gradFunc:(t,e)=>{const n=e[0];return{indices:()=>Zn(n.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ywe={kernelName:Zy,gradFunc:t=>({x:()=>Wt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qwe={kernelName:e0,saveAllInputs:!0,gradFunc:(t,e,n)=>{const{axis:s}=n;return wi(t,s).map(o=>()=>o)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IP={kernelName:t0,inputsToSave:["x"],gradFunc:(t,e,n)=>{const s=e[0],{paddings:r}=n,o=r.map(i=>i[0]);return{x:()=>mt(t,o,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zwe={kernelName:af,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(t,e)=>{const[n,s,r]=e,o=n,i=s,a=ut(o.shape,i.shape);return{a:()=>{const c=De(i,"float32");let h=Y(t,Y(c,Cl(o,Be(c,nt(1)))));const d=bs(o.shape,a);return d.length>0&&(h=Qe(h,d)),ee(h,o.shape)},b:()=>{const c=mo(o,0),h=Ys(c,Ao(o),Wt(o));let d=Y(t,Y(r,h));const f=bs(i.shape,a);return f.length>0&&(d=Qe(d,f)),ee(d,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jwe={kernelName:n0,inputsToSave:["x","alpha"],gradFunc:(t,e)=>{const[n,s]=e,r=mo(n,0);return{x:()=>Ys(r,t,Y(t,s)),alpha:()=>{let o=Ys(r,Wt(t),Y(t,n));const i=bs(s.shape,t.shape);return i.length>0&&(o=Qe(o,i)),ee(o,s.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ebe(t,e,n){const s=t.shape.slice();s[n]=1;const r=ee(e,s),o=Vv(t,n,!0,!1),i=Vv(t,n,!0,!0),a=Y(o,i);return Y(r,a)}function tbe(t,e,n){const s=t.shape.length,r=s-n.length,o=cn(n,s);let i=t;o!=null&&(i=Vt(t,o));const a=i.shape.slice(),l=a.splice(s-n.length,n.length).reduce((d,f)=>d*f,1);a.push(l);const c=i.reshape(a);let h=ebe(c,e,r);if(h=h.reshape(i.shape),o!=null){const d=Ta(o);h=Vt(h,d)}return h}const nbe={kernelName:s0,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{axis:r}=n;let o=[];return r==null?o=s.shape.map((i,a)=>a):typeof r=="number"?o=[r]:o=r,{x:()=>tbe(s,t,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sbe={kernelName:Wp,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=ut(n.shape,s.shape);return{a:()=>{const a=Ge(t,De(s,"float32")),u=bs(n.shape,r);return u.length>0?ee(Qe(a,u),n.shape):a},b:()=>{let a=Y(t,De(n,"float32"));const u=bs(s.shape,r);u.length>0&&(a=ee(Qe(a,u),s.shape));const l=an(s);return $n(Ge(a,De(l,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rbe={kernelName:uf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ge(t,$n(an(n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const obe={kernelName:cf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e,s=Y(vh(n,6),Tf(n));return{x:()=>Y(t,De(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ibe={kernelName:lf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Y(t,De(Tf(n),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const abe={kernelName:r0,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>ee(t,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ube={kernelName:i0,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[s]=e,r={dy:t,images:s};return{images:()=>Z.runKernel(Ib,r,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lbe={kernelName:o0,inputsToSave:["images"],gradFunc:(t,e,n)=>{const[s]=e,r={dy:t,images:s};return{images:()=>Z.runKernel(kb,r,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cbe={kernelName:a0,gradFunc:(t,e,n)=>{const{dims:s}=n,r=vt(s,t.shape);return{x:()=>vi(t,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hbe={kernelName:hf,gradFunc:t=>({x:()=>Wt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dbe={kernelName:df,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>$n(Ge(t,Y(Cl(n,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pbe={kernelName:u0,inputsToSave:["condition"],gradFunc:(t,e)=>{const[n]=e;return{condition:()=>De(Wt(n),"float32"),t:()=>Y(t,De(n,t.dtype)),e:()=>Y(t,De(Xb(n),t.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fbe={kernelName:pf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>{const s=mo(n,nt(0)),r=nt(I0),o=nt($0),i=Y(t,o),a=Y(Y(t,r),mr(De(n,"float32")));return Ys(s,i,a)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mbe={kernelName:yf,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Y(t,Y(n,Be(nt(1),n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gbe={kernelName:gf,gradFunc:t=>({x:()=>Wt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ybe={kernelName:ff,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Y(Ub(De(n,"float32")),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xbe={kernelName:mf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Y(ET(De(n,"float32")),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vbe={kernelName:l0,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{begin:r,size:o}=n,i=s.shape,[a,u]=k0(s,r,o),l=[];for(let c=0;c<t.rank;c++)l.push([a[c],i[c]-a[c]-u[c]]);return{x:()=>Ui(t,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wbe={kernelName:p0,outputsToSave:[!0],gradFunc:(t,e,n)=>{const[s]=e,{dim:r}=n,o=!0,i=Y(t,s);return{logits:()=>Be(i,Y(Qe(i,[r],o),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bbe={kernelName:xf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Y(t,Eo(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $P={kernelName:h0,gradFunc:(t,e,n)=>{const{blockShape:s,paddings:r}=n;return{x:()=>Wb(t,s,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NP={kernelName:d0,gradFunc:(t,e,n)=>{const{axis:s}=n;return{x:()=>Ln(t,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sbe={kernelName:vf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ge(t,Y(Zs(De(n,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cbe={kernelName:_b,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Y(t,Y(De(n,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kbe={kernelName:wf,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=nt(2);return{a:()=>Y(t,Y(r,Be(n,s))),b:()=>Y(t,Y(r,Be(s,n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ibe={kernelName:If,gradFunc:t=>({x:()=>Wt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $be={kernelName:bf,inputsToSave:["a","b"],gradFunc:(t,e)=>{const[n,s]=e,r=ut(n.shape,s.shape);return{a:()=>{let a=t;const u=bs(n.shape,r);return u.length>0&&(a=Qe(a,u)),ee(a,n.shape)},b:()=>{let a=t;const u=bs(s.shape,r);return u.length>0&&(a=Qe(a,u)),ee($n(a),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nbe={kernelName:c0,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,r=s.shape.slice(),{axis:o}=n;vt(o,s.shape).forEach(l=>{r[l]=1});const a=ee(t,r),u=Y(a,no(s.shape,"float32"));return{x:()=>u}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tbe={kernelName:Sf,inputsToSave:["x"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Ge(t,an(Ub(n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ebe={kernelName:Cf,outputsToSave:[!0],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Y(Be(nt(1),an(n)),t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rbe={kernelName:kf,inputsToSave:["x"],gradFunc:(t,e,n)=>{const[s]=e,{reps:r}=n;return{x:()=>{let i=Wt(s);if(s.rank===1)for(let a=0;a<r[0];++a)i=we(i,mt(t,[a*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let a=0;a<r[0];++a)for(let u=0;u<r[1];++u)i=we(i,mt(t,[a*s.shape[0],u*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let a=0;a<r[0];++a)for(let u=0;u<r[1];++u)for(let l=0;l<r[2];++l)i=we(i,mt(t,[a*s.shape[0],u*s.shape[1],l*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let a=0;a<r[0];++a)for(let u=0;u<r[1];++u)for(let l=0;l<r[2];++l)for(let c=0;c<r[3];++c)i=we(i,mt(t,[a*s.shape[0],u*s.shape[1],l*s.shape[2],c*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return i}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Abe={kernelName:Wc,gradFunc:(t,e,n)=>{const s=n,{perm:r}=s,o=Ta(r);return{x:()=>Vt(t,o)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _be={kernelName:f0,gradFunc:(t,e,n)=>{const s=n,{axis:r}=s;return{value:()=>ao(t,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dbe={kernelName:m0,inputsToSave:["segmentIds"],gradFunc:(t,e)=>{const[n]=e;return{x:()=>Pbe(t,n)}}};function Pbe(t,e){const n=Su(e,Wt(e)),s=C0(t,n);let r=Bl(e,nt(0,"int32"));const o=s.rank-r.rank;for(let a=0;a<o;++a)r=us(r,a+1);r=Ca(r,no(s.shape,"bool"));const i=Wt(s);return Ys(r,s,i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fbe={kernelName:g0,gradFunc:t=>({x:()=>Wt(t)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Obe=[QW,Dve,Pve,Fve,Ove,Lve,Mve,zve,Bve,Vve,Wve,Uve,jve,qve,Yve,Qve,Zve,Jve,ewe,twe,nwe,swe,owe,rwe,uwe,lwe,cwe,hwe,dwe,pwe,sbe,fwe,mwe,gwe,ywe,xwe,wwe,vwe,bwe,Swe,Cwe,kwe,Iwe,$we,Nwe,Twe,Ewe,Rwe,Awe,Pwe,kP,kP,Fwe,Mwe,Vwe,Wwe,Uwe,Gwe,Hwe,jwe,Kwe,Xwe,qwe,Ywe,Qwe,IP,IP,Zwe,Jwe,nbe,rbe,obe,ibe,abe,ube,lbe,cbe,hbe,dbe,pbe,fbe,mbe,gbe,ybe,xbe,vbe,wbe,bbe,$P,$P,NP,NP,Sbe,kbe,Cbe,Ibe,$be,Nbe,Tbe,Ebe,Rbe,Abe,_be,Dbe,Fbe];for(const t of Obe)nee(t);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.abs=function(){return this.throwIfDisposed(),ps(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.acos=function(){return this.throwIfDisposed(),uB(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.acosh=function(){return this.throwIfDisposed(),lB(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.add=function(t){return this.throwIfDisposed(),we(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.all=function(t,e){return this.throwIfDisposed(),kT(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.any=function(t,e){return this.throwIfDisposed(),Bv(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.argMax=function(t){return this.throwIfDisposed(),rh(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.argMin=function(t){return this.throwIfDisposed(),cB(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.asScalar=function(){return this.throwIfDisposed(),O(this.size===1,()=>"The array must have only 1 element."),ee(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.asType=function(t){return this.throwIfDisposed(),De(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.as1D=function(){return this.throwIfDisposed(),ee(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.as2D=function(t,e){return this.throwIfDisposed(),ee(this,[t,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.as3D=function(t,e,n){return this.throwIfDisposed(),ee(this,[t,e,n])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.as4D=function(t,e,n,s){return this.throwIfDisposed(),ee(this,[t,e,n,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.as5D=function(t,e,n,s,r){return this.throwIfDisposed(),ee(this,[t,e,n,s,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.asin=function(){return this.throwIfDisposed(),hB(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.asinh=function(){return this.throwIfDisposed(),dB(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.atan=function(){return this.throwIfDisposed(),pB(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.atan2=function(t){return this.throwIfDisposed(),fB(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.atanh=function(){return this.throwIfDisposed(),mB(this)};ye().prototype.avgPool=function(t,e,n,s){return this.throwIfDisposed(),Vb(this,t,e,n,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),Wb(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.batchNorm=function(t,e,n,s,r){return this.throwIfDisposed(),x0(this,t,e,n,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.broadcastTo=function(t){return this.throwIfDisposed(),Kd(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.cast=function(t){return this.throwIfDisposed(),De(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.ceil=function(){return this.throwIfDisposed(),bB(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.clipByValue=function(t,e){return this.throwIfDisposed(),Or(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.concat=function(t,e){return this.throwIfDisposed(),t instanceof en&&(t=[t]),Ln([this,...t],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.conv1d=function(t,e,n,s,r,o){return this.throwIfDisposed(),$T(this,t,e,n,s,r,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.conv2dTranspose=function(t,e,n,s,r){return this.throwIfDisposed(),TT(this,t,e,n,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.conv2d=function(t,e,n,s,r,o){return this.throwIfDisposed(),bl(this,t,e,n,s,r,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.cos=function(){return this.throwIfDisposed(),Ub(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.cosh=function(){return this.throwIfDisposed(),ET(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.cumprod=function(t,e,n){return this.throwIfDisposed(),Vv(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.cumsum=function(t,e,n){return this.throwIfDisposed(),RT(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),EB(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.depthwiseConv2d=function(t,e,n,s,r,o){return this.throwIfDisposed(),v0(this,t,e,n,s,r,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.dilation2d=function(t,e,n,s,r){return this.throwIfDisposed(),RB(this,t,e,n,s,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.divNoNan=function(t){return this.throwIfDisposed(),AB(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.div=function(t){return this.throwIfDisposed(),Ge(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.dot=function(t){return this.throwIfDisposed(),_B(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.elu=function(){return this.throwIfDisposed(),w0(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.equal=function(t){return this.throwIfDisposed(),Wi(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.erf=function(){return this.throwIfDisposed(),DB(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.euclideanNorm=function(t,e){return this.throwIfDisposed(),OB(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.exp=function(){return this.throwIfDisposed(),mr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.expandDims=function(t){return this.throwIfDisposed(),us(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.expm1=function(){return this.throwIfDisposed(),LB(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.fft=function(){return this.throwIfDisposed(),sS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.flatten=function(){return this.throwIfDisposed(),ee(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.floor=function(){return this.throwIfDisposed(),S0(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.floorDiv=function(t){return this.throwIfDisposed(),CT(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.gather=function(t,e,n){return this.throwIfDisposed(),C0(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.greaterEqual=function(t){return this.throwIfDisposed(),Bl(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.greater=function(t){return this.throwIfDisposed(),mo(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.ifft=function(){return this.throwIfDisposed(),Yg(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.irfft=function(){return this.throwIfDisposed(),eE(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.isFinite=function(){return this.throwIfDisposed(),MB(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.isInf=function(){return this.throwIfDisposed(),zB(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.isNaN=function(){return this.throwIfDisposed(),BB(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.leakyRelu=function(t){return this.throwIfDisposed(),Hb(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.lessEqual=function(t){return this.throwIfDisposed(),vh(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.less=function(t){return this.throwIfDisposed(),Kg(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.localResponseNormalization=function(t,e,n,s){return this.throwIfDisposed(),VB(this,t,e,n,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.logSigmoid=function(){return this.throwIfDisposed(),WB(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.logSoftmax=function(t){return this.throwIfDisposed(),DT(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.logSumExp=function(t,e){return this.throwIfDisposed(),Kb(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.log=function(){return this.throwIfDisposed(),Ao(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.log1p=function(){return this.throwIfDisposed(),jb(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.logicalAnd=function(t){return this.throwIfDisposed(),Ca(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.logicalNot=function(){return this.throwIfDisposed(),Xb(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.logicalOr=function(t){return this.throwIfDisposed(),PT(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.logicalXor=function(t){return this.throwIfDisposed(),UB(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.matMul=function(t,e,n){return this.throwIfDisposed(),Dt(this,t,e,n)};ye().prototype.maxPool=function(t,e,n,s){return this.throwIfDisposed(),qb(this,t,e,n,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.max=function(t,e){return this.throwIfDisposed(),fi(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.maximum=function(t){return this.throwIfDisposed(),Su(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.mean=function(t,e){return this.throwIfDisposed(),Un(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.min=function(t,e){return this.throwIfDisposed(),jg(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.minimum=function(t){return this.throwIfDisposed(),kl(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.mirrorPad=function(t,e){return this.throwIfDisposed(),OT(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.mod=function(t){return this.throwIfDisposed(),HB(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.mul=function(t){return this.throwIfDisposed(),Y(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.neg=function(){return this.throwIfDisposed(),$n(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.norm=function(t,e,n){return this.throwIfDisposed(),b0(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.notEqual=function(t){return this.throwIfDisposed(),cp(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.oneHot=function(t,e=1,n=0){return this.throwIfDisposed(),LT(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.onesLike=function(){return this.throwIfDisposed(),_o(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.pad=function(t,e){return this.throwIfDisposed(),Ui(this,t,e)};ye().prototype.pool=function(t,e,n,s,r,o){return this.throwIfDisposed(),jB(this,t,e,n,s,r,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.pow=function(t){return this.throwIfDisposed(),Cl(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.prelu=function(t){return this.throwIfDisposed(),Zb(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.prod=function(t,e){return this.throwIfDisposed(),KB(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.reciprocal=function(){return this.throwIfDisposed(),qB(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.relu=function(){return this.throwIfDisposed(),Ea(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.relu6=function(){return this.throwIfDisposed(),jT(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.reshapeAs=function(t){return this.throwIfDisposed(),ee(this,t.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.reshape=function(t){return this.throwIfDisposed(),ee(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.resizeBilinear=function(t,e,n){return this.throwIfDisposed(),dV(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.resizeNearestNeighbor=function(t,e,n){return this.throwIfDisposed(),pV(this,t,e,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.reverse=function(t){return this.throwIfDisposed(),vi(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.rfft=function(){return this.throwIfDisposed(),rS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.round=function(){return this.throwIfDisposed(),KT(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.rsqrt=function(){return this.throwIfDisposed(),XT(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.selu=function(){return this.throwIfDisposed(),qT(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.separableConv2d=function(t,e,n,s,r,o){return this.throwIfDisposed(),YT(this,t,e,n,s,r,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.sigmoid=function(){return this.throwIfDisposed(),Eo(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.sign=function(){return this.throwIfDisposed(),YB(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.sin=function(){return this.throwIfDisposed(),QT(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.sinh=function(){return this.throwIfDisposed(),ZT(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.slice=function(t,e){return this.throwIfDisposed(),mt(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.softmax=function(t){return this.throwIfDisposed(),nS(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.softplus=function(){return this.throwIfDisposed(),Nf(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),Qb(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.split=function(t,e){return this.throwIfDisposed(),io(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.sqrt=function(){return this.throwIfDisposed(),Zs(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.square=function(){return this.throwIfDisposed(),an(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.squaredDifference=function(t){return this.throwIfDisposed(),tE(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.squeeze=function(t){return this.throwIfDisposed(),Yt(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.stack=function(t,e){this.throwIfDisposed();const n=t instanceof en?[this,t]:[this,...t];return ao(n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.step=function(t){return this.throwIfDisposed(),Tf(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.stridedSlice=function(t,e,n,s,r,o,i,a){return this.throwIfDisposed(),QB(this,t,e,n,s,r,o,i,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.sub=function(t){return this.throwIfDisposed(),Be(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.sum=function(t,e){return this.throwIfDisposed(),Qe(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.tan=function(){return this.throwIfDisposed(),ZB(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.tanh=function(){return this.throwIfDisposed(),lp(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.tile=function(t){return this.throwIfDisposed(),li(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.toBool=function(){return this.throwIfDisposed(),De(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.toFloat=function(){return this.throwIfDisposed(),De(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.toInt=function(){return this.throwIfDisposed(),De(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.topk=function(t,e){return this.throwIfDisposed(),tV(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.transpose=function(t){return this.throwIfDisposed(),Vt(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.unique=function(t){return this.throwIfDisposed(),nV(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),rE(this,t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.unstack=function(t){return this.throwIfDisposed(),wi(this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.where=function(t,e){return this.throwIfDisposed(),Ys(t,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ye().prototype.zerosLike=function(){return this.throwIfDisposed(),Wt(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ca extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ca.prototype)}}class ci extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ci.prototype)}}class se extends Error{constructor(e){super(e),Object.setPrototypeOf(this,se.prototype)}}class Ct extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ct.prototype)}}class AE extends Error{constructor(e){super(e),Object.setPrototypeOf(this,AE.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class JW{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let n;return this.cache.has(e)&&(n=this.cache.get(e),this.cache.delete(e),this.cache.set(e,n)),n}put(e,n){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,n)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let n=0;n<this.maxEntries-e;n++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ch(t,e){if(Array.isArray(t)){let n=[];for(let s=0;s<e;s++)n=n.concat(t);return n}else{const n=new Array(e);return n.fill(t),n}}function ha(t,e){if(!t)throw new AE(e)}function TP(t,e){let n=0;for(const s of t)s===e&&n++;return n}function Er(t){return t.length===1?t[0]:t}function nn(t){return Array.isArray(t)?t:[t]}function Ja(t){const n=t.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return n[0]!=="_"?n:"private"+n}function Nc(t){return t.length<=1||t.indexOf("_")===-1?t:t.replace(/[_]+(\w|$)/g,(e,n)=>n.toUpperCase())}let Yo={};function _E(t){if(t==null)return null;const e={};return e.className=t.getClassName(),e.config=t.getConfig(),e}function N$(t){if(!(t==null||typeof t!="object"))if(Array.isArray(t))t.forEach(e=>N$(e));else{const e=Object.keys(t);for(const n of e){const s=t[n];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?t[n]=s.value:N$(s))}}}function T0(t,e={},n={},s="object",r=!1){if(typeof t=="string"){const o=t;let i;if(o in n)i=n[o];else if(o in Yo)i=Yo[o];else if(i=e[o],i==null)throw new se(`Unknown ${s}: ${t}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{const o=t;if(o.className==null||o.config==null)throw new se(`${s}: Improper config format: ${JSON.stringify(o)}.
'className' and 'config' must set.`);const i=o.className;let a,u;if(i in n?[a,u]=n[i]:i in Yo?[a,u]=Yo.className:i in e&&([a,u]=e[i]),a==null)throw new se(`Unknown ${s}: ${i}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){const l={};for(const f of Object.keys(Yo))l[f]=Yo[f];for(const f of Object.keys(n))l[f]=n[f];const c=o.config;c.customObjects=l;const h=Object.assign({},Yo);for(const f of Object.keys(n))Yo[f]=n[f];N$(o.config);const d=u(a,o.config,n,r);return Yo=Object.assign({},h),d}else{const l=Object.assign({},Yo);for(const h of Object.keys(n))Yo[h]=n[h];const c=new a(o.config);return Yo=Object.assign({},l),c}}}function Lbe(t,e){return t<e?-1:t>e?1:0}function S1(t,e){return-1*Lbe(t,e)}function dl(t){if(t==null)return t;const e=[];for(const n of t)e.indexOf(n)===-1&&e.push(n);return e}function Mbe(t){if(t==null)throw new se(`Invalid value in obj: ${JSON.stringify(t)}`);for(const e in t)if(t.hasOwnProperty(e))return!1;return!0}function Th(t,e,n){if(n!=null&&t.indexOf(n)<0)throw new se(`${n} is not a valid ${e}.  Valid values are ${t} or null/undefined.`)}function DE(t,e,n=0,s=1/0){return ha(n>=0),ha(s>=n),Array.isArray(t)&&t.length>=n&&t.length<=s&&t.every(r=>typeof r===e)}function As(t,e){Array.isArray(t)?(O(t.length>0,()=>`${e} is unexpectedly an empty array.`),t.forEach((n,s)=>As(n,`element ${s+1} of ${e}`))):O(Number.isInteger(t)&&t>0,()=>`Expected ${e} to be a positive integer, but got ${eU(t)}.`)}function eU(t){return t===null?"null":Array.isArray(t)?"["+t.map(e=>eU(e)).join(",")+"]":typeof t=="string"?`"${t}"`:`${t}`}function zbe(t,e,n){let s=n!=null?n():Tr(),r;return(...i)=>{const a=n!=null?n():Tr();return a-s<e||(s=a,r=t(...i)),r}}function tU(t){return t==="relu"?"relu":t==="linear"?"linear":t==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Bbe=0;function nU(){return Bbe++}const C1={};function MS(t=""){return t in C1||(C1[t]=0),C1[t]+=1,t+C1[t].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Vbe=["channelsFirst","channelsLast"],Wbe=["nearest","bilinear"],Ube=["valid","same","causal"],Gbe=["max","avg"],Hbe=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const md=new Map;function ss(t){Th(Vbe,"DataFormat",t)}function jbe(t){Th(Wbe,"InterpolationFormat",t)}function zo(t){Th(Ube,"PaddingMode",t)}function sU(t){Th(Gbe,"PoolMode",t)}const yg=[],EP="/";function Hc(t,e){yg.push(t);try{const n=e();return yg.pop(),n}catch(n){throw yg.pop(),n}}function Kbe(){return yg.length===0?"":yg.join(EP)+EP}function rU(t){if(!iU(t))throw new Error("Not a valid tensor name: '"+t+"'");return Kbe()+t}function oU(t){if(!iU(t))throw new Error("Not a valid tensor name: '"+t+"'");md.has(t)||md.set(t,0);const e=md.get(t);if(md.set(t,md.get(t)+1),e>0){const n=`${t}_${e}`;return md.set(n,1),n}else return t}const Xbe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function iU(t){return!!t.match(Xbe)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function qbe(t){return t===parseInt(t.toString(),10)}function pl(t,e,n){e==null&&(e=0),n==null&&(n=t.length);let s=1;for(let r=e;r<n;++r)s*=t[r];return s}function gp(t){if(t.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let n=0;n<t.length;n++){const s=t[n];s<e&&(e=s)}return e}function $l(t){if(t.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let n=0;n<t.length;n++){const s=t[n];s>e&&(e=s)}return e}function ji(t,e){if(e<t)throw new se(`end (${e}) < begin (${t}) is forbidden.`);const n=[];for(let s=t;s<e;++s)n.push(s);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let gk;function ms(){return gk==null&&(gk=th().epsilon()),gk}function Ki(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function wa(t,e){return De(t,e)}function E0(t,e=-1){const n=t.shape.slice();return e<0&&(e=n.length+e+1),n.splice(e,0,1),ee(t,n)}function Ybe(t,e){return ae(()=>{if(t.shape.length!==2)throw new se(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);const n=E0(t,1);return T$(n,[1,e,1])})}function Qbe(t){const e=[pl(t.shape)];return ee(t,e)}function Zbe(t){if(t.rank<=1)throw new se(`batchFlatten requires a minimum rank of 2. Got rank: ${t.rank}.`);const e=[t.shape[0],pl(t.shape,1)];return ee(t,e)}function jc(t,e,n){return ae(()=>{switch(t.rank){case 1:return eS(t,e,n);case 2:return JT(t,[e,0],[n,t.shape[1]]);case 3:return tS(t,[e,0,0],[n,t.shape[1],t.shape[2]]);case 4:return qg(t,[e,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3]]);case 5:return mt(t,[e,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4]]);case 6:return mt(t,[e,0,0,0,0,0],[n,t.shape[1],t.shape[2],t.shape[3],t.shape[4],t.shape[5]]);default:throw new se(`sliceAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}})}function yk(t,e,n){return ae(()=>{switch(t.rank){case 1:return eS(t,e,n);case 2:return JT(t,[0,e],[t.shape[0],n]);case 3:return tS(t,[0,0,e],[t.shape[0],t.shape[1],n]);case 4:return qg(t,[0,0,0,e],[t.shape[0],t.shape[1],t.shape[2],n]);default:throw new se(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function k1(t,e,n,s){return ae(()=>{switch(t.rank){case 1:return eS(t,e,n);case 2:switch(s){case 1:return jc(t,e,n);case 2:return yk(t,e,n);default:throw new se(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return jc(t,e,n);case 2:return tS(t,[0,e,0],[t.shape[0],n,t.shape[2]]);case 3:return yk(t,e,n);default:throw new se(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return jc(t,e,n);case 2:return qg(t,[0,e,0,0],[t.shape[0],n,t.shape[2],t.shape[3]]);case 3:return qg(t,[0,0,e,0],[t.shape[0],t.shape[1],n,t.shape[3]]);case 4:return yk(t,e,n);default:throw new se(`The axis is not within the rank of the tensor ${s}`)}default:throw new se(`sliceAlongLastAxis() received an unsupported tensor rank: ${t.rank}`)}})}function PE(t,e=-1){let n;return e<0&&(n=t[0].rank,n!==0?e=n:e=0),e===t[0].rank&&(e=-1),Ln(t,e)}function RP(t,e){switch(t.rank){case 1:return SB([t,e]);case 2:return CB([t,e],0);case 3:return kB([t,e],0);case 4:return IB([t,e],0);default:throw new se(`concatAlongFirstAxis() received an unsupported tensor rank: ${t.rank}`)}}function T$(t,e){if(Array.isArray(e)||(e=[e]),t.rank!==e.length)throw new se(`The length of input n (${e.length}) does not match the number of dimensions in input x (${t.rank})`);return li(t,e)}function zS(t,e=0,n=1,s,r){return HT(t,e,n,s,r)}function ba(t,e,n,s){if(t.rank<2||e.rank<2)throw new Ct(`dot requires both inputs to be rank >= 2 but got x shape = ${t.shape} and y shape = ${e.shape}`);if(e.rank>=3){const r=t.shape.slice(-1)[0],o=e.shape.slice(-2)[0];if(r!==o)throw new Ct(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${t.shape} and  y shape = ${e.shape}`)}if(t.rank===2&&e.rank===2)return o$({a:t,b:e,transposeA:!1,transposeB:!1,bias:s?E$(t.rank,s,Ki()):null,activation:n});{const r=t.shape.slice(),o=r.pop();t=ee(t,[-1,o]);const i=e.shape.slice(),a=i.pop(),u=i.pop(),l=[...i,a],c=Array.from({length:e.rank},(m,y)=>y===0?e.rank-2:y<=e.rank-2?y-1:y);e=ee(Vt(e,c),[u,-1]);const h=[...r,...l];return ee(o$({a:t,b:e,transposeA:!1,transposeB:!1,bias:s?E$(t.rank,s,Ki()):null,activation:n}),h)}}function aU(t,e,n){return ae(()=>(Array.isArray(e)?e=ls(e,"int32"):e=De(e,"int32"),C0(t,e,n)))}function R0(t){return Y(t,t)}function E$(t,e,n){const s=e.shape;if(e.rank!==1&&e.rank!==t)throw new se(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${t}`);if(t===5){if(n==="channelsFirst")return s.length===1?ee(e,[1,s[0],1,1,1]):ee(e,[1,s[3],s[0],s[1],s[2]]);if(n==="channelsLast")return s.length===1?ee(e,[1,1,1,1,s[0]]):ee(e,[1].concat(s))}else if(t===4){if(n==="channelsFirst")return s.length===1?ee(e,[1,s[0],1,1]):ee(e,[1,s[2],s[0],s[1]]);if(n==="channelsLast")return s.length===1?ee(e,[1,1,1,s[0]]):ee(e,[1].concat(s))}else if(t===3){if(n==="channelsFirst")return s.length===1?ee(e,[1,s[0],1]):ee(e,[1,s[1],s[0]]);if(n==="channelsLast")return s.length===1?ee(e,[1,1,s[0]]):ee(e,[1].concat(s))}else if(t<3)return e;throw new se(`Unsupported input rank by biasAdd: ${e.rank}`)}function Zi(t,e,n){return ae(()=>(n==null&&(n=Ki()),ss(n),we(t,E$(t.rank,e,n))))}function Jbe(t,e=1){if(e!==1)throw new Ct(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return w0(t)}function eSe(t){return ae(()=>Ge(t,we(ps(t),1)))}function uU(t,e,n,s){return ae(()=>oV(t,e,n,s))}function tSe(t){return ae(()=>{const e=we(.5,Y(.2,t));return Or(e,0,1)})}function A0(t,e,n=!1){return n?t():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const nSe=["fanIn","fanOut","fanAvg"],sSe=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function rSe(t){Th(nSe,"FanMode",t)}function oSe(t){Th(sSe,"Distribution",t)}class bi extends Rf{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class lU extends bi{apply(e,n){return Zn(e,n)}}lU.className="Zeros";$e(lU);class FE extends bi{apply(e,n){return no(e,n)}}FE.className="Ones";$e(FE);class cU extends bi{constructor(e){if(super(),typeof e!="object")throw new se(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new se(`config must have value set but got ${e}`);this.value=e.value}apply(e,n){return ae(()=>Y(nt(this.value),no(e,n)))}getConfig(){return{value:this.value}}}cU.className="Constant";$e(cU);class hU extends bi{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,n){return bh(e,this.minval,this.maxval,n,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}hU.className="RandomUniform";$e(hU);class dU extends bi{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Ct(`randomNormal does not support dType ${n}.`);return zS(e,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}dU.className="RandomNormal";$e(dU);class pU extends bi{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Ct(`truncatedNormal does not support dType ${n}.`);return sE(e,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}pU.className="TruncatedNormal";$e(pU);class fU extends bi{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,n){return ae(()=>{if(e.length!==2||e[0]!==e[1])throw new se("Identity matrix initializer can only be used for 2D square matrices.");return Y(this.gain,_T(e[0]))})}getConfig(){return{gain:this.gain}}}fU.className="Identity";$e(fU);function iSe(t,e="channelsLast"){let n,s;if(ss(e),t.length===2)n=t[0],s=t[1];else if([3,4,5].indexOf(t.length)!==-1){if(e==="channelsFirst"){const r=pl(t,2);n=t[1]*r,s=t[0]*r}else if(e==="channelsLast"){const r=pl(t,0,t.length-2);n=t[t.length-2]*r,s=t[t.length-1]*r}}else{const r=pl(t);n=Math.sqrt(r),s=Math.sqrt(r)}return[n,s]}class lo extends bi{constructor(e){if(super(),e.scale<0)throw new se(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,rSe(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,oSe(this.distribution),this.seed=e.seed}apply(e,n){const s=iSe(e),r=s[0],o=s[1];let i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,r):this.mode==="fanOut"?i/=Math.max(1,o):i/=Math.max(1,(r+o)/2),this.distribution==="normal"){const a=Math.sqrt(i);if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Ct(`${this.getClassName()} does not support dType ${n}.`);return sE(e,0,a,n,this.seed)}else{const a=Math.sqrt(3*i);return bh(e,-a,a,n,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}lo.className="VarianceScaling";$e(lo);class OE extends lo{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return lo.className}}OE.className="GlorotUniform";$e(OE);class LE extends lo{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return lo.className}}LE.className="GlorotNormal";$e(LE);class ME extends lo{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return lo.className}}ME.className="HeNormal";$e(ME);class zE extends lo{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return lo.className}}zE.className="HeUniform";$e(zE);class BE extends lo{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return lo.className}}BE.className="LeCunNormal";$e(BE);class VE extends lo{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return lo.className}}VE.className="LeCunUniform";$e(VE);class mU extends bi{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,n){return ae(()=>{if(e.length<2)throw new Ct("Shape must be at least 2D.");if(n!=="int32"&&n!=="float32"&&n!==void 0)throw new TypeError(`Unsupported data type ${n}.`);n=n;const s=ie(e.slice(0,-1)),r=e[e.length-1],o=s*r;o>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${o}) elements: Slowness may result.`);const i=[Math.max(r,s),Math.min(r,s)],a=zS(i,0,1,n,this.seed),u=fV.qr(a,!1);let l=u[0];const h=u[1].flatten().stridedSlice([0],[Math.min(r,s)*Math.min(r,s)],[Math.min(r,s)+1]);return l=Y(l,h.sign()),s<r&&(l=l.transpose()),Y(nt(this.gain),l.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}mU.className="Orthogonal";$e(mU);const AP={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function _P(t,e={}){return T0(t,ri.getMap().classNameMap,e,"initializer")}function On(t){return _E(t)}function Rn(t){if(typeof t=="string"){const e=t in AP?AP[t]:t;if(e==="GlorotNormal")return new LE;if(e==="GlorotUniform")return new OE;if(e==="HeNormal")return new ME;if(e==="HeUniform")return new zE;if(e==="LeCunNormal")return new BE;if(e==="LeCunUniform")return new VE;{const n={};return n.className=e,n.config={},_P(n)}}else return t instanceof bi?t:_P(t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function R$(t){return Array.isArray(t)&&Array.isArray(t[0])}function Yv(t){return t.length===0?[]:Array.isArray(t[0])?t:[t]}function gt(t){let e;if(Array.isArray(t)){if(t.length!==1)throw new se(`Expected Tensor length to be 1; got ${t.length}`);e=t[0]}else e=t;return e}function Xt(t){if(Array.isArray(t)&&Array.isArray(t[0])){if(t.length===1)return t=t,t[0];throw new se(`Expected exactly 1 Shape; got ${t.length}`)}else return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Qv(t){let e=0;for(const n of t)n.shape.length===0?e+=1:e+=n.shape.reduce((s,r)=>s*r);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const DP="Variable";class aSe{constructor(e,n="float32",s=DP,r=!0,o=null){this.dtype=n??"float32",this.shape=e.shape,this.id=nU(),s=s??DP,this.originalName=rU(s),this.name=oU(this.originalName),this.trainable_=r,this.constraint=o,this.val=sV(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),uSe(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function uSe(t,e){if(t.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(t.shape)+" vs. "+JSON.stringify(e.shape))}function A$(t){return t.map(e=>e.read())}function WE(t){t.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class gs{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class Na{constructor(e,n,s,r,o,i,a){this.dtype=e,this.shape=n,this.sourceLayer=s,this.inputs=r,this.callArgs=o,this.outputTensorIndex=a,this.id=nU(),i!=null&&(this.originalName=rU(i),this.name=oU(this.originalName)),this.rank=n.length}}let lSe=0;class BS{constructor(e,n){this.callArgs=n,this.id=lSe++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s!=null&&s.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const n of this.inboundLayers)n!=null?e.push(n.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let cSe=0;class At extends Rf{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=cSe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let n=e.name;if(!n){const s=this.getClassName();n=Ja(s)+"_"+MS(s)}if(this.name=n,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let o=null;e.batchSize!=null&&(o=e.batchSize),s=[o].concat(e.inputShape)}this.batchInputShape=s;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,n){return e.name+"_ib-"+n.toString()}getNodeAtIndex(e,n){if(this.inboundNodes.length===0)throw new ci(`The layer has never been called and thus has no defined ${n}.`);if(this.inboundNodes.length<=e)throw new se(`Asked to get ${n} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Er(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Er(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new ca(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new ca(`Layer ${this.name} is not connected, no input to return.`);return Er(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new ca(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new ca(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Er(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(n=>n.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const n=nn(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const s=nn(this.inputSpec);if(n.length!==s.length)throw new se(`Layer ${this.name} expects ${s.length} inputs, but it received ${n.length} input tensors. Input received: ${e}`);for(let r=0;r<n.length;r++){const o=n[r],i=s[r];if(i==null)continue;const a=o.rank;if(i.ndim!=null&&a!==i.ndim)throw new se(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${a}`);if(i.maxNDim!=null&&a>i.maxNDim)throw new se(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${a}`);if(i.minNDim!=null&&a<i.minNDim)throw new se(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${a}.`);if(i.dtype!=null&&o.dtype!==i.dtype)throw new se(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${o.dtype}.`);if(i.axes){const u=o.shape;for(const l in i.axes){const c=Number(l),h=i.axes[l],d=c>=0?u[c]:u[u.length+c];if(h!=null&&[h,null].indexOf(d)===-1)throw new se(`Input ${r} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${h} but got shape ${u}.`)}}if(i.shape!=null)for(let u=0;u<i.shape.length;++u){const l=i.shape[u],c=o.shape[u];if(l!=null&&c!=null&&l!==c)throw new se(`Input ${r} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${o.shape}.`)}}}call(e,n){return e}invokeCallHook(e,n){this._callHook!=null&&this._callHook(e,n)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,n){n=n||{},this.assertNotDisposed();const s=nn(e),r=pSe(e),o=fSe(e);if(r===o)throw new se("Arguments to apply() must be all SymbolicTensors or all Tensors");return Hc(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const i=[];for(const a of nn(e))i.push(a.shape);this.build(Er(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&o&&(this._refCount=1)}if(this.assertInputCompatibility(e),o){let i=this.call(e,n);this.supportsMasking&&this.setMaskMetadata(e,i);const a=nn(i),u=[];for(let l of a)s.indexOf(l)!==-1&&(l=l.clone()),u.push(l);if(i=Er(u),this.activityRegularizer!=null)throw new Ct("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{const i=hSe(e),a=this.computeOutputShape(i);let u;const l=dSe(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?i[0]:i),a!=null&&a.length>0&&Array.isArray(a[0])?u=a.map((c,h)=>new Na(l,c,this,nn(e),n,this.name,h)):u=new Na(l,a,this,nn(e),n,this.name),this.addInboundNode(e,u,null,null,i,a,n),this._refCount++,this.activityRegularizer!=null)throw new Ct("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let n=!1;this.batchInputShape.forEach((s,r)=>{s!=null&&e[r]!=null&&e[r]!==s&&(n=!0)}),n&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new ca(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const n of this.inboundNodes){const s=JSON.stringify(n.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const n=this.inboundNodes[0].outputShapes;return Array.isArray(n)&&Array.isArray(n[0])&&n.length===1?n[0]:n}else throw new ca(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new ci(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Qv(this.weights)}build(e){this.built=!0}getWeights(e=!1){return A$(e?this.trainableWeights:this.weights)}setWeights(e){ae(()=>{const n=this.weights;if(n.length!==e.length)throw new se(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${n.length} weights. Provided weights: ${e}...`);if(n.length===0)return;const s=[],r=A$(n);for(let o=0;o<r.length;++o){const i=r[o],a=n[o],u=e[o];if(!kt(i.shape,u.shape))throw new se(`Layer weight shape ${i.shape} not compatible with provided weight shape ${u.shape}`);s.push([a,u])}WE(s)})}addWeight(e,n,s,r,o,i,a,u){if(this._addedWeightNames.indexOf(e)!==-1)throw new se(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(r=u!=null?u():Rn("zeros"));const l=r.apply(n,s),c=new aSe(l,s,e,i,a);return l.dispose(),o!=null&&this.addLoss(()=>o.apply(c.read())),i==null&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=nn(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,n){if(!this.supportsMasking){if(n!=null)if(Array.isArray(n))n.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return n}setMaskMetadata(e,n,s){if(!this.supportsMasking)return;const r=this.computeMask(e,s),o=nn(n),i=nn(r);if(o.length!==i.length)throw new Error(`${this.name} outputs ${o.length} tensors but ${o.length} masks for those tensors`);for(let a=0;a<o.length;a++)o[a].kerasMask=i[a]}addInboundNode(e,n,s,r,o,i,a=null){const u=nn(e);n=nn(n),s=nn(s),r=nn(r),o=Yv(o),i=Yv(i);const l=[],c=[],h=[];for(const d of u)l.push(d.sourceLayer),c.push(d.nodeIndex),h.push(d.tensorIndex);new BS({outboundLayer:this,inboundLayers:l,nodeIndices:c,tensorIndices:h,inputTensors:u,outputTensors:n,inputMasks:s,outputMasks:r,inputShapes:o,outputShapes:i},a);for(let d=0;d<n.length;d++)n[d].sourceLayer=this,n[d].nodeIndex=this.inboundNodes.length-1,n[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function hSe(t){t=nn(t);const e=[];for(const n of t)e.push(n.shape);return Er(e)}function dSe(t){return"float32"}function gU(t,e,n){if((e==null||n!=null&&n>0)&&(e=t.sourceLayer,n=t.nodeIndex),e.inboundNodes.length===0)return[t];{const s=e.inboundNodes[n];if(s.inboundLayers.length===0)return s.inputTensors;{const r=[];for(let o=0;o<s.inboundLayers.length;o++){const i=s.inputTensors[o],a=s.inboundLayers[o],u=s.nodeIndices[o],l=gU(i,a,u);for(const c of l)r.indexOf(c)===-1&&r.push(c)}return r}}}function pSe(t){let e=!0;for(const n of nn(t))if(!(n instanceof Na)){e=!1;break}return e}function fSe(t){let e=!0;for(const n of nn(t))if(n instanceof Na){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class _0 extends At{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:MS("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new se("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let n=e.batchInputShape;if(n==null){if(e.inputShape==null)throw new se("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");n=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new se("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=n,this.dtype=s,this.inputSpec=[{shape:n}];const r=new Na(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new BS({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(e,n){throw new se(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}_0.className="InputLayer";$e(_0);function mSe(t){if(t.batchShape==null&&t.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(t.batchShape!=null&&t.shape!=null)throw new se("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=t.batchShape;t.shape!=null&&e==null&&(e=[null].concat(t.shape));let n=t.dtype;return n==null&&(n="float32"),new _0({batchInputShape:e,name:t.name,dtype:n,sparse:t.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function gSe(t,e){if(t.dtype==null||t.dtype===e.dtype)return e;try{return De(e,t.dtype)}catch{throw new se(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${t.name}' (${t.dtype}).`)}}class el{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof el)for(const n in e.id2Value)this.id2Value[n]=e.id2Value[n],n in e.id2Mask&&(this.id2Mask[n]=e.id2Mask[n]);else{if(e==null)return;for(const n of e)this.add(n.key,n.value)}}add(e,n,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=gSe(e,n),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new se(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Na){if(this.id2Value[e.id]==null)throw new se(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const n=this.name2Id[e];if(n==null)throw new se(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[n]}}getMask(e){if(e instanceof Na){if(this.id2Value[e.id]==null)throw new se(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const n=this.name2Id[e];if(n==null)throw new se(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&ot(this.id2Mask)}}const Zv=new JW,Jv=new JW;function ySe(t){Zv!=null&&Zv.setMaxEntries(t),Jv!=null&&Jv.setMaxEntries(t)}function ng(t,e,n,s){const r=n==null?!1:n.training,o=Array.isArray(t),i=o?t:[t],a=i.map(m=>m.name),u=[],l=e.names();for(const m of a)l.indexOf(m)!==-1?u.push(e.getValue(m)):u.push(null);s!=null&&(s.maxNumTensors=-1/0,s.minNumTensors=1/0);const c=a.join(",")+"|"+e.names().sort().join(",");let h=Zv.get(c),d;if(h==null){const m=xSe(i,e);h=m.sorted,d=m.recipientCounts,Zv.put(c,h),Jv.put(c,d)}d={},r||Object.assign(d,Jv.get(c));const f=new el(e);for(let m=0;m<h.length;++m){if(s!=null){const D=QI().numTensors;D>s.maxNumTensors&&(s.maxNumTensors=D),D<s.minNumTensors&&(s.minNumTensors=D)}const y=h[m],x=y.sourceLayer;if(x instanceof _0)continue;const v=[],w=[],S=[];let k=!1;for(const D of y.inputs){const L=f.getValue(D),V=f.getMask(D);v.push(L),w.push(V),V!=null&&(k=!0),r||(d[D.name]--,d[D.name]===0&&!e.hasKey(D)&&a.indexOf(D.name)===-1&&!L.isDisposed&&D.sourceLayer.stateful!==!0&&S.push(L))}k&&(n=n||{},n.mask=w[0]);const I=nn(x.apply(v,n));let T=null;x.supportsMasking&&(T=x.computeMask(v,w));const R=wSe(y),_=Array.isArray(R)?R:[R];for(let D=0;D<_.length;++D){f.hasKey(_[D])||f.add(_[D],I[D],Array.isArray(T)?T[0]:T);const L=a.indexOf(_[D].name);L!==-1&&(u[L]=I[D])}r||ot(S)}return f.disposeMasks(),o?u:u[0]}function xSe(t,e){O(t!=null&&t.length>0,()=>"Expected at least one fetch, got none");let n=[],s={};if(t.length===1){const r=PP(t[0],e);n=r.sorted,s=r.recipientMap}else{const r=new Set;for(const o of t){const{sorted:i,recipientMap:a}=PP(o,e);for(const u of i)r.has(u.name)||(n.push(u),r.add(u.name));for(const u in a)s[u]==null&&(s[u]=new Set),a[u].forEach(l=>s[u].add(l))}}return{sorted:n,recipientCounts:vSe(s)}}function vSe(t){const e={};for(const n in t)e[n]=t[n].size;return e}function PP(t,e){const n=new Set,s=[],r={};for(const a of e.names())n.add(a);const o=[],i=[];for(o.push(t);o.length>0;){const a=o[o.length-1];if(n.has(a.name)){o.pop();continue}const u=i[i.length-1]===o.length-1;if(a.inputs.length===0||u)o.pop(),s.push(a),n.add(a.name),u&&i.pop();else{i.push(o.length-1);for(const l of a.inputs)r[l.name]==null&&(r[l.name]=new Set),r[l.name].add(a.name),!n.has(l.name)&&o.push(l)}}return{sorted:s,recipientMap:r}}function wSe(t){let e;if(t.sourceLayer.inboundNodes.length===1)e=t.sourceLayer.output;else{let n=null;for(let s=0;s<t.sourceLayer.inboundNodes.length;++s)for(const r of t.sourceLayer.inboundNodes[s].outputTensors)if(r.id===t.id){n=s;break}e=t.sourceLayer.getOutputAt(n)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bSe=ce();bSe.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,ySe);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function UE(t,e){return ae(()=>Zs(Qe(Y(t,t),e,!0)))}class D0 extends Rf{getConfig(){return{}}}class yU extends D0{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ae(()=>{const n=UE(e,this.axis),s=Or(n,0,this.maxValue);return Y(e,Ge(s,we(ms(),n)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}yU.className="MaxNorm";$e(yU);class xU extends D0{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ae(()=>Ge(e,we(ms(),UE(e,this.axis))))}getConfig(){return{axis:this.axis}}}xU.className="UnitNorm";$e(xU);class vU extends D0{apply(e){return Ea(e)}}vU.className="NonNeg";$e(vU);class wU extends D0{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ae(()=>{const n=UE(e,this.axis),s=we(Y(this.rate,Or(n,this.minValue,this.maxValue)),Y(1-this.rate,n));return Y(e,Ge(s,we(ms(),n)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}wU.className="MinMaxNorm";$e(wU);const FP={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function xs(t){return _E(t)}function OP(t,e={}){return T0(t,ri.getMap().classNameMap,e,"constraint")}function vs(t){if(t==null)return null;if(typeof t=="string"){const n={className:t in FP?FP[t]:t,config:{}};return OP(n)}else return t instanceof D0?t:OP(t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function mc(t){if(t==null)return;const e=[],n=[],s=[];for(const r in t){const o=t[r];if(typeof o!="number"){const i=o;e.push(i.data()),n.push(r),s.push(i)}}if(e.length>0){const r=await Promise.all(e);for(let o=0;o<r.length;++o)t[n[o]]=r[o][0];ot(s)}}function bU(t){if(t!=null)for(const e in t){const n=t[e];typeof n!="number"&&n.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var LP;(function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"})(LP||(LP={}));const SSe=125;class ey{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,n){}async onEpochEnd(e,n){}async onBatchBegin(e,n){}async onBatchEnd(e,n){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class CSe{constructor(e,n=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=n}append(e){this.callbacks.push(e)}setParams(e){for(const n of this.callbacks)n.setParams(e)}setModel(e){for(const n of this.callbacks)n.setModel(e)}async onEpochBegin(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onEpochBegin(e,n)}async onEpochEnd(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onEpochEnd(e,n)}async onBatchBegin(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onBatchBegin(e,n)}async onBatchEnd(e,n){n==null&&(n={});for(const s of this.callbacks)await s.onBatchEnd(e,n)}async onTrainBegin(e){e==null&&(e={});for(const n of this.callbacks)await n.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const n of this.callbacks)await n.onTrainEnd(e)}}class kSe extends ey{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,n){n==null&&(n={});const s=n.size==null?0:n.size;this.seen+=s;for(const r in n){const o=n[r];if(typeof o=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+o*s;else{let i;r in this.totals?i=this.totals[r]:this.totals[r]=0;const a=ae(()=>we(this.totals[r],Y(o,s)));this.totals[r]=a,i!=null&&i.dispose()}}}async onEpochEnd(e,n){if(n!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?n[s]=this.totals[s]/this.seen:ae(()=>{const r=Y(Ge(1,this.seen),this.totals[s]);n[s]=r,this.totals[s].dispose(),Rs(n[s])}))}}class ISe extends ey{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,n){n==null&&(n={}),this.epoch.push(e);for(const s in n)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(n[s])}async syncData(){const e=[],n=[],s=[];for(const o in this.history){const i=this.history[o];for(let a=0;a<i.length;++a)if(typeof i[a]!="number"){const u=i[a];e.push(u.data()),n.push(o),s.push(a)}}const r=await Promise.all(e);for(let o=0;o<r.length;++o)this.history[n[o]][s[o]].dispose(),this.history[n[o]][s[o]]=r[o][0]}}class $Se extends ey{constructor(e,n){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||OV,this.yieldEvery=n||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=SSe),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");VI(this.yieldEvery)&&(this.maybeWait=zbe(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,n,s){const r=[];this.yield!=null&&(await mc(s),r.push(this.yield(e,n,s))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,n){this.currentEpoch=e,this.epochBegin!=null&&(await mc(n),await this.epochBegin(e,n))}async onEpochEnd(e,n){const s=[];this.epochEnd!=null&&(await mc(n),s.push(this.epochEnd(e,n))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,n){this.batchBegin!=null&&(await mc(n),await this.batchBegin(e,n))}async onBatchEnd(e,n){const s=[];this.batchEnd!=null&&(await mc(n),s.push(this.batchEnd(e,n))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):VI(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,n)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await mc(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await mc(e),await this.trainEnd(e))}}function SU(t,e){return t==null&&(t={}),t instanceof ey?[t]:Array.isArray(t)&&t[0]instanceof ey?t:nn(t).map(s=>new $Se(s,e))}class ei{constructor(){}static registerCallbackConstructor(e,n){O(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),ei.checkForDuplicate(n),ei.constructors[e]==null&&(ei.constructors[e]=[]),ei.constructors[e].push(n)}static checkForDuplicate(e){for(const n in ei.constructors)ei.constructors[+n].forEach(r=>{if(r===e)throw new se("Duplicate callback constructor.")})}static clear(){ei.constructors={}}static createCallbacks(e){const n=[];for(const s in ei.constructors){const r=+s;e>=r&&n.push(...ei.constructors[r])}return n.map(s=>new s)}}ei.constructors={};function CU(t,e,n,s,r,o,i,a,u){const l=new ISe,c=[new kSe,...ei.createCallbacks(e)];t!=null&&c.push(...t),c.push(l);const h=new CSe(c);return h.setParams({epochs:n,initialEpoch:s,samples:r,steps:o,batchSize:i,verbose:e,doValidation:a,metrics:u}),{callbackList:h,history:l}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function lu(t,e={},n=!1){return T0(t,ri.getMap().classNameMap,e,"layer",n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ew(t,e){return ae(()=>{t.dtype!=="float32"&&(t=De(t,"float32"));const n=Qe(R0(t),e,!0),s=$f(n.shape,ms()),r=Zs(Su(n,s));return Ge(t,r)})}function VS(t,e){return ae(()=>Un(R0(Be(e,t)),-1))}function GE(t,e){return ae(()=>Un(ps(Be(e,t)),-1))}function HE(t,e){return ae(()=>{const n=Be(t,e),s=Or(ps(t),ms(),Number.MAX_VALUE),r=ps(Ge(n,s));return Y(100,Un(r,-1))})}function NSe(t,e){return ae(()=>{const n=Or(e,ms(),Number.MAX_VALUE),s=Ao(we(1,n)),r=Or(t,ms(),Number.MAX_VALUE),o=Ao(we(1,r));return Un(R0(Be(s,o)),-1)})}function TSe(t,e){return ae(()=>{const n=Su(0,Be(1,Y(t,e)));return Un(R0(n),-1)})}function ESe(t,e){return ae(()=>{const n=Su(0,Be(1,Y(t,e)));return Un(n,-1)})}function RSe(t,e){return ae(()=>{const n=Qe(Y(t,e),-1),s=fi(Y(Be(1,t),e),-1);return Su(0,we(1,Be(s,n)))})}function ASe(t,e){return ae(()=>{const n=Math.log(2),s=Be(e,t),r=Be(we(s,Nf(Y(-2,s))),n);return Un(r,-1)})}function ty(t,e,n=!1){return ae(()=>{if(n)e=nS(e);else{const s=Qe(e,e.shape.length-1,!0);e=Ge(e,s)}return e=Or(e,ms(),1-ms()),$n(Qe(Y(De(t,"float32"),Ao(e)),e.shape.length-1))})}function tw(t,e,n=!1){return ae(()=>{const s=De(S0(Qbe(t)),"int32");e=Or(e,ms(),1-ms());const r=e.shape,o=ee(LT(s,r[r.length-1]),r);return ty(o,e,n)})}function _Se(t,e){if(!kt(t.shape,e.shape))throw new se(`logits and labels must have the same shape, but got shapes ${JSON.stringify(t.shape)} and ${JSON.stringify(e.shape)}`);return ae(()=>{const n=Ea(e),s=$n(ps(e));return we(Be(n,Y(e,t)),jb(mr(s)))})}function WS(t,e){return ae(()=>{let n;return n=Or(e,ms(),1-ms()),n=Ao(Ge(n,Be(1,n))),Un(_Se(t,n),-1)})}function DSe(t,e){return ae(()=>{const n=Or(t,ms(),1),s=Or(e,ms(),1);return Qe(Y(t,Ao(Ge(n,s))),-1)})}function PSe(t,e){return ae(()=>{const n=Ao(we(ms(),e));return Un(Be(e,Y(t,n)),-1)})}function kU(t,e){return ae(()=>{const n=ew(t,-1),s=ew(e,-1),r=Y(n,s);return $n(Qe(r,-1))})}const nw={meanSquaredError:VS,meanAbsoluteError:GE,meanAbsolutePercentageError:HE,meanSquaredLogarithmicError:NSe,squaredHinge:TSe,hinge:ESe,categoricalHinge:RSe,logcosh:ASe,categoricalCrossentropy:ty,sparseCategoricalCrossentropy:tw,binaryCrossentropy:WS,kullbackLeiblerDivergence:DSe,poisson:PSe,cosineProximity:kU};function xk(t){if(typeof t=="string"){if(t in nw)return nw[t];let e=`Unknown loss ${t}`;throw t.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${t}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new se(e)}else return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function IU(t,e){return ae(()=>{const n=Y(.5,_o(e)),s=wa(mo(e,n),t.dtype);return Un(Wi(t,s),-1)})}function $U(t,e){return ae(()=>wa(Wi(rh(t,-1),rh(e,-1)),"float32"))}function FSe(t,e){return ae(()=>De(Qe(Ca(Wi(t,1),Wi(e,1))),"float32"))}function OSe(t,e){return ae(()=>De(Qe(Ca(Wi(t,0),Wi(e,1))),"float32"))}function LSe(t,e){return ae(()=>{const n=FSe(t,e),s=OSe(t,e),r=we(n,s);return De(Ys(mo(r,0),Ge(n,r),0),"float32")})}function MSe(t,e){return WS(t,e)}function zSe(t,e){return t.rank===e.rank&&(t=Yt(t,[t.rank-1])),e=rh(e,-1),e.dtype!==t.dtype&&(e=De(e,t.dtype)),De(Wi(t,e),"float32")}const BSe=VS,VSe=VS,WSe=GE,USe=GE,GSe=HE,HSe=HE,NU=ty,jSe=kU,TU=tw,sw={binaryAccuracy:IU,categoricalAccuracy:$U,precision:LSe,categoricalCrossentropy:NU,sparseCategoricalCrossentropy:TU,mse:BSe,MSE:VSe,mae:WSe,MAE:USe,mape:GSe,MAPE:HSe,cosine:jSe};function KSe(t){if(typeof t=="string"&&t in sw)return sw[t];if(typeof t!="string"&&t!=null)return t;throw new se(`Unknown metric ${t}`)}function I1(t){if(ha(t!==null,`Unknown LossOrMetricFn ${t}`),typeof t=="string")return t;{let e;for(const n of Object.keys(nw))if(nw[n]===t){e=n;break}if(e!==void 0)return e;for(const n of Object.keys(sw))if(sw[n]===t){e=n;break}return e!==void 0?e:t.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function XSe(t){const e={Adagrad:()=>hd.adagrad(.01),Adadelta:()=>hd.adadelta(1,.95,ms()),Adam:()=>hd.adam(.001,.9,.999,ms()),Adamax:()=>hd.adamax(.002,.9,.999,ms(),0),RMSProp:()=>hd.rmsprop(.001,.9,0,ms()),SGD:()=>hd.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,t in e)return e[t]();throw new se(`Unknown Optimizer ${t}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const MP=1*1024*1024;function zP(t,e,n=!1){if(t==null||typeof t!="object"||Object.getPrototypeOf(t)!==Object.prototype||!_$(t))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const s=JSON.stringify(t);s.length>MP&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${MP}.`)}}function _$(t){if(t===null)return!0;if(typeof t=="object")if(Object.getPrototypeOf(t)===Object.prototype){const e=Object.keys(t);for(const n of e)if(typeof n!="string"||!_$(t[n]))return!1;return!0}else if(Array.isArray(t)){for(const e of t)if(!_$(e))return!1;return!0}else return!1;else{const e=typeof t;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function qSe(t,e,n,s=console.log){const r=QSe(t),o=["Layer (type)","Input Shape","Output shape","Param #"];r?(e=e||90,n=n||[.32,.61,.89,1]):(e=e||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(e*c)));let i;if(!r){o.push("Receives inputs"),i=[];for(const c in t.nodesByDepth)i.push(...t.nodesByDepth[c])}s("_".repeat(e)),rw(o,n,s),s("=".repeat(e));const a=t.layers;for(let c=0;c<a.length;++c)r?ZSe(a[c],n,s):JSe(a[c],n,i,s),s((c===a.length-1?"=":"_").repeat(e));t.checkTrainableWeightsConsistency();const u=YSe(t),l=Qv(t.nonTrainableWeights);s(`Total params: ${u+l}`),s(`Trainable params: ${u}`),s(`Non-trainable params: ${l}`),s("_".repeat(e))}function YSe(t){let e;return t.collectedTrainableWeights!=null?e=Qv(t.collectedTrainableWeights):e=Qv(t.trainableWeights),e}function QSe(t){let e=!0;const n=[],s=[];for(const r in t.nodesByDepth)n.push(t.nodesByDepth[r]);for(const r of n){if(r.length>1||r.length===1&&r[0].inboundLayers.length>1){e=!1;break}s.push(...r)}if(e)for(const r of t.layers){let o=!1;for(const i of r.inboundNodes)if(s.indexOf(i)!==-1)if(o){e=!1;break}else o=!0;if(!e)break}return e}function rw(t,e,n=console.log){let s="";for(let r=0;r<t.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=t[r],s=s.slice(0,e[r]),s+=" ".repeat(e[r]-s.length);n(s)}function ZSe(t,e,n){let s,r;try{r=t.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(t.outputShape)}catch{s="multiple"}const o=t.name,i=t.getClassName(),a=[`${o} (${i})`,r,s,t.countParams().toString()];rw(a,e,n)}function JSe(t,e,n,s){let r,o;try{o=t.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{o="multiple"}try{r=JSON.stringify(t.outputShape)}catch{r="multiple"}const i=[];for(const h of t.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(h)===-1))for(let d=0;d<h.inboundLayers.length;++d){const f=h.inboundLayers[d].name,m=h.nodeIndices[d],y=h.tensorIndices[d];i.push(`${f}[${m}][${y}]`)}const a=t.name,u=t.getClassName(),l=i.length===0?"":i[0],c=[`${a} (${u})`,o,r,t.countParams().toString(),l];rw(c,e,s);for(let h=1;h<i.length;++h)rw(["","","","",i[h]],e,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function EU(t,e,n){return(t==="inboundNodes"||t==="outputLayers"||t==="inputLayers")&&e===0&&typeof n=="string"}function D$(t,e){if(t===null)return null;if(typeof t=="string")return Nc(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){const n=[],s=t.length;for(let r=0;r<s;++r){const o=t[r];EU(e,r,o)?n.push(o):n.push(D$(o,e))}return n}else{const n={};for(const s of Object.keys(t)){const r=t[s];if(s==="name"&&typeof r=="string")n[s]=r;else{const o=Nc(s);n[o]=D$(r,o)}}return n}}function P$(t,e){if(t==null)return null;if(typeof t=="string")return Ja(t);if(typeof t=="number"||typeof t=="boolean")return t;if(t instanceof Array){const n=[],s=t.length;for(let r=0;r<s;++r){const o=t[r];EU(e,r,o)?n.push(o):n.push(P$(o,e))}return n}else{const n={};for(const s of Object.keys(t)){const r=t[s],o=Ja(s);(s==="name"||s==="className")&&typeof r=="string"?n[o]=r:n[o]=P$(r,s)}return n}}/** @license See the LICENSE file. */const RU="4.15.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const eCe=t=>{const e=Object.keys(t);if(e.length===0)return!1;const n=e[0].split("/");return!isNaN(parseInt(n[n.length-1],10))};class Ri extends At{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const w=this.getClassName().toLowerCase();this.name=MS(w)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],dl(this.inputs).length!==this.inputs.length)throw new se(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(w=>w.name)}`);dl(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(w=>w.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const w of this.outputs){const S=w.sourceLayer,k=w.nodeIndex,I=w.tensorIndex;this.outputLayers.push(S),this.outputLayersNodeIndices.push(k),this.outputLayersTensorIndices.push(I)}for(const w of this.inputs){const S=w.sourceLayer,k=w.nodeIndex,I=w.tensorIndex;ha(k===0,"input layer has >1 nodes"),ha(I===0,"input layer has >1 tensors"),this.inputLayers.push(S),this.inputLayersNodeIndices.push(k),this.inputLayersTensorIndices.push(I)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let w=0;w<this.inputLayers.length;w++){const S=this.inputLayers[w];if(!(S instanceof _0))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${w} (0-based) originates from layer type ${S.getClassName()}.`);this.inputNames.push(S.name),this.feedInputShapes.push(S.batchInputShape),this.feedInputNames.push(S.name)}for(const w of this.outputLayers)this.outputNames.push(w.name);this.internalInputShapes=this.inputs.map(w=>w.shape),this.internalOutputShapes=this.outputs.map(w=>w.shape);const n={},s={},r={},o={},i={},a=[],u=(w,S,k,I,T,R)=>{(I==null||T==null||R==null)&&(I=w.sourceLayer,T=w.nodeIndex,R=w.tensorIndex);const _=I.inboundNodes[T];if(k.indexOf(_)!==-1)throw new ci(`The tensor ${w.name} at layer "${I.name}" is part of a cycle.`);if(S.indexOf(_)!==-1)return;this.containerNodes.add(Ri.nodeKey(I,T)),I.id in i||(i[I.id]=Object.keys(i).length),k.indexOf(_)===-1&&k.push(_);const D=_.inboundLayers.length;for(let L=0;L<D;L++){const V=_.inputTensors[L],U=_.inboundLayers[L],j=_.nodeIndices[L],q=_.tensorIndices[L];u(V,S,k,U,j,q)}for(S.push(_);k.indexOf(_)>=0;)k.splice(k.indexOf(_),1);a.push(_)},l=[],c=[];for(const w of this.outputs)u(w,l,c);const h=a.slice().reverse();for(const w of h){s[w.id]=w,w.id in n||(n[w.id]=0);let S=n[w.id];const k=r[w.outboundLayer.id]==null?0:r[w.outboundLayer.id];S=Math.max(S,k),r[w.outboundLayer.id]=S,o[w.outboundLayer.id]=w.outboundLayer,n[w.id]=S;for(let I=0;I<w.inboundLayers.length;I++){const T=w.inboundLayers[I],R=w.nodeIndices[I],_=T.inboundNodes[R],D=n[_.id]==null?0:n[_.id];n[_.id]=Math.max(S+1,D),s[_.id]=_}}const d={};for(const w in n){const S=n[w];S in d||(d[S]=[]),d[S].push(s[w])}const f={};for(const w in r){const S=r[w];S in f||(f[S]=[]),f[S].push(o[w])}let m=Object.keys(f).map(w=>parseInt(w,10)).sort(S1);this.layers=[];for(const w of m){const S=f[w];S.sort((k,I)=>{const T=i[k.id],R=i[I.id];return T<R?-1:T>R?1:0});for(const k of S)k instanceof Ri&&this.internalContainerRefs.push(k),this.layers.push(k)}this.layersByDepth=f,m=Object.keys(d).map(w=>parseInt(w,10)).sort(S1);const y=this.inputs.slice(),x=[];for(const w of m)for(const S of d[w]){const k=S.outboundLayer;if(k!=null){for(const I of S.inputTensors)if(y.indexOf(I)===-1)throw new ci(`Graph disconnected: cannot obtain value for tensor ${I} at layer "${k.name}". The following previous layers were accessed without issue: ${x}`);for(const I of S.outputTensors)y.push(I);x.push(k.name)}}this.nodesByDepth=d;const v=this.layers.map(w=>w.name);for(const w of v){const S=v.filter(k=>k===w).length;if(S!==1)throw new ci(`The name "${w}" is used ${S} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(v))}this.outboundNodes=[],this.inboundNodes=[],new BS({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(w=>null),outputMasks:this.outputs.map(w=>null),inputShapes:this.inputs.map(w=>w.shape),outputShapes:this.outputs.map(w=>w.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const n of this.layers)e.numDisposedVariables+=n.dispose().numDisposedVariables;for(const n of this.internalContainerRefs)e.numDisposedVariables+=n.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(n=>{n._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new se("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const n of this.layers)e=e.concat(n.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const n of this.layers)e.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const s of this.layers)n.push(...s.trainableWeights);return n.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,n=!0){const s={};let r=0;const o=eCe(e);o&&this.parseWeights(e);for(const a of this.layers)for(const[u,l]of a.weights.entries()){const c=o?`${l.name.split("/").slice(0,-1).join("/")+"/"}${u}`:l.originalName;if(s[c]!=null)throw new se(`Duplicate weight name: ${c}`);s[c]=l,r++}const i=[];for(const a in e){let u=a;if(s[a]==null){const l=a.split("/");u=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(s[u]!=null)i.push([s[u],e[a]]);else if(n)throw new se(`Provided weight data has no target variable: ${a}`);delete s[u]}if(n){const a=[];for(const u in s)a.push(u);if(a.length>0)throw new se(`${a.length} of ${r} weights are not set: ${a}`)}WE(i)}parseWeights(e){for(const n in Object.keys(e)){const s=n.split("/"),r=["vars","layer_checkpoint_dependencies"],o=s.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!r.includes(i)).join("/");o!==n&&(e[o]=e[n],delete e[n])}}updatedConfig(){const e=this.getConfig(),n={};return n.className=this.getClassName(),n.config=e,n.kerasVersion=`tfjs-layers ${RU}`,n.backend="TensorFlow.js",n}toJSON(e,n=!0){const s=P$(this.updatedConfig());return n?JSON.stringify(s):s}call(e,n){return ae(()=>{e=nn(e);const s=new el;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],e[r]);return ng(this.outputs,s,n)})}computeMask(e,n){return ae(()=>{e=nn(e);let s;return n==null?s=ch(null,e.length):s=nn(n),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const n=Yv(e);if(n.length!==this.inputLayers.length)throw new se(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let a=0;a<n.length;a++){const u=this.inputLayers[a],l=n[a],c=u.name+"_0_0";s[c]=l}const r=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(S1);if(r.length>1)for(const a of r){const u=this.nodesByDepth[a];for(const l of u){const c=l.outboundLayer;if(this.inputLayers.map(y=>y.id).indexOf(c.id)!==-1)continue;const h=[];for(let y=0;y<l.inboundLayers.length;y++){const x=l.inboundLayers[y],v=l.nodeIndices[y],w=l.tensorIndices[y],S=`${x.name}_${v}_${w}`,k=s[S];h.push(k)}const d=c.computeOutputShape(Er(h)),f=Yv(d),m=c.inboundNodes.indexOf(l);for(let y=0;y<f.length;y++){const x=`${c.name}_${m}_${y}`;s[x]=f[y]}}}const o=[],i=[];for(let a=0;a<this.outputLayers.length;a++){const u=this.outputLayers[a],l=this.outputLayersNodeIndices[a],c=this.outputLayersTensorIndices[a],h=`${u.name}_${l}_${c}`;i.push(h)}for(let a=0;a<i.length;a++){const u=i[a];ha(u in s),o.push(s[u])}return Er(o)}runInternalGraph(e,n){n==null&&(n=ch(null,e.length));const s={};for(let u=0;u<this.inputs.length;++u){const l=this.inputs[u],c=e[u],h=n[u];s[l.id]=[c,h]}const r=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(S1);for(const u of r){const l=this.nodesByDepth[u];for(const c of l){const h=c.outboundLayer,d=c.inputTensors,f=c.outputTensors,m=new Array;for(const y of d)y.id in s&&m.push(s[y.id]);if(m.length===d.length){let y={},x,v,w,S;if(c.callArgs!=null&&(y=c.callArgs),m.length===1){const[k,I]=m[0];y.mask==null&&(y.mask=I),w=nn(h.call(k,y)),S=nn(h.computeMask(k,I)),x=[k],v=[I]}else x=m.map(k=>k[0]),v=m.map(k=>k[1]),y.mask==null&&(y.mask=v),w=nn(h.call(x,y)),S=nn(h.computeMask(x,v));if(h.activityRegularizer)throw new Ct("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let k=0;k<f.length;++k){const I=f[k],T=w[k],R=S[k];s[I.id]=[T,R]}}}}const o=[],i=[],a=[];for(const u of this.outputs){ha(u.id in s,`Could not compute output ${u.name} : ${u.id}`);const[l,c]=s[u.id];a.push(l.shape),o.push(l),i.push(c)}return[o,i,a]}buildNodeConversionMap(e){const n={};let s;for(const r of this.layers){s=r instanceof Ri?1:0;for(let o=0;o<r.inboundNodes.length;o++){const i=Ri.nodeKey(r,o);this.containerNodes.has(i)&&(n[i]=s,s+=1)}}return n}getLayer(e,n){if(n!=null)return this.findLayer(n);if(e==null)throw new se("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const s of this.layers)if(s.name===e)return s;throw new se(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new se(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return ae(()=>{const e=[];for(const n of this.layers)for(let s=0;s<n.inboundNodes.length;++s){const r=Ri.nodeKey(n,s);this.containerNodes.has(r)&&e.push(...n.calculateLosses())}return e})}getConfig(){const e={name:this.name},n=this.buildNodeConversionMap(this.layers),s=[];for(const i of this.layers){const a=i.getClassName(),u=i.getConfig(),l=[];for(let h=0;h<i.inboundNodes.length;h++){const d=i.inboundNodes[h],f=Ri.nodeKey(i,h);let m={};if(this.containerNodes.has(f)){if(d.callArgs)try{JSON.stringify(d.callArgs),m=d.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),m={}}if(d.inboundLayers.length>0){const y=[];for(let x=0;x<d.inboundLayers.length;x++){const v=d.inboundLayers[x],w=d.nodeIndices[x],S=d.tensorIndices[x],k=Ri.nodeKey(v,w);let I=n[k];I==null&&(I=0),y.push([v.name,I,S,m])}l.push(y)}}}const c={};c.name=i.name,c.className=a,c.config=u,c.inboundNodes=l,s.push(c)}e.layers=s;const r=[];for(let i=0;i<this.inputLayers.length;i++){const a=this.inputLayers[i],u=this.inputLayersNodeIndices[i],l=Ri.nodeKey(a,u);if(!this.containerNodes.has(l))continue;let c=n[l];c==null&&(c=0);const h=this.inputLayersTensorIndices[i];r.push([a.name,c,h])}e.inputLayers=r;const o=[];for(let i=0;i<this.outputLayers.length;i++){const a=this.outputLayers[i],u=this.outputLayersNodeIndices[i],l=Ri.nodeKey(a,u);if(!this.containerNodes.has(l))continue;let c=n[l];c==null&&(c=0);const h=this.outputLayersTensorIndices[i];o.push([a.name,c,h])}return e.outputLayers=o,e}static fromConfig(e,n,s={},r=!1){const o={},i={};function a(x,v){x.name in i?i[x.name].push(v):i[x.name]=[v]}function u(x,v){const w=[];let S;for(const k of v){const I=k[0],T=k[1],R=k[2];if(S=k[3]==null?{}:k[3],!(I in o)){a(x,v);return}const _=o[I];if(_.inboundNodes.length<=T){a(x,v);return}const D=_.inboundNodes[T];w.push(D.outputTensors[R])}w.length>0&&x.apply(Er(w),S)}function l(x){const v=x.name,w=lu(x,n.customObjects!=null?n.customObjects:{});w.setFastWeightInitDuringBuild(r),o[v]=w,x.inboundNodes.forEach(k=>{if(!(k instanceof Array))throw new se(`Corrupted configuration, expected array for nodeData: ${k}`);a(w,k)})}const c=n.name,h=n.layers;for(const x of h)l(x);for(;!Mbe(i);)for(const x of h){const v=o[x.name];if(v.name in i){const w=i[v.name];delete i[v.name];for(const S of w)u(v,S)}}const d=[],f=[],m=n.inputLayers;for(const x of m){const v=x[0],w=x[1],S=x[2];ha(v in o);const I=o[v].inboundNodes[w].outputTensors;d.push(I[S])}const y=n.outputLayers;for(const x of y){const v=x[0],w=x[1],S=x[2];ha(v in o);const I=o[v].inboundNodes[w].outputTensors;f.push(I[S])}return new e({inputs:d,outputs:f,name:c})}get stateful(){if(this._stateful)throw new se("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){ae(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function tCe(t,e,n){const s=e.length;if(t==null||Array.isArray(t)&&t.length===0)return e.map(r=>null);if(s===1)return Array.isArray(t)&&t.length===1?t:typeof t=="object"&&e[0]in t?[t[e[0]]]:[t];if(Array.isArray(t)){if(t.length!==s)throw new Error(`Provided ${n} is an array of ${t.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return t}else if(typeof t=="object"&&Object.keys(t).length>0&&typeof t[Object.keys(t)[0]]=="object"){const r=[];return e.forEach(o=>{o in t?r.push(t[o]):r.push(null)}),r}else throw new Error(`The model has multiple (${s}) outputs, so ${n} must be either an array with ${s} elements or an object with ${e} keys. Provided ${n} not understood: ${JSON.stringify(t)}`)}function AU(t,e){return tCe(t,e,"classWeight")}async function _U(t,e,n,s){if(e!=null||s!=null)throw new Error("Support sampleWeight is not implemented yet");if(n!=null){const r=ae(()=>{if(t.shape.length===1)return au(t);if(t.shape.length===2){if(t.shape[1]>1)return rh(t,1);if(t.shape[1]===1)return ee(t,[t.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${t.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${t.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(await r.data());ot(r);const i=[];return o.forEach(a=>{if(n[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(n[a])}),ls(i,"float32")}else return null}function nCe(t,e){return Y(t,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const sCe=32;function DU(t,e){let n,s;const r=e;n=r.xs,s=r.ys,O(n!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const o=BP("input",t.inputNames,n),i=BP("output",t.outputNames,s),a=o[0].shape[0];O(o.length===t.inputs.length,()=>`LayersModel has ${t.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(t.inputNames)})`),O(i.length===t.outputs.length,()=>`LayersModel has ${t.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(t.outputNames)})`);for(let u=0;u<o.length;u++)O(o[u].shape[0]===a,()=>`Batch size mismatch: input ${t.inputNames[u]} has ${o[u].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);for(let u=0;u<i.length;u++)O(i[u].shape[0]===a,()=>`Batch size mismatch: output ${t.outputNames[u]} has ${i[u].shape[0]}; expected  ${a} based on input ${t.inputNames[0]}.`);return{xs:o,ys:i}}function BP(t,e,n){if(n instanceof en)return[n];if(Array.isArray(n))return O(n.length===e.length,()=>`Received an array of ${n.length} Tensors, but expected ${e.length} to match the ${t} keys ${e}.`),n;{const s=[];for(const r of e){if(n[r]==null)throw new se(`The feature data generated by the dataset lacks the required ${t} key '${r}'.`);s.push(n[r])}return s}}function rCe(t){if(t.length===3)throw new Ct("Validation with sample weights is not implemented yet.");return{xs:t[0],ys:t[1]}}async function oCe(t,e,n){const s=n.batchesPerEpoch!=null;if(O(t.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),O(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),O(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),O(!s||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),O(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),t.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");t.isTraining=!0;try{const r=n.validationData!=null;let o,i;if(r)if(VP(n.validationData))O(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const x=rCe(n.validationData);o=x.xs,i=x.ys}const a=t.makeTrainFunction(),u=t.getDedupedMetricsNames();let l;r?l=u.slice().concat(u.map(x=>"val_"+x)):l=u.slice();const c=SU(n.callbacks,n.yieldEvery),h=n.verbose==null?1:n.verbose,{callbackList:d,history:f}=CU(c,h,n.epochs,null,null,iCe(e,n),null,r,l);d.setModel(t),t.history=f,await d.onTrainBegin(),t.stopTraining_=!1;let m=n.initialEpoch==null?0:n.initialEpoch,y=await e.iterator();for(;m<n.epochs;){const x={};await d.onEpochBegin(m);let v=0,w=0;for(s||(y=await e.iterator());!s||v<n.batchesPerEpoch;){const S=await y.next();if(s&&S.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${v} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(S.value!=null){const{xs:k,ys:I}=DU(t,S.value),T={};T.batch=w,T.size=k[0].shape[0],await d.onBatchBegin(w,T);const R=[];if(n.classWeight!=null){const L=AU(n.classWeight,t.outputNames);for(let V=0;V<L.length;++V)R.push(await _U(I[V],null,L[V]))}const _=k.concat(I).concat(R),D=a(_);ot(_);for(let L=0;L<u.length;++L){const V=u[L],U=D[L];T[V]=U,Rs(U)}await d.onBatchEnd(w,T),bU(T),w++,v++}if(s?v>=n.batchesPerEpoch:S.done){if(r){let k;VP(n.validationData)?k=nn(await t.evaluateDataset(n.validationData,{batches:n.validationBatches})):k=nn(t.evaluate(o,i,{batchSize:n.validationBatchSize==null?sCe:n.validationBatchSize,verbose:0}));for(let I=0;I<t.metricsNames.length;++I)x[`val_${t.metricsNames[I]}`]=k[I]}break}if(t.stopTraining_)break}if(await d.onEpochEnd(m,x),m++,t.stopTraining_)break}return await d.onTrainEnd(),await t.history.syncData(),t.history}finally{t.isTraining=!1}}function iCe(t,e){let n=null;return e.batchesPerEpoch!=null?n=e.batchesPerEpoch:Number.isFinite(t.size)&&(n=t.size),n}function VP(t){return typeof t.iterator=="function"}function aCe(t){return typeof t.next=="function"}async function uCe(t,e,n){n=n||{};const s=n.batches!=null,r=t.testFunction;let o=[];if(n.verbose>0)throw new Ct("Verbose mode is not implemented yet.");O(!s||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const i=aCe(e)?e:await e.iterator();let a=0,u=0;for(;!s||u<n.batches;){const l=await i.next();if(o=ae(()=>{if(l.value){const{xs:c,ys:h}=DU(t,l.value),d=c.concat(h),f=ae(()=>r(d));if(ot(d),u===0)for(let y=0;y<f.length;++y)o.push(nt(0));const m=d[0].shape[0];for(let y=0;y<f.length;++y){const x=f[y],v=o[y];o[y]=ae(()=>we(o[y],Y(m,x))),u>0&&ot(v)}ot(f),a+=m,++u}return o}),l.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<o.length;++l){const c=o[l];o[l]=Ge(o[l],a),ot(c)}return Er(o)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function vk(t){O(t>0&&Number.isInteger(t),()=>`batchSize is required to be a positive integer, but got ${t}`)}function Gm(t,e,n){return t==null?[null]:Array.isArray(t)?t.map(s=>jc(s,e,n-e)):jc(t,e,n-e)}function F$(t,e){return ae(()=>t==null?null:Array.isArray(t)?t.map(n=>F$(n,e)):aU(t,e.dtype==="int32"?e:De(e,"int32")))}function wk(t,e){const n=[];let s=0,r=null;for(;s<t;)r=s+e,r>=t&&(r=t),n.push([s,r]),s=r;return n}function PU(t){const e=[];t instanceof en&&(t=[t]);for(let n=0;n<t.length;++n){const s=t[n];if(s.rank===1)e.push(E0(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function Ei(t,e){if(t==null)return;const n=[];if(e instanceof en)n.push(e.id);else if(Array.isArray(e))e.forEach(r=>n.push(r.id));else if(e!=null)for(const r in e){const o=e[r];n.push(o.id)}const s=[];if(t instanceof en)n.indexOf(t.id)===-1&&s.push(t);else if(Array.isArray(t))t.forEach(r=>{n.indexOf(r.id)===-1&&s.push(r)});else if(t!=null)for(const r in t){const o=t[r];n.indexOf(o.id)===-1&&s.push(o)}s.forEach(r=>{r.isDisposed||r.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function lCe(t){return t instanceof en}function O$(t){return Array.isArray(t)}function WP(t){return!lCe(t)&&!O$(t)}function UP(t,e,n,s=!0,r=""){if(e==null||e.length===0){if(t!=null){let i=!1;if(O$(t)&&t.length>0)i=!0;else if(WP(t)){for(const a in t)if(t.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new se(`Error when checking model ${r} expected no data, but got ${t}`)}return[]}if(t==null)return e.map(i=>null);let o;if(WP(t)){t=t,o=[];for(const i of e){if(t[i]==null)throw new se(`No data provided for "${i}". Need data for each key in: ${e}`);o.push(t[i])}}else if(O$(t)){if(t=t,t.length!==e.length)throw new se(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${t}`);o=t}else{if(t=t,e.length>1)throw new se(`The model ${r} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${t.shape}`);o=[t]}if(o=PU(o),n!=null)for(let i=0;i<e.length;++i){if(n[i]==null)continue;const a=o[i];if(a.shape.length!==n[i].length)throw new se(`Error when checking ${r}: expected ${e[i]} to have ${n[i].length} dimension(s). but got array with shape ${a.shape}`);for(let u=0;u<n[i].length;++u){if(u===0&&!s)continue;const l=a.shape[u],c=n[i][u];if(c!=null&&c>=0&&l!==c)throw new se(`${r} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${r} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return o}function cCe(t,e,n){const s=dl(t.map(o=>o.shape[0]));s.sort();const r=dl(e.map(o=>o.shape[0]));if(r.sort(),s.length>1)throw new se(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(o=>o.shape))}`);if(r.length>1)throw new se(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(o=>o.shape))}`);if(s.length>0&&r.length>0&&!kt(s,r))throw new se(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}function hCe(t,e,n){const s=[VS,WS,ty];for(let r=0;r<t.length;++r){const o=t[r],i=e[r],a=n[r];if(i!=null){if(i===ty&&o.shape[o.shape.length-1]===1)throw new se(`You are passing a target array of shape ${o.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(i)!==-1){const u=o.shape.slice(1),l=a.slice(1);for(let c=0;c<u.length;++c){const h=u[c],d=l[c];if(d!=null&&h!==d)throw new se(`A target Tensor with shape ${o.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function GP(t,e,n,s=!0,r=""){let o;if(Array.isArray(t)){if(t.length!==e.length)throw new se(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${t.length} Tensors(s).`);o=t}else{if(e.length>1)throw new se(`The model expects ${e.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(t.shape)}.`);o=[t]}if(n!=null)for(let i=0;i<e.length;++i){if(n[i]==null)continue;const a=o[i];if(a.shape.length!==n[i].length)throw new se(`Error when checking ${r}: expected ${e[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let u=0;u<n[i].length;++u){if(u===0&&!s)continue;const l=a.shape[u],c=n[i][u];if(c!=null&&c!==l)throw new se(`Error when checking ${r}: expected ${e[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function dCe(t,e){if(t==null||Array.isArray(t)&&t.length===0)return e.map(s=>[]);let n;if(typeof t=="string"||typeof t=="function")n=[t];else if(Array.isArray(t)||typeof t=="object")n=t;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${t}`);if(Array.isArray(n))return e.map(s=>n);{const s=[];for(const r of e){let o=n.hasOwnProperty(r)?n[r]:[];Array.isArray(o)||(o=[o]),s.push(o)}return s}}const pCe="layers-model";class Xd extends Ri{constructor(e){super(e),this.isTraining=!1}summary(e,n,s=console.log){if(!this.built)throw new se("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");qSe(this,e,n,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=XSe(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Vl))throw new se("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let n=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const i in e.loss)if(this.outputNames.indexOf(i)===-1)throw new se(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(const i of this.outputNames)e.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),n.push(xk(e.loss[i]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new se(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);n=e.loss.map(a=>xk(a))}else{const i=xk(e.loss);this.outputs.forEach(a=>{n.push(i)})}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const a=this.internalOutputShapes[i],u=this.outputNames[i];this.feedOutputNames.push(u),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[i])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Hc("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(s.indexOf(i)!==-1)continue;const a=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([a,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});const r=dCe(e.metrics,this.outputNames),o=(i,a,u)=>{this.outputNames.length>1&&(a=this.outputNames[i]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([u,i])};Hc("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(s.indexOf(i)!==-1)continue;const a=r[i];(l=>{const c="";let h,d,f;for(const m of l){if(typeof m=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(m)!==-1){const x=this.internalOutputShapes[i];x[x.length-1]===1||this.lossFunctions[i]===WS?["accuracy","acc"].indexOf(m)!==-1?d=IU:["crossentropy","ce"].indexOf(m)!==-1&&(d=MSe):this.lossFunctions[i]===tw?["accuracy","acc"].indexOf(m)!==-1?d=zSe:["crossentropy","ce"].indexOf(m)!==-1&&(d=TU):["accuracy","acc"].indexOf(m)!==-1?d=$U:["crossentropy","ce"].indexOf(m)!==-1&&(d=NU);let v;["accuracy","acc"].indexOf(m)!==-1?v="acc":["crossentropy","ce"].indexOf(m)!==-1&&(v="ce"),f=d,h=c+v}else f=KSe(m),h=c+I1(m);let y;Hc(h,()=>{y=f}),o(i,h,y)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,n,s={}){const r=s.batchSize==null?32:s.batchSize;vk(r);const o=!0,i=this.standardizeUserDataXY(e,n,o,r);try{const a=i[0].concat(i[1]);this.makeTestFunction();const u=this.testFunction,l=this.testLoop(u,a,r,s.verbose,s.steps);return Er(l)}finally{Ei(i[0],e),Ei(i[1],n)}}async evaluateDataset(e,n){return this.makeTestFunction(),uCe(this,e,n)}checkNumSamples(e,n,s,r="steps"){let o;if(s!=null){if(o=null,n!=null)throw new se(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${n}`)}else if(e!=null)Array.isArray(e)?o=e[0].shape[0]:o=e.shape[0];else throw new se(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return o}execute(e,n){if(Array.isArray(n)&&n.length===0)throw new se("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(n),r=s?n:[n],o=this.retrieveSymbolicTensors(r),i=new el;if(e instanceof en&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new se(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)i.add(this.inputs[u],e[u])}else for(const u of this.inputs){const l=e[u.name];if(l==null)throw new se(`No value is provided for the model's input ${u.name}`);i.add(u,l)}const a=ng(o,i);return s?a:a[0]}retrieveSymbolicTensors(e){const n=ch(null,e.length);let s=e.length;for(const r of this.layers){const o=Array.isArray(r.output)?r.output:[r.output],i=o.map(a=>a.name);for(let a=0;a<e.length;++a){const u=i.indexOf(e[a]);if(u!==-1&&(n[a]=o[u],s--),s===0)break}if(s===0)break}if(s>0){const r=[];throw n.forEach((o,i)=>{o==null&&r.push(e[i])}),new se(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return n}predictLoop(e,n=32,s=!1){return ae(()=>{const r=this.checkNumSamples(e);if(s)throw new Ct("Verbose predictLoop() is not implemented yet.");const o=wk(r,n),i=this.outputs.map(a=>[]);for(let a=0;a<o.length;++a)ae(()=>{const l=o[a][0],c=o[a][1],h=Gm(e,l,c),d=[];if(Array.isArray(h))for(let m=0;m<h.length;++m)d.push({key:this.inputs[m],value:h[m]});else d.push({key:this.inputs[0],value:h});const f=new el(d);return ng(this.outputs,f)}).forEach((l,c)=>i[c].push(l));return Er(i.map(a=>Ln(a,0)))})}predict(e,n={}){const s=PU(e);GP(s,this.inputNames,this.feedInputShapes,!1);try{const r=n.batchSize==null?32:n.batchSize;return vk(r),this.predictLoop(s,r)}finally{Ei(s,e)}}predictOnBatch(e){GP(e,this.inputNames,this.feedInputShapes,!0);const n=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,n)}standardizeUserDataXY(e,n,s=!0,r){if(this.optimizer_==null)throw new ci("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const o=[];for(let i=0;i<this.feedOutputShapes.length;++i){const a=this.feedOutputShapes[i];this.feedLossFns[i]===tw?o.push(a.slice(0,a.length-1).concat([1])):o.push(a)}if(e=UP(e,this.feedInputNames,this.feedInputShapes,!1,"input"),n=UP(n,this.feedOutputNames,o,!1,"target"),cCe(e,n),hCe(n,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new se(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,n]}async standardizeUserData(e,n,s,r,o=!0,i){const[a,u]=this.standardizeUserDataXY(e,n,o,i);if(s!=null)throw new Error("sample weight is not supported yet.");let l=null;if(r!=null){const c=AU(r,this.outputNames);l=[];for(let h=0;h<c.length;++h)l.push(await _U(u[h],null,c[h]))}return[a,u,l]}testLoop(e,n,s,r=0,o){return ae(()=>{const i=this.checkNumSamples(n,s,o,"steps"),a=[];if(r>0)throw new Ct("Verbose mode is not implemented yet.");if(o!=null)throw new Ct("steps mode in testLoop() is not implemented yet");{const u=wk(i,s),l=ls(ji(0,i));for(let c=0;c<u.length;++c){const h=u[c][0],d=u[c][1],f=jc(l,h,d-h),m=F$(n,f),y=e(m);if(c===0)for(let x=0;x<y.length;++x)a.push(nt(0));for(let x=0;x<y.length;++x){const v=y[x];a[x]=we(a[x],Y(d-h,v))}}for(let c=0;c<a.length;++c)a[c]=Ge(a[c],i)}return a})}getDedupedMetricsNames(){const e=this.metricsNames,n=[];for(let s=0;s<e.length;++s){const r=e[s];let o=r;if(TP(e,r)>1){const i=TP(e.slice(0,s),r);o+=`_${i}`}n.push(o)}return n}makeTrainFunction(){return e=>{const n=[],s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],a=()=>{const h=[];for(let y=0;y<this.inputs.length;++y)h.push({key:this.inputs[y],value:s[y]});const d=new el(h),f=ng(this.outputs,d,{training:!0});let m;for(let y=0;y<this.lossFunctions.length;++y){const x=this.lossFunctions[y];let v=x(r[y],f[y]);o[y]!=null&&(v=nCe(v,o[y]));const w=Un(v);n.push(w),y===0?m=v:m=we(m,v)}for(let y=0;y<this.metricsTensors.length;++y){let x;if(this.outputs.length>1&&y<this.outputs.length)x=n[y];else{const v=this.metricsTensors[y][0],w=this.metricsTensors[y][1];x=Un(v(r[w],f[w]))}Rs(x),i.push(x)}return m=Un(m),this.calculateLosses().forEach(y=>{m=we(m,y)}),m},u=this.collectedTrainableWeights.map(h=>h.read()),l=!0;return[this.optimizer_.minimize(a,l,u)].concat(i)}}makeTestFunction(){this.testFunction=e=>ae(()=>{const n=[];let s;const r=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let l=0;l<this.inputs.length;++l)i.push({key:this.inputs[l],value:r[l]});const a=new el(i),u=ng(this.outputs,a);for(let l=0;l<this.lossFunctions.length;++l){const c=this.lossFunctions[l],h=Un(c(o[l],u[l]));l===0?s=h:s=we(s,h),n.push(s)}for(let l=0;l<this.metricsTensors.length;++l){const c=this.metricsTensors[l][0],h=this.metricsTensors[l][1],d=Un(c(o[h],u[h]));n.push(d)}return n})}async fit(e,n,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,o,i,a,u,l,c,h,d;try{const f=s.batchSize==null?32:s.batchSize;vk(f);const m=!1,y=await this.standardizeUserData(e,n,s.sampleWeight,s.classWeight,m,f);r=y[0],o=y[1],d=y[2];let x=!1,v;if(s.validationData!=null&&s.validationData.length>0){if(x=!0,s.validationData.length===2)u=s.validationData[0],l=s.validationData[1];else throw s.validationData.length===3?new Ct("validationData including sample weights is not supported yet."):new se(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const D=!0,L=await this.standardizeUserData(u,l,null,null,D,f);c=L[0],h=L[1],v=c.concat(h)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){x=!0;const D=Math.floor(r[0].shape[0]*(1-s.validationSplit)),L=r[0].shape[0];c=Gm(r,D,L),i=r,r=Gm(r,0,D),h=Gm(o,D,L),a=o,o=Gm(o,0,D),v=c.concat(h)}else s.validationSteps!=null&&(x=!0);const w=r.concat(o).concat(d);this.checkTrainableWeightsConsistency();const S=this.makeTrainFunction(),k=this.getDedupedMetricsNames();let I,T;x?(this.makeTestFunction(),I=this.testFunction,T=k.slice().concat(k.map(D=>"val_"+D))):(I=null,v=[],T=k.slice());const R=SU(s.callbacks,s.yieldEvery);return await this.fitLoop(S,w,k,f,s.epochs,s.verbose,R,I,v,s.shuffle,T,s.initialEpoch,null,null)}finally{this.isTraining=!1,Ei(r,e),Ei(o,n),Ei(i,e),Ei(a,n),Ei(c,u),Ei(h,l),d!=null&&ot(d)}}async fitLoop(e,n,s,r,o,i,a,u,l,c,h,d,f,m){r==null&&(r=32),o==null&&(o=1),c==null&&(c=!0),d==null&&(d=0);let y=!1;if(u!=null&&l!=null&&(y=!0),m!=null&&(y=!0,f==null))throw new se("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const x=this.checkNumSamples(n,r,f,"steps_per_epoch");let v;x!=null&&(v=ji(0,x)),i==null&&(i=1);const{callbackList:w,history:S}=CU(a,i,o,d,x,f,r,y,h);w.setModel(this),this.history=S,await w.onTrainBegin(),this.stopTraining_=!1;for(let k=d;k<o;++k){await w.onEpochBegin(k);const I={};if(f!=null)throw new Ct("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new Ct("batch shuffling is not implemneted yet");c&&VJ(v);const T=ls(v),R=wk(x,r);for(let _=0;_<R.length;++_){const D={};if(await w.onBatchBegin(_,D),ae(()=>{const L=R[_][0],V=R[_][1],U=jc(T,L,V-L);D.batch=_,D.size=V-L;const j=F$(n,U),q=e(j);for(let J=0;J<s.length;++J){const te=s[J],le=q[J];D[te]=le,Rs(le)}if(_===R.length-1&&y){const J=this.testLoop(u,l,r);for(let te=0;te<s.length;++te){const le=s[te],K=J[te];Rs(K),I["val_"+le]=K}}}),await w.onBatchEnd(_,D),bU(D),this.stopTraining_)break}T.dispose()}if(await w.onEpochEnd(k,I),this.stopTraining_)break}return await w.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,n){return oCe(this,e,n)}async trainOnBatch(e,n){const s=await this.standardizeUserData(e,n),r=s[0],o=s[1],a=this.makeTrainFunction()(r.concat(o)),u=[];for(const l of a){const c=await l.data();u.push(c[0])}return ot(a),Ei(s[0],e),Ei(s[1],n),Er(u)}getNamedWeights(e){const n=[],s=e!=null&&e.trainableOnly,r=s?this.trainableWeights:this.weights,o=this.getWeights(s);for(let i=0;i<r.length;++i)s&&!r[i].trainable||n.push({name:r[i].originalName,tensor:o[i]});return n}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const n=QI().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=n-QI().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Ja(this.loss);else if(Array.isArray(this.loss)){for(const n of this.loss)if(typeof n!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(n=>Ja(n))}else{const n=Object.keys(this.loss);e={};const s=this.loss;for(const r of n)if(typeof s[r]=="string")e[r]=Ja(s[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Ja(I1(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Ja(I1(e)));{const e={};for(const n in this.metrics)e[n]=Ja(I1(this.metrics[n]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const n=D$(e.optimizer_config),s=lu(n);let r;if(typeof e.loss=="string")r=Nc(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(i=>Nc(i));else if(e.loss!=null){r={};for(const i in e.loss)r[i]=Nc(e.loss[i])}let o;if(Array.isArray(e.metrics))o=e.metrics.map(i=>Nc(i));else if(e.metrics!=null){o={};for(const i in e.metrics)o[i]=Nc(e.metrics[i])}this.compile({loss:r,metrics:o,optimizer:s})}async save(e,n){if(typeof e=="string"){const l=Jz(e);if(l.length===0)throw new se(`Cannot find any save handlers for URL '${e}'`);if(l.length>1)throw new se(`Found more than one (${l.length}) save handlers for URL '${e}'`);e=l[0]}if(e.save==null)throw new se("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await ZI(this.getNamedWeights(n)),r=!1,o=null,a={modelTopology:this.toJSON(o,r),format:pCe,generatedBy:`TensorFlow.js tfjs-layers v${RU}`,convertedBy:null};if((n==null?!1:n.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const l="optimizer",{data:c,specs:h}=await ZI(await this.optimizer.getWeights(),l);s.specs.push(...h),s.data=Yz([s.data,c])}return this.userDefinedMetadata!=null&&(zP(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=s.data,a.weightSpecs=s.specs,e.save(a)}setUserDefinedMetadata(e){zP(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Xd.className="Model";$e(Xd);class FU extends Xd{}FU.className="Functional";$e(FU);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ny extends Xd{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:MS("sequential_"),e.layers!=null)for(const n of e.layers)this.add(n)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(s=>s<0))throw new se(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const n=e instanceof ny||e instanceof Xd;let s;if(n){if(s=e,s.outputs.length!==1)throw new se("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new se("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new se("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const r=mSe({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(r)}if(n)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new se(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new se("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=gU(this.outputs[0])}this.inboundNodes=[],new BS({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:ch(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(r=>r.shape),outputShapes:this.outputs[0].shape})}else{const r=e.apply(this.outputs[0]);if(Array.isArray(r))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[r],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,n){return this.model==null&&this.build(),this.model.call(e,n)}build(e){if(Xt(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Xd({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,n,s=console.log){this.built||this.build(),super.summary(e,n,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,n,s={}){if(!this.built)throw new ci("The model needs to be compiled before being used.");return this.model.evaluate(e,n,s)}async evaluateDataset(e,n){if(!this.built)throw new ci("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,n)}predict(e,n={}){return this.model==null&&this.build(),this.model.predict(e,n)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,n,s={}){if(!this.built)throw new ci("The model needs to be compiled before being used.");return this.model.fit(e,n,s)}async fitDataset(e,n){if(!this.built)throw new ci("The model needs to be compiled before being used.");return this.model.fitDataset(e,n)}async trainOnBatch(e,n){return this.model.trainOnBatch(e,n)}static fromConfig(e,n,s={},r=!1){let o,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new se("Legacy serialization format not supported yet.");o=n}else O(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=n.layers,delete n.layers,i=n;const a=new e(i);if(!(a instanceof ny))throw new Ct(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(const u of o){const c=lu(u,void 0,r);r&&c.setFastWeightInitDuringBuild(!0),a.add(c)}return a}set stopTraining(e){if(this.model==null)throw new se("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new se("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const n of this.layers){const s={};s.className=n.getClassName(),s.config=n.getConfig(),e.push(s)}return{name:this.name,layers:e}}}ny.className="Sequential";$e(ny);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Vr=class extends Rf{getConfig(){return{}}};class OU extends Vr{apply(e,n=1){return Jbe(e,n)}}OU.className="elu";$e(OU);class LU extends Vr{apply(e){return qT(e)}}LU.className="selu";$e(LU);class MU extends Vr{apply(e){return Ea(e)}}MU.className="relu";$e(MU);class zU extends Vr{apply(e){return ae(()=>kl(6,Ea(e)))}}zU.className="relu6";$e(zU);class BU extends Vr{apply(e){return e}}BU.className="linear";$e(BU);class VU extends Vr{apply(e){return Eo(e)}}VU.className="sigmoid";$e(VU);class WU extends Vr{apply(e){return tSe(e)}}WU.className="hardSigmoid";$e(WU);class UU extends Vr{apply(e){return Nf(e)}}UU.className="softplus";$e(UU);class GU extends Vr{apply(e){return eSe(e)}}GU.className="softsign";$e(GU);class HU extends Vr{apply(e){return lp(e)}}HU.className="tanh";$e(HU);let jE=class extends Vr{apply(e,n=-1){return nS(e,n)}};jE.className="softmax";$e(jE);class jU extends Vr{apply(e,n=-1){return DT(e,n)}}jU.className="logSoftmax";$e(jU);class KU extends Vr{apply(e,n=1){return ae(()=>Y(Eo(Y(e,n)),e))}}KU.className="swish";$e(KU);class XU extends Vr{apply(e){return ae(()=>Y(e,lp(Nf(e))))}}XU.className="mish";$e(XU);function Nl(t){return t.getClassName()}function bk(t,e={}){return T0(t,ri.getMap().classNameMap,e,"activation")}function Tl(t){if(t==null){const e={};return e.className="linear",e.config={},bk(e)}if(typeof t=="string"){const e={};return e.className=t,e.config={},bk(e)}else return t instanceof Vr?t:bk(t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function fCe(t){if(t!=null&&typeof t!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${t}`)}class qU extends Rf{}class YU extends qU{constructor(e){super(),fCe(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return ae(()=>{let n=Zn([1]);return this.hasL1&&(n=we(n,Qe(Y(this.l1,ps(e))))),this.hasL2&&(n=we(n,Qe(Y(this.l2,R0(e))))),ee(n,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,n){return new e({l1:n.l1,l2:n.l2})}}YU.className="L1L2";$e(YU);const HP={l1l2:"L1L2"};function gn(t){return _E(t)}function jP(t,e={}){return T0(t,ri.getMap().classNameMap,e,"regularizer")}function _n(t){if(t==null)return null;if(typeof t=="string"){const n={className:t in HP?HP[t]:t,config:{}};return jP(n)}else return t instanceof qU?t:jP(t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class QU extends At{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,n){e=gt(e);let s=Ea(e);return this.maxValue!=null&&(s=Or(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},n=super.getConfig();return Object.assign(e,n),e}}QU.className="ReLU";$e(QU);class ZU extends At{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,n){const s=gt(e);return Hb(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},n=super.getConfig();return Object.assign(e,n),e}}ZU.className="LeakyReLU";$e(ZU);class JU extends At{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Rn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=_n(e.alphaRegularizer),this.alphaConstraint=vs(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new se(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Xt(e);const n=e.slice(1);if(this.sharedAxes!=null)for(const r of this.sharedAxes)n[r-1]=1;this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)s[r]=e[r];this.inputSpec=[new gs({ndim:e.length,axes:s})],this.built=!0}call(e,n){return e=gt(e),Zb(e,this.alpha.read())}getConfig(){const e={alphaInitializer:On(this.alphaInitializer),alphaRegularizer:gn(this.alphaRegularizer),alphaConstraint:xs(this.alphaConstraint),sharedAxes:this.sharedAxes},n=super.getConfig();return Object.assign(e,n),e}}JU.className="PReLU";$e(JU);let eG=class extends At{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Ct(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,n){const s=gt(e);return w0(s)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},n=super.getConfig();return Object.assign(e,n),e}};eG.className="ELU";$e(eG);class tG extends At{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,n){const s=gt(e);return Y(s,De(mo(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},n=super.getConfig();return Object.assign(e,n),e}}tG.className="ThresholdedReLU";$e(tG);class nG extends At{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new jE().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,n){return ae(()=>{let s=gt(e);const r=n.mask;if(r!=null){const o=Y(Be(no(s.shape),De(r,s.dtype)),nt(-1e9));s=we(s,o)}return this.axis instanceof Array?this.axis.length>1?mr(Be(s,Kb(s,this.axis,!0))):this.softmax(s,this.axis[0]):this.softmax(s,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},n=super.getConfig();return Object.assign(e,n),e}}nG.className="Softmax";$e(nG);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function qd(t,e,n){if(typeof t=="number")return ch(t,e);if(t.length!==e)throw new se(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${t.length} elements.`);for(let s=0;s<e;++s){const r=t[s];if(!qbe(r))throw new se(`The ${n} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(t)} including a non-integer number ${r}`)}return t}function zi(t,e,n,s,r=1){if(t==null)return t;const o=e+(e-1)*(r-1);let i;return n==="same"?i=t:i=t-o+1,Math.floor((i+s-1)/s)}function da(t,e,n,s){if(t==null)return null;if(s==="valid")t=t*e+$l([n-e,0]);else if(s==="same")t=t*e;else throw new se(`Unsupport padding mode: ${s}.`);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function KE(t,e){return ae(()=>(ss(e),e==="channelsFirst"?Vt(t,[0,2,3,1]):t))}function sG(t,e){return ae(()=>(ss(e),e==="channelsFirst"?Vt(t,[0,2,3,4,1]):t))}function mCe(t,e,n,s=1,r="valid",o,i=1){return ae(()=>{if(o==null&&(o=Ki()),ss(o),t.shape.length!==3)throw new se(`The input of a conv1dWithBias operation should be 3, but is ${t.shape.length} instead.`);if(e.shape.length!==3)throw new se(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new se(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(o==="channelsFirst"&&(t=Vt(t,[0,2,1])),r==="causal")throw new Ct("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=$T(t,e,s,r==="same"?"same":"valid","NWC",i);return n!=null&&(a=Zi(a,n)),a})}function KP(t,e,n,s=[1,1],r="valid",o,i,a=null){return ae(()=>{if(o==null&&(o=Ki()),ss(o),t.rank!==3&&t.rank!==4)throw new se(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${t.rank}.`);if(e.rank!==3&&e.rank!==4)throw new se(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${t.rank}.`);let u=KE(t,o);if(r==="causal")throw new Ct("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=aV({x:u,filter:e,strides:s,pad:r==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:a}),o==="channelsFirst"&&(u=Vt(u,[0,3,1,2])),u})}function gCe(t,e,n,s=[1,1,1],r="valid",o,i){return ae(()=>{if(o==null&&(o=Ki()),ss(o),t.rank!==4&&t.rank!==5)throw new se(`conv3dWithBias expects input to be of rank 4 or 5, but received ${t.rank}.`);if(e.rank!==4&&e.rank!==5)throw new se(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${t.rank}.`);let a=sG(t,o);if(r==="causal")throw new Ct("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=$B(a,e,s,r==="same"?"same":"valid","NDHWC",i),n!=null&&(a=Zi(a,n)),o==="channelsFirst"&&(a=Vt(a,[0,4,1,2,3])),a})}class US extends At{constructor(e,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",US.verifyArgs(n),this.rank=e,As(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Ct(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=qd(n.kernelSize,e,"kernelSize"),this.strides=qd(n.strides==null?1:n.strides,e,"strides"),this.padding=n.padding==null?"valid":n.padding,zo(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,ss(this.dataFormat),this.activation=Tl(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=Rn(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=vs(n.biasConstraint),this.biasRegularizer=_n(n.biasRegularizer),this.activityRegularizer=_n(n.activityRegularizer),this.dilationRate=qd(n.dilationRate==null?1:n.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new se(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new se(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new se(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(ha("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!DE(e.kernelSize,"number",1,3))throw new se(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Nl(this.activation),useBias:this.useBias,biasInitializer:On(this.biasInitializer),biasRegularizer:gn(this.biasRegularizer),activityRegularizer:gn(this.activityRegularizer),biasConstraint:xs(this.biasConstraint)},n=super.getConfig();return Object.assign(e,n),e}}class Pf extends US{constructor(e,n){super(e,n),this.kernel=null,Pf.verifyArgs(n),this.filters=n.filters,As(this.filters,"filters"),this.kernelInitializer=Rn(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=vs(n.kernelConstraint),this.kernelRegularizer=_n(n.kernelRegularizer)}build(e){e=Xt(e);const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new se(`The channel dimension of the input should be defined. Found ${e[n]}`);const s=e[n],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:s}}],this.built=!0}call(e,n){return ae(()=>{e=gt(e);let s;const r=this.bias==null?null:this.bias.read(),o=tU(this.activation.getClassName());if(o!=null&&this.rank===2)s=KP(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(this.rank===1)s=mCe(e,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=KP(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=gCe(e,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Ct("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=Xt(e);const n=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let o=0;o<s.length;++o){const i=zi(s[o],this.kernelSize[o],this.padding,this.strides[o],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[o]);n.push(i)}let r=[e[0]];return this.dataFormat==="channelsLast"?(r=r.concat(n),r.push(this.filters)):(r.push(this.filters),r=r.concat(n)),r}getConfig(){const e={filters:this.filters,kernelInitializer:On(this.kernelInitializer),kernelRegularizer:gn(this.kernelRegularizer),kernelConstraint:xs(this.kernelConstraint)},n=super.getConfig();return Object.assign(e,n),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new se(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class P0 extends Pf{constructor(e){super(2,e),P0.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!DE(e.kernelSize,"number",1,2))throw new se(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}P0.className="Conv2D";$e(P0);class F0 extends Pf{constructor(e){super(3,e),F0.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new se(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}F0.className="Conv3D";$e(F0);class rG extends P0{constructor(e){if(super(e),this.inputSpec=[new gs({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new se(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Xt(e),e.length!==4)throw new se("Input should have rank 4; Received input shape: "+JSON.stringify(e));const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new se("The channel dimension of the inputs should be defined. Found `None`.");const s=e[n],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new gs({ndim:4,axes:{[n]:s}})],this.built=!0}call(e,n){return ae(()=>{let s=gt(e);if(s.shape.length!==4)throw new se(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,o=r[0];let i,a;this.dataFormat==="channelsFirst"?(i=2,a=3):(i=1,a=2);const u=r[i],l=r[a],c=this.kernelSize[0],h=this.kernelSize[1],d=this.strides[0],f=this.strides[1],m=da(u,d,c,this.padding),y=da(l,f,h,this.padding),x=[o,m,y,this.filters];this.dataFormat!=="channelsLast"&&(s=Vt(s,[0,2,3,1]));let v=TT(s,this.kernel.read(),x,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(v=Vt(v,[0,3,1,2])),this.bias!=null&&(v=Zi(v,this.bias.read(),this.dataFormat)),this.activation!=null&&(v=this.activation.apply(v)),v})}computeOutputShape(e){e=Xt(e);const n=e.slice();let s,r,o;this.dataFormat==="channelsFirst"?(s=1,r=2,o=3):(s=3,r=1,o=2);const i=this.kernelSize[0],a=this.kernelSize[1],u=this.strides[0],l=this.strides[1];return n[s]=this.filters,n[r]=da(n[r],u,i,this.padding),n[o]=da(n[o],l,a,this.padding),n}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}rG.className="Conv2DTranspose";$e(rG);class oG extends F0{constructor(e){if(super(e),this.inputSpec=[new gs({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new se(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Xt(e),e.length!==5)throw new se("Input should have rank 5; Received input shape: "+JSON.stringify(e));const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new se("The channel dimension of the inputs should be defined. Found `None`.");const s=e[n],r=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new gs({ndim:5,axes:{[n]:s}})],this.built=!0}call(e,n){return ae(()=>{let s=gt(e);if(s.shape.length!==5)throw new se(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const r=s.shape,o=r[0];let i,a,u;this.dataFormat==="channelsFirst"?(u=2,i=3,a=4):(u=1,i=2,a=3);const l=r[u],c=r[i],h=r[a],d=this.kernelSize[0],f=this.kernelSize[1],m=this.kernelSize[2],y=this.strides[0],x=this.strides[1],v=this.strides[2],w=da(l,y,d,this.padding),S=da(c,x,f,this.padding),k=da(h,v,m,this.padding),I=[o,w,S,k,this.filters];this.dataFormat!=="channelsLast"&&(s=Vt(s,[0,2,3,4,1]));let T=TB(s,this.kernel.read(),I,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(T=Vt(T,[0,4,1,2,3])),this.bias!==null&&(T=Zi(T,this.bias.read(),this.dataFormat)),this.activation!==null&&(T=this.activation.apply(T)),T})}computeOutputShape(e){e=Xt(e);const n=e.slice();let s,r,o,i;this.dataFormat==="channelsFirst"?(s=1,r=2,o=3,i=4):(s=4,r=1,o=2,i=3);const a=this.kernelSize[0],u=this.kernelSize[1],l=this.kernelSize[2],c=this.strides[0],h=this.strides[1],d=this.strides[2];return n[s]=this.filters,n[r]=da(n[r],c,a,this.padding),n[o]=da(n[o],h,u,this.padding),n[i]=da(n[i],d,l,this.padding),n}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}oG.className="Conv3DTranspose";$e(oG);class iG extends Pf{constructor(e,n){if(super(e,n),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,n.filters==null)throw new se("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(n.kernelInitializer!=null||n.kernelRegularizer!=null||n.kernelConstraint!=null)throw new se("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(n.padding!=null&&n.padding!=="same"&&n.padding!=="valid")throw new se(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(n.padding)}`);this.depthMultiplier=n.depthMultiplier==null?1:n.depthMultiplier,this.depthwiseInitializer=Rn(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=_n(n.depthwiseRegularizer),this.depthwiseConstraint=vs(n.depthwiseConstraint),this.pointwiseInitializer=Rn(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=_n(n.pointwiseRegularizer),this.pointwiseConstraint=vs(n.pointwiseConstraint)}build(e){if(e=Xt(e),e.length<this.rank+2)throw new se(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null||e[n]<0)throw new se(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[n])}`);const s=e[n],r=this.kernelSize.concat([s,this.depthMultiplier]),o=[];for(let a=0;a<this.rank;++a)o.push(1);o.push(s*this.depthMultiplier,this.filters);const i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new gs({ndim:this.rank+2,axes:{[n]:s}})],this.built=!0}call(e,n){return ae(()=>{e=gt(e);let s;if(this.rank===1)throw new Ct("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Vt(e,[0,2,3,1])),s=YT(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Zi(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=Vt(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=On(this.depthwiseInitializer),e.pointwiseInitializer=On(this.pointwiseInitializer),e.depthwiseRegularizer=gn(this.depthwiseRegularizer),e.pointwiseRegularizer=gn(this.pointwiseRegularizer),e.depthwiseConstraint=xs(this.depthwiseConstraint),e.pointwiseConstraint=xs(this.pointwiseConstraint),e}}iG.className="SeparableConv";class aG extends iG{constructor(e){super(2,e)}}aG.className="SeparableConv2D";$e(aG);class GS extends Pf{constructor(e){super(1,e),GS.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!DE(e.kernelSize,"number",1,1))throw new se(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}GS.className="Conv1D";$e(GS);class uG extends At{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,n){return ae(()=>{if(e=gt(e),this.dataFormat==="channelsLast"){const s=k1(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return k1(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=k1(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return k1(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}uG.className="Cropping2D";$e(uG);class lG extends At{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ss(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,jbe(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const n=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],n,s]}else{const n=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],n,s,e[3]]}}call(e,n){return ae(()=>{let s=gt(e);const r=s.shape;if(this.dataFormat==="channelsFirst"){s=Vt(s,[0,2,3,1]);const o=this.size[0]*r[2],i=this.size[1]*r[3],a=this.interpolation==="nearest"?Xs.resizeNearestNeighbor(s,[o,i]):Xs.resizeBilinear(s,[o,i]);return Vt(a,[0,3,1,2])}else{const o=this.size[0]*r[1],i=this.size[1]*r[2];return this.interpolation==="nearest"?Xs.resizeNearestNeighbor(s,[o,i]):Xs.resizeBilinear(s,[o,i])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},n=super.getConfig();return Object.assign(e,n),e}}lG.className="UpSampling2D";$e(lG);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function yCe(t,e,n=[1,1],s="valid",r,o){return ae(()=>{r==null&&(r=Ki()),ss(r);let i=KE(t,r);if(t.rank!==4)throw new se(`Input for depthwiseConv2d is required to be 4-D, but is instead ${t.rank}-D`);if(e.rank!==4)throw new se(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return i=v0(i,e,n,s==="same"?"same":"valid","NHWC",o),r==="channelsFirst"&&(i=Vt(i,[0,3,1,2])),i})}class cG extends US{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Rn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=vs(e.depthwiseConstraint),this.depthwiseRegularizer=_n(e.depthwiseRegularizer)}build(e){if(e=Xt(e),e.length<4)throw new se(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const n=this.dataFormat==="channelsFirst"?1:3;if(e[n]==null||e[n]<0)throw new se(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[n]}).`);const s=e[n],r=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return ae(()=>{e=gt(e);let s=yCe(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Zi(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=Xt(e);const n=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,o=zi(n,this.kernelSize[0],this.padding,this.strides[0]),i=zi(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,o,i]:[e[0],o,i,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=On(this.depthwiseInitializer),e.depthwiseRegularizer=gn(this.depthwiseRegularizer),e.depthwiseConstraint=xs(this.depthwiseRegularizer),e}}cG.className="DepthwiseConv2D";$e(cG);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function hG(t,e,n,s){if(Array.isArray(t)){if(e!=null||n!=null)throw new se("When inputs is an array, neither initialState or constants should be provided");s!=null&&(n=t.slice(t.length-s,t.length),t=t.slice(0,t.length-s)),t.length>1&&(e=t.slice(1,t.length)),t=t[0]}function r(o){return o==null||Array.isArray(o)?o:[o]}return e=r(e),n=r(n),{inputs:t,initialState:e,constants:n}}function dG(t,e,n,s=!1,r,o,i=!1,a=!1){return ae(()=>{const u=e.shape.length;if(u<3)throw new se(`Input should be at least 3D, but is ${u}D.`);const l=[1,0].concat(ji(2,u));if(e=Vt(e,l),o!=null)throw new Ct("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),r!=null&&(r=De(De(r,"bool"),"float32"),r.rank===u-1&&(r=us(r,-1)),r=Vt(r,l)),s&&(e=vi(e,0),r!=null&&(r=vi(r,0)));const c=[];let h,d=n;const f=e.shape[0],m=wi(e);let y;r!=null&&(y=wi(r));for(let v=0;v<f;++v){const w=m[v],S=ae(()=>t(w,d));if(r==null)h=S[0],d=S[1];else{const k=ae(()=>{const I=y[v],T=Be(_o(I),I),R=we(Y(S[0],I),Y(d[0],T)),_=d.map((D,L)=>we(Y(S[1][L],I),Y(D,T)));return{output:R,newStates:_}});h=k.output,d=k.newStates}a&&c.push(h)}let x;return a&&(x=ao(c,1)),[h,x,d]})}class Gl extends At{constructor(e){super(e);let n;if(e.cell==null)throw new se("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?n=new YE({cells:e.cell}):n=e.cell,n.stateSize==null)throw new se("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new gs({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return ji(0,e).map(n=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){R$(e)&&(e=e[0]),e=e;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);const s=n[0];let r;if(this.returnSequences?r=[e[0],e[1],s]:r=[e[0],s],this.returnState){const o=[];for(const i of n)o.push([e[0],i]);return[r].concat(o)}else return r}computeMask(e,n){return ae(()=>{Array.isArray(n)&&(n=n[0]);const s=this.returnSequences?n:null;if(this.returnState){const r=this.states.map(o=>null);return[s].concat(r)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let s=0;s<e;++s)n.push(null);return n}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Ct("Constants support is not implemented in RNN yet.");R$(e)&&(e=e[0]),e=e;const n=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new gs({shape:[n,null,...s]});const r=[e[0]].concat(e.slice(2));this.cell.build(r);let o;if(Array.isArray(this.cell.stateSize)?o=this.cell.stateSize:o=[this.cell.stateSize],this.stateSpec!=null){if(!kt(this.stateSpec.map(i=>i.shape[i.shape.length-1]),o))throw new se(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=o.map(i=>new gs({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(e,n=!1){ae(()=>{if(!this.stateful)throw new ca("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new se("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Zn([s,r])):this.states_=[Zn([s,this.cell.stateSize])];else if(e==null)ot(this.states_),this.keptStates!=null&&(ot(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(r=>Zn([s,r])):this.states_[0]=Zn([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new se(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);n===!0?this.keptStates.push(this.states_.slice()):ot(this.states_);for(let r=0;r<this.states_.length;++r){const o=e[r],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[r]:this.cell.stateSize,a=[s,i];if(!kt(o.shape,a))throw new se(`State ${r} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${o.shape}`);this.states_[r]=o}}this.states_=this.states_.map(r=>Rs(r.clone()))})}apply(e,n){let s=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});const o=hG(e,s,r,this.numConstants);e=o.inputs,s=o.initialState,r=o.constants;let i=[],a=[];if(s!=null){n.initialState=s,i=i.concat(s),this.stateSpec=[];for(const l of s)this.stateSpec.push(new gs({shape:l.shape}));a=a.concat(this.stateSpec)}if(r!=null&&(n.constants=r,i=i.concat(r),this.numConstants=r.length),i[0]instanceof Na){const l=[e].concat(i),c=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=c;const d=super.apply(l,n);return this.inputSpec=h,d}else return super.apply(e,n)}call(e,n){return ae(()=>{const s=n==null?null:n.mask,r=n==null?null:n.training;let o=n==null?null:n.initialState;e=gt(e),o==null&&(this.stateful?o=this.states_:o=this.getInitialState(e));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==i)throw new se(`RNN Layer has ${i} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:r},l=dG((m,y)=>{const x=this.cell.call([m].concat(y),a);return[x[0],x.slice(1)]},e,o,this.goBackwards,s,null,this.unroll,this.returnSequences),c=l[0],h=l[1],d=l[2];this.stateful&&this.resetStates(d,r);const f=this.returnSequences?h:c;return this.returnState?[f].concat(d):f})}getInitialState(e){return ae(()=>{let n=Zn(e.shape);return n=Qe(n,[1,2]),n=E0(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?T$(n,[1,s]):n):this.cell.stateSize>1?[T$(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===Gl.className&&(n.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),n)}static fromConfig(e,n,s={}){const r=n.cell,o=lu(r,s);return new e(Object.assign(n,{cell:o}))}}Gl.className="RNN";$e(Gl);class HS extends At{}class XE extends HS{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,As(this.units,"units"),this.activation=Tl(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Rn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Rn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Rn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=_n(e.kernelRegularizer),this.recurrentRegularizer=_n(e.recurrentRegularizer),this.biasRegularizer=_n(e.biasRegularizer),this.kernelConstraint=vs(e.kernelConstraint),this.recurrentConstraint=vs(e.recurrentConstraint),this.biasConstraint=vs(e.biasConstraint),this.dropout=gp([1,$l([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=gp([1,$l([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Xt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return ae(()=>{if(e=e,e.length!==2)throw new se(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const r=n.training==null?!1:n.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=El({ones:()=>_o(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=El({ones:()=>_o(s),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let o;const i=this.dropoutMask,a=this.recurrentDropoutMask;i!=null?o=ba(Y(e,i),this.kernel.read()):o=ba(e,this.kernel.read()),this.bias!=null&&(o=Zi(o,this.bias.read())),a!=null&&(s=Y(s,a));let u=we(o,ba(s,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:Nl(this.activation),useBias:this.useBias,kernelInitializer:On(this.kernelInitializer),recurrentInitializer:On(this.recurrentInitializer),biasInitializer:On(this.biasInitializer),kernelRegularizer:gn(this.kernelRegularizer),recurrentRegularizer:gn(this.recurrentRegularizer),biasRegularizer:gn(this.biasRegularizer),activityRegularizer:gn(this.activityRegularizer),kernelConstraint:xs(this.kernelConstraint),recurrentConstraint:xs(this.recurrentConstraint),biasConstraint:xs(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),n)}}XE.className="SimpleRNNCell";$e(XE);class pG extends Gl{constructor(e){e.cell=new XE(e),super(e)}call(e,n){return ae(()=>{this.cell.dropoutMask!=null&&(ot(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ot(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=n==null?null:n.mask,r=n==null?null:n.training,o=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}static fromConfig(e,n){return new e(n)}}pG.className="SimpleRNN";$e(pG);class qE extends HS{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new se("GRUCell does not support reset_after parameter set to true.");this.units=e.units,As(this.units,"units"),this.activation=Tl(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Tl(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Rn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Rn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Rn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=_n(e.kernelRegularizer),this.recurrentRegularizer=_n(e.recurrentRegularizer),this.biasRegularizer=_n(e.biasRegularizer),this.kernelConstraint=vs(e.kernelConstraint),this.recurrentConstraint=vs(e.recurrentConstraint),this.biasConstraint=vs(e.biasConstraint),this.dropout=gp([1,$l([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=gp([1,$l([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Xt(e);const n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return ae(()=>{if(e=e,e.length!==2)throw new se(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=n.training==null?!1:n.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=El({ones:()=>_o(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=El({ones:()=>_o(r),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,i=this.recurrentDropoutMask;let a,u,l;0<this.dropout&&this.dropout<1&&(e=Y(e,o[0]));let c=ba(e,this.kernel.read());this.useBias&&(c=Zi(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Y(r,i[0]));const h=this.recurrentKernel.read(),[d,f]=io(h,[2*this.units,this.units],h.rank-1),m=ba(r,d),[y,x,v]=io(c,3,c.rank-1),[w,S]=io(m,2,m.rank-1);a=this.recurrentActivation.apply(we(y,w)),u=this.recurrentActivation.apply(we(x,S));const k=ba(Y(u,r),f);l=this.activation.apply(we(v,k));const I=we(Y(a,r),Y(we(1,$n(a)),l));return[I,I]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:Nl(this.activation),recurrentActivation:Nl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:On(this.kernelInitializer),recurrentInitializer:On(this.recurrentInitializer),biasInitializer:On(this.biasInitializer),kernelRegularizer:gn(this.kernelRegularizer),recurrentRegularizer:gn(this.recurrentRegularizer),biasRegularizer:gn(this.biasRegularizer),activityRegularizer:gn(this.activityRegularizer),kernelConstraint:xs(this.kernelConstraint),recurrentConstraint:xs(this.recurrentConstraint),biasConstraint:xs(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),n)}}qE.className="GRUCell";$e(qE);class fG extends Gl{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new qE(e),super(e)}call(e,n){return ae(()=>{this.cell.dropoutMask!=null&&(ot(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ot(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=n==null?null:n.mask,r=n==null?null:n.training,o=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}static fromConfig(e,n){return n.implmentation===0&&(n.implementation=1),new e(n)}}fG.className="GRU";$e(fG);class jS extends HS{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,As(this.units,"units"),this.activation=Tl(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Tl(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Rn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Rn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Rn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=_n(e.kernelRegularizer),this.recurrentRegularizer=_n(e.recurrentRegularizer),this.biasRegularizer=_n(e.biasRegularizer),this.kernelConstraint=vs(e.kernelConstraint),this.recurrentConstraint=vs(e.recurrentConstraint),this.biasConstraint=vs(e.biasConstraint),this.dropout=gp([1,$l([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=gp([1,$l([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var n;e=Xt(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){const o=this.biasInitializer,i=this.units;r=new(n=class extends bi{apply(u,l){const c=o.apply([i]),h=new FE().apply([i]),d=o.apply([i*2]);return RP(RP(c,h),d)}},n.className="CustomInit",n)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,n){return ae(()=>{const s=n.training==null?!1:n.training;if(e=e,e.length!==3)throw new se(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const o=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=El({ones:()=>_o(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=El({ones:()=>_o(r),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,a=this.recurrentDropoutMask;let u,l,c,h;0<this.dropout&&this.dropout<1&&(e=Y(e,i[0]));let d=ba(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Y(r,a[0])),d=we(d,ba(r,this.recurrentKernel.read())),this.useBias&&(d=Zi(d,this.bias.read()));const[f,m,y,x]=io(d,4,d.rank-1);u=this.recurrentActivation.apply(f),l=this.recurrentActivation.apply(m),c=we(Y(l,o),Y(u,this.activation.apply(y))),h=this.recurrentActivation.apply(x);const v=Y(h,this.activation.apply(c));return[v,v,c]})}getConfig(){const e=super.getConfig(),n={units:this.units,activation:Nl(this.activation),recurrentActivation:Nl(this.recurrentActivation),useBias:this.useBias,kernelInitializer:On(this.kernelInitializer),recurrentInitializer:On(this.recurrentInitializer),biasInitializer:On(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:gn(this.kernelRegularizer),recurrentRegularizer:gn(this.recurrentRegularizer),biasRegularizer:gn(this.biasRegularizer),activityRegularizer:gn(this.activityRegularizer),kernelConstraint:xs(this.kernelConstraint),recurrentConstraint:xs(this.recurrentConstraint),biasConstraint:xs(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),n)}}jS.className="LSTMCell";$e(jS);class mG extends Gl{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new jS(e),super(e)}call(e,n){return ae(()=>{this.cell.dropoutMask!=null&&(ot(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ot(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=n==null?null:n.mask,r=n==null?null:n.training,o=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}static fromConfig(e,n){return n.implmentation===0&&(n.implementation=1),new e(n)}}mG.className="LSTM";$e(mG);class YE extends HS{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const n of this.cells.slice().reverse())Array.isArray(n.stateSize)?e.push(...n.stateSize):e.push(n.stateSize);return e}call(e,n){return ae(()=>{e=e;let s=e.slice(1);const r=[];for(const a of this.cells.slice().reverse())Array.isArray(a.stateSize)?r.push(s.splice(0,a.stateSize.length)):r.push(s.splice(0,1));r.reverse();const o=[];let i;for(let a=0;a<this.cells.length;++a){const u=this.cells[a];s=r[a],a===0?i=[e[0]].concat(s):i=[i[0]].concat(s),i=u.call(i,n),o.push(i.slice(1))}s=[];for(const a of o.slice().reverse())s.push(...a);return[i[0]].concat(s)})}build(e){R$(e)&&(e=e[0]),e=e;let n;this.cells.forEach((s,r)=>{Hc(`RNNCell_${r}`,()=>{s.build(e),Array.isArray(s.stateSize)?n=s.stateSize[0]:n=s.stateSize,e=[e[0],n]})}),this.built=!0}getConfig(){const e=super.getConfig(),n=o=>({className:o.getClassName(),config:o.getConfig()}),r={cells:this.cells.map(n)};return Object.assign(Object.assign({},e),r)}static fromConfig(e,n,s={}){const r=[];for(const o of n.cells)r.push(lu(o,s));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const n of this.cells)e.push(...n.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const n of this.cells)e.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const s of this.cells)n.push(...s.trainableWeights);return n.concat(e)}return e}getWeights(){const e=[];for(const n of this.cells)e.push(...n.weights);return A$(e)}setWeights(e){const n=[];for(const s of this.cells){const r=s.weights.length,o=e.splice(r);for(let i=0;i<s.weights.length;++i)n.push([s.weights[i],o[i]])}WE(n)}}YE.className="StackedRNNCells";$e(YE);function El(t){const{ones:e,rate:n,training:s=!1,count:r=1,dropoutFunc:o}=t,i=()=>o!=null?o(e(),n):uU(e(),n),a=()=>A0(i,e,s);return!r||r<=1?Rs(a().clone()):Array(r).fill(void 0).map(a).map(l=>Rs(l.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var xCe=function(t,e){var n={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&e.indexOf(s)<0&&(n[s]=t[s]);if(t!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,s=Object.getOwnPropertySymbols(t);r<s.length;r++)e.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(t,s[r])&&(n[s[r]]=t[s[r]]);return n};class gG extends Gl{constructor(e){if(e.unroll)throw new Ct("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Ct("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new gs({ndim:5})]}call(e,n){return ae(()=>{if(this.cell.dropoutMask!=null&&(ot(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(ot(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),n&&n.constants)throw new se("ConvRNN2D cell does not support constants");const s=n==null?null:n.mask,r=n==null?null:n.training,o=n==null?null:n.initialState;return super.call(e,{mask:s,training:r,initialState:o})})}computeOutputShape(e){let n=this.computeSingleOutputShape(e);return this.returnSequences||(n=[n[0],...n.slice(2)]),this.returnState&&(n=[n,...Array(2).fill([e[0],...n.slice(-3)])]),n}getInitialState(e){return ae(()=>{const{stateSize:n}=this.cell,s=e.shape,r=this.computeSingleOutputShape(s),o=[r[0],...r.slice(2)],i=Zn(o);return Array.isArray(n)?Array(n.length).fill(i):[i]})}resetStates(e,n=!1){ae(()=>{if(!this.stateful)throw new ca("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,r=this.computeSingleOutputShape(s),o=[r[0],...r.slice(2)];if(s[0]==null)throw new se("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Zn(o)):this.states_=[Zn(o)];else if(e==null)ot(this.states_),this.keptStates!=null&&(ot(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Zn(o)):this.states_[0]=Zn(o);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new se(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);n?this.keptStates.push(this.states_.slice()):ot(this.states_);for(let a=0;a<this.states_.length;++a){const u=e[a],l=o;if(!kt(u.shape,l))throw new se(`State ${a} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${u.shape}`);this.states_[a]=u}}this.states_=this.states_.map(a=>Rs(a.clone()))})}computeSingleOutputShape(e){const{dataFormat:n,filters:s,kernelSize:r,padding:o,strides:i,dilationRate:a}=this.cell,u=n==="channelsFirst",l=e[u?3:2],c=e[u?4:3],h=zi(l,r[0],o,i[0],a[0]),d=zi(c,r[1],o,i[1],a[1]);return[...e.slice(0,2),...u?[s,h,d]:[h,d,s]]}}gG.className="ConvRNN2D";class QE extends jS{constructor(e){const{filters:n,kernelSize:s,strides:r,padding:o,dataFormat:i,dilationRate:a}=e;super(Object.assign(Object.assign({},e),{units:n})),this.filters=n,As(this.filters,"filters"),this.kernelSize=qd(s,2,"kernelSize"),this.kernelSize.forEach(u=>As(u,"kernelSize")),this.strides=qd(r||1,2,"strides"),this.strides.forEach(u=>As(u,"strides")),this.padding=o||"valid",zo(this.padding),this.dataFormat=i||"channelsLast",ss(this.dataFormat),this.dilationRate=qd(a||1,2,"dilationRate"),this.dilationRate.forEach(u=>As(u,"dilationRate"))}build(e){var n;e=Xt(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new se(`The channel dimension of the input should be defined. Found ${e[s]}`);const r=e[s],o=4,i=this.kernelSize.concat([r,this.filters*o]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,this.filters*o]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const l=this.biasInitializer,c=this.filters;u=new(n=class extends bi{apply(d,f){const m=l.apply([c]),y=no([c]),x=l.apply([c*2]);return PE([m,y,x])}},n.className="CustomInit",n)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*o],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,n){return ae(()=>{if(e.length!==3)throw new se(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=n.training||!1,r=e[0],o=e[1],i=e[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=El({ones:()=>_o(r),rate:this.dropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,l=(pe,he,xe)=>!he||!he[xe]?pe:Y(he[xe],pe);let c=l(r,u,0),h=l(r,u,1),d=l(r,u,2),f=l(r,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=El({ones:()=>_o(o),rate:this.recurrentDropout,training:s,count:a,dropoutFunc:this.dropoutFunc}));const m=this.recurrentDropoutMask;let y=l(o,m,0),x=l(o,m,1),v=l(o,m,2),w=l(o,m,3);const S=3,[k,I,T,R]=io(this.kernel.read(),a,S),[_,D,L,V]=this.useBias?io(this.bias.read(),a):[null,null,null,null];c=this.inputConv(c,k,_,this.padding),h=this.inputConv(h,I,D,this.padding),d=this.inputConv(d,T,L,this.padding),f=this.inputConv(f,R,V,this.padding);const[U,j,q,J]=io(this.recurrentKernel.read(),a,S);y=this.recurrentConv(y,U),x=this.recurrentConv(x,j),v=this.recurrentConv(v,q),w=this.recurrentConv(w,J);const te=this.recurrentActivation.apply(we(c,y)),le=this.recurrentActivation.apply(we(h,x)),K=we(Y(le,i),Y(te,this.activation.apply(we(d,v)))),re=Y(this.recurrentActivation.apply(we(f,w)),this.activation.apply(K));return[re,re,K]})}getConfig(){const e=super.getConfig(),n=xCe(e,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),s)}inputConv(e,n,s,r){const o=bl(e,n,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Zi(o,s,this.dataFormat):o}recurrentConv(e,n){return bl(e,n,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}QE.className="ConvLSTM2DCell";$e(QE);class yG extends gG{constructor(e){const n=new QE(e);super(Object.assign(Object.assign({},e),{cell:n}))}static fromConfig(e,n){return new e(n)}}yG.className="ConvLSTM2D";$e(yG);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ZE extends At{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const n=e.shape,s=[];for(let r=0;r<this.noiseShape.length;++r)s.push(this.noiseShape[r]==null?n[r]:this.noiseShape[r]);return s}call(e,n){return ae(()=>{this.invokeCallHook(e,n);const s=gt(e);if(0<this.rate&&this.rate<1){const r=n.training==null?!1:n.training,o=this.getNoiseShape(s);return A0(()=>uU(s,this.rate,o,this.seed),()=>s,r)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=super.getConfig();return Object.assign(e,n),e}dispose(){return super.dispose()}}ZE.className="Dropout";$e(ZE);class xG extends ZE{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const n=e.shape;return[n[0],1,n[2]]}}xG.className="SpatialDropout1D";$e(xG);class vG extends At{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let n=null;e.batchSize!=null&&(n=e.batchSize),this.batchInputShape=[n,e.inputDim]}this.units=e.units,As(this.units,"units"),this.activation=Tl(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=Rn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Rn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=vs(e.kernelConstraint),this.biasConstraint=vs(e.biasConstraint),this.kernelRegularizer=_n(e.kernelRegularizer),this.biasRegularizer=_n(e.biasRegularizer),this.activityRegularizer=_n(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Xt(e);const n=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:n}}],this.built=!0}computeOutputShape(e){e=Xt(e);const n=e.slice();return n[n.length-1]=this.units,n}call(e,n){return ae(()=>{this.invokeCallHook(e,n);const s=gt(e),r=tU(this.activation.getClassName());let o;return r!=null?o=ba(s,this.kernel.read(),r,this.bias?this.bias.read():null):(o=ba(s,this.kernel.read()),this.bias!=null&&(o=Zi(o,this.bias.read())),this.activation!=null&&(o=this.activation.apply(o))),o})}getConfig(){const e={units:this.units,activation:Nl(this.activation),useBias:this.useBias,kernelInitializer:On(this.kernelInitializer),biasInitializer:On(this.biasInitializer),kernelRegularizer:gn(this.kernelRegularizer),biasRegularizer:gn(this.biasRegularizer),activityRegularizer:gn(this.activityRegularizer),kernelConstraint:xs(this.kernelConstraint),biasConstraint:xs(this.biasConstraint)},n=super.getConfig();return Object.assign(e,n),e}}vG.className="Dense";$e(vG);class wG extends At{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Xt(e);for(const n of e.slice(1))if(n==null)throw new se(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],pl(e,1)]}call(e,n){return ae(()=>{this.invokeCallHook(e,n);let s=gt(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const r=[0];for(let o=2;o<s.rank;++o)r.push(o);r.push(1),s=Vt(s,r)}return Zbe(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const n=super.getConfig();return Object.assign(e,n),e}}wG.className="Flatten";$e(wG);class bG extends At{constructor(e){super(e),this.supportsMasking=!0,this.activation=Tl(e.activation)}call(e,n){return ae(()=>{this.invokeCallHook(e,n);const s=gt(e);return this.activation.apply(s)})}getConfig(){const e={activation:Nl(this.activation)},n=super.getConfig();return Object.assign(e,n),e}}bG.className="Activation";$e(bG);class SG extends At{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,n){return ae(()=>(e=gt(e),Ybe(e,this.n)))}getConfig(){const e={n:this.n},n=super.getConfig();return Object.assign(e,n),e}}SG.className="RepeatVector";$e(SG);class CG extends At{constructor(e){super(e),this.targetShape=e.targetShape;for(let n=0;n<this.targetShape.length;++n)this.isUnknown(this.targetShape[n])&&(this.targetShape[n]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,n){const s="Total size of new array must be unchanged.",r=n.slice();let o=1,i=null;for(let u=0;u<r.length;++u){const l=r[u];if(this.isUnknown(l))if(i===null)i=u;else throw new se("Can only specifiy one unknown dimension.");else o*=l}const a=pl(e);if(i!==null){if(o===0||a%o!==0)throw new se(s);r[i]=a/o}else if(a!==o)throw new se(s);return r}computeOutputShape(e){let n=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){n=!0;break}return n?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,n){return ae(()=>{this.invokeCallHook(e,n);const s=gt(e),r=s.shape,o=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return ee(s,o)})}getConfig(){const e={targetShape:this.targetShape},n=super.getConfig();return Object.assign(e,n),e}}CG.className="Reshape";$e(CG);class kG extends At{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const n=ji(1,e.dims.length+1);if(!kt(e.dims.slice().sort(),n))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new gs({ndim:this.dims.length+1})]}computeOutputShape(e){e=Xt(e);const n=e.slice();return this.dims.forEach((s,r)=>{n[r+1]=e[s]}),n}call(e,n){return Vt(gt(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},n=super.getConfig();return Object.assign(e,n),e}}kG.className="Permute";$e(kG);class IG extends At{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={maskValue:this.maskValue};return Object.assign(n,e),n}computeMask(e,n){const s=gt(e),r=-1;return Bv(cp(s,this.maskValue),r)}call(e,n){return ae(()=>{this.invokeCallHook(e,n);const s=gt(e),r=-1,o=!0,i=Bv(cp(s,this.maskValue),r,o);return Y(s,De(i,s.dtype))})}}IG.className="Masking";$e(IG);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class $G extends At{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let n=null;e.batchSize!=null&&(n=e.batchSize),e.inputLength==null?this.batchInputShape=[n,null]:this.batchInputShape=[n].concat(nn(e.inputLength))}this.inputDim=e.inputDim,As(this.inputDim,"inputDim"),this.outputDim=e.outputDim,As(this.outputDim,"outputDim"),this.embeddingsInitializer=Rn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=_n(e.embeddingsRegularizer),this.activityRegularizer=_n(e.activityRegularizer),this.embeddingsConstraint=vs(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,n){return ae(()=>this.maskZero?(e=gt(e),cp(e,Wt(e))):null)}computeOutputShape(e){if(e=Xt(e),this.inputLength==null)return[...e,this.outputDim];const n=nn(this.inputLength);if(n.length!==e.length-1)throw new se(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let r=0;r<n.length;++r){const o=n[r],i=e[r+1];if(o!=null&&i!=null&&o!==i)throw new se(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);o==null&&(n[s]=i),s++}}return[e[0],...n,this.outputDim]}call(e,n){return ae(()=>{this.invokeCallHook(e,n);let s=gt(e);s.dtype!=="int32"&&(s=wa(s,"int32"));const r=aU(this.embeddings.read(),ee(s,[s.size]));return ee(r,Xt(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:On(this.embeddingsInitializer),embeddingsRegularizer:gn(this.embeddingsRegularizer),activityRegularizer:gn(this.activityRegularizer),embeddingsConstraint:xs(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=super.getConfig();return Object.assign(e,n),e}}$G.className="Embedding";$e($G);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Eh extends At{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Ct}computeElementwiseOpOutputShape(e,n){if(e==null||n==null)return null;if(e.length<n.length)return this.computeElementwiseOpOutputShape(n,e);if(n.length===0)return e;const s=e.slice(0,e.length-n.length);for(let r=0;r<n.length;++r){const o=e[e.length-n.length+r],i=n[r];if(o==null||i==null||o<0||i<0)s.push(null);else if(o===1)s.push(i);else if(i===1)s.push(o);else{if(o!==i)throw new se("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(n));s.push(o)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Xt(e)]),e=e,e.length<2)throw new se(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let n=[];for(const o of e)o!=null&&o[0]!==null&&n.push(o[0]);if(n=dl(n),n.length>1)throw new se(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let o=1;o<e.length;++o){const i=e[o]==null?null:e[o].slice(1);s=this.computeElementwiseOpOutputShape(s,i)}const r=e.map(o=>o.length);e.indexOf(null)===-1&&dl(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,n){return ae(()=>{if(e=e,this.reshapeRequired){const s=[],r=e.map(o=>o.rank);if(r.indexOf(null)===-1){const o=$l(r);for(let i of e){const a=i.rank;for(let u=0;u<o-a;++u)i=E0(i,1);s.push(i)}return this.mergeFunction(s)}else{let o=!1;for(const u of e){const l=u.rank;if(l==null){const c=u.shape,h=c[0],d=c.slice(1).concat([h]);let f=ee(u,[h].concat(pl(c.slice(1))));f=Vt(f,[1,0]),f=ee(f,d),s.push(f),o=!0}else if(l>1){const c=ji(1,l).concat([0]);s.push(Vt(u,c)),o=!0}else s.push(u)}let i=this.mergeFunction(s);const a=i.rank;if(o){if(a==null){const u=i.shape,l=u.length,c=u[l-1],h=[c].concat(u.slice(0,u.length-1));i=ee(Vt(ee(i,[-1,c]),[1,0]),h)}else if(a>1){const u=[a-1].concat(ji(0,a-1));i=Vt(i,u)}}return i}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let n;e[0]==null?n=null:n=e[0].slice(1);for(let r=1;r<e.length;++r){const o=e[r]==null?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,o)}let s=[];for(const r of e)r!=null&&r[0]!==null&&s.push(r[0]);return s=dl(s),s.length===1?n=s.concat(n):n=[null].concat(n),n}computeMask(e,n){return ae(()=>{if(n==null)return null;if(!Array.isArray(n))throw new se("`mask` should be an Array");if(!Array.isArray(e))throw new se("`inputs` should be an Array");if(n.length!==e.length)throw new se(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${n.length})`);if(n.every(r=>r==null))return null;n=n.map(r=>r==null?r:us(r,0));let s=n[0];for(let r=1;r<n.length-1;++r)s=Ca(s,n[r]);return s})}}class NG extends Eh{constructor(e){super(e)}mergeFunction(e){return ae(()=>{let n=e[0].clone();for(let s=1;s<e.length;++s)n=we(n,e[s]);return n})}}NG.className="Add";$e(NG);class TG extends Eh{constructor(e){super(e)}mergeFunction(e){return ae(()=>{let n=e[0].clone();for(let s=1;s<e.length;++s)n=Y(n,e[s]);return n})}}TG.className="Multiply";$e(TG);class EG extends Eh{constructor(e){super(e)}mergeFunction(e){return ae(()=>{let n=e[0].clone();for(let s=1;s<e.length;++s)n=we(n,e[s]);return Y(1/e.length,n)})}}EG.className="Average";$e(EG);class RG extends Eh{constructor(e){super(e)}mergeFunction(e){return ae(()=>{let n=e[0];for(let s=1;s<e.length;++s)n=Su(n,e[s]);return n})}}RG.className="Maximum";$e(RG);class AG extends Eh{constructor(e){super(e)}mergeFunction(e){return ae(()=>{let n=e[0];for(let s=1;s<e.length;++s)n=kl(n,e[s]);return n})}}AG.className="Minimum";$e(AG);class _G extends Eh{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new se("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let n=!0;for(const r of e)if(r!=null){n=!1;break}if(n)return;const s=[];for(let r=0;r<e.length;++r){const o=e[r].slice();o.splice(this.axis,1);let i=!1;for(const a of s)if(kt(a,o)){i=!0;break}i||s.push(o)}if(s.length>1)throw new se("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return ae(()=>PE(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new se("A `Concatenate` layer should be called on a list of inputs.");const n=e,s=n[0].slice(),r=this.axis<0?s.length+this.axis:this.axis;for(const o of n.slice(1)){if(s[r]==null||o[r]==null){s[r]=null;break}s[r]+=o[r]}return s}computeMask(e,n){if(n==null)return null;if(!Array.isArray(n))throw new se("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new se("`inputs` should be an array for Concatenate");if(n.length!==e.length)throw new se(`Mismatch in the length of mask (${n.length}) and the legnth of inputs (${e.length})`);return ae(()=>{let s=!0;if(n.forEach(i=>{if(i!=null){s=!1;return}}),s)return null;const r=[];for(let i=0;i<e.length;++i)n[i]==null?r.push(De(_o(e[i]),"bool")):n[i].rank<e[i].rank?r.push(us(n[i],-1)):r.push(n[i]);const o=Ln(r,this.axis);return kT(o,-1,!1)})}getConfig(){const e={axis:this.axis},n=super.getConfig();return Object.assign(e,n),e}}_G.className="Concatenate";$e(_G);function Hm(t,e){for(;t<0;)t+=e;return t}function vCe(t,e,n){if(t.shape.length>3||e.shape.length>3)throw new Ct("batchDot is not implemented for tensors of 4D or higher rank yet");if(O(t.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${t.shape.length}`),O(t.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof n=="number"&&(n=[n,n]),t.dtype==="complex64"||e.dtype==="complex64")throw new Ct("batchDot is not implemented for complex64-type Tensors yet.");const s=t.shape.length,r=e.shape.length;n==null&&(n=[s-1,r-2]);const o=n;return ae(()=>{let i;if(s>r){i=s-r;const u=[];for(let l=0;l<i;++l)u.push(1);e=ee(e,e.shape.concat(u))}else if(r>s){i=r-s;const u=[];for(let l=0;l<i;++l)u.push(1);t=ee(t,t.shape.concat(u))}else i=0;let a;if(t.shape.length===2&&e.shape.length===2)o[0]===o[1]?a=Qe(Y(t,e),o[0]):a=Qe(Y(Vt(t,[1,0]),e),o[1]);else{const u=o[0]!==t.shape.length-1,l=o[1]===e.shape.length-1;a=Dt(t,e,u,l)}if(i>0){let u;s>r?u=s+r-3:u=s-1;const l=[];for(let c=u;c<u+i;++c)l.push(c);a=Yt(a,l)}return a.shape.length===1&&(a=us(a,1)),a})}class DG extends Eh{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){O(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=e[0],s=e[1];if(n.length>3||s.length>3)throw new Ct("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(n,s);if(n[r[0]]!==s[r[1]])throw new se(`Dimension incompatibility: ${n[r[0]]} !== ${s[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new se(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let n=e[0],s=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((o,i)=>Hm(o,e[i].shape.length)):r=[Hm(this.axes,n.shape.length),Hm(this.axes,s.shape.length)],this.normalize&&(n=ew(n,r[0]),s=ew(s,r[1])),vCe(n,s,r)}interpretAxes(e,n){let s;return Array.isArray(this.axes)?s=this.axes:s=[Hm(this.axes,e.length),Hm(this.axes,n.length)],s}computeOutputShape(e){O(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=e[0].slice(),s=e[1].slice();if(n.length>3||s.length>3)throw new Ct("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(n,s);n.splice(r[0],1),s.splice(r[1],1),s.splice(0,1);const o=n.concat(s);return o.length===1&&o.push(1),o}computeMask(e,n){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},n=super.getConfig();return Object.assign(e,n),e}}DG.className="Dot";$e(DG);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class PG extends At{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,e),n}call(e,n){return ae(()=>{this.invokeCallHook(e,n);const s=gt(e);return A0(()=>we(zS(s.shape,0,this.stddev),s),()=>s,n.training||!1)})}}PG.className="GaussianNoise";$e(PG);class FG extends At{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={rate:this.rate};return Object.assign(n,e),n}call(e,n){return ae(()=>{this.invokeCallHook(e,n);const s=gt(e);return this.rate>0&&this.rate<1?A0(()=>{const o=Math.sqrt(this.rate/(1-this.rate));return Y(s,zS(s.shape,1,o))},()=>s,n.training||!1):s})}}FG.className="GaussianDropout";$e(FG);class OG extends At{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||gt(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),n={rate:this.rate};return Object.assign(n,e),n}call(e,n){return ae(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return A0(()=>{const o=gt(e),i=1.6732632423543772,a=1.0507009873554805,u=-i*a;let l=Bl(bh(s),this.rate);l=wa(l,"float32");const c=((1-this.rate)*(1+this.rate*u**2))**-.5,h=-c*u*this.rate,d=we(Y(o,l),Y(we(l,-1),u));return we(Y(d,c),h)},()=>gt(e),n.training||!1)}return e})}}OG.className="AlphaDropout";$e(OG);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function sy(t,e,n,s,r,o=.001){let i;if(t.rank===2)i=yB(t,e,n,s,r,o);else if(t.rank===3)i=xB(t,e,n,s,r,o);else if(t.rank===4)i=vB(t,e,n,s,r,o);else throw new Ct(`batchNormalization is not implemented for array of rank ${t.rank} yet`);return i}function wCe(t,e,n,s,r=.001){return ae(()=>{const o=Yb(t,s),i=o.mean,a=o.variance;return[sy(t,i,a,n,e,r),i,a]})}function bCe(t,e,n,s,r=.001){return ae(()=>{const o=Yb(t,s),i=o.mean,a=o.variance,u=[];for(const m of ji(0,t.rank))s.indexOf(m)!==-1?u.push(1):u.push(t.shape[m]);const l=ee(i,u),c=ee(a,u),h=e==null?null:ee(e,u),d=n==null?null:ee(n,u);return[sy(t,l,c,d,h,r),i,a]})}function SCe(t,e,n,s,r=.001){return kt(s.slice().sort(),ji(0,t.rank-1))?wCe(t,e,n,s,r):bCe(t,e,n,s,r)}class LG extends At{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Rn(e.betaInitializer||"zeros"),this.gammaInitializer=Rn(e.gammaInitializer||"ones"),this.movingMeanInitializer=Rn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Rn(e.movingVarianceInitializer||"ones"),this.betaConstraint=vs(e.betaConstraint),this.gammaConstraint=vs(e.gammaConstraint),this.betaRegularizer=_n(e.betaRegularizer),this.gammaRegularizer=_n(e.gammaRegularizer)}build(e){e=Xt(e);const n=this.axis>=0?this.axis:this.axis+e.length,s=e[n];if(s==null)throw new se(`Axis ${n} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new gs({ndim:e.length,axes:{[n]:s}})];const r=[s];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,n){return ae(()=>{const s=n.training==null?!1:n.training,r=gt(e),o=r.shape,i=o.length,a=ji(0,i),u=this.axis>=0?this.axis:this.axis+i;a.splice(u,1);const l=ch(1,i);l[u]=o[u];const c=a.slice();c.sort();const h=!kt(c,ji(0,i).slice(0,i-1)),d=()=>{if(h){const w=ee(this.movingMean.read(),l),S=ee(this.movingVariance.read(),l),k=this.center?ee(this.beta.read(),l):null,I=this.scale?ee(this.gamma.read(),l):null;return sy(r,w,S,k,I,this.epsilon)}else return sy(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return d();const[f,m,y]=SCe(r,this.gamma.read(),this.beta.read(),a,this.epsilon),x=(w,S,k)=>{ae(()=>{const I=1-k,T=w.read(),R=Y(Be(T,S),I);w.write(Be(T,R))})};return(()=>{x(this.movingMean,m,this.momentum),x(this.movingVariance,y,this.momentum)})(),f})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:On(this.betaInitializer),gammaInitializer:On(this.gammaInitializer),movingMeanInitializer:On(this.movingMeanInitializer),movingVarianceInitializer:On(this.movingVarianceInitializer),betaRegularizer:gn(this.betaRegularizer),gammaRegularizer:gn(this.gammaRegularizer),betaConstraint:xs(this.betaConstraint),gammaConstraint:xs(this.gammaConstraint)},n=super.getConfig();return Object.assign(e,n),e}}LG.className="BatchNormalization";$e(LG);class MG extends At{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const n of this.axis)if(!Number.isInteger(n))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Rn(e.betaInitializer||"zeros"),this.gammaInitializer=Rn(e.gammaInitializer||"ones"),this.betaRegularizer=_n(e.betaRegularizer),this.gammaRegularizer=_n(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Xt(e);const n=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=n);for(const o of this.axis)if(o<0||o>=n)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==dl(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(o=>e[o]),r=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,n){const s=gt(e),r=s.shape,o=r.length;return ae(()=>{let{mean:a,variance:u}=Yb(s,this.axis,!0);const l=ch(1,o);for(const y of this.axis)l[y]=r[y];const c=y=>y!=null&&y.shape.length!==o?ee(y,l):y;let h=this.scale?c(this.gamma.read()):null,d=this.center?c(this.beta.read()):null;const f=[],m=[];for(let y=0;y<o;++y)this.axis.indexOf(y)!==-1?(f.push(r[y]),m.push(1)):(f.push(1),m.push(r[y]));return a=li(a,f),u=li(u,f),h!=null&&(h=li(h,m)),d!=null&&(d=li(d,m)),sy(s,a,u,d,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:On(this.betaInitializer),gammaInitializer:On(this.gammaInitializer),betaRegularizer:gn(this.betaRegularizer),gammaRegularizer:gn(this.gammaRegularizer)},n=super.getConfig();return Object.assign(e,n),e}}MG.className="LayerNormalization";$e(MG);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function CCe(t,e,n){return ae(()=>{if(t.rank!==4)throw new se(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new se("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=Ki()),n!=="channelsLast"&&n!=="channelsFirst")throw new se(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return n==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],Ui(t,s)})}class zG extends At{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Ki():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new se(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let n,s;if(typeof e.padding[0]=="number")n=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new se(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(n=e.padding[0],e.padding[1].length!==2)throw new se(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[n,s]}this.inputSpec=[new gs({ndim:4})]}computeOutputShape(e){e=Xt(e);let n,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?n=e[2]+this.padding[0][0]+this.padding[0][1]:n=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],n,s]):(e[1]!=null&&e[1]>=0?n=e[1]+this.padding[0][0]+this.padding[0][1]:n=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],n,s,e[3]])}call(e,n){return ae(()=>CCe(gt(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}zG.className="ZeroPadding2D";$e(zG);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function KS(t,e,n,s,r,o){return ae(()=>{ss(r),sU(o),zo(s),n==null&&(n=[1,1]),s==null&&(s="valid"),r==null&&(r=Ki()),o==null&&(o="max"),t=KE(t,r);let i;const a=s==="same"?"same":"valid";return o==="max"?i=qb(t,e,n,a):i=Vb(t,e,n,a),r==="channelsFirst"&&(i=Vt(i,[0,3,1,2])),i})}function BG(t,e,n,s,r,o){return ae(()=>{ss(r),sU(o),zo(s),n==null&&(n=[1,1,1]),s==null&&(s="valid"),r==null&&(r=Ki()),o==null&&(o="max"),t=sG(t,r);let i;const a=s==="same"?"same":"valid";return o==="max"?i=GB(t,e,n,a):i=gB(t,e,n,a),r==="channelsFirst"&&(i=Vt(i,[0,4,1,2,3])),i})}class VG extends At{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new se(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(As(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new se(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);As(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,zo(this.padding),this.inputSpec=[new gs({ndim:3})]}computeOutputShape(e){e=Xt(e);const n=zi(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],n,e[2]]}call(e,n){return ae(()=>{this.invokeCallHook(e,n),e=E0(gt(e),2);const s=this.poolingFunction(gt(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Yt(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=super.getConfig();return Object.assign(e,n),e}}class WG extends VG{constructor(e){super(e)}poolingFunction(e,n,s,r,o){return ss(o),zo(r),KS(e,n,s,r,o,"max")}}WG.className="MaxPooling1D";$e(WG);class UG extends VG{constructor(e){super(e)}poolingFunction(e,n,s,r,o){return ss(o),zo(r),KS(e,n,s,r,o,"avg")}}UG.className="AveragePooling1D";$e(UG);class GG extends At{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new se(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];As(this.poolSize,"poolSize"),As(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ss(this.dataFormat),zo(this.padding),this.inputSpec=[new gs({ndim:4})]}computeOutputShape(e){e=Xt(e);let n=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return n=zi(n,this.poolSize[0],this.padding,this.strides[0]),s=zi(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],n,s]:[e[0],n,s,e[3]]}call(e,n){return ae(()=>(this.invokeCallHook(e,n),this.poolingFunction(gt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class HG extends GG{constructor(e){super(e)}poolingFunction(e,n,s,r,o){return ss(o),zo(r),KS(e,n,s,r,o,"max")}}HG.className="MaxPooling2D";$e(HG);class jG extends GG{constructor(e){super(e)}poolingFunction(e,n,s,r,o){return ss(o),zo(r),KS(e,n,s,r,o,"avg")}}jG.className="AveragePooling2D";$e(jG);class KG extends At{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new se(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];As(this.poolSize,"poolSize"),As(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ss(this.dataFormat),zo(this.padding),this.inputSpec=[new gs({ndim:5})]}computeOutputShape(e){e=Xt(e);let n=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return n=zi(n,this.poolSize[0],this.padding,this.strides[0]),s=zi(s,this.poolSize[1],this.padding,this.strides[1]),r=zi(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],n,s,r]:[e[0],n,s,r,e[4]]}call(e,n){return ae(()=>(this.invokeCallHook(e,n),this.poolingFunction(gt(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class XG extends KG{constructor(e){super(e)}poolingFunction(e,n,s,r,o){return ss(o),zo(r),BG(e,n,s,r,o,"max")}}XG.className="MaxPooling3D";$e(XG);class qG extends KG{constructor(e){super(e)}poolingFunction(e,n,s,r,o){return ss(o),zo(r),BG(e,n,s,r,o,"avg")}}qG.className="AveragePooling3D";$e(qG);class YG extends At{constructor(e){super(e),this.inputSpec=[new gs({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,n){throw new Ct}}class QG extends YG{constructor(e){super(e||{})}call(e,n){return ae(()=>{const s=gt(e);return Un(s,1)})}}QG.className="GlobalAveragePooling1D";$e(QG);class ZG extends YG{constructor(e){super(e||{})}call(e,n){return ae(()=>{const s=gt(e);return fi(s,1)})}}ZG.className="GlobalMaxPooling1D";$e(ZG);class JG extends At{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,ss(this.dataFormat),this.inputSpec=[new gs({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,n){throw new Ct}getConfig(){const e={dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}}class eH extends JG{call(e,n){return ae(()=>{const s=gt(e);return this.dataFormat==="channelsLast"?Un(s,[1,2]):Un(s,[2,3])})}}eH.className="GlobalAveragePooling2D";$e(eH);class tH extends JG{call(e,n){return ae(()=>{const s=gt(e);return this.dataFormat==="channelsLast"?fi(s,[1,2]):fi(s,[2,3])})}}tH.className="GlobalMaxPooling2D";$e(tH);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class nH extends At{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=super.getConfig();return Object.assign(e,n),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,n,s={}){const r=n.layer,o=lu(r,s);delete n.layer;const i={layer:o};return Object.assign(i,n),new e(i)}}class sH extends nH{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Xt(e),e.length<3)throw new se(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const n=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Xt(e);const n=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(n),r=e[1];return[s[0],r].concat(s.slice(1))}call(e,n){return ae(()=>(e=gt(e),dG((i,a)=>[gt(this.layer.call(i,n)),[]],e,[],!1,null,null,!1,!0)[1]))}}sH.className="TimeDistributed";$e(sH);function kCe(t){Th(Hbe,"BidirectionalMergeMode",t)}const ICe="concat";class rH extends nH{constructor(e){super(e);const n=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=n,this.forwardLayer=lu(s),n.goBackwards=n.goBackwards!==!0;const r={};if(r.className=e.layer.getClassName(),r.config=n,this.backwardLayer=lu(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?ICe:e.mergeMode,kCe(this.mergeMode),e.weights)throw new Ct("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const n=e.length,s=Math.floor(n/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let n=this.forwardLayer.computeOutputShape(e);Array.isArray(n)&&Array.isArray(n[0])||(n=[n]),n=n;let s,r,o;return this.returnState&&(o=n.slice(1)),s=n[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,r=[s]):this.mergeMode==null?r=[s,s.slice()]:r=[s],this.returnState?this.mergeMode==null?r.concat(o).concat(o.slice()):[s].concat(o).concat(o.slice()):Er(r)}apply(e,n){let s=n==null?null:n.initialState,r=n==null?null:n.constants;n==null&&(n={});const o=hG(e,s,r,this.numConstants);if(e=o.inputs,s=o.initialState,r=o.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&r==null)return super.apply(e,n);const i=[],a=[];if(s!=null){const l=s.length;if(l%2>0)throw new se("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=s,i.push(...s);const c=s.map(h=>new gs({shape:h.shape}));this.forwardLayer.stateSpec=c.slice(0,l/2),this.backwardLayer.stateSpec=c.slice(l/2),a.push(...c)}if(r!=null)throw new Ct("Support for constants in Bidirectional layers is not implemented yet.");const u=i[0]instanceof Na;for(const l of i)if(l instanceof Na!==u)throw new se("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const l=[e].concat(i),c=this.inputSpec.concat(a),h=this.inputSpec;this.inputSpec=c;const d=super.apply(l,n);return this.inputSpec=h,d}else return super.apply(e,n)}call(e,n){return ae(()=>{const s=n.initialState;let r,o;if(s==null)r=this.forwardLayer.call(e,n),o=this.backwardLayer.call(e,n);else{const u=s.slice(0,s.length/2),l=s.slice(s.length/2);r=this.forwardLayer.call(e,Object.assign(n,{initialState:u})),o=this.backwardLayer.call(e,Object.assign(n,{initialState:l}))}let i;this.returnState&&(Array.isArray(r)&&(i=r.slice(1).concat(o.slice(1))),r=r[0],o=o[0]),this.returnSequences&&(o=vi(o,1));let a;return this.mergeMode==="concat"?a=PE([r,o]):this.mergeMode==="sum"?a=we(r,o):this.mergeMode==="ave"?a=Y(.5,we(r,o)):this.mergeMode==="mul"?a=Y(r,o):this.mergeMode==null&&(a=[r,o]),this.returnState?this.mergeMode==null?a.concat(i):[a].concat(i):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Hc(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Hc(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,n){Array.isArray(n)&&(n=n[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[n,n]:s=n:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const o=this.forwardLayer.states.map(i=>null);return Array.isArray(s)?s.concat(o).concat(o):[s].concat(o).concat(o)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},n=super.getConfig();return Object.assign(e,n),e}static fromConfig(e,n){const s=lu(n.layer);if(delete n.layer,n.numConstants!=null)throw new Ct("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=n;return r.layer=s,new e(r)}}rH.className="Bidirectional";$e(rH);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class oH extends At{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},n=super.getConfig();return Object.assign(e,n),e}call(e,n){return ae(()=>(e=gt(e),e.dtype!=="float32"&&(e=wa(e,"float32")),we(Y(e,this.scale),this.offset)))}}oH.className="Rescaling";$e(oH);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:$Ce,cropAndResize:NCe}=Xs;class iH extends At{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,n,s,r,o,i,a,u){return ae(()=>{let l,c=!1;const h=n/i,d=s/a,f=(r+n)/i,m=(o+s)/a,y=[h,d,f,m],x=[];e.rank===3?(c=!0,l=ao([e])):l=e;for(let I=0;I<l.shape[0];I++)x.push(y);const v=Mi(x,[x.length,4]),w=hp(0,x.length,1,"int32"),k=NCe(l,v,w,[r,o],"nearest");return wa(c?gt(wi(k)):k,u)})}upsize(e,n,s,r){return ae(()=>{const o=$Ce(e,[n,s]);return wa(o,r)})}call(e,n){return ae(()=>{const s=gt(e),r=s.dtype,o=s.shape,i=o[o.length-3],a=o[o.length-2];let u=0;i!==this.height&&(u=Math.floor((i-this.height)/2));let l=0;return a!==this.width&&(l=Math.floor((a-this.width)/2),l===0&&(l=1)),u>=0&&l>=0?this.centerCrop(s,u,l,this.height,this.width,i,a,r):this.upsize(e,this.height,this.width,r)})}getConfig(){const e={height:this.height,width:this.width},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){e=Xt(e);const n=e.length-3,s=e.length-2;return e[n]=this.height,e[s]=this.width,e}}iH.className="CenterCrop";$e(iH);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function TCe(t,e,n,s){let r=gt(t);if(r.dtype!=="int32"&&(r=wa(r,"int32")),e==="int")return r;const o=r.shape;if(r.rank===0&&(r=us(r,-1)),e==="oneHot"&&r.shape[r.shape.length-1]!==1&&(r=us(r,-1)),r.rank>2)throw new se(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${o} which would result in output rank ${r.rank}.`);const i=["multiHot","oneHot"].includes(e),a=r;let u;if(typeof s<"u"&&e==="count"?u=r$(a,s,n,i):u=r$(a,[],n,i),e!=="tfIdf")return u;if(s)return Y(u,s);throw new se("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class aH extends At{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){return e=Xt(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,n){return ae(()=>{e=gt(e),e.dtype!=="int32"&&(e=wa(e,"int32"));let s;if(typeof n.countWeights<"u"){if(this.outputMode!=="count")throw new se(`countWeights is not used when outputMode !== count.
              Received countWeights=${n.countWeights}`);s=gt(n.countWeights)}const r=fi(e),o=jg(e),i=mo(this.numTokens,r).bufferSync().get(0),a=Bl(o,0).bufferSync().get(0);if(!(i&&a))throw new se(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return TCe(e,this.outputMode,this.numTokens,s)})}}aH.className="CategoryEncoding";$e(aH);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const ECe=["bilinear","nearest"],XP=new Set(ECe);class uH extends At{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(XP.has(e.interpolation))this.interpolation=e.interpolation;else throw new se(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=Xt(e);const n=e[2];return[this.height,this.width,n]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},n=super.getConfig();return Object.assign(e,n),e}call(e,n){return ae(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return Xs.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Xs.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...XP]} are supported`)})}}uH.className="Resizing";$e(uH);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class lH{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}lH.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class cH extends At{constructor(e){super(e),this.randomGenerator=new lH(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},n=super.getConfig();return Object.assign(e,n),e}}cH.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const RCe=["bilinear","nearest"],qP=new Set(RCe);class hH extends cH{constructor(e){super(e);const{factor:n,interpolation:s="bilinear"}=e;if(this.factor=n,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new se(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new se(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new se(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(s)if(qP.has(s))this.interpolation=s;else throw new se(`Invalid interpolation parameter: ${s} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},n=super.getConfig();return Object.assign(e,n),e}computeOutputShape(e){e=Xt(e);const n=e[2];return[this.imgHeight,-1,n]}call(e,n){return ae(()=>{const s=gt(e);this.imgHeight=s.shape[s.shape.length-3];const r=s.shape[s.shape.length-2];this.widthFactor=bh([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let o=this.widthFactor.dataSync()[0]*r;o=Math.round(o);const i=[this.imgHeight,o];switch(this.interpolation){case"bilinear":return Xs.resizeBilinear(e,i);case"nearest":return Xs.resizeNearestNeighbor(e,i);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...qP]} are supported`)}})}}hH.className="RandomWidth";$e(hH);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var YP;(function(t){t[t.FAIL=0]="FAIL",t[t.SHORTEST=1]="SHORTEST",t[t.LONGEST=2]="LONGEST"})(YP||(YP={}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ACe=oE;class XS extends Vw{nextDataId(){return XS.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new nT(this,lr())}write(e,n,s){this.firstUse&&(this.firstUse=!1,ce().get("IS_NODE")&&Io(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,n,s){let r;if(n==="string"&&s!=null&&s.length>0&&Tp(s[0])){const o=s.map(i=>iu(i));r=this.write(o,e,n)}else r=this.write(s,e,n);return{dataId:r,shape:e,dtype:n}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const n=this.data.get(e);n.refCount++}decRef(e){if(this.data.has(e)){const n=this.data.get(e);n.refCount--}}move(e,n,s,r,o){this.data.set(e,{values:n,dtype:r,refCount:o})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:n,complexTensorInfos:s}=this.data.get(e);if(n==="complex64"){const r=this.readSync(s.real.dataId),o=this.readSync(s.imag.dataId);return Gi(r,o)}return Q1(this.data.get(e).values,n)}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const s=n.map(r=>Vi(r));return xt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return xt(e.shape,e.dtype,n)}makeOutput(e,n,s){return lr().makeTensorFromTensorInfo(this.makeTensorInfo(n,s,e),this)}disposeData(e,n=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!n&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const n=Tr();return e(),{kernelMs:Tr()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Ze([e],"where");const n=this.readSync(e.dataId);return ACe(e.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}XS.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */wT("cpu",()=>new XS,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dH=sn(Up,t=>t>=0?t:Math.exp(t)-1),_Ce={kernelName:Up,backendName:"cpu",kernelFunc:dH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pH(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{alpha:o}=s;Ze([r],"leakyRelu");const i=ie(r.shape),a=n.data.get(r.dataId).values,u=ws("float32",i);for(let l=0;l<a.length;l++)u[l]=a[l]<0?o*a[l]:a[l];return n.makeTensorInfo(r.shape,"float32",u)}const DCe={kernelName:Ly,backendName:"cpu",kernelFunc:pH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PCe=ns((t,e)=>t<0?e*t:t);function fH(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e;Ze([s,r],"prelu");const o=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values,[a,u]=PCe(s.shape,r.shape,o,i,"float32");return n.makeTensorInfo(u,"float32",a)}const FCe={kernelName:n0,backendName:"cpu",kernelFunc:fH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mH=sn(lf,t=>Math.max(0,t)),OCe={kernelName:lf,backendName:"cpu",kernelFunc:mH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gH=sn(cf,t=>Math.min(Math.max(0,t),6)),LCe={kernelName:cf,backendName:"cpu",kernelFunc:gH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ow(t,e,n,s,r){if(n==="linear")return ka({inputs:{x:e},backend:t});if(n==="relu")return mH({inputs:{x:e},backend:t});if(n==="elu")return dH({inputs:{x:e},backend:t});if(n==="relu6")return gH({inputs:{x:e},backend:t});if(n==="prelu")return fH({inputs:{x:e,alpha:s},backend:t});if(n==="leakyrelu")return pH({inputs:{x:e},backend:t,attrs:{alpha:r}});if(n==="sigmoid")return X4({inputs:{x:e},backend:t});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wn(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{shape:o}=s,i=ie(r.shape),a=rT(o,i),u=ie(a);O(i===u,()=>`The new shape (${a}) has ${u} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(r.dataId);const l=n.data.get(r.dataId);if(l.complexTensorInfos!=null){const c=l.complexTensorInfos.real,h=l.complexTensorInfos.imag;c.shape=a,h.shape=a}return{dataId:r.dataId,shape:a,dtype:r.dtype}}const MCe={kernelName:r0,backendName:"cpu",kernelFunc:wn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yH(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:o}=e,{transposeA:i,transposeB:a}=s;Ze([r,o],"matMul");const u=r.shape.length,l=o.shape.length,c=i?r.shape[u-2]:r.shape[u-1],h=a?o.shape[l-1]:o.shape[l-2],d=i?r.shape[u-1]:r.shape[u-2],f=a?o.shape[l-2]:o.shape[l-1],m=r.shape.slice(0,-2),y=o.shape.slice(0,-2),x=ie(m),v=ie(y),S=ut(r.shape.slice(0,-2),o.shape.slice(0,-2)).concat([d,f]);O(c===h,()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${r.shape} and ${o.shape} and transposeA=${i} and transposeB=${a} must match.`);const k=i?[x,c,d]:[x,d,c],I=a?[v,f,h]:[v,h,f],T=wn({inputs:{x:r},backend:n,attrs:{shape:k}}),R=wn({inputs:{x:o},backend:n,attrs:{shape:I}}),_=i?T.shape[1]:T.shape[2],D=i?T.shape[2]:T.shape[1],L=a?R.shape[1]:R.shape[2],V=Math.max(x,v),U=n.data.get(T.dataId).values,j=n.data.get(R.dataId).values,q=et(T.shape),J=et(R.shape),[te,le,K]=i?[q[0],1,q[1]]:[q[0],q[1],1],[re,pe,he]=a?[1,J[1],J[0]]:[J[1],1,J[0]],xe=D*L,Ce=xt([V,D,L],T.dtype),Ee=Ce.values,Ie=n.blockSize;for(let ke=0;ke<V;ke++){const Ae=ke%x,Ke=ke%v;for(let je=0;je<D;je+=Ie){const rt=Math.min(je+Ie,D);for(let tt=0;tt<L;tt+=Ie){const Et=Math.min(tt+Ie,L);for(let lt=0;lt<_;lt+=Ie){const at=Math.min(lt+Ie,_);for(let Lt=je;Lt<rt;Lt++)for(let qt=tt;qt<Et;qt++){let Ft=0;for(let Zt=lt;Zt<at;Zt++){const Wr=U[Ae*te+Lt*le+Zt*K],yn=j[Zt*re+qt*pe+Ke*he];Ft+=Wr*yn}Ee[ke*xe+(Lt*L+qt)]+=Ft}}}}}return n.disposeIntermediateTensorInfo(T),n.disposeIntermediateTensorInfo(R),n.makeTensorInfo(S,Ce.dtype,Ce.values)}const zCe={kernelName:Sy,backendName:"cpu",kernelFunc:yH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BCe(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:o,bias:i,preluActivationWeights:a}=e,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:h}=s;let d,f,m;const y=[];d=yH({inputs:{a:r,b:o},attrs:{transposeA:u,transposeB:l},backend:n}),i&&(f=fp({inputs:{a:d,b:i},backend:n}),y.push(d),d=f),c&&(m=ow(n,d,c,a,h),y.push(d),d=m);for(const v of y)n.disposeIntermediateTensorInfo(v);return d}const VCe={kernelName:Bg,backendName:"cpu",kernelFunc:BCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WCe=sn(Rp,t=>Math.acos(t)),UCe={kernelName:Rp,backendName:"cpu",kernelFunc:WCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GCe=sn(Ap,t=>Math.acosh(t)),HCe={kernelName:Ap,backendName:"cpu",kernelFunc:GCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jCe(t){const{inputs:e,backend:n}=t,s=e;Ze(e,"addN");const r=s.map(a=>n.data.get(a.dataId).values),o=xt(s[0].shape,s[0].dtype),i=o.values;for(let a=0;a<s.length;a++){const u=r[a];for(let l=0;l<i.length;l++)i[l]+=u[l]}return n.makeTensorInfo(o.shape,o.dtype,o.values)}const KCe={kernelName:yy,backendName:"cpu",kernelFunc:jCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XCe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:i}=s;Ze(r,"all");const a=vt(o,r.shape);let u=a;const l=cn(u,r.shape.length);let c=r;l!=null&&(c=Lr({inputs:{x:r},backend:n,attrs:{perm:l}}),u=Sn(u.length,r.shape.length)),cs("all",u,c.shape.length);const[h,d]=ts(c.shape,u),f=ie(d),m=Vs(ie(h),c.dtype),y=n.data.get(c.dataId).values;for(let v=0;v<m.length;++v){const w=v*f;let S=y[w];for(let k=0;k<f;++k){const I=y[w+k];S=S&&I}m[v]=S}l!=null&&n.disposeIntermediateTensorInfo(c);const x=n.makeTensorInfo(h,c.dtype,m);if(i){const v=qn(h,a),w=wn({inputs:{x},backend:n,attrs:{shape:v}});return n.disposeIntermediateTensorInfo(x),w}return x}const qCe={kernelName:Ww,backendName:"cpu",kernelFunc:XCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YCe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:i}=s;Ze(r,"any");const a=vt(o,r.shape);let u=a;const l=cn(u,r.shape.length);let c=r;l!=null&&(c=Lr({inputs:{x:r},backend:n,attrs:{perm:l}}),u=Sn(u.length,r.shape.length)),cs("any",u,c.shape.length);const[h,d]=ts(c.shape,u),f=ie(d),m=Vs(ie(h),c.dtype),y=n.data.get(c.dataId).values;for(let v=0;v<m.length;++v){const w=v*f;let S=y[w];for(let k=0;k<f;++k){const I=y[w+k];S=S||I}m[v]=S}l!=null&&n.disposeIntermediateTensorInfo(c);const x=n.makeTensorInfo(h,c.dtype,m);if(i){const v=qn(h,a),w=wn({inputs:{x},backend:n,attrs:{shape:v}});return n.disposeIntermediateTensorInfo(x),w}return x}const QCe={kernelName:Uw,backendName:"cpu",kernelFunc:YCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZCe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o}=s;Ze(r,"argMax");let i=vt(o,r.shape);const a=cn(i,r.shape.length);let u=r;const l=[];a!=null&&(u=Lr({inputs:{x:r},backend:n,attrs:{perm:a}}),l.push(u),i=Sn(i.length,u.shape.length)),i=[i[0]],cs("argMax",i,u.shape.length);const[c,h]=ts(u.shape,i),d=ie(c),f=Vs(d,"int32"),m=ie(h),y=n.data.get(u.dataId).values;for(let x=0;x<f.length;++x){const v=x*m;let w=y[v],S=0;for(let k=0;k<m;++k){const I=y[v+k];I>w&&(w=I,S=k)}f[x]=S}return l.forEach(x=>n.disposeIntermediateTensorInfo(x)),n.makeTensorInfo(c,"int32",f)}const JCe={kernelName:xy,backendName:"cpu",kernelFunc:ZCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e2e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o}=s;Ze(r,"argMin");let i=vt(o,r.shape);const a=cn(i,r.shape.length);let u=r;const l=[];a!=null&&(u=Lr({inputs:{x:r},backend:n,attrs:{perm:a}}),l.push(u),i=Sn(i.length,u.shape.length)),i=[i[0]],cs("argMin",i,u.shape.length);const[c,h]=ts(u.shape,i),d=ie(c),f=Vs(d,"int32"),m=ie(h),y=n.data.get(u.dataId).values;for(let x=0;x<f.length;++x){const v=x*m;let w=y[v],S=0;for(let k=0;k<m;++k){const I=y[v+k];I<w&&(w=I,S=k)}f[x]=S}return l.forEach(x=>n.disposeIntermediateTensorInfo(x)),n.makeTensorInfo(c,"int32",f)}const t2e={kernelName:vy,backendName:"cpu",kernelFunc:e2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n2e=sn(_p,t=>Math.asin(t)),s2e={kernelName:_p,backendName:"cpu",kernelFunc:n2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r2e=sn(Dp,t=>Math.asinh(t)),o2e={kernelName:Dp,backendName:"cpu",kernelFunc:r2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i2e=sn(Pp,t=>Math.atan(t)),a2e={kernelName:Pp,backendName:"cpu",kernelFunc:i2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u2e=ns((t,e)=>Math.atan2(t,e)),l2e=Cs(Op,u2e),c2e={kernelName:Op,backendName:"cpu",kernelFunc:l2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h2e=sn(Fp,t=>Math.atanh(t)),d2e={kernelName:Fp,backendName:"cpu",kernelFunc:h2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JE(t,e,n,s,r,o){const i=r.strideHeight,a=r.strideWidth,u=r.dilationHeight,l=r.dilationWidth,c=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,f=r.padInfo.left,m=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,y=xt(r.outShape,n),x=y.values,v=r.outShape[1]*r.outShape[2]*r.outShape[3],w=r.outShape[2]*r.outShape[3],S=r.outShape[3];for(let k=0;k<r.batchSize;++k){const I=k*v,T=k*s[0];for(let R=0;R<r.inChannels;++R)for(let _=0;_<r.outHeight;++_){const D=_*i-d,L=Math.max(0,D),V=Math.min(r.inHeight,c+D),U=I+_*w;for(let j=0;j<r.outWidth;++j){const q=j*a-f,J=Math.max(0,q),te=Math.min(r.inWidth,h+q);let le=m,K=0,re=0;for(let he=L;he<V;he+=u){const xe=T+he*s[1];for(let Ce=J;Ce<te;Ce+=l){const Ee=xe+Ce*s[2],Ie=t[Ee+R];o==="max"&&Ie>le?le=Ie:o==="avg"&&(K+=Ie,re++)}if(isNaN(le))break}const pe=U+j*S+R;x[pe]=o==="avg"?K/re:le}}}return y}function xH(t,e,n,s,r=!1,o=!1){const i=xt(s.outShape,"int32"),a=s.strideHeight,u=s.strideWidth,l=s.dilationHeight,c=s.dilationWidth,h=s.effectiveFilterHeight,d=s.effectiveFilterWidth,f=s.padInfo.top,m=s.padInfo.left,y=xt(e,n,t);for(let x=0;x<s.batchSize;++x)for(let v=0;v<s.inChannels;++v)for(let w=0;w<s.outHeight;++w){const S=w*a-f;let k=S;for(;k<0;)k+=l;const I=Math.min(s.inHeight,h+S);for(let T=0;T<s.outWidth;++T){const R=T*u-m;let _=R;for(;_<0;)_+=c;const D=Math.min(s.inWidth,d+R);let L=Number.NEGATIVE_INFINITY,V=-1;for(let U=k;U<I;U+=l){const j=U-S;for(let q=_;q<D;q+=c){const J=q-R,te=y.get(x,U,q,v);te>L&&(L=te,r?V=o?((x*s.inHeight+U)*s.inWidth+q)*s.inChannels+v:(U*s.inWidth+q)*s.inChannels+v:V=j*d+J)}}i.set(V,x,w,T,v)}}return i}function vH(t,e,n,s,r,o){const i=r.strideDepth,a=r.strideHeight,u=r.strideWidth,l=r.dilationDepth,c=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,f=r.effectiveFilterHeight,m=r.effectiveFilterWidth,y=r.padInfo.front,x=r.padInfo.top,v=r.padInfo.left,w=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,S=xt(r.outShape,n),k=S.values,I=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],T=r.outShape[2]*r.outShape[3]*r.outShape[4],R=r.outShape[3]*r.outShape[4],_=r.outShape[4];for(let D=0;D<r.batchSize;++D){const L=D*I,V=D*s[0];for(let U=0;U<r.inChannels;++U)for(let j=0;j<r.outDepth;++j){const q=j*i-y;let J=q;for(;J<0;)J+=l;const te=Math.min(r.inDepth,d+q),le=L+j*T;for(let K=0;K<r.outHeight;++K){const re=K*a-x;let pe=re;for(;pe<0;)pe+=c;const he=Math.min(r.inHeight,f+re),xe=le+K*R;for(let Ce=0;Ce<r.outWidth;++Ce){const Ee=Ce*u-v;let Ie=Ee;for(;Ie<0;)Ie+=h;const ke=Math.min(r.inWidth,m+Ee),Ae=xe+Ce*_;let Ke=w,je=0,rt=0;for(let Et=J;Et<te;Et+=l){const lt=V+Et*s[1];for(let at=pe;at<he;at+=c){const Lt=lt+at*s[2];for(let qt=Ie;qt<ke;qt+=h){const Ft=Lt+qt*s[3],Zt=t[Ft+U];if(o==="max"&&Zt>Ke?Ke=Zt:o==="avg"&&(je+=Zt,rt++),isNaN(Ke))break}if(isNaN(Ke))break}if(isNaN(Ke))break}const tt=Ae+U;k[tt]=o==="avg"?je/Math.max(rt,1):Ke}}}}return S}function p2e(t,e){const n=xt(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,a=e.dilationHeight,u=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,f=e.padInfo.top,m=e.padInfo.left;for(let y=0;y<e.batchSize;++y)for(let x=0;x<e.inChannels;++x)for(let v=0;v<e.outDepth;++v){const w=v*s-d;let S=w;for(;S<0;)S+=i;const k=Math.min(e.inDepth,l+w);for(let I=0;I<e.outHeight;++I){const T=I*r-f;let R=T;for(;R<0;)R+=a;const _=Math.min(e.inHeight,c+T);for(let D=0;D<e.outWidth;++D){const L=D*o-m;let V=L;for(;V<0;)V+=u;const U=Math.min(e.inWidth,h+L);let j=Number.NEGATIVE_INFINITY,q=-1;for(let J=S;J<k;J+=i){const te=J-w;for(let le=R;le<_;le+=a){const K=le-T;for(let re=V;re<U;re+=u){const pe=re-L,he=t.get(y,J,le,re,x);he>=j&&(j=he,q=te*c*h+K*c+pe)}}}n.set(q,y,v,I,D,x)}}}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f2e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;Ze(r,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=s,l=1;O(Ss(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);const c=Js(r.shape,o,i,l,a,u);let h;if(c.filterWidth===1&&c.filterHeight===1&&kt(c.inShape,c.outShape))h=ka({inputs:{x:r},backend:n});else{const d=n.data.get(r.dataId).values,f=et(r.shape),m=JE(d,r.shape,r.dtype,f,c,"avg");h=n.makeTensorInfo(c.outShape,r.dtype,m.values)}return h}const m2e={kernelName:wy,backendName:"cpu",kernelFunc:f2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g2e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=s;Ze(r,"avgPool3d");const c=Lo(r.shape,o,i,1,a,u,l),h=n.data.get(r.dataId).values,d=vH(h,r.shape,r.dtype,et(r.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}const y2e={kernelName:by,backendName:"cpu",kernelFunc:g2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x2e(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o}=e,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=s;Ze([r,o],"avgPool3DGrad");const c=Lo(o.shape,i,a,1,u,l),h=c.strideDepth,d=c.strideHeight,f=c.strideWidth,m=c.filterDepth,y=c.filterHeight,x=c.filterWidth,v=c.dilationDepth,w=c.dilationHeight,S=c.dilationWidth,k=c.effectiveFilterDepth,I=c.effectiveFilterHeight,T=c.effectiveFilterWidth,R=k-1-c.padInfo.front,_=T-1-c.padInfo.left,D=I-1-c.padInfo.top,L=xt(o.shape,"float32"),V=1/(m*y*x),U=n.bufferSync(r);for(let j=0;j<c.batchSize;++j)for(let q=0;q<c.inChannels;++q)for(let J=0;J<c.inDepth;++J)for(let te=0;te<c.inHeight;++te)for(let le=0;le<c.inWidth;++le){const K=J-R,re=te-D,pe=le-_;let he=0;for(let xe=0;xe<k;xe+=v){const Ce=(K+xe)/h;if(!(Ce<0||Ce>=c.outDepth||Math.floor(Ce)!==Ce))for(let Ee=0;Ee<I;Ee+=w){const Ie=(re+Ee)/d;if(!(Ie<0||Ie>=c.outHeight||Math.floor(Ie)!==Ie))for(let ke=0;ke<T;ke+=S){const Ae=(pe+ke)/f;if(Ae<0||Ae>=c.outWidth||Math.floor(Ae)!==Ae)continue;const Ke=U.get(j,Ce,Ie,Ae,q);he+=Ke}}}L.set(he*V,j,J,te,le,q)}return n.makeTensorInfo(L.shape,L.dtype,L.values)}const v2e={kernelName:Hw,backendName:"cpu",kernelFunc:x2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w2e(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o}=e,i=o;Ze([r,o],"avgPoolGrad");const{filterSize:a,strides:u,pad:l}=s,c=Js(i.shape,a,u,1,l),h=c.strideHeight,d=c.strideWidth,f=c.filterHeight,m=c.filterWidth,y=c.dilationHeight,x=c.dilationWidth,v=c.effectiveFilterHeight,w=c.effectiveFilterWidth,S=w-1-c.padInfo.left,k=v-1-c.padInfo.top,I=xt(i.shape,"float32"),T=1/(f*m),R=n.data.get(r.dataId).values,_=xt(r.shape,"float32",R);for(let D=0;D<c.batchSize;++D)for(let L=0;L<c.inChannels;++L)for(let V=0;V<c.inHeight;++V)for(let U=0;U<c.inWidth;++U){const j=V-k,q=U-S;let J=0;for(let te=0;te<v;te+=y){const le=(j+te)/h;if(!(le<0||le>=c.outHeight||Math.floor(le)!==le))for(let K=0;K<w;K+=x){const re=(q+K)/d;if(re<0||re>=c.outWidth||Math.floor(re)!==re)continue;const pe=_.get(D,le,re,L);J+=pe}}I.set(J*T,D,V,U,L)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}const b2e={kernelName:Gw,backendName:"cpu",kernelFunc:w2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S2e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,scale:o,offset:i,mean:a,variance:u}=e;O(a.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Ze([r,a,u,o,i],"batchNorm");let{varianceEpsilon:l}=s;l==null&&(l=.001);const c=n.data.get(r.dataId).values,h=n.data.get(a.dataId).values,d=n.data.get(u.dataId).values,f=o?n.data.get(o.dataId).values:new Float32Array([1]),m=i?n.data.get(i.dataId).values:new Float32Array([0]),y=new Float32Array(c.length),x=m.length,v=f.length,w=d.length,S=h.length;let k=0,I=0,T=0,R=0;for(let _=0;_<c.length;++_)y[_]=m[k++]+(c[_]-h[I++])*f[T++]/Math.sqrt(d[R++]+l),k>=x&&(k=0),I>=S&&(I=0),T>=v&&(T=0),R>=w&&(R=0);return n.makeTensorInfo(r.shape,r.dtype,y)}const C2e={kernelName:Py,backendName:"cpu",kernelFunc:S2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k2e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:o,crops:i}=s;Ze([r],"batchToSpaceND");const a=o.reduce((v,w)=>v*w),u=Sh(r.shape,o,a),l=Ch(u.length,o.length),c=kh(r.shape,o,a),h=xS(i,o.length),d=vS(c,i,o.length),f=wn({inputs:{x:r},backend:n,attrs:{shape:u}}),m=Lr({inputs:{x:f},backend:n,attrs:{perm:l}}),y=wn({inputs:{x:m},backend:n,attrs:{shape:c}}),x=lh({inputs:{x:y},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),x}const I2e={kernelName:Cy,backendName:"cpu",kernelFunc:k2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $2e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:o}=e,{size:i}=s,a=n.data.get(r.dataId).values,u=n.data.get(o.dataId).values,l=CE(a,u,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,l)}const N2e={kernelName:jw,backendName:"cpu",kernelFunc:$2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T2e(t){const{inputs:e,backend:n}=t,{s0:s,s1:r}=e,o=n.data.get(s.dataId).values,i=n.data.get(r.dataId).values,a=ut(Array.from(o),Array.from(i));return n.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const E2e={kernelName:Xw,backendName:"cpu",kernelFunc:T2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R2e=sn(zp,(t,e)=>{const n=e;return t>n.clipValueMax?n.clipValueMax:t<n.clipValueMin?n.clipValueMin:t}),A2e={kernelName:zp,backendName:"cpu",kernelFunc:R2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _2e=t=>{const{x:e}=t.inputs,n=t.backend,s=new Float32Array(ie(e.shape)),r=n.data.get(e.dataId),o=r.complexTensorInfos.real,i=r.complexTensorInfos.imag,a=n.data.get(o.dataId).values,u=n.data.get(i.dataId).values;for(let l=0;l<a.length;l++){const c=a[l],h=u[l];s[l]=Math.hypot(c,h)}return n.makeOutput(s,e.shape,"float32")},D2e={kernelName:ky,backendName:"cpu",kernelFunc:_2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yp(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.data.get(s.dataId).complexTensorInfos.imag,o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}const P2e={kernelName:pb,backendName:"cpu",kernelFunc:yp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xp(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s,o=vt(r,e[0].shape)[0],i=e.map(y=>y.shape);mS(i,o);let a=Dr(e.map(y=>y.shape),o);if(ie(a)===0)return n.makeTensorInfo(a,e[0].dtype,[]);const u=e.filter(y=>ie(y.shape)>0);if(u.length===1)return ka({inputs:{x:u[0]},backend:n});if(u[0].dtype==="complex64"){const y=u.map(k=>uh({inputs:{input:k},backend:n})),x=u.map(k=>yp({inputs:{input:k},backend:n})),v=xp({inputs:y,backend:n,attrs:{axis:o}}),w=xp({inputs:x,backend:n,attrs:{axis:o}}),S=Jr({inputs:{real:v,imag:w},backend:n});return y.forEach(k=>n.disposeIntermediateTensorInfo(k)),x.forEach(k=>n.disposeIntermediateTensorInfo(k)),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),S}const l=u.map(y=>{const v=[-1,ie(y.shape.slice(o))];return wn({inputs:{x:y},backend:n,attrs:{shape:v}})}),c=l.map(y=>({vals:n.data.get(y.dataId).values,shape:y.shape}));a=Dr(l.map(y=>y.shape),1);const h=l[0].shape[0]===1,d=b4(c,a,e[0].dtype,h),f=Dr(u.map(y=>y.shape),o),m=n.makeTensorInfo(f,e[0].dtype,d);return l.forEach(y=>n.disposeIntermediateTensorInfo(y)),m}const F2e={kernelName:Iy,backendName:"cpu",kernelFunc:xp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wH(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o}=e,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=s;Ze([r,o],"conv2d");const h=fo(u),d=bn(r.shape,o.shape,i,l,a,c,!1,h),f=d.filterHeight,m=d.filterWidth,y=d.dilationHeight,x=d.dilationWidth,v=d.padInfo.left,w=d.padInfo.top,S=d.dataFormat==="channelsLast",k=new ys(d.outShape,r.dtype),I=et(r.shape),T=et(o.shape),R=I[0],_=S?I[1]:I[2],D=S?I[2]:1,L=S?1:I[1],V=k.strides[0],U=S?k.strides[1]:k.strides[2],j=S?k.strides[2]:1,q=S?1:k.strides[1],J=n.data.get(r.dataId).values,te=n.data.get(o.dataId).values,le=k.values;for(let K=0;K<d.batchSize;++K){const re=K*R,pe=K*V;for(let he=0;he<d.outHeight;++he){const xe=pe+he*U,Ce=he*d.strideHeight-w;for(let Ee=0;Ee<f;++Ee){const Ie=Ce+Ee*y;if(Ie<0||Ie>=d.inHeight)continue;const ke=Ee*T[0],Ae=re+Ie*_;for(let Ke=0;Ke<d.outWidth;++Ke){const je=xe+Ke*j,rt=Ke*d.strideWidth-v;for(let tt=0;tt<m;++tt){const Et=rt+tt*x;if(Et<0||Et>=d.inWidth)continue;const lt=ke+tt*T[1],at=Ae+Et*D;let Lt=lt;for(let qt=0;qt<d.inChannels;++qt){const Ft=J[at+qt*L];for(let Zt=0;Zt<d.outChannels;++Zt)le[je+Zt*q]+=Ft*te[Lt+Zt];Lt+=d.outChannels}}}}}}return n.makeTensorInfo(k.shape,k.dtype,le)}const O2e={kernelName:$y,backendName:"cpu",kernelFunc:wH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L2e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:o}=e,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=s;Ze([r,o],"conv2dBackpropFilter");const h=fo(u),d=bn(r.shape,c,i,1,a,l,!1,h),{strideHeight:f,strideWidth:m,filterHeight:y,filterWidth:x}=d,v=d.dataFormat==="channelsLast",w=new ys(d.filterShape,"float32"),S=d.padInfo.left,k=d.padInfo.top,I=n.data.get(r.dataId).values,T=n.data.get(o.dataId).values,R=new ys(r.shape,r.dtype,I),_=new ys(o.shape,o.dtype,T);for(let D=0;D<y;++D){const L=Math.max(0,Math.ceil((k-D)/f)),V=Math.min(d.outHeight,(d.inHeight+k-D)/f);for(let U=0;U<x;++U){const j=Math.max(0,Math.ceil((S-U)/m)),q=Math.min(d.outWidth,(d.inWidth+S-U)/m);for(let J=0;J<d.inChannels;++J)for(let te=0;te<d.outChannels;++te){let le=0;for(let K=0;K<d.batchSize;++K)for(let re=L;re<V;++re){const pe=D+re*f-k;for(let he=j;he<q;++he){const xe=U+he*m-S;v?le+=R.get(K,pe,xe,J)*_.get(K,re,he,te):le+=R.get(K,J,pe,xe)*_.get(K,te,re,he)}}w.set(le,D,U,J,te)}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}const M2e={kernelName:Yw,backendName:"cpu",kernelFunc:L2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z2e(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:o}=e,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=s;Ze([r,o],"conv2dBackpropInput");const h=et(o.shape),d=et(r.shape);let f=fo(l);const m=bn(i,o.shape,a,1,u,c,!1,f),y=new ys(m.inShape,"float32"),x=y.values,v=n.data.get(r.dataId).values,w=n.data.get(o.dataId).values,[S,k,I]=h,{batchSize:T,filterHeight:R,filterWidth:_,inChannels:D,inHeight:L,inWidth:V,outChannels:U,outHeight:j,outWidth:q,strideHeight:J,strideWidth:te}=m;f=m.dataFormat;const le=R-1-m.padInfo.top,K=_-1-m.padInfo.left,re=f==="channelsLast",pe=y.strides[0],he=re?y.strides[1]:y.strides[2],xe=re?y.strides[2]:1,Ce=re?1:y.strides[1],Ee=d[0],Ie=re?d[1]:d[2],ke=re?d[2]:1,Ae=re?1:d[1];for(let Ke=0;Ke<T;++Ke)for(let je=0;je<D;++je)for(let rt=0;rt<L;++rt){const tt=rt-le,Et=Math.max(0,Math.ceil(tt/J)),lt=Math.min(j,(R+tt)/J);for(let at=0;at<V;++at){const Lt=at-K,qt=Math.max(0,Math.ceil(Lt/te)),Ft=Math.min(q,(_+Lt)/te);let Zt=0;for(let yn=Et;yn<lt;++yn){const Mn=yn*J-tt;for(let zn=qt;zn<Ft;++zn){const vr=zn*te-Lt,rs=Ee*Ke+Ie*yn+ke*zn,Ps=S*(R-1-Mn)+k*(_-1-vr)+I*je;for(let wr=0;wr<U;++wr){const Fs=v[rs+Ae*wr],Gs=w[Ps+wr];Zt+=Fs*Gs}}}const Wr=pe*Ke+he*rt+xe*at+Ce*je;x[Wr]=Zt}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}const B2e={kernelName:Ny,backendName:"cpu",kernelFunc:z2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V2e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o}=e,{strides:i,pad:a,dilations:u}=s;Ze([r,o],"conv3d");const l=Qi(r.shape,o.shape,i,u,a),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:f,dilationHeight:m,dilationWidth:y,padInfo:x}=l,v=x.front,w=x.left,S=x.top,k=new ys(l.outShape,r.dtype),I=n.data.get(r.dataId).values,T=n.data.get(o.dataId).values,R=k.values,_=et(r.shape),D=et(o.shape);for(let L=0;L<l.batchSize;++L){const V=L*_[0],U=L*k.strides[0];for(let j=0;j<l.outDepth;++j){const q=U+j*k.strides[1],J=j*l.strideDepth-v;for(let te=0;te<c;++te){const le=J+te*f;if(le<0||le>=l.inDepth)continue;const K=te*D[0],re=V+le*_[1];for(let pe=0;pe<l.outHeight;++pe){const he=q+pe*k.strides[2],xe=pe*l.strideHeight-S;for(let Ce=0;Ce<h;++Ce){const Ee=xe+Ce*m;if(Ee<0||Ee>=l.inHeight)continue;const Ie=K+Ce*D[1],ke=re+Ee*_[2];for(let Ae=0;Ae<l.outWidth;++Ae){const Ke=he+Ae*l.outChannels,je=Ae*l.strideWidth-w;for(let rt=0;rt<d;++rt){const tt=je+rt*y;if(tt<0||tt>=l.inWidth)continue;const Et=Ie+rt*D[2],lt=ke+tt*l.inChannels;let at=Et;for(let Lt=0;Lt<l.inChannels;++Lt){const qt=I[lt+Lt];for(let Ft=0;Ft<l.outChannels;++Ft)R[Ke+Ft]+=qt*T[at+Ft];at+=l.outChannels}}}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const W2e={kernelName:Ty,backendName:"cpu",kernelFunc:V2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U2e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:o}=e,{strides:i,pad:a,filterShape:u}=s;Ze([r,o],"conv3dBackpropFilterV2");const l=et(r.shape),c=et(o.shape),h=Qi(r.shape,u,i,1,a),d=h.strideDepth,f=h.strideHeight,m=h.strideWidth,y=h.filterDepth,x=h.filterHeight,v=h.filterWidth,w=new ys(h.filterShape,"float32"),S=w.values,[k,I,T,R]=w.strides,_=n.data.get(o.dataId).values,[D,L,V,U]=c,j=n.data.get(r.dataId).values,[q,J,te,le]=l,K=h.padInfo.front,re=h.padInfo.left,pe=h.padInfo.top;for(let he=0;he<y;++he){const xe=Math.max(0,Math.ceil((K-he)/d)),Ce=Math.min(h.outDepth,(h.inDepth+K-he)/d),Ee=he*k;for(let Ie=0;Ie<x;++Ie){const ke=Math.max(0,Math.ceil((pe-Ie)/f)),Ae=Math.min(h.outHeight,(h.inHeight+pe-Ie)/f),Ke=Ie*I+Ee;for(let je=0;je<v;++je){const rt=Math.max(0,Math.ceil((re-je)/m)),tt=Math.min(h.outWidth,(h.inWidth+re-je)/m),Et=je*T+Ke;for(let lt=0;lt<h.inChannels;++lt){const at=lt*R+Et;for(let Lt=0;Lt<h.outChannels;++Lt){let qt=0;for(let Ft=0;Ft<h.batchSize;++Ft){const Zt=Ft*q,Wr=Ft*D;for(let yn=xe;yn<Ce;++yn){const zn=(he+yn*d-K)*J+Zt,vr=yn*L+Wr;for(let rs=ke;rs<Ae;++rs){const wr=(Ie+rs*f-pe)*te+zn,Fs=rs*V+vr;for(let Gs=rt;Gs<tt;++Gs){const _a=(je+Gs*m-re)*le+wr,Ji=Gs*U+Fs;qt+=j[_a+lt]*_[Ji+Lt]}}}}S[at+Lt]=qt}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}const G2e={kernelName:Qw,backendName:"cpu",kernelFunc:U2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H2e(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:o}=e,{pad:i,strides:a,inputShape:u}=s;Ze([r],"conv3dBackpropInputV2");const l=et(r.shape),c=et(o.shape),h=Qi(u,o.shape,a,1,i),d=new ys(h.inShape,"float32"),f=d.values,[m,y,x,v]=d.strides,w=n.data.get(r.dataId).values,[S,k,I,T]=l,R=n.data.get(o.dataId).values,[_,D,L,V]=c,{batchSize:U,filterDepth:j,filterHeight:q,filterWidth:J,inChannels:te,inDepth:le,inHeight:K,inWidth:re,outChannels:pe,outDepth:he,outHeight:xe,outWidth:Ce,strideDepth:Ee,strideHeight:Ie,strideWidth:ke}=h,Ae=j-1-h.padInfo.front,Ke=q-1-h.padInfo.top,je=J-1-h.padInfo.left;for(let rt=0;rt<U;++rt)for(let tt=0;tt<te;++tt)for(let Et=0;Et<le;++Et){const lt=Et-Ae,at=Math.max(0,Math.ceil(lt/Ee)),Lt=Math.min(he,(j+lt)/Ee);for(let qt=0;qt<K;++qt){const Ft=qt-Ke,Zt=Math.max(0,Math.ceil(Ft/Ie)),Wr=Math.min(xe,(q+Ft)/Ie);for(let yn=0;yn<re;++yn){const Mn=yn-je,zn=Math.max(0,Math.ceil(Mn/ke)),vr=Math.min(Ce,(J+Mn)/ke);let rs=0;for(let Ps=at;Ps<Lt;++Ps){const wr=Ps*Ee-lt;for(let Fs=Zt;Fs<Wr;++Fs){const Gs=Fs*Ie-Ft;for(let Bo=zn;Bo<vr;++Bo){const _a=Bo*ke-Mn,Ji=S*rt+k*Ps+I*Fs+T*Bo,$u=_*(j-1-wr)+D*(q-1-Gs)+L*(J-1-_a)+V*tt;for(let Ur=0;Ur<pe;++Ur){const Da=w[Ji+Ur],Nu=R[$u+Ur];rs+=Da*Nu}}}}f[m*rt+y*Et+x*qt+v*yn+tt]=rs}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}const j2e={kernelName:Zw,backendName:"cpu",kernelFunc:H2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K2e=sn(Bp,t=>Math.cos(t)),X2e={kernelName:Bp,backendName:"cpu",kernelFunc:K2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q2e=sn(Vp,t=>Math.cosh(t)),Y2e={kernelName:Vp,backendName:"cpu",kernelFunc:q2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q2e(t){const{inputs:e,backend:n,attrs:s}=t,{image:r,boxes:o,boxInd:i}=e,{cropSize:a,method:u,extrapolationValue:l}=s,[c,h,d,f]=r.shape,m=o.shape[0],[y,x]=a,v=xt([m,y,x,f],"float32"),w=n.data.get(o.dataId).values,S=n.data.get(i.dataId).values,k=n.data.get(r.dataId).values,I=et(r.shape),T=et(v.shape);for(let R=0;R<m;R++){const _=R*4,D=w[_],L=w[_+1],V=w[_+2],U=w[_+3],j=S[R];if(j>=c)continue;const q=y>1?(V-D)*(h-1)/(y-1):0,J=x>1?(U-L)*(d-1)/(x-1):0;for(let te=0;te<y;te++){const le=y>1?D*(h-1)+te*q:.5*(D+V)*(h-1);if(le<0||le>h-1){for(let K=0;K<x;K++)for(let re=0;re<f;re++){const pe=re+K*T[2]+te*T[1]+R*T[0];v.values[pe]=l}continue}if(u==="bilinear"){const K=Math.floor(le),re=Math.ceil(le),pe=le-K;for(let he=0;he<x;he++){const xe=x>1?L*(d-1)+he*J:.5*(L+U)*(d-1);if(xe<0||xe>d-1){for(let ke=0;ke<f;ke++){const Ae=ke+he*T[2]+te*T[1]+R*T[0];v.values[Ae]=l}continue}const Ce=Math.floor(xe),Ee=Math.ceil(xe),Ie=xe-Ce;for(let ke=0;ke<f;ke++){let Ae=ke+Ce*I[2]+K*I[1]+j*I[0];const Ke=k[Ae];Ae=ke+Ee*I[2]+K*I[1]+j*I[0];const je=k[Ae];Ae=ke+Ce*I[2]+re*I[1]+j*I[0];const rt=k[Ae];Ae=ke+Ee*I[2]+re*I[1]+j*I[0];const tt=k[Ae],Et=Ke+(je-Ke)*Ie,lt=rt+(tt-rt)*Ie;Ae=ke+he*T[2]+te*T[1]+R*T[0],v.values[Ae]=Et+(lt-Et)*pe}}}else for(let K=0;K<x;++K){const re=x>1?L*(d-1)+K*J:.5*(L+U)*(d-1);if(re<0||re>d-1){for(let xe=0;xe<f;xe++){const Ce=xe+K*T[2]+te*T[1]+R*T[0];v.values[Ce]=l}continue}const pe=Math.round(re),he=Math.round(le);for(let xe=0;xe<f;xe++){const Ce=xe+pe*I[2]+he*I[1]+j*I[0],Ee=xe+K*T[2]+te*T[1]+R*T[0];v.values[Ee]=k[Ce]}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}const Z2e={kernelName:eb,backendName:"cpu",kernelFunc:Q2e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J2e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,exclusive:i,reverse:a}=s;Ze(r,"cumprod");const u=cn([o],r.shape.length);let l=r;u!=null&&(l=Lr({inputs:{x:r},backend:n,attrs:{perm:u}}));const c=Sn(1,r.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);const h=_s(l.dtype,"int32"),d=iT(ie(l.shape),h),f=n.data.get(l.dataId).values,m=l.shape[l.shape.length-1],y=a?(v,w)=>v+m-w-1:(v,w)=>v+w;for(let v=0;v<f.length;v+=m)for(let w=0;w<m;w++){const S=y(v,w);if(w===0)d[S]=i?1:f[S];else{const k=y(v,w-1);d[S]=i?f[k]*d[k]:f[S]*d[k]}}const x=n.makeTensorInfo(l.shape,h,d);if(u!=null){const v=Ta(u),w=Lr({inputs:{x},backend:n,attrs:{perm:v}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(l),w}return x}const eke={kernelName:Jw,backendName:"cpu",kernelFunc:J2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tke(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,exclusive:i,reverse:a}=s;Ze(r,"cumsum");const u=cn([o],r.shape.length);let l=r;u!=null&&(l=Lr({inputs:{x:r},backend:n,attrs:{perm:u}}));const c=Sn(1,r.shape.length)[0];if(c!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${c}`);const h=_s(l.dtype,"int32"),d=Vs(ie(l.shape),h),f=n.data.get(l.dataId).values,m=l.shape[l.shape.length-1],y=a?(v,w)=>v+m-w-1:(v,w)=>v+w;for(let v=0;v<f.length;v+=m)for(let w=0;w<m;w++){const S=y(v,w);if(w===0)d[S]=i?0:f[S];else{const k=y(v,w-1);d[S]=i?f[k]+d[k]:f[S]+d[k]}}const x=n.makeTensorInfo(l.shape,h,d);if(u!=null){const v=Ta(u),w=Lr({inputs:{x},backend:n,attrs:{perm:v}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(l),w}return x}const nke={kernelName:Ey,backendName:"cpu",kernelFunc:tke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ske(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:o}=e,{size:i,binaryOutput:a}=s;if(r.shape.length===1){const u=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,c=CE(u,l,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,c)}else if(r.shape.length===2){const u=n.bufferSync(r),l=n.bufferSync(o),c=x4(u,l,i,a);return n.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const rke={kernelName:tb,backendName:"cpu",kernelFunc:ske};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oke(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockSize:o,dataFormat:i}=s;O(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const a=r.shape[0],u=r.shape[1],l=r.shape[2],c=r.shape[3],h=u*o,d=l*o,f=c/(o*o),m=n.data.get(r.dataId).values,y=new Float32Array(a*h*d*f);let x=0;for(let v=0;v<a;++v)for(let w=0;w<h;++w){const S=Math.floor(w/o),k=w%o;for(let I=0;I<d;++I){const T=Math.floor(I/o),R=I%o,_=(k*o+R)*f;for(let D=0;D<f;++D){const V=D+_+c*(T+l*(S+u*v));y[x++]=m[V]}}}return n.makeTensorInfo([a,h,d,f],r.dtype,y)}const ike={kernelName:nb,backendName:"cpu",kernelFunc:oke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bH(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o}=e,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=s;Ze([r,o],"depthwiseConv2DNative");const c=et(r.shape),h=et(o.shape);let d=u;d==null&&(d=[1,1]),O(Ss(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);const f=bn(r.shape,o.shape,i,d,a,l,!0),{filterHeight:m,filterWidth:y,dilationHeight:x,dilationWidth:v,padInfo:w}=f,S=w.left,k=w.top,I=f.outChannels/f.inChannels,T=new ys(f.outShape,r.dtype),R=n.data.get(r.dataId).values,_=n.data.get(o.dataId).values,D=T.values;for(let L=0;L<f.batchSize;++L){const V=L*c[0],U=L*T.strides[0];for(let j=0;j<f.outHeight;++j){const q=U+j*T.strides[1],J=j*f.strideHeight-k;for(let te=0;te<m;++te){const le=J+te*x;if(le<0||le>=f.inHeight)continue;const K=te*h[0],re=V+le*c[1];for(let pe=0;pe<f.outWidth;++pe){const he=q+pe*T.strides[2],xe=pe*f.strideWidth-S;for(let Ce=0;Ce<y;++Ce){const Ee=xe+Ce*v;if(Ee<0||Ee>=f.inWidth)continue;const Ie=K+Ce*h[1],ke=re+Ee*f.inChannels;let Ae=he,Ke=Ie;for(let je=0;je<f.inChannels;++je){const rt=R[ke+je];for(let tt=0;tt<I;++tt)D[Ae+tt]+=rt*_[Ke+tt];Ae+=I,Ke+=I}}}}}}return n.makeTensorInfo(T.shape,T.dtype,T.values)}const ake={kernelName:Ry,backendName:"cpu",kernelFunc:bH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uke(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:o}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=s;Ze([r,o],"depthwiseConv2dNativeBackpropFilter");const h=bn(r.shape,c,i,a,u,l,!0),{strideHeight:d,strideWidth:f,filterHeight:m,filterWidth:y}=h,x=new ys(h.filterShape,"float32"),v=h.padInfo.left,w=h.padInfo.top,S=h.outChannels/h.inChannels,k=n.data.get(r.dataId).values,I=new ys(r.shape,r.dtype,k),T=n.data.get(o.dataId).values,R=new ys(o.shape,o.dtype,T);for(let _=0;_<m;++_){const D=Math.max(0,Math.ceil((w-_)/d)),L=Math.min(h.outHeight,(h.inHeight+w-_)/d);for(let V=0;V<y;++V){const U=Math.max(0,Math.ceil((v-V)/f)),j=Math.min(h.outWidth,(h.inWidth+v-V)/f);for(let q=0;q<h.outChannels;++q){const J=Math.trunc(q/S),te=q%S;let le=0;for(let K=0;K<h.batchSize;++K)for(let re=D;re<L;++re){const pe=_+re*d-w;for(let he=U;he<j;++he){const xe=V+he*f-v;le+=I.get(K,pe,xe,J)*R.get(K,re,he,q)}}x.set(le,_,V,J,te)}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}const lke={kernelName:sb,backendName:"cpu",kernelFunc:uke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cke(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:o}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=s;Ze([r,o],"depthwiseConv2DNativeBackpropInput");const h=et(r.shape),d=et(o.shape),f=bn(c,o.shape,i,a,u,l,!0),m=new ys(f.inShape,"float32"),y=m.values,[x,v,w]=m.strides,S=n.data.get(r.dataId).values,[k,I,T]=h,R=n.data.get(o.dataId).values,[_,D,L]=d,{batchSize:V,filterHeight:U,filterWidth:j,inChannels:q,inHeight:J,inWidth:te,outChannels:le,outHeight:K,outWidth:re,strideHeight:pe,strideWidth:he}=f,xe=U-1-f.padInfo.top,Ce=j-1-f.padInfo.left,Ee=le/q;for(let Ie=0;Ie<V;++Ie)for(let ke=0;ke<q;++ke)for(let Ae=0;Ae<J;++Ae){const Ke=Ae-xe,je=Math.max(0,Math.ceil(Ke/pe)),rt=Math.min(K,(U+Ke)/pe);for(let tt=0;tt<te;++tt){const Et=tt-Ce,lt=Math.max(0,Math.ceil(Et/he)),at=Math.min(re,(j+Et)/he);let Lt=0;for(let qt=je;qt<rt;++qt){const Ft=qt*pe-Ke;for(let Zt=lt;Zt<at;++Zt){const Wr=Zt*he-Et,yn=k*Ie+I*qt+T*Zt,Mn=_*(U-1-Ft)+D*(j-1-Wr)+L*ke;for(let zn=0;zn<Ee;++zn){const vr=ke*Ee+zn,rs=S[yn+vr],Ps=R[Mn+zn];Lt+=rs*Ps}}}y[x*Ie+v*Ae+w*tt+ke]=Lt}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}const hke={kernelName:rb,backendName:"cpu",kernelFunc:cke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dke(t){const{inputs:e,backend:n}=t,{x:s}=e,r=ie(s.shape),o=n.data.get(s.dataId).values,i=xt([r,r],s.dtype),a=i.values;for(let l=0;l<o.length;l++)a[l*r+l]=o[l];const u=[...s.shape,...s.shape];return n.makeTensorInfo(u,i.dtype,i.values)}const pke={kernelName:ob,backendName:"cpu",kernelFunc:dke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fke={kernelName:Ay,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r}=t,{strides:o,pad:i,dilations:a}=n,u=e,l=u.data.get(s.dataId).values,c=s.shape.length,h=u.data.get(r.dataId).values,d=r.shape.length,{batchSize:f,inHeight:m,inWidth:y,inChannels:x,outHeight:v,outWidth:w,padInfo:S,strideHeight:k,strideWidth:I,filterHeight:T,filterWidth:R,dilationHeight:_,dilationWidth:D,outShape:L}=zl(s.shape,r.shape,o,i,"NHWC",a),V=ie(L),U=L.length,j=Hn(s.dtype,V);for(let J=0;J<f;++J)for(let te=0;te<v;++te){const le=te*k-S.top;for(let K=0;K<w;++K){const re=K*I-S.left;for(let pe=0;pe<x;++pe){let he=Number.MIN_SAFE_INTEGER;for(let Ce=0;Ce<T;++Ce){const Ee=le+Ce*_;if(Ee>=0&&Ee<m)for(let Ie=0;Ie<R;++Ie){const ke=re+Ie*D;if(ke>=0&&ke<y){const Ae=xa([J,Ee,ke,pe],c,et(s.shape)),Ke=xa([Ce,Ie,pe],d,et(r.shape)),je=l[Ae]+h[Ke];je>he&&(he=je)}}}const xe=xa([J,te,K,pe],U,et(L));j[xe]=he}}}return{dataId:u.write(xh(j,s.dtype),L,s.dtype),shape:L,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mke={kernelName:Dv,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r,dy:o}=t,{strides:i,pad:a,dilations:u}=n,l=e,c=pi(s.shape,l.data.get(s.dataId).values),h=pi(r.shape,l.data.get(r.dataId).values),{batchSize:d,inHeight:f,inWidth:m,inChannels:y,outHeight:x,outWidth:v,padInfo:w,strideHeight:S,strideWidth:k,filterHeight:I,filterWidth:T,dilationHeight:R,dilationWidth:_,outShape:D}=zl(s.shape,r.shape,i,a,"NHWC",u);O(o.rank===D.length,()=>`Error in ${Dv}, dy must have the same rank as output ${D.length}, but got ${o.rank}`);const L=pi(D,l.data.get(o.dataId).values),V=kz(r.shape,r.dtype);for(let j=0;j<d;++j)for(let q=0;q<x;++q){const J=q*S-w.top;for(let te=0;te<v;++te){const le=te*k-w.left;for(let K=0;K<y;++K){let re=Number.MIN_SAFE_INTEGER,pe=0,he=0;for(let xe=0;xe<I;++xe){const Ce=J+xe*R;if(Ce>=0&&Ce<f)for(let Ee=0;Ee<T;++Ee){const Ie=le+Ee*_;if(Ie>=0&&Ie<m){const ke=c[j][Ce][Ie][K]+h[xe][Ee][K];ke>re&&(re=ke,pe=xe,he=Ee)}}}V[pe][he][K]+=L[j][q][te][K]}}}return{dataId:l.write(xh(V,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gke={kernelName:_v,backendName:"cpu",kernelFunc:({inputs:t,backend:e,attrs:n})=>{const{x:s,filter:r,dy:o}=t,{strides:i,pad:a,dilations:u}=n,l=e,c=pi(s.shape,l.data.get(s.dataId).values),h=pi(r.shape,l.data.get(r.dataId).values),{batchSize:d,inHeight:f,inWidth:m,inChannels:y,outHeight:x,outWidth:v,padInfo:w,strideHeight:S,strideWidth:k,filterHeight:I,filterWidth:T,dilationHeight:R,dilationWidth:_,outShape:D}=zl(s.shape,r.shape,i,a,"NHWC",u);O(o.rank===D.length,()=>`Error in ${_v}, dy must have the same rank as output ${D.length}, but got ${o.rank}`);const L=pi(D,l.data.get(o.dataId).values),V=kz(s.shape,s.dtype);for(let j=0;j<d;++j)for(let q=0;q<x;++q){const J=q*S-w.top;for(let te=0;te<v;++te){const le=te*k-w.left;for(let K=0;K<y;++K){let re=Number.MIN_SAFE_INTEGER,pe=J<0?0:J,he=le<0?0:le;for(let xe=0;xe<I;++xe){const Ce=J+xe*R;if(Ce>=0&&Ce<f)for(let Ee=0;Ee<T;++Ee){const Ie=le+Ee*_;if(Ie>=0&&Ie<m){const ke=c[j][Ce][Ie][K]+h[xe][Ee][K];ke>re&&(re=ke,pe=Ce,he=Ie)}}}V[j][pe][he][K]+=L[j][q][te][K]}}}return{dataId:l.write(xh(V,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yke(t){const{inputs:e,backend:n,attrs:s}=t,{image:r}=e,{canvas:o,options:i}=s,{contextOptions:a,imageOptions:u}=i||{},l=(u==null?void 0:u.alpha)||1,c=(a==null?void 0:a.contextType)||"2d";if(c!=="2d")throw new Error(`Context type ${a.contextType} is not supported by the CPU backend.`);const h=o.getContext(c,(a==null?void 0:a.contextAttributes)||{});if(h==null)throw new Error(`Could not get the context with ${c} type.`);const[d,f]=r.shape.slice(0,2),m=r.shape.length===2?1:r.shape[2],y=n.data.get(r.dataId).values,x=r.dtype==="float32"?255:1,v=new Uint8ClampedArray(f*d*4);for(let S=0;S<d*f;++S){const k=[0,0,0,255*l];for(let T=0;T<m;T++){const R=y[S*m+T];if(r.dtype==="float32"){if(R<0||R>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${R}.`)}else if(r.dtype==="int32"&&(R<0||R>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${R}.`);m===1?(k[0]=R*x,k[1]=R*x,k[2]=R*x):k[T]=R*x}const I=S*4;v[I+0]=Math.round(k[0]),v[I+1]=Math.round(k[1]),v[I+2]=Math.round(k[2]),v[I+3]=Math.round(k[3])}o.width=f,o.height=d;const w=new ImageData(v,f,d);return h.putImageData(w,0,0),r}const xke={kernelName:uT,backendName:"cpu",kernelFunc:yke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O0(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:i}=s;Ze(r,"sum");let a;r.dtype==="bool"?a=Il({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):a=ka({inputs:{x:r},backend:n});const u=a.shape.length,l=vt(o,a.shape),c=cn(l,u);let h=l,d=a;c!=null&&(d=Lr({inputs:{x:a},backend:n,attrs:{perm:c}}),h=Sn(h.length,u)),cs("sum",h,d.shape.length);const[f,m]=ts(d.shape,h),y=_s(d.dtype,"int32");let x=Hv(n,f,y);const v=ie(m),w=n.data.get(x.dataId).values,S=n.data.get(d.dataId).values;for(let k=0;k<w.length;++k){const I=k*v;let T=0;for(let R=0;R<v;++R)T+=S[I+R];w[k]=T}if(i){const k=qn(x.shape,l),I=x;x=wn({inputs:{x},backend:n,attrs:{shape:k}}),n.disposeIntermediateTensorInfo(I)}return n.disposeIntermediateTensorInfo(a),c!=null&&n.disposeIntermediateTensorInfo(d),x}const vke={kernelName:c0,backendName:"cpu",kernelFunc:O0};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wke(t){const{inputs:e,backend:n,attrs:s}=t,{equation:r}=s,o=e,{allDims:i,summedDims:a,idDims:u}=$S(r,o.length);TS(i.length,u,o);const{path:l,steps:c}=ES(a,u),h=c.length;let d=null,f=i.length;const m=[];for(let y=0;y<h;++y){for(const x of c[y]){const{permutationIndices:v,expandDims:w}=NS(f,u[x]);let S;RS(v)?S=o[x]:(S=Lr({inputs:{x:o[x]},backend:n,attrs:{perm:v}}),m.push(S));const k=S.shape.slice();for(let I=0;I<w.length;++I)k.splice(w[I],0,1);kt(S.shape,k)||(S=wn({inputs:{x:S},backend:n,attrs:{shape:k}}),m.push(S)),d===null?d=S:(d=OS({inputs:{a:S,b:d},backend:n}),m.push(d))}y<h-1&&(l[y]>=0&&(d=O0({inputs:{x:d},backend:n,attrs:{axis:l[y]-(i.length-f),keepDims:!1}}),m.push(d)),f--)}for(const y of m)y!==d&&n.disposeIntermediateTensorInfo(y);return d}const bke={kernelName:ib,backendName:"cpu",kernelFunc:wke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ske(t){const{inputs:e,backend:n}=t,{dy:s,y:r}=e;Ze([s,r],"eluGrad");const o=new Float32Array(ie(r.shape)),i=n.data.get(r.dataId).values,a=n.data.get(s.dataId).values;for(let u=0;u<i.length;++u){const l=i[u];l>=0?o[u]=a[u]:o[u]=a[u]*(l+1)}return n.makeTensorInfo(r.shape,"float32",o)}const Cke={kernelName:ab,backendName:"cpu",kernelFunc:Ske};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kke=wS,Ike=bS,$ke=SS,Nke=CS,Tke=kS,Eke=IS,Rke=sn(Gp,t=>{const e=Math.sign(t),n=Math.abs(t),s=1/(1+kke*n);return e*(1-((((Eke*s+Tke)*s+Nke)*s+$ke)*s+Ike)*s*Math.exp(-n*n))}),Ake={kernelName:Gp,backendName:"cpu",kernelFunc:Rke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iw(t){const{inputs:e,backend:n,attrs:s}=t,{input:r}=e,{dim:o}=s,i=r.shape.length,a=r.shape.slice();let u=o;return o<0&&(O(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+o+1),a.splice(u,0,1),wn({inputs:{x:r},backend:n,attrs:{shape:a}})}const _ke={kernelName:Dy,backendName:"cpu",kernelFunc:iw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dke=ns((t,e)=>t/e),eR=Cs(Wp,Dke),L$={kernelName:Wp,backendName:"cpu",kernelFunc:eR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SH(t,e,n){const s=t.shape,r=s[0],o=s[1],i=n.data.get(t.dataId),a=i.complexTensorInfos.real,u=i.complexTensorInfos.imag,l=[r,o],c=ie(l),h=ws("float32",c),d=ws("float32",c);for(let x=0;x<r;x++){const v=lh({inputs:{x:a},backend:n,attrs:{begin:[x,0],size:[1,o]}}),w=lh({inputs:{x:u},backend:n,attrs:{begin:[x,0],size:[1,o]}}),S=Jr({inputs:{real:v,imag:w},backend:n}),{real:k,imag:I}=Pke(S,e,n),T=Gi(k,I);for(let R=0;R<o;R++){const _=yE(T,R);h[x*o+R]=_.real,d[x*o+R]=_.imag}n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(S)}const f=n.makeTensorInfo(l,"float32",h),m=n.makeTensorInfo(l,"float32",d),y=Jr({inputs:{real:f,imag:m},backend:n});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),y}function Pke(t,e,n){const s=ie(t.shape),r=n.data.get(t.dataId),o=n.data.get(r.complexTensorInfos.real.dataId).values,i=n.data.get(r.complexTensorInfos.imag.dataId).values;if(Fke(s)){const a=M$(o,i,s,e,n),u=[t.shape[0],t.shape[1]];if(e){const l=n.makeTensorInfo(u,"float32",a.real),c=n.makeTensorInfo(u,"float32",a.imag),h=n.makeTensorInfo([],"float32",Ol(s,"float32")),d=ka({inputs:{x:h},backend:n}),f=L$.kernelFunc({inputs:{a:l,b:h},backend:n}),m=L$.kernelFunc({inputs:{a:c,b:d},backend:n}),y=n.data.get(f.dataId).values,x=n.data.get(m.dataId).values;return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),{real:y,imag:x}}return a}else{const a=Gi(o,i),u=Oke(a,s,e);return VV(u)}}function Fke(t){return(t&t-1)===0}function M$(t,e,n,s,r){if(n===1)return{real:t,imag:e};const o=Gi(t,e),i=n/2,a=WV(o),u=a.real,l=a.imag,c=[u.length],h=r.makeTensorInfo(c,"float32",u),d=r.makeTensorInfo(c,"float32",l),f=Jr({inputs:{real:h,imag:d},backend:r}),m=UV(o),y=m.real,x=m.imag,v=[y.length],w=r.makeTensorInfo(v,"float32",y),S=r.makeTensorInfo(v,"float32",x),k=Jr({inputs:{real:w,imag:S},backend:r}),I=M$(u,l,i,s,r),T=I.real,R=I.imag,_=[T.length],D=r.makeTensorInfo(_,"float32",T),L=r.makeTensorInfo(_,"float32",R),V=Jr({inputs:{real:D,imag:L},backend:r}),U=M$(y,x,i,s,r),j=U.real,q=U.imag,J=[j.length],te=r.makeTensorInfo(J,"float32",j),le=r.makeTensorInfo(J,"float32",q),K=Jr({inputs:{real:te,imag:le},backend:r}),re=HV(n,s),pe=[re.real.length],he=r.makeTensorInfo(pe,"float32",re.real),xe=r.makeTensorInfo(pe,"float32",re.imag),Ce=Jr({inputs:{real:he,imag:xe},backend:r}),Ee=OS({inputs:{a:Ce,b:K},backend:r}),Ie=fp({inputs:{a:V,b:Ee},backend:r}),ke=NE({inputs:{a:V,b:Ee},backend:r}),Ae=uh({inputs:{input:Ie},backend:r}),Ke=uh({inputs:{input:ke},backend:r}),je=yp({inputs:{input:Ie},backend:r}),rt=yp({inputs:{input:ke},backend:r}),tt=xp({inputs:[Ae,Ke],backend:r,attrs:{axis:0}}),Et=xp({inputs:[je,rt],backend:r,attrs:{axis:0}}),lt=r.data.get(tt.dataId).values,at=r.data.get(Et.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(S),r.disposeIntermediateTensorInfo(k),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(L),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(te),r.disposeIntermediateTensorInfo(le),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(he),r.disposeIntermediateTensorInfo(xe),r.disposeIntermediateTensorInfo(Ce),r.disposeIntermediateTensorInfo(Ee),r.disposeIntermediateTensorInfo(Ie),r.disposeIntermediateTensorInfo(ke),r.disposeIntermediateTensorInfo(Ae),r.disposeIntermediateTensorInfo(je),r.disposeIntermediateTensorInfo(Ke),r.disposeIntermediateTensorInfo(rt),r.disposeIntermediateTensorInfo(tt),r.disposeIntermediateTensorInfo(Et),{real:lt,imag:at}}function Oke(t,e,n){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let o=0,i=0;for(let a=0;a<e;a++){const u=jV(r*a,e,n),l=yE(t,a);o+=l.real*u.real-l.imag*u.imag,i+=l.real*u.imag+l.imag*u.real}n&&(o/=e,i/=e),GV(s,o,i,r)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lke(t){const{inputs:e,backend:n}=t,{input:s}=e,r=ie(s.shape),o=s.shape[s.shape.length-1],i=r/o,a=wn({inputs:{x:s},backend:n,attrs:{shape:[i,o]}}),u=SH(a,!1,n),l=wn({inputs:{x:u},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),l}const Mke={kernelName:ub,backendName:"cpu",kernelFunc:Lke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tR(t){const{backend:e,attrs:n}=t,{shape:s,value:r,dtype:o}=n,i=o||mh(r),a=Hn(i,ie(s));return Bke(a,r,i),e.makeTensorInfo(s,i,a)}const zke={kernelName:lb,backendName:"cpu",kernelFunc:tR};function Bke(t,e,n){t.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vke={kernelName:cb,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,r=n,o=ws(s.dtype,ie(s.shape)),[i,a,u,l]=s.shape,c=r.data.get(s.dataId).values;for(let d=0;d<i;d++){const f=d*u*a*l;for(let m=0;m<a;m++){const y=m*(u*l);for(let x=0;x<u;x++){const v=x*l;for(let w=0;w<l;w++){const S=Math.round(u-x-1),k=f+y+v+w;let I=c[k];if(S>=0&&S<u){const T=S*l,R=f+y+T+w;I=c[R]}o[k]=I}}}}return{dataId:r.write(o,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wke(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d,activation:f,leakyreluAlpha:m}=s;let y=wH({inputs:{x:r,filter:o},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const x=y;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){const v=wn({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});y=fp({inputs:{a:y,b:v},backend:n}),n.disposeIntermediateTensorInfo(v)}else y=fp({inputs:{a:y,b:i},backend:n});n.disposeIntermediateTensorInfo(x)}if(f){const x=y;if(c==="NCHW"&&f==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const v=wn({inputs:{x:a},backend:n,attrs:{shape:[a.shape[0],1,1]}});y=ow(n,y,f,v,m),n.disposeIntermediateTensorInfo(v)}else y=ow(n,y,f,a,m);n.disposeIntermediateTensorInfo(x)}return y}const Uke={kernelName:Vg,backendName:"cpu",kernelFunc:Wke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gke(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d,activation:f,leakyreluAlpha:m}=s;let y=bH({inputs:{x:r,filter:o},backend:n,attrs:{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d}});if(i){const x=y;y=fp({inputs:{a:y,b:i},backend:n}),n.disposeIntermediateTensorInfo(x)}if(f){const x=y;y=ow(n,y,f,a,m),n.disposeIntermediateTensorInfo(x)}return y}const Hke={kernelName:Wg,backendName:"cpu",kernelFunc:Gke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jke(t){const{inputs:e,backend:n}=t,{params:s,indices:r}=e,o=ie(s.shape),i=r.shape,a=i[i.length-1],[u,l,c,h]=hS(s,r);if(l===0)return n.makeTensorInfo(u,s.dtype,[]);const d=n.data.get(r.dataId).values,f=n.bufferSync(s),m=E4(d,f,s.dtype,l,a,c,h,s.shape,o);return n.makeTensorInfo(u,s.dtype,m.values)}const Kke={kernelName:hb,backendName:"cpu",kernelFunc:jke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xke(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,indices:o}=e,{axis:i,batchDims:a}=s;Ze([r,o],"gatherV2");const u=vt(i,r.shape)[0],l=n.data.get(o.dataId).values,c=r.shape[u];for(let k=0;k<l.length;++k){const I=l[k];O(I<=c-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${c-1}]`)}let h=a;a==null&&(h=0);const d=ie(o.shape),f=_S(r,o,u,h),m=wn({inputs:{x:r},backend:n,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),y=wn({inputs:{x:o},backend:n,attrs:{shape:[f.batchSize,d/f.batchSize]}}),x=[f.batchSize,f.outerSize,d/f.batchSize,f.sliceSize],v=n.bufferSync(y),w=n.bufferSync(m),S=R4(w,v,x);return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),n.makeTensorInfo(f.outputShape,S.dtype,S.values)}const qke={kernelName:Fy,backendName:"cpu",kernelFunc:Xke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yke(t){const{inputs:e,backend:n}=t,{input:s}=e,r=ie(s.shape),o=s.shape[s.shape.length-1],i=r/o,a=wn({inputs:{x:s},backend:n,attrs:{shape:[i,o]}}),u=SH(a,!0,n),l=wn({inputs:{x:u},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),l}const Qke={kernelName:db,backendName:"cpu",kernelFunc:Yke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zke=sn(Qp,t=>Number.isFinite(t)?1:0,"bool"),Jke={kernelName:Qp,backendName:"cpu",kernelFunc:Zke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eIe=sn(Zp,t=>Math.abs(t)===1/0?1:0,"bool"),tIe={kernelName:Zp,backendName:"cpu",kernelFunc:eIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nIe=sn(Jp,t=>Number.isNaN(t)?1:0,"bool"),sIe={kernelName:Jp,backendName:"cpu",kernelFunc:nIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rIe(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:o}=n,i=F4(s,r,o);return e.makeTensorInfo([i.length],"float32",i)}const oIe={kernelName:fb,backendName:"cpu",kernelFunc:rIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iIe=sn(tf,t=>Math.log1p(t)),aIe={kernelName:tf,backendName:"cpu",kernelFunc:iIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uIe=ns((t,e)=>t&&e),lIe=Cs(By,uIe,null,"bool"),cIe={kernelName:By,backendName:"cpu",kernelFunc:lIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hIe=sn(Vy,t=>t?0:1,"bool"),dIe={kernelName:Vy,backendName:"cpu",kernelFunc:hIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pIe=ns((t,e)=>t||e),fIe=Cs(Wy,pIe,null,"bool"),mIe={kernelName:Wy,backendName:"cpu",kernelFunc:fIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gIe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{depthRadius:o,bias:i,alpha:a,beta:u}=s;Ze(r,"LRN");const l=r.shape[3],c=l-1,h=n.data.get(r.dataId).values,d=ie(r.shape),f=new Float32Array(d);function m(y){const x=y%l;let v=y-x+Math.max(0,x-o);const w=y-x+Math.min(x+o,c);let S=0;for(;v<=w;v++){const k=h[v];S+=k*k}return S}for(let y=0;y<d;y++){const x=m(y),v=h[y]*Math.pow(i+a*x,-u);f[y]=v}return n.makeTensorInfo(r.shape,r.dtype,f)}const yIe={kernelName:Uy,backendName:"cpu",kernelFunc:gIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xIe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,y:o,dy:i}=e,{depthRadius:a,bias:u,alpha:l,beta:c}=s;Ze(i,"LRNGrad");const h=ie(i.shape),d=i.shape[3],f=n.data.get(i.dataId).values,m=n.data.get(r.dataId).values,y=n.data.get(o.dataId).values,x=new Float32Array(h),v=h;for(let w=0;w<v;w++){const S=w%d,k=w-S+Math.max(0,S-a),I=w-S+Math.min(d,S+a+1);let T=0;for(let R=k;R<I;R++)T+=Math.pow(m[R],2);T=l*T+u;for(let R=k;R<I;R++){let _=-2*l*c*m[R]*y[w]/T;w===R&&(_+=Math.pow(T,-c)),_*=f[w],x[R]+=_}}return n.makeTensorInfo(i.shape,r.dtype,x)}const vIe={kernelName:mb,backendName:"cpu",kernelFunc:xIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CH(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reductionIndices:o,keepDims:i}=s,a=n;let u=r.shape;const l=u.length,c=vt(o,u);let h=c;const d=cn(h,l);let f=a.data.get(r.dataId).values;if(d!=null){const k=new Array(l);for(let I=0;I<k.length;I++)k[I]=u[d[I]];f=IE(f,u,r.dtype,d,k),h=Sn(h.length,l),u=k}Ze(r,"max"),cs("max",h,l);const[m,y]=ts(u,h),x=ie(y),v=L4(f,x,m,r.dtype),w=a.write(v,m,r.dtype);let S=m;return i&&(S=qn(m,c)),{dataId:w,shape:S,dtype:r.dtype}}const wIe={kernelName:Gy,backendName:"cpu",kernelFunc:CH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bIe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;Ze(r,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=s,l=1;O(Ss(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);const c=Js(r.shape,o,i,l,a,u);let h;if(c.filterWidth===1&&c.filterHeight===1&&kt(c.inShape,c.outShape))h=ka({inputs:{x:r},backend:n});else{const d=n.data.get(r.dataId).values,f=et(r.shape),m=JE(d,r.shape,r.dtype,f,c,"max");h=n.makeTensorInfo(c.outShape,r.dtype,m.values)}return h}const SIe={kernelName:Hy,backendName:"cpu",kernelFunc:bIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CIe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=s;Ze(r,"maxPool3d");const c=Lo(r.shape,o,i,1,a,u,l),h=n.data.get(r.dataId).values,d=vH(h,r.shape,r.dtype,et(r.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}const kIe={kernelName:jy,backendName:"cpu",kernelFunc:CIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IIe(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o}=e,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=s;Ze([r,o],"maxPool3DGrad");const c=Lo(o.shape,i,a,1,u,l),h=n.bufferSync(o),d=p2e(h,c),f=c.strideDepth,m=c.strideHeight,y=c.strideWidth,x=c.dilationDepth,v=c.dilationHeight,w=c.dilationWidth,S=c.effectiveFilterDepth,k=c.effectiveFilterHeight,I=c.effectiveFilterWidth,T=S-1-c.padInfo.front,R=I-1-c.padInfo.left,_=k-1-c.padInfo.top,D=xt(o.shape,"float32"),L=n.bufferSync(r);for(let V=0;V<c.batchSize;++V)for(let U=0;U<c.inChannels;++U)for(let j=0;j<c.inDepth;++j)for(let q=0;q<c.inHeight;++q)for(let J=0;J<c.inWidth;++J){const te=j-T,le=q-_,K=J-R;let re=0;for(let pe=0;pe<S;pe+=x){const he=(te+pe)/f;if(!(he<0||he>=c.outDepth||Math.floor(he)!==he))for(let xe=0;xe<k;xe+=v){const Ce=(le+xe)/m;if(!(Ce<0||Ce>=c.outHeight||Math.floor(Ce)!==Ce))for(let Ee=0;Ee<I;Ee+=w){const Ie=(K+Ee)/y;if(Ie<0||Ie>=c.outWidth||Math.floor(Ie)!==Ie)continue;const ke=S*k*I-1-d.get(V,he,Ce,Ie,U),Ae=pe*k*I+xe*I+Ee,Ke=ke===Ae?1:0;if(Ke===0)continue;const je=L.get(V,he,Ce,Ie,U);re+=je*Ke}}}D.set(re,V,j,q,J,U)}return n.makeTensorInfo(D.shape,D.dtype,D.values)}const $Ie={kernelName:yb,backendName:"cpu",kernelFunc:IIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NIe(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o,output:i}=e,a=o;Ze([o,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=s,d=Js(a.shape,u,l,1,c,h),f=n.data.get(a.dataId).values,m=xt(d.outShape,a.dtype,xH(f,a.shape,a.dtype,d).values),y=d.strideHeight,x=d.strideWidth,v=d.dilationHeight,w=d.dilationWidth,S=d.effectiveFilterHeight,k=d.effectiveFilterWidth,I=k-1-d.padInfo.left,T=S-1-d.padInfo.top,R=xt(a.shape,"float32"),_=n.data.get(r.dataId).values,D=xt(r.shape,"float32",_);for(let L=0;L<d.batchSize;++L)for(let V=0;V<d.inChannels;++V)for(let U=0;U<d.inHeight;++U)for(let j=0;j<d.inWidth;++j){const q=U-T,J=j-I;let te=0;for(let le=0;le<S;le+=v){const K=(q+le)/y;if(!(K<0||K>=d.outHeight||Math.floor(K)!==K))for(let re=0;re<k;re+=w){const pe=(J+re)/x;if(pe<0||pe>=d.outWidth||Math.floor(pe)!==pe)continue;const he=S*k-1-m.get(L,K,pe,V),xe=le*k+re,Ce=he===xe?1:0;if(Ce===0)continue;const Ee=D.get(L,K,pe,V);te+=Ee*Ce}}R.set(te,L,U,j,V)}return n.makeTensorInfo(R.shape,R.dtype,R.values)}const TIe={kernelName:gb,backendName:"cpu",kernelFunc:NIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EIe(t,e,n,s,r){const o=et(e),i=JE(t,e,n,o,r,"max"),a=xH(t,e,n,r,!0,s);return[i.values,a.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RIe={kernelName:xb,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{filterSize:r,strides:o,pad:i,includeBatchInIndex:a}=e,u=n;Ze(s,"MaxPoolWithArgmax");const l=u.data.get(s.dataId).values,c=Js(s.shape,r,o,[1,1],i),[h,d]=EIe(l,s.shape,s.dtype,a,c),f=u.write(h,c.outShape,s.dtype),m=u.write(d,c.outShape,s.dtype);return[{dataId:f,shape:c.outShape,dtype:s.dtype},{dataId:m,shape:c.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AIe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:i}=s,a=vt(o,r.shape),l=ts(r.shape,a)[1],c=ie(l),h=[],d=n.makeTensorInfo([],"float32",new Float32Array([c]));h.push(d);const f=Il({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});h.push(f);const m=eR({inputs:{a:f,b:d},backend:n});h.push(m);const y=O0({inputs:{x:m},backend:n,attrs:{axis:o,keepDims:i}});return h.forEach(x=>n.disposeIntermediateTensorInfo(x)),y}const _Ie={kernelName:Ky,backendName:"cpu",kernelFunc:AIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DIe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:i}=s;Ze(r,"min");const a=vt(o,r.shape);let u=a;const l=cn(u,r.shape.length);let c=r;l!=null&&(c=Lr({inputs:{x:r},backend:n,attrs:{perm:l}}),u=Sn(u.length,r.shape.length)),cs("min",u,c.shape.length);const[h,d]=ts(c.shape,u),f=ie(d),m=Vs(ie(h),c.dtype),y=n.data.get(c.dataId).values;for(let v=0;v<m.length;++v){const w=v*f;let S=y[w];for(let k=0;k<f;++k){const I=y[w+k];(Number.isNaN(I)||I<S)&&(S=I)}m[v]=S}l!=null&&n.disposeIntermediateTensorInfo(c);const x=n.makeTensorInfo(h,c.dtype,m);if(i){const v=qn(h,a),w=wn({inputs:{x},backend:n,attrs:{shape:v}});return n.disposeIntermediateTensorInfo(x),w}return x}const PIe={kernelName:Xy,backendName:"cpu",kernelFunc:DIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FIe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:o,mode:i}=s;Ze(r,"mirrorPad");const a=o.map((S,k)=>S[0]+r.shape[k]+S[1]),u=o.map(S=>S[0]),l=o.map((S,k)=>S[0]+r.shape[k]),c=i==="reflect"?0:1,h=n.data.get(r.dataId).values,d=r.shape.length,f=et(r.shape),m=ie(a),y=a.length,x=et(a),v=ws(r.dtype,m);for(let S=0;S<m;S++){let k=Ep(S,y,x);for(let T=0;T<y;T++)k[T]<u[T]?k[T]=u[T]*2-k[T]-c:k[T]>=l[T]&&(k[T]=(l[T]-1)*2-k[T]+c);k=k.map((T,R)=>T-u[R]);const I=xa(k,d,f);v[S]=h[I]}return{dataId:n.write(v,a,r.dtype),shape:a,dtype:r.dtype}}const OIe={kernelName:qy,backendName:"cpu",kernelFunc:FIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LIe=ns((t,e)=>{const n=t%e;return t<0&&e<0||t>=0&&e>=0?n:(n+e)%e}),MIe=Cs(rf,LIe),zIe={kernelName:rf,backendName:"cpu",kernelFunc:MIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kH(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{dim:o}=s,i=r.shape.length;let a=o;if(a===-1&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);const u=vt([a],r.shape),l=CH({inputs:{x:r},backend:n,attrs:{reductionIndices:u,keepDims:!1}}),c=qn(l.shape,u),h=wn({inputs:{x:l},backend:n,attrs:{shape:c}}),d=NE({inputs:{a:r,b:h},backend:n}),f=I4({inputs:{x:d},backend:n}),m=O0({inputs:{x:f},backend:n,attrs:{axis:u,keepDims:!1}}),y=wn({inputs:{x:m},backend:n,attrs:{shape:c}}),x=eR({inputs:{a:f,b:y},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),x}const BIe={kernelName:p0,backendName:"cpu",kernelFunc:kH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VIe(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{numSamples:o,seed:i,normalized:a}=s;Ze(r,"multinomial");const u=a?r:kH({inputs:{logits:r},backend:n,attrs:{dim:-1}}),l=u.shape[0],c=u.shape[1],h=n.data.get(u.dataId).values,d=[l,o],f=Vs(ie(d),"int32");for(let m=0;m<l;++m){const y=m*c,x=new Float32Array(c-1);x[0]=h[y];for(let S=1;S<x.length;++S)x[S]=x[S-1]+h[y+S];const v=Jb.alea(i.toString()),w=m*o;for(let S=0;S<o;++S){const k=v();f[w+S]=x.length;for(let I=0;I<x.length;I++)if(k<x[I]){f[w+S]=I;break}}}return a||n.disposeIntermediateTensorInfo(u),n.makeTensorInfo(d,"int32",f)}const WIe={kernelName:vb,backendName:"cpu",kernelFunc:VIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UIe=lS;function GIe(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=s;Ze(r,"NonMaxSuppression");const l=n.data.get(r.dataId).values,c=n.data.get(o.dataId).values,{selectedIndices:h}=UIe(l,c,i,a,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}const HIe={kernelName:wb,backendName:"cpu",kernelFunc:GIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jIe=uE;function KIe(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=s;Ze(r,"NonMaxSuppressionPadded");const c=n.data.get(r.dataId).values,h=n.data.get(o.dataId).values,{selectedIndices:d,validOutputs:f}=jIe(c,h,i,a,u,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}const XIe={kernelName:lT,backendName:"cpu",kernelFunc:KIe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qIe=cS;function YIe(t){const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=s;Ze(r,"NonMaxSuppressionWithScore");const c=n.data.get(r.dataId).values,h=n.data.get(o.dataId).values,d=i,f=a,m=u,y=l,{selectedIndices:x,selectedScores:v}=qIe(c,h,d,f,m,y);return[n.makeTensorInfo([x.length],"int32",new Int32Array(x)),n.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const QIe={kernelName:bb,backendName:"cpu",kernelFunc:YIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZIe(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r}=e,{dtype:o,depth:i,onValue:a,offValue:u}=s;Ze(r,"oneHot");const l=ie(r.shape),c=new Float32Array(l*i);c.fill(u);const h=n.data.get(r.dataId).values;for(let d=0;d<l;++d)h[d]>=0&&h[d]<i&&(c[d*i+h[d]]=a);return n.makeTensorInfo([...r.shape,i],o,c)}const JIe={kernelName:Jy,backendName:"cpu",kernelFunc:ZIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aw(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=uh({inputs:{input:s},backend:n}),o=aw({inputs:{x:r},backend:n}),i=yp({inputs:{input:s},backend:n}),a=aw({inputs:{x:i},backend:n}),u=Jr({inputs:{real:o,imag:a},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),u}else return tR({backend:n,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const e$e={kernelName:g0,backendName:"cpu",kernelFunc:aw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IH(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=uh({inputs:{input:s},backend:n}),o=IH({inputs:{x:r},backend:n}),i=yp({inputs:{input:s},backend:n}),a=aw({inputs:{x:i},backend:n}),u=Jr({inputs:{real:o,imag:a},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),u}else return tR({backend:n,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const t$e={kernelName:Zy,backendName:"cpu",kernelFunc:IH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $H(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s;if(e.length===1)return iw({inputs:{input:e[0]},backend:n,attrs:{dim:r}});const o=e[0].shape,i=e[0].dtype;e.forEach(c=>{Br(o,c.shape,"All tensors passed to stack must have matching shapes"),O(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=e.map(c=>{const h=iw({inputs:{input:c},backend:n,attrs:{dim:r}});return a.push(h),h}),l=xp({inputs:u,backend:n,attrs:{axis:r}});return a.forEach(c=>n.disposeIntermediateTensorInfo(c)),l}const n$e={kernelName:e0,backendName:"cpu",kernelFunc:$H};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s$e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:o,constantValue:i}=s;Ze(r,"pad");const a=o.map((w,S)=>w[0]+r.shape[S]+w[1]),u=o.map(w=>w[0]),l=n.data.get(r.dataId).values,c=ie(r.shape),h=r.shape.length,d=et(r.shape),f=ie(a),m=a.length,y=et(a),x=ws(r.dtype,f);i!==0&&x.fill(i);for(let w=0;w<c;w++){const k=Ep(w,h,d).map((T,R)=>T+u[R]),I=xa(k,m,y);x[I]=l[w]}return{dataId:n.write(x,a,r.dtype),shape:a,dtype:r.dtype}}const NH={kernelName:t0,backendName:"cpu",kernelFunc:s$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r$e=ns((t,e)=>Math.pow(t,e)),o$e=Cs(af,r$e),i$e={kernelName:af,backendName:"cpu",kernelFunc:o$e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a$e(t){const{inputs:e,backend:n,attrs:s}=t,{paramsNestedSplits:r,paramsDenseValues:o,indices:i}=e,a=r.map(x=>n.data.get(x.dataId).values),u=r.map(x=>x.shape),l=n.data.get(o.dataId).values,c=n.data.get(i.dataId).values,[h,d,f]=U4(a,u,l,o.shape,o.dtype,c,i.shape),m=h.map(x=>n.makeTensorInfo([x.length],"int32",x)),y=n.makeTensorInfo(f,o.dtype,d);return m.concat([y])}const u$e={kernelName:cT,backendName:"cpu",kernelFunc:a$e};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l$e(t){const{inputs:e,backend:n}=t,{starts:s,limits:r,deltas:o}=e,i=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,u=n.data.get(o.dataId).values,[l,c]=G4(i,s.shape,s.dtype,a,r.shape,u,o.shape),h=n.makeTensorInfo([l.length],"int32",l),d=n.makeTensorInfo([c.length],s.dtype,c);return[h,d]}const c$e={kernelName:hT,backendName:"cpu",kernelFunc:l$e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h$e(t){const{inputs:e,backend:n,attrs:s}=t,{shape:r,values:o,defaultValue:i,rowPartitionTensors:a}=e,{rowPartitionTypes:u}=s,l=n.data.get(r.dataId).values,c=n.data.get(o.dataId).values,h=n.data.get(i.dataId).values,d=a.map(x=>n.data.get(x.dataId).values),f=a.map(x=>x.shape),[m,y]=H4(l,r.shape,c,o.shape,o.dtype,h,i.shape,d,f,u);return n.makeTensorInfo(m,o.dtype,y)}const d$e={kernelName:dT,backendName:"cpu",kernelFunc:h$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p$e(t){const{backend:e,attrs:n}=t,{start:s,stop:r,dtype:o,step:i}=n,a=j4(s,r,i,o);return e.makeTensorInfo([a.length],o,a)}const f$e={kernelName:Sb,backendName:"cpu",kernelFunc:p$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m$e=sn(uf,t=>1/t),g$e={kernelName:uf,backendName:"cpu",kernelFunc:m$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y$e(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:o,halfPixelCenters:i,size:a}=s;Ze(r,"resizeBilinear");const u=et(r.shape),[l,c]=a,[h,d,f,m]=r.shape,y=n.data.get(r.dataId).values,x=new Float32Array(ie([h,l,c,m])),v=[o&&l>1?d-1:d,o&&c>1?f-1:f],w=[o&&l>1?l-1:l,o&&c>1?c-1:c];let S=0;const k=v[0]/w[0],I=v[1]/w[1];for(let T=0;T<h;T++)for(let R=0;R<l;R++){let _;i?_=k*(R+.5)-.5:_=k*R;const D=Math.max(0,Math.floor(_)),L=_-D,V=Math.min(d-1,Math.ceil(_)),U=T*u[0]+D*u[1],j=T*u[0]+V*u[1];for(let q=0;q<c;q++){let J;i?J=I*(q+.5)-.5:J=I*q;const te=Math.max(0,Math.floor(J)),le=J-te,K=Math.min(f-1,Math.ceil(J)),re=U+te*u[2],pe=j+te*u[2],he=U+K*u[2],xe=j+K*u[2];for(let Ce=0;Ce<m;Ce++){const Ee=y[re+Ce],Ie=y[pe+Ce],ke=y[he+Ce],Ae=y[xe+Ce],Ke=Ee+(ke-Ee)*le,je=Ie+(Ae-Ie)*le,rt=Ke+(je-Ke)*L;x[S++]=rt}}}return n.makeTensorInfo([h,l,c,m],"float32",x)}const x$e={kernelName:i0,backendName:"cpu",kernelFunc:y$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v$e(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:o}=e,{alignCorners:i}=s;Ze([o,r],"resizeBilinearGrad");const a=et(r.shape),[u,l,c,h]=r.shape,[,d,f]=o.shape,m=new Float32Array(u*l*c*h),y=[i&&d>1?l-1:l,i&&f>1?c-1:c],x=[i&&d>1?d-1:d,i&&f>1?f-1:f],v=y[0]/x[0],w=y[1]/x[1],S=n.data.get(o.dataId).values;let k=0;for(let I=0;I<u;I++){const T=I*a[0];for(let R=0;R<d;R++){const _=R*v,D=Math.floor(_),L=Math.min(Math.ceil(_),l-1),V=T+D*a[1],U=T+L*a[1],j=_-D,q=1-j;for(let J=0;J<f;J++){const te=J*w,le=Math.floor(te),K=Math.min(Math.ceil(te),c-1),re=te-le,pe=1-re,he=V+le*a[2],xe=V+K*a[2],Ce=U+le*a[2],Ee=U+K*a[2],Ie=q*pe,ke=q*re,Ae=j*pe,Ke=j*re;for(let je=0;je<h;je++){const rt=S[k++];m[he+je]+=rt*Ie,m[xe+je]+=rt*ke,m[Ce+je]+=rt*Ae,m[Ee+je]+=rt*Ke}}}}return n.makeTensorInfo([u,c,l,h],"float32",m)}const w$e={kernelName:Ib,backendName:"cpu",kernelFunc:v$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b$e(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:o,halfPixelCenters:i,size:a}=s;Ze(r,"resizeNearestNeighbor");const u=et(r.shape),[l,c]=a,[h,d,f,m]=r.shape,y=n.data.get(r.dataId).values,x=new Float32Array(h*l*c*m),v=[o&&l>1?d-1:d,o&&c>1?f-1:f],w=[o&&l>1?l-1:l,o&&c>1?c-1:c],S=v[0]/w[0],k=v[1]/w[1];let I=0;for(let T=0;T<h;T++){const R=T*u[0];for(let _=0;_<l;_++){const D=i?S*(_+.5):S*_;let L=Math.min(d-1,o?Math.round(D):Math.floor(D));i&&(L=Math.max(0,L));const V=R+L*u[1];for(let U=0;U<c;U++){const j=i?k*(U+.5):k*U;let q=Math.min(f-1,o?Math.round(j):Math.floor(j));i&&(q=Math.max(0,q));const J=V+q*u[2];for(let te=0;te<m;te++){const le=y[J+te];x[I++]=le}}}}return n.makeTensorInfo([h,l,c,m],r.dtype,x)}const S$e={kernelName:o0,backendName:"cpu",kernelFunc:b$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C$e(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:o}=e,{alignCorners:i}=s;Ze([o,r],"resizeNearestNeighborGrad");const a=et(r.shape),u=et(o.shape),[l,c,h,d]=r.shape,[,f,m]=o.shape,y=new Float32Array(l*c*h*d),x=n.data.get(o.dataId).values,v=[i&&f>1?c-1:c,i&&m>1?h-1:h],w=[i&&f>1?f-1:f,i&&m>1?m-1:m],S=v[0]/w[0],k=v[1]/w[1],I=1/S,T=1/k,R=Math.ceil(I)*2+2,_=Math.ceil(T)*2+2;for(let D=0;D<l;D++){const L=D*a[0];for(let V=0;V<c;V++){const U=L+V*a[1],j=Math.floor(V*I),q=Math.floor(j-R/2);for(let J=0;J<h;J++){const te=U+J*a[2],le=Math.floor(J*T),K=Math.floor(le-_/2);for(let re=0;re<d;re++){let pe=0;for(let he=0;he<R;he++){const xe=he+q;if(xe<0||xe>=f)continue;const Ce=L+xe*u[1],Ee=xe*S,Ie=Math.min(c-1,i?Math.round(Ee):Math.floor(Ee));if(V===Ie)for(let ke=0;ke<_;ke++){const Ae=ke+K;if(Ae<0||Ae>=m)continue;const Ke=Ce+Ae*u[2],je=Ae*k,rt=Math.min(h-1,i?Math.round(je):Math.floor(je));J===rt&&(pe+=x[Ke+re])}}y[te+re]=pe}}}}return n.makeTensorInfo(r.shape,r.dtype,y)}const k$e={kernelName:kb,backendName:"cpu",kernelFunc:C$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I$e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dims:o}=s;Ze(r,"reverse");const i=r.shape.length,a=vt(o,r.shape);if(i===0)return ka({inputs:{x:r},backend:n});const u=new ys(r.shape,r.dtype),l=n.bufferSync(r);for(let c=0;c<u.size;c++){const h=u.indexToLoc(c),d=h.slice();a.forEach(f=>d[f]=r.shape[f]-1-d[f]),u.set(l.get(...d),...h)}return n.makeTensorInfo(u.shape,u.dtype,u.values)}const $$e={kernelName:a0,backendName:"cpu",kernelFunc:I$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N$e={kernelName:Mb,backendName:"cpu",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,{radians:r,fillValue:o,center:i}=e,a=n,u=ws(s.dtype,ie(s.shape)),[l,c,h,d]=s.shape,[f,m]=yS(i,c,h),y=255,x=Math.sin(r),v=Math.cos(r),w=a.data.get(s.dataId).values;for(let k=0;k<l;k++){const I=k*h*c*d;for(let T=0;T<c;T++){const R=T*(h*d);for(let _=0;_<h;_++){const D=_*d;for(let L=0;L<d;L++){const V=[l,T,_,L],U=V[2],j=V[1];let q=(U-f)*v-(j-m)*x,J=(U-f)*x+(j-m)*v;q=Math.round(q+f),J=Math.round(J+m);let te=o;if(typeof o!="number"&&(L===3?te=y:te=o[L]),q>=0&&q<h&&J>=0&&J<c){const K=J*(h*d),re=q*d,pe=I+K+re+L;te=w[pe]}const le=I+R+D+L;u[le]=te}}}}return{dataId:a.write(u,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T$e=sn(hf,t=>{const e=Math.floor(t);return t-e<.5?Math.floor(t):t-e>.5?Math.ceil(t):e%2===0?e:e+1}),E$e={kernelName:hf,backendName:"cpu",kernelFunc:T$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R$e(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:o}=e,{shape:i}=s,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=Ra(o,r,i),d=!0,f=n.bufferSync(r),m=n.bufferSync(o),y=Oc(f,m,i,h,l,u,a,c,0,d);return n.makeTensorInfo(i,y.dtype,y.values)}const A$e={kernelName:$b,backendName:"cpu",kernelFunc:R$e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _$e(t,e){let n=0,s=t.length,r=0;for(;n<s;)r=Math.floor((n+s)/2),t[r]<e?n=r+1:s=r;return s}function D$e(t,e){let n=0,s=t.length,r=0;for(;n<s;)r=Math.floor((n+s)/2),t[r]<=e?n=r+1:s=r;return s}function P$e(t,e,n,s,r,o){const i=Hn("int32",n*r);for(let a=0;a<n;++a){const u=t.slice(a*s,(a+1)*s),l=a*r;for(let c=0;c<r;++c)i[l+c]=o==="left"?_$e(u,e[c+l]):D$e(u,e[c+l])}return i}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F$e(t){const{inputs:e,backend:n,attrs:s}=t,{sortedSequence:r,values:o}=e,{side:i}=s,a=n.data.get(r.dataId).values,u=n.data.get(o.dataId).values,l=P$e(a,u,r.shape[0],r.shape[1],o.shape[1],i);return n.makeTensorInfo(o.shape,"int32",l)}const O$e={kernelName:Tb,backendName:"cpu",kernelFunc:F$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L$e(t){const{inputs:e,backend:n}=t,{condition:s,t:r,e:o}=e;Ze([s,r,o],"select");const i=s.shape.length,a=n.data.get(s.dataId).values,u=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,c=_s(r.dtype,o.dtype),h=Vs(ie(r.shape),c);let d=0;const f=i===0||i>1||r.shape.length===1?1:ie(r.shape.slice(1));for(let m=0;m<a.length;m++)for(let y=0;y<f;y++)a[m]===1?h[d++]=u[m]:h[d++]=l[m];return n.makeTensorInfo(r.shape,c,h)}const M$e={kernelName:u0,backendName:"cpu",kernelFunc:L$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z$e=I0,B$e=$0,V$e=sn(pf,t=>t>=0?B$e*t:z$e*(Math.exp(t)-1)),W$e={kernelName:pf,backendName:"cpu",kernelFunc:V$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U$e=sn(gf,t=>t<0?-1:t>0?1:0),G$e={kernelName:gf,backendName:"cpu",kernelFunc:U$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H$e=sn(ff,t=>Math.sin(t)),j$e={kernelName:ff,backendName:"cpu",kernelFunc:H$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K$e=sn(mf,t=>Math.sinh(t)),X$e={kernelName:mf,backendName:"cpu",kernelFunc:K$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q$e=11920928955078125e-23,QP=Math.log(q$e)+2,Y$e=sn(xf,t=>{const e=t>-QP,n=t<QP,s=Math.exp(t);let r;return n?r=s:e?r=t:r=Math.log(1+s),r}),Q$e={kernelName:xf,backendName:"cpu",kernelFunc:Y$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z$e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:o,paddings:i}=s;Ze([r],"spaceToBatchND");const a=ie(o),u=[[0,0]];u.push(...i);for(let T=1+o.length;T<r.shape.length;++T)u.push([0,0]);const l=NH.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:u,constantValue:0}}),c=Sh(l.shape,o,a,!1),h=Ch(c.length,o.length,!1),d=kh(l.shape,o,a,!1),y=wn({inputs:{x:l},backend:n,attrs:{shape:c}}),w=Lr({inputs:{x:y},backend:n,attrs:{perm:h}}),I=wn({inputs:{x:w},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(w),I}const J$e={kernelName:h0,backendName:"cpu",kernelFunc:Z$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eNe(t){const{inputs:e,backend:n}=t,{indices:s,values:r,denseShape:o,defaultValue:i}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${o.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const a=n.data.get(s.dataId).values,u=n.data.get(r.dataId).values,l=n.data.get(o.dataId).values,c=n.data.get(i.dataId).values[0],[h,d,f,m,y]=Y4(a,s.shape,s.dtype,u,r.dtype,l,c);return[n.makeTensorInfo(d,s.dtype,h),n.makeTensorInfo([d[0]],r.dtype,f),n.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(x=>Number(x)))),n.makeTensorInfo([y.length],s.dtype,new Int32Array(y))]}const tNe={kernelName:pT,backendName:"cpu",kernelFunc:eNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nNe(t){const{inputs:e,backend:n}=t,{inputIndices:s,inputShape:r,newShape:o}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(n.data.get(r.dataId).values),a=n.data.get(s.dataId).values,u=Array.from(n.data.get(o.dataId).values),[l,c,h]=Q4(a,s.shape,s.dtype,i,u);return[n.makeTensorInfo(c,s.dtype,l),n.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}const sNe={kernelName:fT,backendName:"cpu",kernelFunc:nNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rNe(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${o.shape}`);if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,u=n.data.get(o.dataId).values,[l,c]=$E(i,s.shape,s.dtype,a,u,!0);return n.makeTensorInfo(c,s.dtype,l)}const oNe={kernelName:Eb,backendName:"cpu",kernelFunc:rNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iNe(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${o.shape}`);if(r.shape[0]!==o.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,u=n.data.get(o.dataId).values,[l,c]=$E(i,s.shape,s.dtype,a,u);return n.makeTensorInfo(c,s.dtype,l)}const aNe={kernelName:Rb,backendName:"cpu",kernelFunc:iNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uNe(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:o,defaultValue:i}=e,{outputShape:a}=s,{sliceRank:u,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=Ra(o,r,a),f=!1,m=n.bufferSync(r);let y;switch(o.dtype){case"bool":{const x=n.bufferSync(o),v=!!n.data.get(i.dataId).values[0];y=Oc(m,x,a,d,c,l,u,h,v,f);break}case"float32":{const x=n.bufferSync(o),v=n.data.get(i.dataId).values[0];y=Oc(m,x,a,d,c,l,u,h,v,f);break}case"int32":{const x=n.bufferSync(o),v=n.data.get(i.dataId).values[0];y=Oc(m,x,a,d,c,l,u,h,v,f);break}case"string":{const x=n.bufferSync(o),v=Vi(n.data.get(i.dataId).values[0]);y=Oc(m,x,a,d,c,l,u,h,v,f);break}default:throw new Error(`Unsupported type ${o.dtype}`)}return n.makeTensorInfo(a,y.dtype,y.values)}const lNe={kernelName:Ab,backendName:"cpu",kernelFunc:uNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cNe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{numOrSizeSplits:o,axis:i}=s,a=vt(i,r.shape)[0],u=AS(r,o,a),l=new Array(r.shape.length).fill(0),c=r.shape.slice();return u.map(h=>{const d=[...c];d[a]=h;const f=lh({inputs:{x:r},backend:n,attrs:{begin:l,size:d}});return l[a]+=h,f})}const hNe={kernelName:d0,backendName:"cpu",kernelFunc:cNe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dNe={kernelName:_b,backendName:"cpu",kernelFunc:({inputs:t,backend:e})=>{const{x:n}=t,s=e;Ze(n,"square");const r=s.data.get(n.dataId).values,o=new Float32Array(r.length);for(let a=0;a<r.length;++a){const u=r[a];o[a]=u*u}return{dataId:s.write(o,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pNe=sn(If,(t,e)=>{const n=e;return isNaN(t)?NaN:t>0?1:n.alpha}),fNe={kernelName:If,backendName:"cpu",kernelFunc:pNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mNe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:o,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s;Ze(r,"stridedSlice");const{finalShapeSparse:f,finalShape:m,isIdentity:y,sliceDim0:x,isSimpleSlice:v,begin:w,end:S,strides:k}=fS(r.shape,o,i,a,u,l,c,h,d);let I;if(y)I=wn({inputs:{x:r},backend:n,attrs:{shape:m}});else if(x||v){O(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const T=pS(w,S,k),R=lh({inputs:{x:r},backend:n,attrs:{begin:w,size:T}});I=wn({inputs:{x:R},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(R)}else{const T=n.bufferSync(r),R=eW(f,T,k,w);I=n.makeTensorInfo(m,R.dtype,R.values)}return I}const gNe={kernelName:Pb,backendName:"cpu",kernelFunc:mNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yNe(t){const{inputs:e,backend:n,attrs:s}=t,{separator:r,nGramWidths:o,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=s,{data:c,dataSplits:h}=e,d=n.data.get(c.dataId).values,f=n.data.get(h.dataId).values,[m,y]=tW(d,f,r,o,i,a,u,l);return[n.makeTensorInfo([m.length],"string",m),n.makeTensorInfo(h.shape,"int32",y)]}const xNe={kernelName:Fb,backendName:"cpu",kernelFunc:yNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vNe(t){const{inputs:e,backend:n,attrs:s}=t,{skipEmpty:r}=s,{input:o,delimiter:i}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=n.data.get(o.dataId).values,u=n.data.get(i.dataId).values[0],[l,c,h]=nW(a,u,r),d=c.length;return[n.makeTensorInfo([d,2],"int32",l),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}const wNe={kernelName:mT,backendName:"cpu",kernelFunc:vNe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bNe(t){const{inputs:e,backend:n,attrs:s}=t,{numBuckets:r}=s,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=n.data.get(o.dataId).values,a=sW(i,r);return n.makeTensorInfo(o.shape,"int32",a)}const SNe={kernelName:gT,backendName:"cpu",kernelFunc:bNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CNe=sn(Sf,t=>Math.tan(t)),kNe={kernelName:Sf,backendName:"cpu",kernelFunc:CNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const INe=sn(Cf,t=>Math.tanh(t)),$Ne={kernelName:Cf,backendName:"cpu",kernelFunc:INe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NNe(t){const{inputs:e,backend:n}=t,{tensor:s,indices:r,updates:o}=e,{sliceRank:i,numUpdates:a,sliceSize:u,strides:l,outputSize:c}=Ra(o,r,s.shape),h=!1,d=n.bufferSync(r),f=n.bufferSync(o),m=n.bufferSync(s),y=Oc(d,f,s.shape,c,u,a,i,l,m,h);return n.makeTensorInfo(s.shape,y.dtype,y.values)}const TNe={kernelName:Nb,backendName:"cpu",kernelFunc:NNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ENe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reps:o}=s;Ze(r,"tile");const i=oW(n.bufferSync(r),o);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const RNe={kernelName:kf,backendName:"cpu",kernelFunc:ENe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ANe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:o,sorted:i}=s;Ze(r,"topk");const a=n.data.get(r.dataId).values,[u,l]=aW(a,r.shape,r.dtype,o,i);return[n.makeTensorInfo(u.shape,u.dtype,u.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}const _Ne={kernelName:Ob,backendName:"cpu",kernelFunc:ANe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DNe(t){const{inputs:e,attrs:n,backend:s}=t,{image:r,transforms:o}=e,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=n,[c,h,d,f]=r.shape,[m,y]=l??[h,d],x=[c,m,y,f],v=et(r.shape),w=v[0],S=v[1],k=v[2],I=et(x),T=I[0],R=I[1],_=I[2],D=ws(r.dtype,ie(x));D.fill(u);const L=s.data.get(r.dataId).values,V=s.data.get(o.dataId).values;for(let j=0;j<c;++j){const q=o.shape[0]===1?V:V.subarray(j*8,j*8+8);for(let J=0;J<m;++J)for(let te=0;te<y;++te)for(let le=0;le<f;++le){let K;const re=q[6]*te+q[7]*J+1;if(re===0)continue;const pe=(q[0]*te+q[1]*J+q[2])/re,he=(q[3]*te+q[4]*J+q[5])/re,xe=ZP(pe,d,a),Ce=ZP(he,h,a);switch(i){case"nearest":K=zNe(L,h,d,w,S,k,j,Ce,xe,le,u);break;case"bilinear":K=BNe(L,h,d,w,S,k,j,Ce,xe,le,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}const Ee=j*T+J*R+te*_+le;D[Ee]=K}return s.makeTensorInfo(x,r.dtype,D)}return{dataId:s.write(D,x,r.dtype),shape:r.shape,dtype:r.dtype}}const PNe={kernelName:Lb,backendName:"cpu",kernelFunc:DNe};function ZP(t,e,n){switch(n){case"reflect":return FNe(t,e);case"wrap":return ONe(t,e);case"nearest":return MNe(t,e);case"constant":default:return LNe(t)}}function FNe(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const s=2*e;n<s&&(n=s*Math.trunc(-n/s)+n),n=n<-e?n+s:-n-1}else if(n>e-1)if(e<=1)n=0;else{const s=2*e;n-=s*Math.trunc(n/s),n>=e&&(n=s-n-1)}return Zc(0,n,e-1)}function ONe(t,e){let n=t;if(n<0)if(e<=1)n=0;else{const s=e-1;n+=e*(Math.trunc(-n/s)+1)}else if(n>e-1)if(e<=1)n=0;else{const s=e-1;n-=e*Math.trunc(n/s)}return Zc(0,n,e-1)}function LNe(t,e){return t}function MNe(t,e){return Zc(0,t,e-1)}function sg(t,e,n,s,r,o,i,a,u,l,c){const h=i*s+a*r+u*o+l;return 0<=a&&a<e&&0<=u&&u<n?t[h]:c}function zNe(t,e,n,s,r,o,i,a,u,l,c){const h=Math.round(a),d=Math.round(u);return sg(t,e,n,s,r,o,i,h,d,l,c)}function BNe(t,e,n,s,r,o,i,a,u,l,c){const h=Math.floor(a),d=Math.floor(u),f=h+1,m=d+1,y=(m-u)*sg(t,e,n,s,r,o,i,h,d,l,c)+(u-d)*sg(t,e,n,s,r,o,i,h,m,l,c),x=(m-u)*sg(t,e,n,s,r,o,i,f,d,l,c)+(u-d)*sg(t,e,n,s,r,o,i,f,m,l,c);return(f-a)*y+(a-h)*x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VNe(t){const{inputs:e,attrs:n,backend:s}=t,{axis:r}=n,{x:o}=e;Ze(o,"unique");const i=s.data.get(o.dataId).values,{outputValues:a,outputShape:u,indices:l}=uW(i,r,o.shape,o.dtype);return[s.makeTensorInfo(u,o.dtype,a),s.makeTensorInfo([l.length],"int32",l)]}const WNe={kernelName:yT,backendName:"cpu",kernelFunc:VNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UNe(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:o}=s;o<0&&(o+=r.shape.length);const i=r.shape.length,a=r.shape[o],u=new Array(i-1);let l=0;for(let f=0;f<i;f++)f!==o&&(u[l++]=r.shape[f]);const c=new Array(i).fill(0),h=r.shape.slice();h[o]=1;const d=new Array(a);for(let f=0;f<d.length;f++){c[o]=f;const m=lh({inputs:{x:r},backend:n,attrs:{begin:c,size:h}});d[f]=wn({inputs:{x:m},backend:n,attrs:{shape:u}}),n.disposeIntermediateTensorInfo(m)}return d}const GNe={kernelName:f0,backendName:"cpu",kernelFunc:UNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HNe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,segmentIds:o}=e,{numSegments:i}=s;Ze(r,"unsortedSegmentSum");const a=r.shape.length,u=o.shape.length,l=[],c=[],h=a-u;let d=o;for(let m=0;m<h;++m){const y=iw({inputs:{input:d},backend:n,attrs:{dim:m+1}});d=y,c.push(y)}for(let m=0;m<i;++m){const y=Ol(m,"int32"),x=n.makeTensorInfo([],"int32",y),v=C4({inputs:{a:x,b:d},backend:n}),w=Il({inputs:{x:v},backend:n,attrs:{dtype:"float32"}}),S=OS({inputs:{a:w,b:r},backend:n}),k=O0({inputs:{x:S},backend:n,attrs:{axis:0,keepDims:!1}});l.push(k),c.push(x),c.push(v),c.push(w),c.push(S),c.push(k)}const f=$H({inputs:l,backend:n,attrs:{axis:0}});return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}const jNe={kernelName:m0,backendName:"cpu",kernelFunc:HNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KNe=[VCe,Hhe,UCe,HCe,Qhe,KCe,qCe,QCe,JCe,t2e,s2e,o2e,a2e,c2e,d2e,m2e,y2e,v2e,b2e,zCe,C2e,I2e,N2e,Jhe,E2e,qhe,tde,A2e,jhe,D2e,F2e,O2e,M2e,B2e,W2e,G2e,j2e,X2e,Y2e,Z2e,eke,nke,rke,ike,ake,lke,hke,pke,fke,mke,gke,xke,bke,_Ce,Cke,nde,Ake,sde,_ke,ode,Mke,zke,Vke,ade,lde,Uke,Hke,Kke,qke,hde,pde,Khe,Qke,P2e,Jke,tIe,sIe,DCe,mde,yde,oIe,vde,aIe,cIe,dIe,mIe,yIe,vIe,wIe,bde,SIe,kIe,$Ie,TIe,RIe,_Ie,PIe,Cde,OIe,zIe,WIe,Ide,Nde,HIe,XIe,QIe,Ede,JIe,t$e,n$e,NH,i$e,FCe,_de,u$e,c$e,d$e,f$e,Xhe,L$,g$e,OCe,LCe,MCe,x$e,w$e,S$e,k$e,$$e,N$e,E$e,Bde,A$e,O$e,M$e,W$e,Wde,G$e,j$e,X$e,Ude,BIe,Q$e,J$e,tNe,sNe,oNe,aNe,lNe,hNe,jde,dNe,Xde,Yde,fNe,gNe,xNe,wNe,SNe,epe,vke,kNe,$Ne,TNe,RNe,_Ne,PNe,Rde,WNe,GNe,jNe,e$e];for(const t of KNe)xT(t);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tc={},$1={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function XNe(t,e){Tc[t]=e}function Xi(t,e){if(!(t in Tc)||e!=null){const s=YNe(t,e);if(s!==null)Tc[t]=s;else return console.log("Could not get context for WebGL version",t),null}const n=Tc[t];return n==null||n.isContextLost()?(delete Tc[t],Xi(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),Tc[t])}function qNe(t){if(!ce().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&t===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function YNe(t,e){if(t!==1&&t!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=e??qNe(t);return n.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete Tc[t]},!1),ce().getBool("SOFTWARE_WEBGL_ENABLED")&&($1.failIfMajorPerformanceCaveat=!1),t===1?n.getContext("webgl",$1)||n.getContext("experimental-webgl",$1):n.getContext("webgl2",$1)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ry;(function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"})(ry||(ry={}));var No;(function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"})(No||(No={}));var zs;(function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(zs||(zs={}));function L0(t,e){return[e,t]}function QNe(t,e){return t*e}function N1(t){const e=ie(t),n=Math.ceil(e/4);return BI(n)}function Ff(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function ZNe(t,e){const[n,s]=Ff(t,e);return n*s*4}function nR(t,e){const n=t;let s,r,o,i,a,u,l,c,h,d;return ce().getNumber("WEBGL_VERSION")===2?(s=n.R32F,r=n.R16F,o=n.RGBA16F,i=n.RGBA32F,a=n.RED,l=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT,u=n.RGBA8):(s=t.RGBA,r=t.RGBA,o=t.RGBA,i=n.RGBA,a=t.RGBA,l=4,c=4,h=e!=null?e.HALF_FLOAT_OES:null,d=t.FLOAT,u=t.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ue(t,e){const n=e();return ce().getBool("DEBUG")&&JNe(t),n}function JNe(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+sTe(t,e))}const eTe=596e-10,tTe=65504;function nTe(t){return!!(ce().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||t===0||eTe<Math.abs(t)&&Math.abs(t)<tTe)}function sTe(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function T1(t,e){return Iu(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function rTe(t,e){const n=Iu(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ue(t,()=>t.shaderSource(n,e)),Ue(t,()=>t.compileShader(n)),t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function oTe(t,e){const n=Iu(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ue(t,()=>t.shaderSource(n,e)),Ue(t,()=>t.compileShader(n)),ce().get("ENGINE_COMPILE_ONLY"))return n;if(t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw TH(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const iTe=/ERROR: [0-9]+:([0-9]+):/g;function TH(t,e){const n=iTe.exec(e);if(n==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(t);return}const s=+n[1],r=t.split(`
`),o=r.length.toString().length+2,i=r.map((h,d)=>Gd((d+1).toString(),o)+h);let a=0;for(let h=0;h<i.length;h++)a=Math.max(i[h].length,a);const u=i.slice(0,s-1),l=i.slice(s-1,s),c=i.slice(s);console.log(u.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Gd(l[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function aTe(t){return Iu(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}function uTe(t,e){if(Ue(t,()=>t.linkProgram(e)),!ce().get("ENGINE_COMPILE_ONLY")&&t.getProgramParameter(e,t.LINK_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Sk(t,e){if(Ue(t,()=>t.validateProgram(e)),t.getProgramParameter(e,t.VALIDATE_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function lTe(t,e){const n=Iu(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Ue(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),Ue(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function cTe(t,e){const n=Iu(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return Ue(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),Ue(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function hTe(t){return Iu(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}function dTe(t,e){const n=ce().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){const s=`[${t}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(t>n||e>n){const s=`[${t}x${e}]`,r=`[${n}x${n}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function pTe(t){return Iu(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function JP(t,e,n,s,r,o,i){const a=t.getAttribLocation(e,n);return a===-1?!1:(Ue(t,()=>t.bindBuffer(t.ARRAY_BUFFER,s)),Ue(t,()=>t.vertexAttribPointer(a,r,t.FLOAT,!1,o,i)),Ue(t,()=>t.enableVertexAttribArray(a)),!0)}function fTe(t,e,n){vTe(t,n),Ue(t,()=>t.activeTexture(t.TEXTURE0+n)),Ue(t,()=>t.bindTexture(t.TEXTURE_2D,e))}function mTe(t,e,n){return Iu(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}function gTe(t,e,n){return t.getUniformLocation(e,n)}function yTe(t,e,n,s){Ue(t,()=>fTe(t,e,s)),Ue(t,()=>t.uniform1i(n,s))}function Ck(t,e,n){Ue(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),Ue(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function eF(t,e){Ue(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),Ue(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function E1(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+xTe(t,e))}function xTe(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Iu(t,e,n){const s=Ue(t,()=>e());if(s==null)throw new Error(n);return s}function vTe(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+t.TEXTURE0;if(s<t.TEXTURE0||s>n){const r=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${r}.`)}}function vp(t,e=2){return ie(t.slice(0,t.length-e))}function wp(t){if(t.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function R1(t){let e=[1,1,1];return t.length===0||t.length===1&&t[0]===1||(e=[vp(t),...wp(t)]),e}function wTe(t,e=!1){let n=ce().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=ce().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&ce().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=n/2),e&&(n=n*2,s=s*2,t=t.map((a,u)=>u>=t.length-2?sT(t[u]):t[u]),t.length===1&&(t=[2,t[0]])),t.length!==2&&(t=Fl(t).newShape);let r=ie(t),o=null;t.length<=1&&r<=n?o=[1,r]:t.length===2&&t[0]<=n&&t[1]<=n?o=t:t.length===3&&t[0]*t[1]<=n&&t[2]<=n?o=[t[0]*t[1],t[2]]:t.length===3&&t[0]<=n&&t[1]*t[2]<=n?o=[t[0],t[1]*t[2]]:t.length===4&&t[0]*t[1]*t[2]<=n&&t[3]<=n?o=[t[0]*t[1]*t[2],t[3]]:t.length===4&&t[0]<=n&&t[1]*t[2]*t[3]<=n&&(o=[t[0],t[1]*t[2]*t[3]]);const i=o!=null&&Math.max(...o)>s&&Math.min(...o)<=(e?2:1)&&Math.min(...o)>0;if(o==null||i)if(e){const a=vp(t);let u=2,l=2;t.length&&([u,l]=wp(t)),r=a*(u/2)*(l/2),o=BI(r).map(c=>c*2)}else o=BI(r);return o}function A1(t){return t%2===0}function uw(t,e){if(t=t.slice(-2),e=e.slice(-2),kt(t,e)||!t.length||!e.length||t[0]===0||t[1]===0||e[0]===0||e[1]===0)return!0;if(t.length!==e.length){const n=t[t.length-1],s=e[e.length-1];if(n===s||A1(n)&&A1(s)&&(t[0]===1||e[0]===1))return!0}return t[1]===e[1]&&A1(t[0])&&A1(e[0])}let kk,Ik;function bTe(t){if(kk==null){const e=Xi(t);kk=e.getParameter(e.MAX_TEXTURE_SIZE)}return kk}function STe(t){if(Ik==null){const e=Xi(t);Ik=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Ik)}function CTe(t){if(t===0)return 0;let e;const n=Xi(t);return hi(n,"EXT_disjoint_timer_query_webgl2")&&t===2?e=2:hi(n,"EXT_disjoint_timer_query")?e=1:e=0,e}function hi(t,e){return t.getExtension(e)!=null}function tF(t){try{if(Xi(t)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function kTe(t){if(t===0)return!1;const e=Xi(t);if(t===1){if(!hi(e,"OES_texture_float"))return!1}else if(!hi(e,"EXT_color_buffer_float"))return!1;return z$(e)}function ITe(t){if(t===0)return!1;const e=Xi(t);if(t===1){if(!hi(e,"OES_texture_float")||!hi(e,"WEBGL_color_buffer_float"))return!1}else{if(hi(e,"EXT_color_buffer_float"))return z$(e);const s="EXT_color_buffer_half_float";if(hi(e,s)){const r=e.getExtension(s);return $Te(e,r)}return!1}return z$(e)}function z$(t){const e=nR(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n);const s=1,r=1;t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,s,r,0,e.textureFormatFloat,e.textureTypeFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const i=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(o),i}function $Te(t,e){const n=nR(t,e),s=t.createTexture();t.bindTexture(t.TEXTURE_2D,s);const r=1,o=1;t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,r,o,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,s,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(s),t.deleteFramebuffer(i),a}function NTe(t){return t!==2?!1:Xi(t).fenceSync!=null}function M0(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&O(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Je=ce();Je.registerFlag("HAS_WEBGL",()=>Je.getNumber("WEBGL_VERSION")>0);Je.registerFlag("WEBGL_VERSION",()=>tF(2)?2:tF(1)?1:0);Je.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Je.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Je.get("WEBGL_VERSION")===2);Je.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Je.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Je.registerFlag("WEBGL_PACK",()=>Je.getBool("HAS_WEBGL"));Je.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Je.getBool("WEBGL_PACK"));Je.registerFlag("WEBGL_PACK_CLIP",()=>Je.getBool("WEBGL_PACK"));Je.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Je.getBool("WEBGL_PACK"));Je.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Je.getBool("WEBGL_PACK"));Je.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Je.getBool("WEBGL_PACK"));Je.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Je.getBool("WEBGL_PACK"));Je.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Je.getBool("WEBGL_PACK"));Je.registerFlag("WEBGL_PACK_REDUCE",()=>Je.getBool("WEBGL_PACK"));Je.registerFlag("WEBGL_LAZILY_UNPACK",()=>Je.getBool("WEBGL_PACK"));Je.registerFlag("WEBGL_CONV_IM2COL",()=>Je.getBool("WEBGL_PACK"));Je.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Je.getBool("WEBGL_PACK"));Je.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>bTe(Je.getNumber("WEBGL_VERSION")));Je.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>STe(Je.getNumber("WEBGL_VERSION")));Je.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=Je.getNumber("WEBGL_VERSION");return t===0?0:CTe(t)});Je.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Je.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Uz());Je.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>kTe(Je.getNumber("WEBGL_VERSION")));Je.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Je.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Je.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Je.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>ITe(Je.getNumber("WEBGL_VERSION")));Je.registerFlag("WEBGL_FENCE_API_ENABLED",()=>NTe(Je.getNumber("WEBGL_VERSION")));Je.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Je.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Je.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});Je.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Uz()?1:-1,t=>{if(typeof t!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${t}.`);if(t<0&&t!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});Je.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Je.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Je.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Je.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Je.registerFlag("WEBGL_EXP_CONV",()=>!1);Je.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Je.getBool("IS_TEST"));Je.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Je.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Je.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Je.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xr(){let t,e,n,s,r,o,i,a,u,l;return ce().getNumber("WEBGL_VERSION")===2?(t="#version 300 es",e="in",n="out",s="in",r="texture",o="outputColor",i="out vec4 outputColor;",a=ce().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(t="",e="attribute",n="varying",s="varying",r="texture2D",o="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:t,attribute:e,varyingVs:n,varyingFs:s,texture2D:r,output:o,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:u,defineRound:l}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rh(t,e,n="index"){const s=et(e);return s.map((r,o)=>{const i=`int ${t[o]} = ${n} / ${r}`,a=o===s.length-1?`int ${t[o+1]} = ${n} - ${t[o]} * ${r}`:`index -= ${t[o]} * ${r}`;return`${i}; ${a};`}).join("")}function qS(t,e,n="index"){const s=et(e);return s.map((r,o)=>{const i=`int ${t[o]} = ${n} / outShapeStrides[${o}]`,a=o===s.length-1?`int ${t[o+1]} = ${n} - ${t[o]} * outShapeStrides[${o}]`:`index -= ${t[o]} * outShapeStrides[${o}]`;return`${i}; ${a};`}).join("")}function TTe(t,e){const n=t.length,s=t.map(o=>`${e}[${o}]`),r=new Array(n-1);r[n-2]=s[n-1];for(let o=n-3;o>=0;--o)r[o]=`(${r[o+1]} * ${s[o+1]})`;return r}function ETe(t,e,n="index"){const s=t.map((o,i)=>i),r=TTe(s,e);return r.map((o,i)=>{const a=`int ${t[i]} = ${n} / ${r[i]}`,u=i===r.length-1?`int ${t[i+1]} = ${n} - ${t[i]} * ${r[i]}`:`index -= ${t[i]} * ${r[i]}`;return`${a}; ${u};`}).join("")}function sR(t){const e=et(t).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function rR(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const EH=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:RH}=hue;function RTe(t,e,n){const s=[];if(t.forEach(f=>{const m=ie(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?s.push(`uniform float ${f.name}${m>1?`[${m}]`:""};`):(s.push(`uniform sampler2D ${f.name};`),s.push(`uniform int offset${f.name};`)),n.enableShapeUniforms){const{uniformShape:y}=oR(n.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(y.length){case 1:s.push(`uniform int ${f.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${f.name}Shape;`);break}s.push(`uniform ivec2 ${f.name}TexShape;`)}}),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(f=>{s.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});const r=s.join(`
`),o=t.map(f=>ATe(f,e,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=e.texShape,a=xr(),u=PTe(a);let l,c,h=LTe(a);return e.isPacked?(l=_Te(e.logicalShape,i,n.enableShapeUniforms),c=OTe(a)):(l=DTe(e.logicalShape,i,n.enableShapeUniforms),c=FTe(a)),n.packedInputs&&(h+=VTe),[h,u,c,r,l,o,n.userCode].join(`
`)}function Of(t,e=!1){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return JTe(t,e);case 1:return tEe(t,e);case 2:return sEe(t,e);case 3:return oEe(t,e);case 4:return aEe(t,e);case 5:return uEe(t);case 6:return lEe(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function AH(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return ZTe(t);case 1:return eEe(t,e);case 2:return nEe(t,e);case 3:return rEe(t,e);default:return iEe(t,e)}}function ATe(t,e,n=!1,s){let r="";n?r+=AH(t,s):r+=Of(t,s);const o=t.shapeInfo.logicalShape,i=e.logicalShape;return o.length<=i.length&&(n?r+=cEe(t,e):r+=hEe(t,e)),r}function _Te(t,e,n){switch(t.length){case 0:return _H();case 1:return WTe(t,e,n);case 2:return YTe(t,e,n);case 3:return GTe(t,e,n);default:return jTe(t,e,n)}}function DTe(t,e,n){switch(t.length){case 0:return _H();case 1:return UTe(t,e,n);case 2:return QTe(t,e,n);case 3:return HTe(t,e,n);case 4:return KTe(t,e,n);case 5:return XTe(t,e);case 6:return qTe(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}function PTe(t){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${t.texture2D}(textureSampler, uv).r;
    }
  `}function FTe(t){return`
    void setOutput(float val) {
      ${t.output} = vec4(val, 0, 0, 0);
    }
  `}function OTe(t){return`
    void setOutput(vec4 val) {
      ${t.output} = val;
    }
  `}function LTe(t){return`${t.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t.varyingFs} vec2 resultUV;
    ${t.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${t.defineSpecialNaN}
    ${t.defineSpecialInf}
    ${t.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${MTe}
    ${zTe}
    ${BTe}
  `}const MTe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,zTe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,BTe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,VTe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function _H(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function WTe(t,e,n){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function UTe(t,e,n){return e[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function GTe(t,e,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[2]/2),o=r*Math.ceil(t[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function HTe(t,e,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${qS(["r","c","d"],t)}
    return ivec3(r, c, d);
  }
`;const s=Rh(["r","c","d"],t);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function jTe(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(t[t.length-1]/2),o=r*Math.ceil(t[t.length-2]/2);let i=o,a="",u="b, r, c";for(let l=2;l<t.length-1;l++)i*=t[t.length-l-1],a=`
      int b${l} = index / ${i};
      index -= b${l} * ${i};
    `+a,u=`b${l}, `+u;return`
    ivec${t.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${a}

      int b = index / ${o};
      index -= b * ${o};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${t.length}(${u});
    }
  `}function KTe(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${qS(["r","c","d","d2"],t)}
      return ivec4(r, c, d, d2);
    }
  `;const s=Rh(["r","c","d","d2"],t);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function XTe(t,e){const n=Rh(["r","c","d","d2","d3"],t);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function qTe(t,e){const n=Rh(["r","c","d","d2","d3","d4"],t);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function YTe(t,e,n){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(kt(t,e))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(t[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function QTe(t,e,n){return kt(t,e)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:t[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:t[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${t[1]};
      int c = index - r * ${t[1]};
      return ivec2(r, c);
    }
  `}function Ah(t){return`offset${t}`}function ZTe(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),s=xr();return`
    vec4 ${n}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function JTe(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${s}() {return ${n};}`;const[r,o]=t.shapeInfo.texShape;if(r===1&&o===1)return`
      float ${s}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const i=Ah(n);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;const[a,u]=t.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${a}, ${u}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function eEe(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t.shapeInfo.texShape,o=xr();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${o.texture2D}(${n}, uv);
    }
  `;const i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${o.texture2D}(${n}, uv);
    }
  `}function tEe(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${Lf(t)}
      }
    `;const r=t.shapeInfo.texShape,o=r[0],i=r[1];if(i===1&&o===1)return`
      float ${s}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const a=Ah(n);return i===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${o}.0);
        return sampleTexture(${n}, uv);
      }
    `:o===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${a});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${o}, ${i}, index + ${a});
      return sampleTexture(${n}, uv);
    }
  `}function nEe(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=t.shapeInfo.texShape,i=o[0],a=o[1],u=xr();if(o!=null&&kt(n,o))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${u.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${u.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `;const l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${l[0]}, ${l[1]}, row, col);
      return ${u.texture2D}(${s}, uv);
    }
  `}function sEe(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=t.shapeInfo.texShape;if(o!=null&&kt(n,o)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const d=o[0],f=o[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:i,keptDims:a}=Fl(n),u=i;if(u.length<n.length){const d=Mf(t,u),f=["row","col"];return`
      ${Of(d,e)}
      float ${r}(int row, int col) {
        return ${r}(${zf(f,a)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Lf(t)}
      }
    `;const l=o[0],c=o[1],h=Ah(s);return c===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${s}, uv);
    }
  `:l===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${h};
    vec2 uv = uvFromFlat(${l}, ${c}, index);
    return sampleTexture(${s}, uv);
  }
`}function rEe(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=t.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];if(n[0]===1){const d=n.slice(1),f=[1,2],m=Mf(t,d),y=["b","row","col"];return`
        ${AH(m,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${zf(y,f)});
        }
      `}const a=xr();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `;const u=i[0],l=i[1],c=Math.ceil(n[2]/2),h=c*Math.ceil(n[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${l}, ${h}, ${c}, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `}function oEe(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n[1]*n[2],i=n[2],{newShape:a,keptDims:u}=Fl(n),l=a;if(l.length<n.length){const y=Mf(t,l),x=["row","col","depth"];return`
        ${Of(y,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${zf(x,u)});
        }
      `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${o}, ${i}, 1)));
        ${Lf(t)}
      }
    `;const c=t.shapeInfo.texShape,h=c[0],d=c[1],f=t.shapeInfo.flatOffset;if(d===o&&f==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(d===i&&f==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `;const m=Ah(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${m};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${o} + col * ${i} + depth + ${m};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${s}, uv);
      }
  `}function iEe(t,e){const n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=xr();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${n}, uv);
    }
  `;const o=t.shapeInfo.logicalShape,i=o.length,a=t.shapeInfo.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],l=u[0],c=u[1],h=Math.ceil(o[i-1]/2);let d=h*Math.ceil(o[i-2]/2),f="int b, int row, int col",m=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let y=2;y<i-1;y++)f=`int b${y}, `+f,d*=o[i-y-1],m=`b${y} * ${d} + `+m;return`
    vec4 ${s}(${f}) {
      int index = ${m};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${l});
      return ${r.texture2D}(${n}, uv);
    }
  `}function aEe(t,e){const n=t.shapeInfo.logicalShape,s=t.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),o=n[3],i=n[2]*o,a=n[1]*i,{newShape:u,keptDims:l}=Fl(n);if(u.length<n.length){const w=Mf(t,u),S=["row","col","depth","depth2"];return`
      ${Of(w,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${zf(S,l)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${o}, 1)));
        ${Lf(t)}
      }
    `;const c=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],f=h[1],m=`int stride2 = ${s}Shape[3];`,y=`int stride1 = ${s}Shape[2] * stride2;`,x=`int stride0 = ${s}Shape[1] * stride1;`;if(f===a&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${m}
        ${y}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(f===o&&c==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;const v=Ah(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${m}
      ${y}
      ${x}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${v});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${o} + depth2;
      vec2 uv = uvFromFlat(${d}, ${f}, index + ${v});
      return sampleTexture(${s}, uv);
    }
  `}function uEe(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e[4],o=e[3]*r,i=e[2]*o,a=e[1]*i,{newShape:u,keptDims:l}=Fl(e);if(u.length<e.length){const y=Mf(t,u),x=["row","col","depth","depth2","depth3"];return`
      ${Of(y)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${zf(x,l)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${o}, ${r})) +
          depth3;
        ${Lf(t)}
      }
    `;const c=t.shapeInfo.flatOffset,h=t.shapeInfo.texShape,d=h[0],f=h[1];if(f===a&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${o}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===r&&c==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${n}, uv);
      }
    `;const m=Ah(n);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${o} +
          depth2 * ${r} + depth3 + ${m};
      vec2 uv = uvFromFlat(${d}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function lEe(t){const e=t.shapeInfo.logicalShape,n=t.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:o}=Fl(e);if(r.length<e.length){const x=Mf(t,r),v=["row","col","depth","depth2","depth3","depth4"];return`
      ${Of(x)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${zf(v,o)});
      }
    `}const i=e[5],a=e[4]*i,u=e[3]*a,l=e[2]*u,c=e[1]*l;if(t.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${l}, ${u}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Lf(t)}
      }
    `;const h=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,f=d[0],m=d[1];if(m===c&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${u}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(m===i&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;const y=Ah(n);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${l} + depth * ${u} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${y};
      vec2 uv = uvFromFlat(${f}, ${m}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Lf(t){const e=t.name,n=ie(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function cEe(t,e){const n=t.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",o=t.shapeInfo.logicalShape.length,i=e.logicalShape.length,a=RH(t.shapeInfo.logicalShape,e.logicalShape),u=ln(i),l=i-o;let c;const h=["x","y","z","w","u","v"];o===0?c="":i<2&&a.length>=1?c="coords = 0;":c=a.map(w=>`coords.${h[w+l]} = 0;`).join(`
`);let d="";i<2&&o>0?d="coords":d=t.shapeInfo.logicalShape.map((w,S)=>`coords.${h[S+l]}`).join(", ");let f="return outputValue;";const y=ie(t.shapeInfo.logicalShape)===1,v=ie(e.logicalShape)===1;if(o===1&&!y&&!v)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(y&&!v)i===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(a.length){const w=o-2,S=o-1;a.indexOf(w)>-1&&a.indexOf(S)>-1?f="return vec4(outputValue.x);":a.indexOf(w)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(S)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${u} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${s}(${d});
      ${f}
    }
  `}function hEe(t,e){const n=t.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",o=e.texShape,i=t.shapeInfo.texShape,a=t.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!t.shapeInfo.isUniform&&a===u&&t.shapeInfo.flatOffset==null&&kt(i,o))return`
      float ${r}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const l=ln(u),c=RH(t.shapeInfo.logicalShape,e.logicalShape),h=u-a;let d;const f=["x","y","z","w","u","v"];a===0?d="":u<2&&c.length>=1?d="coords = 0;":d=c.map(y=>`coords.${f[y+h]} = 0;`).join(`
`);let m="";return u<2&&a>0?m="coords":m=t.shapeInfo.logicalShape.map((y,x)=>`coords.${f[x+h]}`).join(", "),`
    float ${r}() {
      ${l} coords = getOutputCoords();
      ${d}
      return get${s}(${m});
    }
  `}function ln(t){if(t<=1)return"int";if(t===2)return"ivec2";if(t===3)return"ivec3";if(t===4)return"ivec4";if(t===5)return"ivec5";if(t===6)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function oR(t,e,n){const{newShape:s,keptDims:r}=Fl(e),o=e.length,i=t&&o===3&&e[0]===1,a=i?e.slice(1):s,u=!t&&o>1&&!kt(e,n)&&s.length<o||i;return{useSqueezeShape:u,uniformShape:u?a:e,keptDims:r}}function Mf(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function zf(t,e){return e.map(n=>t[n]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dEe(t,e,n,s){const r=n.map((c,h)=>{const d={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(d.flatOffset=c.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:d}}),o=r.map(c=>c.shapeInfo),i={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},a=RTe(r,i,e),u=oTe(t.gl,a),l=t.createProgram(u);return ce().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:u,source:a,webGLProgram:l,inShapeInfos:o,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(t.buildVao(l),Object.assign({program:e,fragmentShader:u,source:a,webGLProgram:l,inShapeInfos:o,outShapeInfo:i},DH(t,e,l)))}function DH(t,e,n){const s=[],r=[];let o,i,a,u=null,l=null;l=t.getUniformLocation(n,"NAN",!1),ce().getNumber("WEBGL_VERSION")===1&&(u=t.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const h of e.variableNames){const d={name:h,uniform:t.getUniformLocation(n,h,c),offset:t.getUniformLocation(n,`offset${h}`,c)};e.enableShapeUniforms&&(d.shape=t.getUniformLocation(n,`${h}Shape`,c),d.texShape=t.getUniformLocation(n,`${h}TexShape`,c)),s.push(d)}if(e.enableShapeUniforms&&(o=t.getUniformLocation(n,"outShape",c),a=t.getUniformLocation(n,"outShapeStrides",c),i=t.getUniformLocation(n,"outTexShape",c)),e.customUniforms)for(const h of e.customUniforms)r.push(t.getUniformLocation(n,h.name,c));return{variablesLocations:s,customUniformLocations:r,infLoc:u,nanLoc:l,outShapeLocation:o,outShapeStridesLocation:a,outTexShapeLocation:i}}function nF(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((n,s)=>{const r=n.logicalShape,o=e[s],i=o.shape;if(!kt(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(n.isUniform&&o.isUniform)return;const a=n.texShape,u=o.isUniform?null:o.texData.texShape;if(!kt(a,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`)})}function pEe(t,e,n,s,r){e.program.enableShapeUniforms||(nF(e.inShapeInfos,n),nF([e.outShapeInfo],[s]));const o=s.texData.texture,i=s.texData.texShape;s.texData.isPacked?t.setOutputPackedMatrixTexture(o.texture,i[0],i[1]):t.setOutputMatrixTexture(o.texture,i[0],i[1]),t.setProgram(e.webGLProgram),t.bindVertexArray(e.webGLProgram.vao),ce().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&t.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&t.gl.uniform1f(e.nanLoc,NaN);for(let u=0;u<n.length;++u){const l=n[u],{uniform:c,offset:h,shape:d,texShape:f}=e.variablesLocations[u];if(d){const{uniformShape:m}=oR(e.program.packedInputs,l.shape,l.texData.texShape);switch(m.length){case 1:t.gl.uniform1iv(d,new Int32Array(m));break;case 2:t.gl.uniform2iv(d,new Int32Array(m));break;case 3:t.gl.uniform3iv(d,new Int32Array(m));break;case 4:t.gl.uniform4iv(d,new Int32Array(m));break}}if(f&&t.gl.uniform2i(f,l.texData.texShape[0],l.texData.texShape[1]),c!=null){if(l.isUniform){if(ie(l.shape)<2)t.gl.uniform1f(c,l.uniformValues[0]);else{let m=l.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),t.gl.uniform1fv(c,m)}continue}l.texData.slice!=null&&h!=null&&t.gl.uniform1i(h,l.texData.slice.flatOffset),t.setInputMatrixTexture(l.texData.texture.texture,c,u)}}const a=e.outShapeLocation;if(a)switch(s.shape.length){case 1:t.gl.uniform1iv(a,new Int32Array(s.shape));break;case 2:t.gl.uniform2iv(a,new Int32Array(s.shape));break;case 3:t.gl.uniform3iv(a,new Int32Array(s.shape));break;case 4:t.gl.uniform4iv(a,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const u=et(s.shape);switch(s.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(u));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(u));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(u));break}}if(e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r)for(let u=0;u<e.program.customUniforms.length;++u){const l=e.program.customUniforms[u],c=e.customUniformLocations[u],h=r[u];if(l.type==="float")t.gl.uniform1fv(c,h);else if(l.type==="vec2")t.gl.uniform2fv(c,h);else if(l.type==="vec3")t.gl.uniform3fv(c,h);else if(l.type==="vec4")t.gl.uniform4fv(c,h);else if(l.type==="int")t.gl.uniform1iv(c,h);else if(l.type==="ivec2")t.gl.uniform2iv(c,h);else if(l.type==="ivec3")t.gl.uniform3iv(c,h);else if(l.type==="ivec4")t.gl.uniform4iv(c,h);else throw Error(`uniform type ${l.type} is not supported yet.`)}t.executeProgram()}function fEe(t,e,n){let s="";e.concat(n).forEach(i=>{const a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!i.isUniform){const u=i.texData.texShape,{useSqueezeShape:l,uniformShape:c,keptDims:h}=oR(t.packedInputs,i.shape,u);let d="",f="",m="";if(c.length===1&&t.packedInputs){const I=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];d=`${I[0]>1}_${I[1]>1}`}else if(c.length===2&&!t.packedInputs)f=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!t.packedInputs){const I=et(c);m=`${I[0]===u[1]}_${I[I.length-1]===u[1]}`}const y=i.shape.length,x=c.length===2&&kt(i.shape,u),v=ie(i.shape)===1,w=Sl(i.shape,n.shape),S=!t.packedInputs&&y===n.shape.length&&kt(u,n.texData.texShape),k=t.packedInputs||c.length>2?"":`${u[0]>1}_${u[1]>1}`;s+=`${y}_${S}_${l?h:""}_${c.length}_${v}_${w}_${x}_${d}_${f}_${m}_${k}_${a}`}else{const u=i.isUniform?"uniform":i.texData.texShape;s+=`${i.shape}_${u}_${a}`}});const r=t.userCode;let o=t.constructor.name;return o+="_"+s+"_"+r+`${ce().getNumber("WEBGL_VERSION")}`,o}function er(t){return ce().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mEe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=ry.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=xr();this.outputShape=e,this.enableShapeUniforms=er(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?qS(["r","c","d"],e):Rh(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gEe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=ry.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=xr();this.outputShape=e,this.enableShapeUniforms=er(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?qS(["r","c","d"],e):Rh(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yEe{constructor(e){this.variableNames=["A"],this.outTexUsage=No.DOWNLOAD;const n=xr();this.outputShape=e,this.userCode=`
      ${EH}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xEe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=No.DOWNLOAD;const n=xr();this.outputShape=e,this.userCode=`
      ${EH}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vEe={R:0,G:1,B:2,A:3};class sF{constructor(e,n=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=xr();this.outputShape=e,this.enableShapeUniforms=er(this.outputShape.length);let o="result";n&&(o="floor(result * 255. + 0.5)");let i="";for(let a=0;a<s.length;a++){const u=s[a];i+=`
          if(offset == ${a}) {
            result = values[${vEe[u]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?rR():sR(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${i}
        }
        ${r.output} = vec4(${o}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wEe{constructor(e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=xr();this.outputShape=e,this.enableShapeUniforms=er(this.outputShape.length);let r="",o="result";n&&(o="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){const u=i*2+a;r+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?rR():sR(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${o};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bEe(t){const e=xr(),n=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return rTe(t,n)}function SEe(t){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return lTe(t,e)}function CEe(t){const e=new Uint16Array([0,1,2,2,1,3]);return cTe(t,e)}function z0(t,e,n,s,r,o){dTe(e,n);const i=hTe(t),a=t.TEXTURE_2D;return Ue(t,()=>t.bindTexture(a,i)),Ue(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),Ue(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),Ue(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),Ue(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),ce().getNumber("WEBGL_VERSION")===1?Ue(t,()=>t.texImage2D(a,0,s,e,n,0,r,o,null)):Ue(t,()=>t.texStorage2D(a,1,s,e,n)),Ue(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:i,texShape:[n,e]}}function PH(t){return t.internalFormatFloat}function kEe(t,e,n,s){const[r,o]=L0(e,n);return z0(t,r,o,PH(s),s.textureFormatFloat,t.FLOAT)}function FH(t){return t.internalFormatHalfFloat}function IEe(t,e,n,s){const[r,o]=L0(e,n);return z0(t,r,o,FH(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function OH(t){return t.downloadTextureFormat}function $Ee(t,e,n,s){const[r,o]=L0(e,n);return z0(t,r,o,OH(s),t.RGBA,t.UNSIGNED_BYTE)}function LH(t){return t.internalFormatPackedFloat}function NEe(t,e,n,s){const[r,o]=Ff(e,n);return z0(t,r,o,LH(s),t.RGBA,t.FLOAT)}function MH(t){return t.internalFormatPackedHalfFloat}function TEe(t,e,n,s){const[r,o]=Ff(e,n);return z0(t,r,o,MH(s),t.RGBA,s.textureTypeHalfFloat)}function EEe(t,e,n){return Ue(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),JP(t,e,"clipSpacePos",n,3,20,0)&&JP(t,e,"uv",n,2,20,12)}function REe(t,e,n,s,r,o){Ue(t,()=>t.bindTexture(t.TEXTURE_2D,e));let i,a,u;r instanceof Uint8Array?(i=new Uint8Array(n*s*4),a=t.UNSIGNED_BYTE,u=t.RGBA):(i=new Float32Array(n*s*4),a=t.FLOAT,u=o.internalFormatPackedFloat),i.set(r),ce().getNumber("WEBGL_VERSION")===2?Ue(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,s,t.RGBA,a,i)):Ue(t,()=>t.texImage2D(t.TEXTURE_2D,0,u,n,s,0,t.RGBA,a,i)),Ue(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function AEe(t,e,n){Ue(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?ce().getNumber("WEBGL_VERSION")===2?Ue(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data)):Ue(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):ce().getNumber("WEBGL_VERSION")===2?Ue(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n)):Ue(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),Ue(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function _Ee(t,e,n,s){const r=t.createBuffer();Ue(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,r));const a=4*4*e*n;return Ue(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,a,t.STREAM_READ)),Ue(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),Ue(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),r}function DEe(t,e,n){const s=t,r=new Float32Array(n);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function PEe(t,e,n,s){const[r,o]=L0(e,n),i=4,a=new Uint8Array(QNe(e*n,i));return Ue(t,()=>t.readPixels(0,0,r,o,s.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function FEe(t,e,n,s,r,o,i,a){const u=t,l=new Float32Array(ZNe(o,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function OEe(t,e,n){const s=new Float32Array(e*n*4);return Ue(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $k{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=ce().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,XNe(n,e)):this.gl=Xi(n),e=this.gl,ce().getNumber("WEBGL_VERSION")===2){const o=e;this.createVertexArray=()=>Ue(o,()=>o.createVertexArray()),this.bindVertexArray=i=>Ue(o,()=>o.bindVertexArray(i)),this.deleteVertexArray=i=>Ue(o,()=>o.deleteVertexArray(i)),this.getVertexArray=()=>Ue(o,()=>o.getParameter(o.VERTEX_ARRAY_BINDING))}else if(e!=null){const o=e.getExtension("OES_vertex_array_object");if(o==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Ue(e,()=>o.createVertexArrayOES()),this.bindVertexArray=i=>Ue(e,()=>o.bindVertexArrayOES(i)),this.deleteVertexArray=i=>Ue(e,()=>o.deleteVertexArrayOES(i)),this.getVertexArray=()=>Ue(e,()=>e.getParameter(o.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ce().getNumber("WEBGL_VERSION")===1){const o="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=T1(this.gl,o),hi(this.gl,i))this.textureHalfFloatExtension=T1(this.gl,i);else if(ce().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),hi(this.gl,r))this.colorBufferHalfFloatExtension=T1(this.gl,r);else if(ce().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",hi(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(hi(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=SEe(this.gl),this.indexBuffer=CEe(this.gl),this.framebuffer=pTe(this.gl),this.textureConfig=nR(this.gl,this.textureHalfFloatExtension)}get debug(){return ce().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Ue(e,()=>e.finish()),Ue(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Ue(e,()=>e.deleteFramebuffer(this.framebuffer)),Ue(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Ue(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Ue(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,n){return this.throwIfDisposed(),kEe(this.gl,e,n,this.textureConfig)}createFloat16MatrixTexture(e,n){return this.throwIfDisposed(),IEe(this.gl,e,n,this.textureConfig)}createUnsignedBytesMatrixTexture(e,n){return this.throwIfDisposed(),$Ee(this.gl,e,n,this.textureConfig)}uploadPixelDataToTexture(e,n){this.throwIfDisposed(),AEe(this.gl,e,n)}uploadDenseMatrixToTexture(e,n,s,r){this.throwIfDisposed(),REe(this.gl,e,n,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,n){return this.throwIfDisposed(),TEe(this.gl,e,n,this.textureConfig)}createPackedMatrixTexture(e,n){return this.throwIfDisposed(),NEe(this.gl,e,n,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(eF(this.gl,this.framebuffer),this.outputTexture=null),Ue(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,n,s){return this.downloadMatrixDriver(e,()=>PEe(this.gl,n,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,n,s,r,o,i){return FEe(this.gl,e,n,s,r,o,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,n){return DEe(this.gl,e,n)}createBufferFromTexture(e,n,s){this.bindTextureToFrameBuffer(e);const r=_Ee(this.gl,n,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,s;if(ce().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,o=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const i=r.clientWaitSync(o,0,0);return i===r.ALREADY_SIGNALED||i===r.CONDITION_SATISFIED},n=o}else ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(n,ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:n,isFencePassed:s}}downloadMatrixFromPackedTexture(e,n,s){return this.downloadMatrixDriver(e,()=>OEe(this.gl,n,s))}createProgram(e){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=bEe(n));const s=aTe(n);Ue(n,()=>n.attachShader(s,this.vertexShader)),Ue(n,()=>n.attachShader(s,e)),uTe(n,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&Sk(n,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const n=this.gl;Ue(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),EEe(n,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Ue(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Sk(this.gl,this.program),Ue(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,n,s=!0){return this.throwIfDisposed(),s?mTe(this.gl,e,n):gTe(this.gl,e,n)}getAttributeLocation(e,n){return this.throwIfDisposed(),Ue(this.gl,()=>this.gl.getAttribLocation(e,n))}getUniformLocationNoThrow(e,n){return this.throwIfDisposed(),this.gl.getUniformLocation(e,n)}setInputMatrixTexture(e,n,s){this.throwIfDisposed(),this.throwIfNoProgram(),yTe(this.gl,e,n,s)}setOutputMatrixTexture(e,n,s){this.setOutputMatrixTextureDriver(e,s,n)}setOutputPackedMatrixTexture(e,n,s){this.throwIfDisposed();const[r,o]=Ff(n,s);this.setOutputMatrixTextureDriver(e,r,o)}setOutputMatrixWriteRegion(e,n,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,n)}setOutputPackedMatrixWriteRegion(e,n,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Sk(this.gl,this.program),E1(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Ue(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ue(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=T1(this.gl,ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,o),o}const e=this.getQueryTimerExtensionWebGL1(),n=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,n),n}endQuery(){if(ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,s=this.getQueryTimerExtensionWebGL2();n.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await KD(()=>this.disposed||this.isQueryAvailable(e,ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,n){if(n===0)return null;if(n===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,n){if(n===0)return!0;if(n===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),o=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(n=>{this.addItemToPoll(()=>e.isFencePassed(),()=>n())})}pollItems(){const e=LEe(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=e;++n){const{resolveFn:s}=this.itemsToPoll[n];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,n){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in ce().platform&&(s=ce().platform.setTimeoutCustom.bind(ce().platform)),KD(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Ck(this.gl,e,this.framebuffer),this.debug&&E1(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Ck(this.gl,this.outputTexture,this.framebuffer),this.debug&&E1(this.gl)):eF(this.gl,this.framebuffer)}downloadMatrixDriver(e,n){this.bindTextureToFrameBuffer(e);const s=n();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,n,s){this.throwIfDisposed();const r=this.gl;Ck(r,e,this.framebuffer),this.debug&&E1(r),this.outputTexture=e,Ue(r,()=>r.viewport(0,0,n,s)),Ue(r,()=>r.scissor(0,0,n,s))}setOutputMatrixWriteRegionDriver(e,n,s,r){this.throwIfDisposed(),Ue(this.gl,()=>this.gl.scissor(e,n,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function LEe(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:MEe,bincountImpl:zH,bincountReduceImpl:zEe,bitwiseAndImpl:BEe,castImpl:VEe,ceilImpl:WEe,concatImpl:UEe,equalImpl:GEe,expImpl:HEe,expm1Impl:jEe,floorImpl:KEe,gatherNdImpl:XEe,gatherV2Impl:qEe,greaterImpl:YEe,greaterEqualImpl:QEe,lessImpl:ZEe,lessEqualImpl:JEe,linSpaceImpl:eRe,logImpl:tRe,maxImpl:nRe,maximumImpl:sRe,minimumImpl:rRe,multiplyImpl:oRe,negImpl:iRe,notEqualImpl:aRe,prodImpl:uRe,raggedGatherImpl:lRe,raggedRangeImpl:cRe,raggedTensorToTensorImpl:hRe,rangeImpl:dRe,rsqrtImpl:pRe,scatterImpl:fRe,sigmoidImpl:mRe,simpleAbsImpl:BH,sliceImpl:gRe,sparseFillEmptyRowsImpl:yRe,sparseReshapeImpl:xRe,sparseSegmentReductionImpl:VH,sqrtImpl:vRe,staticRegexReplaceImpl:wRe,stridedSliceImpl:bRe,stringNGramsImpl:SRe,stringSplitImpl:CRe,stringToHashBucketFastImpl:kRe,subImpl:IRe,tileImpl:$Re,topKImpl:NRe,transposeImpl:iR,uniqueImpl:TRe}=lW;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WH(t,e){return["x","y","z","w","u","v"].slice(0,e).map(n=>`${t}.${n}`)}function pr(t,e){return e===1?[t]:WH(t,e)}function ERe(t,e){if(t===1)return"rc";let n="";for(let s=0;s<t;s++)n+=e[s],s<t-1&&(n+=",");return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RRe{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=er(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=pr("rc",this.rank),s=ln(this.rank),r=this.getOutOfBoundsCondition(n),o=this.getSetup(n),i=this.getOutput(n);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${o}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(e){const n=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let o=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)o=`${e[e.length-1-i]},`+o;n.push(o)}return n}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let s=this.rank-2;s<this.rank;s++)n+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(n+="||");return n}getSetup(e){if(this.rank===1)return"";const n=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const n=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UH{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=er(this.outputShape.length);let s="";for(let r=0;r<4;r++){let o="thisRC = rc;";r%2===1&&(o+="thisRC.z += 1;"),r>1&&(o+="thisRC.y += 1;"),s+=`
        ${o}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${ARe(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?rR():sR(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function ARe(t,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?ETe(["r","c","d"],"inputShape"):Rh(["r","c","d"],t)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _Re{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,n,s){const r=oF(n,s),o=iF(e,r,s);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);const i=rF(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const u=this.freeTextures[o].pop();return this.usedTextures[o].push(u),u}let a;return r===zs.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===zs.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===zs.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===zs.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===zs.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(e,n,s,r){if(this.freeTextures==null)return;const o=oF(s,r),i=iF(n,o,r);i in this.freeTextures||(this.freeTextures[i]=[]);const a=rF(n,o,this.gpgpu.gl,this.gpgpu.textureConfig,r),u=ce().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const l=this.usedTextures[i],c=l&&l.indexOf(e);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[c]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function DRe(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function rF(t,e,n,s,r){const o=PRe(e,s);let i;if(r){const[u,l]=Ff(t[0],t[1]);i=u*l}else{const[u,l]=L0(t[0],t[1]);i=u*l}const a=DRe(n,o);return i*a}function PRe(t,e){switch(t){case zs.PACKED_2X2_FLOAT32:return LH(e);case zs.PACKED_2X2_FLOAT16:return MH(e);case zs.UNPACKED_FLOAT32:return PH(e);case zs.UNPACKED_FLOAT16:return FH(e);case zs.PACKED_4X1_UNSIGNED_BYTE:return OH(e);default:throw new Error(`Unknown physical texture type ${t}`)}}function FRe(t){return ce().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?zs.PACKED_2X2_FLOAT32:zs.UNPACKED_FLOAT32:t?zs.PACKED_2X2_FLOAT16:zs.UNPACKED_FLOAT16}function oF(t,e){if(t===No.UPLOAD)return zs.PACKED_2X2_FLOAT32;if(t===No.RENDER||t==null)return FRe(e);if(t===No.DOWNLOAD||t===No.PIXELS)return zs.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function iF(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ma{constructor(e,n){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=er(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Si="if (isnan(x)) return x;",ORe="return x;",aF="return abs(x);",LRe="return (x >= 0.0) ? x : (exp(x) - 1.0);",MRe=Si+`
  return (x < 0.0) ? 0.0 : x;
`,zRe=Si+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,ju="return x;",BRe="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VRe="return x;",WRe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,URe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,GRe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,HRe="return 1.0 / (1.0 + exp(-1.0 * x));";class tl{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=er(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jRe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=er(this.outputShape.length);const n=e.length,s=pr("rc",n),r=ln(n),o=ERe(n,s),i=s.slice(-2),a=n<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KRe=oE,XRe=1e-7,qRe=1e-4,_1={};function YRe(t){return t in _1||(_1[t]={}),_1[t]}const QRe=ce().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),ZRe=600;function JRe(){return ce().global.screen==null?1024:ce().global.screen.height*ce().global.screen.width*window.devicePixelRatio*ZRe/1024/1024}class YS extends Vw{nextDataId(){return YS.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ce().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(e!=null){if(e instanceof $k)n=e;else{const s=Xi(ce().getNumber("WEBGL_VERSION"),e);n=new $k(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Xi(ce().getNumber("WEBGL_VERSION"));n=new $k(s),this.binaryCache=YRe(ce().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new _Re(this.gpgpu),this.numMBBeforeWarning=JRe(),this.texData=new nT(this,lr())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,n,s,r,o,i){const a=this.makeTensorInfo(n,s),u=this.texData.get(a.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[r,o]},u.texShape=[r,o];const l=R1(n),c=new sF(l,!1,i),h=this.runWebGLProgram(c,[a],s,[[r,o]]);return h.shape=n,u.texture=null,this.disposeIntermediateTensorInfo(a),h.dataId}write(e,n,s){if((ce().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ce().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:n,dtype:s,values:e,usage:No.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const n=this.texData.get(e);n.refCount++}decRef(e){if(this.texData.has(e)){const n=this.texData.get(e);n.refCount--}}move(e,n,s,r,o){if(ce().getBool("DEBUG")&&this.checkNumericalProblems(n),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:n,usage:No.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const n=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:o,slice:i,shape:a,isPacked:u}=n;if(i!=null){let d;u?d=new tl(a,ju):d=new ma(a,ju);const f=this.runWebGLProgram(d,[{dataId:e,shape:a,dtype:r}],r),m=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),m}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const l=this.activeTimers!=null;let c;l&&(c=Tr());let h;if(r==="complex64"){const d=this.readSync(o.real.dataId),f=this.readSync(o.imag.dataId);h=Gi(d,f)}else h=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=Tr()-c),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const m=this.pendingRead.get(e);return new Promise(y=>m.push(y))}const n=this.texData.get(e),{values:s,shape:r,slice:o,dtype:i,complexTensorInfos:a,isPacked:u}=n;if(o!=null){let m;u?m=new tl(r,ju):m=new ma(r,ju);const y=this.runWebGLProgram(m,[{dataId:e,shape:r,dtype:i}],i),x=this.read(y.dataId);return this.disposeIntermediateTensorInfo(y),x}if(s!=null)return this.convertAndCacheOnCPU(e);if(ce().getBool("DEBUG")&&!ce().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ce().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,c;if(i!=="complex64"&&ce().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const m=this.texData.get(c.dataId);l=this.gpgpu.createBufferFromTexture(m.texture.texture,...N1(r))}this.pendingRead.set(e,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(i==="complex64"){const m=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),y=m[0],x=m[1];h=Gi(y,x)}else if(l==null)h=this.getValuesFromTexture(e);else{const m=ie(r);h=this.gpgpu.downloadFloat32MatrixFromBuffer(l,m)}if(c!=null&&this.disposeIntermediateTensorInfo(c),l!=null){const m=this.gpgpu.gl;Ue(m,()=>m.deleteBuffer(l))}const d=this.convertAndCacheOnCPU(e,h),f=this.pendingRead.get(e);return this.pendingRead.delete(e),f.forEach(m=>m(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&lr().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,n={}){const s=this.texData.get(e),{values:r,shape:o,slice:i,dtype:a,isPacked:u,texture:l}=s;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let f;u?f=new tl(o,ju):f=new ma(o,ju);const m=this.runWebGLProgram(f,[{dataId:e,shape:o,dtype:a}],a),y=this.readToGPU(m,n);return this.disposeIntermediateTensorInfo(m),y}if(l==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(e,n.customTexShape),h=lr().makeTensorFromTensorInfo(c),d=this.texData.get(c.dataId);return Object.assign({tensorRef:h},d.texture)}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const s=n.map(r=>Vi(r));return xt(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return xt(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let n=0;n<e.length;n++){const s=e[n];if(!nTe(s))throw ce().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:n,dtype:s,isPacked:r}=this.texData.get(e),o=ie(n);if(ce().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const d=this.decode(e),f=this.texData.get(d.dataId),m=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,...N1(n)).subarray(0,o);return this.disposeIntermediateTensorInfo(d),m}const i=ce().getBool("WEBGL_PACK")&&r===!0,a=i?R1(n):n,u=i?new xEe(a):new yEe(a),l=this.runWebGLProgram(u,[{shape:a,dtype:s,dataId:e}],"float32"),c=this.texData.get(l.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(l),h}timerAvailable(){return ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const n=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const o=xu(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),i=xu(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=n,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=await Promise.all(o);a.kernelMs=Sz(u),a.getExtraProfileInfo=()=>u.map((l,c)=>({name:i[c],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Tr(),endMs:null}}endTimer(e){return ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Tr(),e)}async getQueryTime(e){if(ce().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const n=e;return n.endMs-n.startMs}disposeData(e,n=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,n),this.disposeData(s.imag.dataId,n)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:n,dtype:s,texShape:r,usage:o,isPacked:i,slice:a}=this.texData.get(e),u=a&&a.origDataId||e,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),n!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(n,r,o,i)));const c=this.texData.get(e);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,n=QRe){return ce().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&ie(s.shape)<n)}getGPGPUContext(){return this.gpgpu}where(e){Io("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=e.dataSync();return KRe(e.shape,n)}packedUnaryOp(e,n,s){const r=new tl(e.shape,n),o=this.compileAndRun(r,[e],s);return lr().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=BH(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(ce().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,aF,e.dtype);const n=new ma(e.shape,aF),s=this.compileAndRun(n,[e]);return lr().makeTensorFromTensorInfo(s)}makeTensorInfo(e,n,s){let r;if(n==="string"&&s!=null&&s.length>0&&Tp(s[0])){const o=s.map(i=>iu(i));r=this.write(o,e,n)}else r=this.write(s,e,n);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:n}}makeOutput(e,n,s){return lr().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,s),this)}unpackTensor(e){const n=new jRe(e.shape);return this.runWebGLProgram(n,[e],e.dtype)}packTensor(e){const n=new RRe(e.shape),s=!0;return this.runWebGLProgram(n,[e],e.dtype,null,s)}packedReshape(e,n){const s=[vp(e.shape),...wp(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},o=[vp(n),...wp(n)],i=new UH(o,s),a=!0,u=[s],l=this.runWebGLProgram(i,[r],e.dtype,u,a);return{dataId:l.dataId,shape:n,dtype:l.dtype}}decode(e,n){const s=this.texData.get(e),{isPacked:r,shape:o,dtype:i}=s;if(n!=null){const d=ie(o),f=n[0]*n[1]*4;O(d<=f,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=R1(o);let u;r?u=new gEe(a):u=new mEe(a);const l=!0,c=[n??N1(a)],h=this.runWebGLProgram(u,[{shape:a,dtype:i,dataId:e}],i,c,l,n);return{dtype:i,shape:o,dataId:h.dataId}}runWebGLProgram(e,n,s,r,o=!1,i){const a=this.makeTensorInfo(e.outputShape,s),u=this.texData.get(a.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===ry.DENSE){const v=i??N1(e.outputShape);u.texShape=v.map(w=>w*2)}if(e.outTexUsage!=null&&(u.usage=e.outTexUsage),ie(a.shape)===0)return u.values=ws(a.dtype,0),a;const l=[],c=n.map(v=>{if(v.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let w=this.texData.get(v.dataId);if(w.texture==null){if(!e.packedInputs&&ie(v.shape)<=ce().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:v.shape,texData:null,isUniform:!0,uniformValues:w.values};e.packedInputs&&(w.isPacked=!0,w.shape=v.shape)}if(this.uploadToGPU(v.dataId),!!w.isPacked!=!!e.packedInputs)v=w.isPacked?this.unpackTensor(v):this.packTensor(v),l.push(v),w=this.texData.get(v.dataId);else if(w.isPacked&&!uw(w.shape,v.shape)){const S=v,k=v.shape;v.shape=w.shape,v=this.packedReshape(v,k),l.push(v),w=this.texData.get(v.dataId),S.shape=k}return{shape:v.shape,texData:w,isUniform:!1}});this.uploadToGPU(a.dataId);const h={shape:a.shape,texData:u,isUniform:!1},d=fEe(e,c,h),f=this.getAndSaveBinary(d,()=>dEe(this.gpgpu,e,c,h)),m=this.activeTimers!=null;let y;m&&(y=this.startTimer()),ce().get("ENGINE_COMPILE_ONLY")||pEe(this.gpgpu,f,c,h,r),l.forEach(v=>this.disposeIntermediateTensorInfo(v)),m&&(y=this.endTimer(y),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(y)}));const x=ce().getNumber("WEBGL_FLUSH_THRESHOLD");if(x>0){const v=Tr();v-this.lastGlFlushTime>x&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=v)}if(!ce().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&o===!1){const v=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),v}return a}compileAndRun(e,n,s,r,o=!1){return s=s||n[0].dtype,this.runWebGLProgram(e,n,s,r,o)}getAndSaveBinary(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ce().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ae(()=>{if(!ce().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ce().getBool("DEBUG");ce().set("DEBUG",!1);const n=this.abs(nt(1e-8)).dataSync()[0];if(ce().set("DEBUG",e),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?XRe:qRe}uploadToGPU(e){const n=this.texData.get(e),{shape:s,dtype:r,values:o,texture:i,usage:a,isPacked:u}=n;if(i!=null)return;const l=this.activeTimers!=null;let c;l&&(c=Tr());let h=n.texShape;if(h==null&&(h=wTe(s,u),n.texShape=h),o!=null){const d=R1(s);let f,m=h[1],y=h[0];const x=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(u||!x)&&([m,y]=Ff(h[0],h[1])),u?f=new wEe(d,x):f=new sF(d,x);const v=x?[y,m]:h,w=this.makeTensorInfo(v,r),S=this.texData.get(w.dataId);x?S.usage=No.PIXELS:S.usage=No.UPLOAD,S.texShape=v,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(w.dataId),m,y,o);const k=[[y,m]],I=!0,T=this.runWebGLProgram(f,[w],r,k,I),R=this.texData.get(T.dataId);n.texShape=R.texShape,n.isPacked=R.isPacked,n.usage=R.usage,ce().get("ENGINE_COMPILE_ONLY")?this.disposeData(T.dataId):(n.texture=R.texture,n.values=null,this.texData.delete(T.dataId)),this.disposeIntermediateTensorInfo(w),l&&(this.uploadWaitMs+=Tr()-c)}else{const d=this.acquireTexture(h,a,r,u);n.texture=d}}convertAndCacheOnCPU(e,n){const s=this.texData.get(e),{dtype:r}=s;return n!=null&&(s.values=eAe(n,r)),s.values}acquireTexture(e,n,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,n,r)}computeBytes(e,n){return e[0]*e[1]*Av(n)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(n));return Promise.all(e)}else{for(const[,n]of Object.entries(this.binaryCache)){const s=new Promise(r=>{try{this.checkCompletion_(n),r(!0)}catch(o){throw o}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await OV(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(TH(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:n,customUniformLocations:s,infLoc:r,nanLoc:o,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:u}=DH(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=n,e.customUniformLocations=s,e.infLoc=r,e.nanLoc=o,e.outShapeLocation=i,e.outShapeStridesLocation=a,e.outTexShapeLocation=u}}createTensorFromGPUData(e,n,s){e.channels=e.channels||"RGBA";const{texture:r,height:o,width:i,channels:a}=e,u=lr().backend;if(!u.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=u.writeTexture(r,n,s,o,i,a);return lr().makeTensorFromDataId(l,n,s,u)}}YS.nextDataId=0;function eAe(t,e){if(e==="float32"||e==="complex64")return t;if(e==="int32"||e==="bool"){const n=e==="int32"?new Int32Array(t.length):new Uint8Array(t.length);for(let s=0;s<n.length;++s)n[s]=Math.round(t[s]);return n}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Gz()&&wT("webgl",()=>new YS,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aR=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class hh{constructor(e,n,s){this.variableNames=["A","B"],this.outputShape=ut(n,s),this.enableShapeUniforms=er(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _h=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Bf{constructor(e,n,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ut(n,s);const o=this.outputShape.length;this.enableShapeUniforms=er(o);let i="";if(r)if(o===0||ie(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${ln(o)} coords = getOutputCoords();
        `,o===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const u=pr("coords",o);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${u[o-2]} + 1) >= outShape[${o} - 2];
            bool nextColOutOfBounds =
              (${u[o-1]} + 1) >= outShape[${o} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${u[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${u[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function co(t){const{inputs:e,backend:n}=t,{x:s}=e;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const tAe={kernelName:Yp,backendName:"webgl",kernelFunc:co};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hl(t){const{inputs:e,backend:n}=t,{real:s,imag:r}=e,o=n.makeTensorInfo(s.shape,"complex64"),i=n.texData.get(o.dataId),a=co({inputs:{x:s},backend:n}),u=co({inputs:{x:r},backend:n});return i.complexTensorInfos={real:a,imag:u},o}const nAe={kernelName:qw,backendName:"webgl",kernelFunc:Hl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GH="return (a < 0.) ? b * a : a;",HH=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function sAe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{alpha:o}=s,i=n.makeTensorInfo([],"float32",Ol(o,"float32")),a=ce().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Bf(HH,r.shape,i.shape):new hh(GH,r.shape,i.shape),u=n.runWebGLProgram(a,[r,i],"float32");return n.disposeIntermediateTensorInfo(i),u}const rAe={kernelName:Ly,backendName:"webgl",kernelFunc:sAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jH="return (a < 0.) ? b * a : a;",KH=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function oAe(t){const{inputs:e,backend:n}=t,{x:s,alpha:r}=e,o=ce().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Bf(KH,s.shape,r.shape):new hh(jH,s.shape,r.shape);return n.runWebGLProgram(o,[s,r],"float32")}const iAe={kernelName:n0,backendName:"webgl",kernelFunc:oAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vf="if (isnan(x)) return x;";function jt({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:s}){return({inputs:r,backend:o})=>{const{x:i}=r,a=o,u=s||i.dtype;if(a.shouldExecuteOnCPU([i])&&n!=null){const h=a.texData.get(i.dataId),d=n(h.values,u);return a.makeTensorInfo(i.shape,u,d)}const l=ce().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let c;return l?c=new tl(i.shape,e):c=new ma(i.shape,t),a.runWebGLProgram(c,[i],u)}}function Us({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:o}){return({inputs:i,backend:a})=>{const{a:u,b:l}=i,c=a;if(s&&u.dtype==="complex64"){const m=c.texData.get(u.dataId),y=c.texData.get(l.dataId),[x,v]=[[m.complexTensorInfos.real,y.complexTensorInfos.real],[m.complexTensorInfos.imag,y.complexTensorInfos.imag]].map(S=>{const[k,I]=S,T={dataId:k.dataId,dtype:k.dtype,shape:u.shape},R={dataId:I.dataId,dtype:I.dtype,shape:l.shape},_=new hh(t,u.shape,l.shape);return c.runWebGLProgram(_,[T,R],_s(k.dtype,I.dtype))}),w=Hl({inputs:{real:x,imag:v},backend:c});return c.disposeIntermediateTensorInfo(x),c.disposeIntermediateTensorInfo(v),w}const h=o||_s(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||c.shouldExecuteOnCPU([u,l]))&&r!=null){const m=c.texData.get(u.dataId).values,y=c.texData.get(l.dataId).values,x=u.dtype==="string"?Hi(m):m,v=u.dtype==="string"?Hi(y):y,[w,S]=r(u.shape,l.shape,x,v,h),k=c.makeTensorInfo(S,h),I=c.texData.get(k.dataId);return I.values=w,k}const d=ce().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let f;return d?f=new Bf(e,u.shape,l.shape,n):f=new hh(t,u.shape,l.shape),c.runWebGLProgram(f,[u,l],h)}}function oy(t,e=!1){if(t==="linear")return e?VRe:ORe;if(t==="relu")return e?URe:MRe;if(t==="elu")return e?WRe:LRe;if(t==="relu6")return e?GRe:zRe;if(t==="prelu")return e?KH:jH;if(t==="leakyrelu")return e?HH:GH;if(t==="sigmoid")return e?HRe:BRe;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XH{constructor(e,n,s,r=!1,o=!1,i=!1,a=null,u=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=er(this.outputShape.length);const c=r?e[1]:e[2],h=Math.ceil(c/2),d=r?"i * 2, rc.y":"rc.y, i * 2",f=o?"rc.z, i * 2":"i * 2, rc.z",m=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],y=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let x="",v="";a&&(u?x=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:l?x=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:x=`vec4 activation(vec4 x) {
          ${a}
        }`,v="result = activation(result);");const w=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let S="rc.x",k="rc.x";e[0]<n[0]?S=`imod(rc.x, ${e[0]})`:n[0]<e[0]&&(k=`imod(rc.x, ${n[0]})`),this.userCode=`
      ${x}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${S};
        int batchB = ${k};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${m[0]} * ${y[0]});
          result += (${m[1]} * ${y[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${w}

        ${v}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uF={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class lF{constructor(e,n,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ut(n,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cF="return a * b;";function uR(t){const{inputs:e,backend:n}=t,{a:s,b:r}=e,o=_s(s.dtype,r.dtype);if(s.dtype==="complex64"){const a=n.texData.get(s.dataId),u=n.texData.get(r.dataId),l=new lF(uF.REAL,s.shape,r.shape),c=new lF(uF.IMAG,s.shape,r.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:s.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:r.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:r.shape}],d=n.runWebGLProgram(l,h,"float32"),f=n.runWebGLProgram(c,h,"float32"),m=Hl({inputs:{real:d,imag:f},backend:n});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),m}if(n.shouldExecuteOnCPU([s,r])){const a=n.texData.get(s.dataId),u=n.texData.get(r.dataId),[l,c]=oRe(s.shape,r.shape,a.values,u.values,o),h=n.makeTensorInfo(c,o),d=n.texData.get(h.dataId);return d.values=l,h}let i;return ce().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Bf(cF,s.shape,r.shape):i=new hh(cF,s.shape,r.shape),n.runWebGLProgram(i,[s,r],o)}const aAe={kernelName:of,backendName:"webgl",kernelFunc:uR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uAe(t,e,n){const s=[vp(t.shape),...wp(t.shape)],r={dtype:t.dtype,shape:s,dataId:t.dataId},o=[vp(e),...wp(e)],i=new UH(o,s),a=!0,u=[s],l=n.runWebGLProgram(i,[r],t.dtype,u,a);return{dataId:l.dataId,shape:e,dtype:l.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Le(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{shape:o}=s,i=n,a=ie(r.shape),u=rT(o,a),l=ie(u);O(a===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(r.dataId);return c.isPacked&&!uw(r.shape,u)&&!(c.texture!==null&&uw(c.shape,u))?uAe(r,u,i):(i.incRef(r.dataId),{dataId:r.dataId,shape:u,dtype:r.dtype})}const lAe={kernelName:r0,backendName:"webgl",kernelFunc:Le};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hF{constructor(e,n){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:o,outSize:i}=e;this.outputShape=[r,i];const a=Math.floor(s/4)*4,u=s%4;let l="sumValue += dot(values, ones);";if(n!=null){const h=1/n;l=`sumValue += dot(values * ${ip(h)?h.toPrecision(2):h}, ones);`}let c="";o%s>0&&(c=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${a};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cAe{constructor(e,n){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:o,outSize:i}=e;this.outputShape=[r,i];let a="0.0",u="";n==="prod"?a="1.0":n==="min"?(a="1.0 / 1e-20",u="min"):n==="max"&&(a="-1.0 / 1e-20",u="max");let l=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?l="sumValue":n==="prod"?l="prodValue":n==="all"?l="allValue":n==="any"&&(l="anyValue");const c=Math.floor(s/4)*4,h=s%4;let d=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f="vec4";n==="all"?(a="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):n==="any"&&(a="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let m="";o%s>0&&(m=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${m}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${l});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hAe(t){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const n=e.length?e[e.length-1].outSize:t[1],s=gS(n);e.push({inSize:n,windowSize:s,outSize:Math.ceil(n/s)})}return e}function Dh(t,e,n,s){const r=hAe(t.shape);let o=t;for(let i=0;i<r.length;i++){const{inSize:a,windowSize:u,outSize:l}=r[i];let c,h;n==="mean"?c=i===0?new hF({windowSize:u,inSize:a,batchSize:t.shape[0],outSize:l},a):new hF({windowSize:u,inSize:a,batchSize:t.shape[0],outSize:l}):c=new cAe({windowSize:u,inSize:a,batchSize:t.shape[0],outSize:l},n),h=o,o=s.runWebGLProgram(c,[o],e),h.dataId!==t.dataId&&s.disposeIntermediateTensorInfo(h)}return o}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dAe{constructor(e,n){this.variableNames=["A"];const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[n[i]];this.outputShape=s,this.rank=s.length;const r=ln(this.rank),o=pAe(n);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}}function pAe(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<t.length;r++)s[t[r]]=n[r];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fAe{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let c=0;c<s.length;c++)s[c]=e[n[c]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=ln(this.rank),o=WH("rc",this.rank),i=new Array(this.rank);for(let c=0;c<n.length;c++)i[n[c]]=o[c];const a=`vec2(${i.slice(-2).join()})`,u=`++${o[this.rank-1]} < ${s[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${u}) {
        result[1] = ${l};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${l};
        if(${u}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QS(t,e,n){const s=ce().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fAe(t.shape,e):new dAe(t.shape,e);return n.runWebGLProgram(s,[t],t.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mAe(t,e,n,s){const r=e,o=t.shape.length,i=vt(r,t.shape);let a=i;const u=cn(a,o),l=u!=null;let c=t;l&&(c=QS(t,u,s),a=Sn(a.length,o)),cs("sum",a,o);const[h,d]=ts(c.shape,a);let f=h;n&&(f=qn(h,i));const m=ie(d),x=ie(t.shape)/m,v=Le({inputs:{x:c},attrs:{shape:[x,m]},backend:s}),w=Bb(t.dtype),S=Dh(v,w,"sum",s),k=Le({inputs:{x:S},attrs:{shape:f},backend:s});return s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(S),l&&s.disposeIntermediateTensorInfo(c),k}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZS(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:i}=s;return mAe(r,o,i,n)}const gAe={kernelName:c0,backendName:"webgl",kernelFunc:ZS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gr(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{perm:o}=s,i=n,a=r.shape.length,u=new Array(a);for(let c=0;c<u.length;c++)u[c]=r.shape[o[c]];let l;if(i.shouldExecuteOnCPU([r])){const h=i.texData.get(r.dataId).values,d=iR(h,r.shape,r.dtype,o,u);l=i.makeTensorInfo(u,r.dtype);const f=i.texData.get(l.dataId);f.values=d}else l=QS(r,o,i);return l}const yAe={kernelName:Wc,backendName:"webgl",kernelFunc:gr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qH=1e3;function lw({a:t,b:e,transposeA:n,transposeB:s,backend:r,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){const l=t.shape.length,c=e.shape.length,h=n?t.shape[l-2]:t.shape[l-1],d=s?e.shape[c-1]:e.shape[c-2],f=n?t.shape[l-1]:t.shape[l-2],m=s?e.shape[c-2]:e.shape[c-1],y=t.shape.slice(0,-2),x=e.shape.slice(0,-2),v=ie(y),w=ie(x),k=ut(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([f,m]);O(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${s} must match.`);const I=n?[v,h,f]:[v,f,h],T=s?[w,m,d]:[w,d,m],R=Le({inputs:{x:t},backend:r,attrs:{shape:I}}),_=Le({inputs:{x:e},backend:r,attrs:{shape:T}}),D=[R,_],L=Math.max(v,w),V=n?R.shape[1]:R.shape[2],U=o!=null,j=i!=null,q=u==="leakyrelu",J=u!=null?oy(u,!0):null,te=U||j||q||J!=null;let le;if((f===1||m===1)&&V>qH&&te===!1){let re=R,pe=_;n&&(re=gr({inputs:{x:R},backend:r,attrs:{perm:[0,2,1]}}),D.push(re)),s&&(pe=gr({inputs:{x:_},backend:r,attrs:{perm:[0,2,1]}}),D.push(pe));const he=m!==1,xe=m===1;let Ce=re;he&&(Ce=Le({inputs:{x:re},backend:r,attrs:{shape:[L,V,1]}}),D.push(Ce));const Ee=m===1?2:1;let Ie=pe;xe&&(Ie=Le({inputs:{x:pe},backend:r,attrs:{shape:[L,1,V]}}),D.push(Ie));const ke=uR({inputs:{a:Ce,b:Ie},backend:r});le=ZS({inputs:{x:ke},backend:r,attrs:{axis:Ee,keepDims:!0}}),D.push(ke)}else{const re=_s(t.dtype,e.dtype),pe=new XH(I,T,[L,f,m],n,s,U,J,j,q),he=[R,_];if(o!=null&&he.push(o),j&&he.push(i),q){const xe=r.makeTensorInfo([],"float32",Ol(a,"float32"));he.push(xe),D.push(xe)}le=r.runWebGLProgram(pe,he,re)}const K=Le({inputs:{x:le},backend:r,attrs:{shape:k}});D.push(le);for(const re of D)r.disposeIntermediateTensorInfo(re);return K}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xAe(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:o,bias:i,preluActivationWeights:a}=e,{transposeA:u,transposeB:l,activation:c,leakyreluAlpha:h}=s;return lw({a:r,b:o,transposeA:u,transposeB:l,backend:n,bias:i,preluActivationWeights:a,leakyreluAlpha:h,activation:c})}const vAe={kernelName:Bg,backendName:"webgl",kernelFunc:xAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dF="return abs(x);";function wAe(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const o=n.texData.get(s.dataId),i=BH(o.values);return n.makeTensorInfo(s.shape,s.dtype,i)}let r;return ce().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new tl(s.shape,dF):r=new ma(s.shape,dF),n.runWebGLProgram(r,[s],s.dtype)}const bAe={kernelName:gy,backendName:"webgl",kernelFunc:wAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SAe=Si+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,CAe=jt({opSnippet:SAe}),kAe={kernelName:Rp,backendName:"webgl",kernelFunc:CAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IAe=Si+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,$Ae=jt({opSnippet:IAe}),NAe={kernelName:Ap,backendName:"webgl",kernelFunc:$Ae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pF="return a + b;",TAe=Us({opSnippet:pF,packedOpSnippet:pF,supportsComplex:!0,cpuKernelImpl:MEe}),EAe={kernelName:gh,backendName:"webgl",kernelFunc:TAe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RAe{constructor(e,n){this.outputShape=[],this.outputShape=e,this.variableNames=n.map((o,i)=>`T${i}`);const s=[];this.variableNames.forEach(o=>{s.push(`float v${o} = get${o}AtOutCoords();`)});const r=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AAe{constructor(e,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=n.map((o,i)=>`T${i}`);const s=[];this.variableNames.forEach(o=>{s.push(`vec4 v${o} = get${o}AtOutCoords();`)});const r=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nv(t){const{inputs:e,backend:n}=t,s=e;if(s.length===1)return co({inputs:{x:s[0]},backend:n});if(s.length>ce().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(s.length/2),l=nv({inputs:s.slice(0,u),backend:n}),c=nv({inputs:s.slice(u),backend:n});return nv({inputs:[l,c],backend:n})}const r=s.map(u=>u.dtype).reduce((u,l)=>_s(u,l)),o=s.map(u=>u.shape),a=ce().getBool("WEBGL_PACK")?new AAe(s[0].shape,o):new RAe(s[0].shape,o);return n.runWebGLProgram(a,s,r)}const _Ae={kernelName:yy,backendName:"webgl",kernelFunc:nv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DAe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:i}=s,a=r.shape.length,u=vt(o,r.shape);let l=u;const c=cn(l,a);let h=r;c!=null&&(h=gr({inputs:{x:r},backend:n,attrs:{perm:c}}),l=Sn(l.length,a)),cs("all",l,a);const[d,f]=ts(h.shape,l),m=ie(f),y=Le({inputs:{x:h},backend:n,attrs:{shape:[-1,m]}}),x=Dh(y,y.dtype,"all",n);let v;if(i){const w=qn(d,u);v=Le({inputs:{x},backend:n,attrs:{shape:w}})}else v=Le({inputs:{x},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x),c!=null&&n.disposeIntermediateTensorInfo(h),v}const PAe={kernelName:Ww,backendName:"webgl",kernelFunc:DAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FAe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:i}=s,a=r.shape.length,u=vt(o,r.shape);let l=u;const c=cn(l,a);let h=r;c!=null&&(h=gr({inputs:{x:r},backend:n,attrs:{perm:c}}),l=Sn(l.length,a)),cs("any",l,a);const[d,f]=ts(h.shape,l),m=ie(f),y=Le({inputs:{x:h},backend:n,attrs:{shape:[-1,m]}}),x=Dh(y,y.dtype,"any",n);let v;if(i){const w=qn(d,u);v=Le({inputs:{x},backend:n,attrs:{shape:w}})}else v=Le({inputs:{x},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x),c!=null&&n.disposeIntermediateTensorInfo(h),v}const OAe={kernelName:Uw,backendName:"webgl",kernelFunc:FAe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LAe{constructor(e,n,s){this.variableNames=["A"];const{windowSize:r,batchSize:o,outSize:i}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i];const a=n==="max"?">":"<",u=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MAe{constructor(e,n,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,O(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const o=e[e.length-1],i=Math.ceil(o/n);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,u=a.length,l=ln(u),c=pr("coords",u);let h,d;if(i===1){d=u+1;const _=ln(d);h=`
        ${_} sourceLocR = ${_}(${c.join()}, 0);
        ++${c[u-1]};
        ${_} sourceLocG = ${_}(${c.join()}, 0);
        ++${c[u-2]};
        ${_} sourceLocA = ${_}(${c.join()}, 0);
        --${c[u-1]};
        ${_} sourceLocB = ${_}(${c.join()}, 0);
        --${c[u-2]};`}else d=u,h=`
        ${l} sourceLocR = coords;
        ++${c[u-1]};
        ${l} sourceLocG = coords;
        ++${c[u-2]};
        ${l} sourceLocA = coords;
        --${c[u-1]};
        ${l} sourceLocB = coords;
        --${c[u-2]};`;const f=["x","y","z","w","u","v"].slice(0,d),m="."+f[d-1],y=f.map(_=>"int "+_),x=pr("sourceLocR",d-1).concat("inIdx.r"),v=pr("sourceLocG",d-1).concat("inIdx.g"),w=pr("sourceLocB",d-1).concat("inIdx.b"),S=pr("sourceLocA",d-1).concat("inIdx.a"),k=s==="max"?"greaterThan":"lessThan",I=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${S.join()})));`,T=`vec4(
            getAChannel(${x.join()}),
            hasNextCol ? getAChannel(${v.join()}) : 0.,
            hasNextRow ? getAChannel(${w.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${S.join()}) : 0.)`,R=r?"":`
      float getBestIndicesAChannel(${y.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${y.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${R}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${c[u-1]} < ${a[u-1]-1};
        bool hasNextRow = ${c[u-2]} < ${a[u-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${m}, sourceLocG${m},
          sourceLocB${m}, sourceLocA${m}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${T};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${I}
          vec4 candidate = ${T};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${k}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YH(t,e,n,s=null){let r=e.shape[0],o=e.shape[1];s!=null&&(r=s.shape[0],o=s.shape[1]);const i=gS(o),a={windowSize:i,inSize:o,batchSize:r,outSize:Math.ceil(o/i)},u=new LAe(a,n,s==null),l=[e];s!=null&&l.push(s);const c=t.runWebGLProgram(u,l,"int32");if(c.shape[1]===1)return c;const h=YH(t,e,n,c);return t.disposeIntermediateTensorInfo(c),h}function QH(t,e,n,s=null){const r=s!=null?s.shape:e.shape,o=r[r.length-1],i=gS(o),a=new MAe(r,i,n,s==null),u=s==null?[e]:[e,s],l=t.runWebGLProgram(a,u,"int32");if(l.shape.length===e.shape.length){const c=QH(t,e,n,l);return t.disposeIntermediateTensorInfo(l),c}return l}function ZH(t,e,n,s){const r=[n];if(cs("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!ce().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const o=[],i=t.texData.get(e.dataId),a=i!==null&&i.isPacked;let u=e;a&&(u=t.unpackTensor(e),o.push(u));const[l,c]=ts(u.shape,r),h=ie(c),d=Le({inputs:{x:u},backend:t,attrs:{shape:[-1,h]}});o.push(d);const f=YH(t,d,s);o.push(f);const m=Le({inputs:{x:f},backend:t,attrs:{shape:l}});return o.forEach(y=>t.disposeIntermediateTensorInfo(y)),m}return QH(t,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zAe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o}=s;let i=vt(o,r.shape);const a=cn(i,r.shape.length);let u=r;const l=[];a!=null&&(u=gr({inputs:{x:r},backend:n,attrs:{perm:a}}),l.push(u),i=Sn(i.length,u.shape.length)),cs("argMax",[i[0]],u.shape.length);const c=ZH(n,u,i[0],"max");return l.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}const BAe={kernelName:xy,backendName:"webgl",kernelFunc:zAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VAe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o}=s;let i=vt(o,r.shape);const a=cn(i,r.shape.length);let u=r;const l=[];a!=null&&(u=gr({inputs:{x:r},backend:n,attrs:{perm:a}}),l.push(u),i=Sn(i.length,u.shape.length)),cs("argMin",[i[0]],u.shape.length);const c=ZH(n,u,i[0],"min");return l.forEach(h=>n.disposeIntermediateTensorInfo(h)),c}const WAe={kernelName:vy,backendName:"webgl",kernelFunc:VAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UAe=Si+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,GAe=jt({opSnippet:UAe}),HAe={kernelName:_p,backendName:"webgl",kernelFunc:GAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jAe=Si+"return log(x + sqrt(x * x + 1.0));",KAe=jt({opSnippet:jAe}),XAe={kernelName:Dp,backendName:"webgl",kernelFunc:KAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qAe=Si+`
  return atan(x);
`,YAe=jt({opSnippet:qAe}),QAe={kernelName:Pp,backendName:"webgl",kernelFunc:YAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZAe=aR+`
  return atan(a, b);
`,JAe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+_h+`
  return result;
`,e_e=Us({opSnippet:ZAe,packedOpSnippet:JAe}),t_e={kernelName:Op,backendName:"webgl",kernelFunc:e_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n_e=Si+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,s_e=jt({opSnippet:n_e}),r_e={kernelName:Fp,backendName:"webgl",kernelFunc:s_e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iy{constructor(e,n,s,r=!1,o=!1){if(this.variableNames=["x"],n==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,c=e.dilationWidth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=e.padInfo.top,m=e.padInfo.left;this.outputShape=e.outShape;const y=n==="avg",x=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,v=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let w="0.0";if(y||(w="-1.0 / 1e-20"),s){const _=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${u});
        const ivec2 pads = ivec2(${f}, ${m});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${_} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?o?x:v:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const S="max";let k=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(k="avgValue / max(count, 1.0)");const I=Math.floor(i/4)*4,T=i%4,R=`
      if (${y}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${S}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${u});
      const ivec2 pads = ivec2(${f}, ${m});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${I}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${R}
          }

          int xC = xCCorner + ${I};
          if (${T===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${T===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${T===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${R}
          }
        }
        setOutput(${k});
      }
    `}}class lR{constructor(e,n,s,r=!1,o=!1){if(this.variableNames=["x"],n==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideDepth,u=e.strideHeight,l=e.strideWidth,c=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,f=e.effectiveFilterDepth,m=e.effectiveFilterHeight,y=e.effectiveFilterWidth,x=e.padInfo.front,v=e.padInfo.top,w=e.padInfo.left;this.outputShape=e.outShape;const S=n==="avg";let k="0.0";if(S||(k="-1.0 / 1e-20"),s){const L=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${u}, ${l});
        const ivec3 pads = ivec3(${x}, ${v}, ${w});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${m};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${y};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${L} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?o?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${m} * ${y} +
                      wR * ${y} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const I="max";let T=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(T="avgValue / max(count, 1.0)");const R=Math.floor(i/4)*4,_=i%4,D=`
      if (${S}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${I}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${u}, ${l});
      const ivec3 pads = ivec3(${x}, ${v}, ${w});
      const float initializationValue = ${k};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${k});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${R}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${D}
            }

            int xC = xCCorner + ${R};
            if (${_===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${_===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${D}
            } else if (${_===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${D}
            }
          }
        }
        setOutput(${T});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o_e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;M0(r,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=s,l=1;O(Ss(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);const c=Js(r.shape,o,i,l,a,u);if(c.filterWidth===1&&c.filterHeight===1&&kt(c.inShape,c.outShape))return co({inputs:{x:r},backend:n});const h=new iy(c,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}const i_e={kernelName:wy,backendName:"webgl",kernelFunc:o_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a_e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=s,c=[1,1,1],h=Lo(r.shape,o,i,c,a,u,l),d=new lR(h,"avg",!1);return n.runWebGLProgram(d,[r],"float32")}const u_e={kernelName:by,backendName:"webgl",kernelFunc:a_e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class l_e{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,i=e.dilationHeight,a=e.dilationWidth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,c=u-1-e.padInfo.top,h=l-1-e.padInfo.left,d=1/(n*s);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${h});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class c_e{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterDepth,s=e.filterHeight,r=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,h=e.effectiveFilterDepth,d=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=h-1-e.padInfo.front,y=d-1-e.padInfo.top,x=f-1-e.padInfo.left,v=1/(n*s*r);this.userCode=`
      const ivec3 pads = ivec3(${m}, ${y}, ${x});
      const float avgMultiplier = float(${v});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h_e(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o}=e,i=o,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=s,h=[1,1,1],d=Lo(i.shape,a,u,h,l,c),f=new c_e(d);return n.runWebGLProgram(f,[r],i.dtype)}const d_e={kernelName:Hw,backendName:"webgl",kernelFunc:h_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p_e(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o}=e,i=o;M0([r,o],"avgPoolGrad");const{filterSize:a,strides:u,pad:l}=s,c=Js(i.shape,a,u,1,l),h=new l_e(c);return n.runWebGLProgram(h,[r],i.dtype)}const f_e={kernelName:Gw,backendName:"webgl",kernelFunc:p_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m_e(t){const{inputs:e,backend:n,attrs:s}=t,{a:r,b:o}=e,{transposeA:i,transposeB:a}=s;return lw({a:r,b:o,transposeA:i,transposeB:a,backend:n})}const g_e={kernelName:Sy,backendName:"webgl",kernelFunc:m_e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class y_e{constructor(e,n,s,r,o,i){this.outputShape=[],this.variableNames=["x","mean","variance"],ut(e,n),ut(e,s);let a="0.0";r!=null&&(ut(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="1.0";o!=null&&(ut(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class x_e{constructor(e,n,s,r,o,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ut(e,n),ut(e,s);let a="vec4(0.0)";r!=null&&(ut(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="vec4(1.0)";o!=null&&(ut(e,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v_e=({inputs:t,backend:e,attrs:n})=>{const{x:s,mean:r,variance:o,offset:i,scale:a}=t;O(r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O(i==null||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=n;u==null&&(u=.001);const l=[s,r,o];let c=null;i!=null&&(c=i.shape,l.push(i));let h=null;a!=null&&(h=a.shape,l.push(a));const d=ce().getBool("WEBGL_PACK_NORMALIZATION")?new x_e(s.shape,r.shape,o.shape,c,h,u):new y_e(s.shape,r.shape,o.shape,c,h,u);return e.runWebGLProgram(d,l,l[0].dtype)},w_e={kernelName:Py,backendName:"webgl",kernelFunc:v_e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class b_e{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const n=ln(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=S_e(this.rank);let r;const o=e.map((i,a)=>`sourceLoc.${B$[a]} = start[${a}] + coords.${B$[a]};`);r=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${o.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const B$=["x","y","z","w","u","v"];function S_e(t){if(t===1)return"sourceLoc";if(t<=6)return B$.slice(0,t).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class C_e{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=ln(this.rank),s=pr("coords",this.rank),r=pr("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,i=`getChannel(getSource(${r.join()}), ${o})`,a=`
      result.x = ${i};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${i};
        --${r[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${i};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${i};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${n}(${e.map((c,h)=>`start[${h}]`).join()});`:e.map((c,h)=>`${r[h]} = ${s[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${a}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k_e(t,e,n,s){const r=s.texData.get(t.dataId),o=s.makeTensorInfo(n,t.dtype),i=s.texData.get(o.dataId);Object.assign(i,r),i.refCount=1,i.shape=n,i.dtype=t.dtype;let a=mE(e,et(t.shape));r.slice&&(a+=r.slice.flatOffset),i.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||t.dataId};const u=s.dataRefCount.get(i.slice.origDataId)||1;return s.dataRefCount.set(i.slice.origDataId,u+1),o}function Wf(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:o,size:i}=s,[a,u]=k0(r,o,i);if(dS(r,a,u),ie(u)===0)return n.makeTensorInfo(u,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||r.dtype==="string"){const h=n.texData.get(r.dataId),d=gRe(h.values,a,u,r.shape,r.dtype);return n.makeTensorInfo(u,r.dtype,d)}const{isPacked:l}=n.texData.get(r.dataId),c=fE(r.shape,a,u);if(l||!c){const h=ce().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new C_e(u):new b_e(u),d=[a];return n.runWebGLProgram(h,[r],r.dtype,d)}return n.uploadToGPU(r.dataId),k_e(r,a,u,n)}const I_e={kernelName:l0,backendName:"webgl",kernelFunc:Wf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $_e=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:o,crops:i}=s;O(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((w,S)=>w*S),u=Sh(r.shape,o,a),l=Ch(u.length,o.length),c=kh(r.shape,o,a),h=xS(i,o.length),d=vS(c,i,o.length),f=[],m=Le({inputs:{x:r},backend:n,attrs:{shape:u}}),y=gr({inputs:{x:m},backend:n,attrs:{perm:l}}),x=Le({inputs:{x:y},backend:n,attrs:{shape:c}}),v=Wf({inputs:{x},backend:n,attrs:{begin:h,size:d}});return f.push(m),f.push(y),f.push(x),f.forEach(w=>n.disposeIntermediateTensorInfo(w)),v},N_e={kernelName:Cy,backendName:"webgl",kernelFunc:$_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T_e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:o}=e,{size:i}=s,a=n.readSync(r.dataId),u=n.readSync(o.dataId),l=zH(a,u,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,l)}const E_e={kernelName:jw,backendName:"webgl",kernelFunc:T_e};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R_e=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,A_e=`
  return float(int(a.r) & int(b.r));
`;function __e(t){const{inputs:e,backend:n}=t,{a:s,b:r}=e,o=ce().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=ce().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([s,r])||i===1){const u=n.texData.get(s.dataId).values,l=n.texData.get(r.dataId).values,[c,h]=BEe(s.shape,r.shape,u,l,s.dtype),d=n.makeTensorInfo(h,s.dtype),f=n.texData.get(d.dataId);return f.values=c,d}let a;return o?a=new Bf(R_e,s.shape,r.shape,!1):a=new hh(A_e,s.shape,r.shape),n.runWebGLProgram(a,[s,r],s.dtype)}const D_e={kernelName:Kw,backendName:"webgl",kernelFunc:__e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P_e(t){const{inputs:e,backend:n}=t,{s0:s,s1:r}=e,o=n.readSync(s.dataId),i=n.readSync(r.dataId),a=ut(Array.from(o),Array.from(i));return n.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const F_e={kernelName:Xw,backendName:"webgl",kernelFunc:P_e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O_e="return float(a != b);",JH=Us({opSnippet:O_e,cpuKernelImpl:aRe,dtype:"bool"}),L_e={kernelName:Qy,backendName:"webgl",kernelFunc:JH};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B0(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.texData.get(s.dataId);return co({inputs:{x:r.complexTensorInfos.real},backend:n})}const M_e={kernelName:Cb,backendName:"webgl",kernelFunc:B0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z_e="return float(int(x));";function B_e(t,e){const n=new ma(t.shape,z_e),s=e.runWebGLProgram(n,[t],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V$(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dtype:o}=s;if(o==="complex64"){if(r.dtype==="complex64")return co({inputs:{x:r},backend:n});const i=Zn(r.shape),a=V$({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),u=Hl({inputs:{real:a,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(a),u}if(r.dtype==="complex64"){const i=B0({inputs:{input:r},backend:n}),a=V$({inputs:{x:i},backend:n,attrs:{dtype:o}});return n.disposeIntermediateTensorInfo(i),a}if(!oT(r.dtype,o)){const i=co({inputs:{x:r},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(n.shouldExecuteOnCPU([r])){const i=n.texData.get(r.dataId).values,[a,u,l]=VEe(i,r.shape,r.dtype,o);return n.makeTensorInfo(a,u,l)}if(o==="int32")return B_e(r,n);if(o==="bool"){const i=n.makeTensorInfo([],"bool",ws("bool",1)),u=JH({inputs:{a:r,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),u}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${o}`)}const V_e={kernelName:Lp,backendName:"webgl",kernelFunc:V$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fF="return ceil(x);",W_e=jt({opSnippet:fF,packedOpSnippet:fF,cpuKernelImpl:WEe}),U_e={kernelName:Mp,backendName:"webgl",kernelFunc:W_e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class G_e{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class H_e{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j_e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{clipValueMin:o,clipValueMax:i}=s;let a;ce().getBool("WEBGL_PACK_CLIP")?a=new H_e(r.shape):a=new G_e(r.shape);const u=[[o],[i]];return n.runWebGLProgram(a,[r],r.dtype,u)}const K_e={kernelName:zp,backendName:"webgl",kernelFunc:j_e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class X_e{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mF(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function q_e(t){const{inputs:e,backend:n}=t,{x:s}=e,r=n.texData.get(s.dataId),o=new X_e(s.shape),i=[mF(s,r.complexTensorInfos.real),mF(s,r.complexTensorInfos.imag)];return n.runWebGLProgram(o,i,i[0].dtype)}const Y_e={kernelName:ky,backendName:"webgl",kernelFunc:q_e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q_e{constructor(e){this.outputShape=[],this.outputShape=Dr(e,1),this.variableNames=e.map((i,a)=>`T${a}`);const n=new Array(e.length-1);n[0]=e[0][1];for(let i=1;i<n.length;i++)n[i]=n[i-1]+e[i][1];const s=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<n.length;i++){const a=n[i-1];s.push(`else if (yC < ${n[i]}) setOutput(getT${i}(yR, yC-${a}));`)}const r=n.length,o=n[n.length-1];s.push(`else setOutput(getT${r}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Z_e{constructor(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Dr(e,n);const s=this.outputShape,r=s.length,o=ln(r),i=pr("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((y,x)=>`T${x}`);const u=new Array(e.length-1);u[0]=e[0][n];for(let y=1;y<u.length;y++)u[y]=u[y-1]+e[y][n];const l=a[n],c=a.slice(-2),h=a.join();let d=`if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${h}), vec2(${c.join()}));
        }`;for(let y=1;y<u.length;y++){const x=u[y-1];d+=`
        if (${l} < ${u[y]}  && ${l} >= ${u[y-1]}) {
          return getChannel(
            getT${y}(${D1(a,l,x)}),
            vec2(${D1(c,l,x)}));
        }`}const f=u.length,m=u[u.length-1];d+=`
        return getChannel(
          getT${f}(${D1(a,l,m)}),
          vec2(${D1(c,l,m)}));`,this.userCode=`
      float getValue(${a.map(y=>"int "+y)}) {
        ${d}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[r-1]} = ${i[r-1]} + 1;
        if (${i[r-1]} < ${s[r-1]}) {
          result.g = getValue(${i});
        }

        ${i[r-2]} = ${i[r-2]} + 1;
        if (${i[r-2]} < ${s[r-2]}) {
          result.a = getValue(${i});
        }

        ${i[r-1]} = ${i[r-1]} - 1;
        if (${i[r-2]} < ${s[r-2]} &&
            ${i[r-1]} < ${s[r-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}}function D1(t,e,n){const s=t.indexOf(e);return t.map((o,i)=>i===s?`${o} - ${n}`:o).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JS(t){const{inputs:e,backend:n}=t,{input:s}=e,r=n.texData.get(s.dataId);return co({inputs:{x:r.complexTensorInfos.imag},backend:n})}const J_e={kernelName:pb,backendName:"webgl",kernelFunc:JS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rg(t,e,n){const s=t[0].dtype;if(s==="complex64"){const f=t.map(w=>B0({inputs:{input:w},backend:n})),m=t.map(w=>JS({inputs:{input:w},backend:n})),y=rg(f,e,n),x=rg(m,e,n),v=Hl({inputs:{real:y,imag:x},backend:n});return f.forEach(w=>n.disposeIntermediateTensorInfo(w)),m.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x),v}let r=n.shouldExecuteOnCPU(t);if(s==="string"&&(r=!0),r){const f=t.map(k=>{const T=[-1,ie(k.shape.slice(e))];return Le({inputs:{x:k},backend:n,attrs:{shape:T}})}),m=f.map(k=>({vals:n.readSync(k.dataId),shape:k.shape})),y=Dr(f.map(k=>k.shape),1),x=f[0].shape[0]===1,v=UEe(m,y,s,x),w=Dr(t.map(k=>k.shape),e),S=n.makeTensorInfo(w,s,v);return f.forEach(k=>n.disposeIntermediateTensorInfo(k)),S}const o=t.filter(f=>ie(f.shape)>0),i=ce().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&o[0].shape.length>1;if(o.length===1){const f=i?new ma(t[0].shape,ju):new tl(t[0].shape,ju);return n.runWebGLProgram(f,t,s)}const a=ce().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(o.length>a){const f=[];for(let y=0;y<o.length;y+=a){const x=o.slice(y,y+a);f.push(rg(x,e,n))}const m=rg(f,e,n);for(const y of f)n.disposeIntermediateTensorInfo(y);return m}if(i){const f=new Z_e(o.map(m=>m.shape),e);return n.runWebGLProgram(f,o,s)}const{tensors2D:u,outShape:l}=eDe(o,e,n),c=new Q_e(u.map(f=>f.shape)),h=n.runWebGLProgram(c,u,s);u.forEach(f=>n.disposeIntermediateTensorInfo(f));const d=Le({inputs:{x:h},attrs:{shape:l},backend:n});return n.disposeIntermediateTensorInfo(h),d}function eDe(t,e,n){const s=Dr(t.map(o=>o.shape),e);return{tensors2D:t.map(o=>Le({inputs:{x:o},attrs:{shape:[-1,ie(o.shape.slice(e))]},backend:n})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e6(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s,o=vt(r,e[0].shape)[0],i=e.map(l=>l.shape);mS(i,o);const a=Dr(e.map(l=>l.shape),o);if(ie(a)===0)return n.makeTensorInfo(a,e[0].dtype,[]);const u=e.filter(l=>ie(l.shape)>0);return u.length===1?co({inputs:{x:u[0]},backend:n}):rg(u,o,n)}const tDe={kernelName:Iy,backendName:"webgl",kernelFunc:e6};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class t6{constructor(e,n=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.padInfo.top,a=e.padInfo.left,u=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,h=e.dilationWidth,d=e.filterHeight,f=e.filterWidth,m=Math.floor(e.inChannels/4)*4,y=e.inChannels%4,x=e.dataFormat==="channelsLast",v=x?1:2,w=x?2:3,S=x?3:1;let k="",I="";s&&(r?k=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?k=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:k=`
          float activation(float x) {
            ${s}
          }
        `,I="result = activation(result);");const T=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${k}

      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${S}];

        ivec2 xRCCorner =
            ivec2(coords[${v}], coords[${w}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${m}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${x}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${y===1}) {

              if (${x}) {
                dotProd +=
                    getX(batch, xR, xC, ${m}) *
                    getW(wR, wC, ${m}, d2);
              } else {
                dotProd +=
                    getX(batch, ${m}, xR, xC) *
                    getW(wR, wC, ${m}, d2);
              }

            } else if (${y===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2)
              );

              if (${x}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${y===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${m}, d2),
                getW(wR, wC, ${m} + 1, d2),
                getW(wR, wC, ${m} + 2, d2)
              );

              if (${x}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${m}),
                  getX(batch, xR, xC, ${m} + 1),
                  getX(batch, xR, xC, ${m} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${m}, xR, xC),
                  getX(batch, ${m} + 1, xR, xC),
                  getX(batch, ${m} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${T}
        ${I}
        setOutput(result);
      }
    `}}class nDe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const n=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,c=e.dilationWidth,h=e.filterDepth,d=e.filterHeight,f=e.filterWidth,m=Math.floor(e.inChannels/4)*4,y=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${i}, ${a});
      const ivec3 pads = ivec3(${n}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${m}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${y===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${m}) *
                  getW(wF, wR, wC, ${m}, d2);
              } else if (${y===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${y===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${m}),
                  getX(batch, xF, xR, xC, ${m} + 1),
                  getX(batch, xF, xR, xC, ${m} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${m}, d2),
                  getW(wF, wR, wC, ${m} + 1, d2),
                  getW(wF, wR, wC, ${m} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class n6{constructor(e,n=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=er(this.outputShape.length);const i=e.padInfo.left,a=e.strideWidth,u=e.dilationWidth,l=e.filterHeight,c=e.filterWidth,h=c;let d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<c;x++)d+=`
           vec4 xTexelC${x*2};
           int xTexelC${x*2}Ready;
           vec4 xTexelC${x*2+1};
           int xTexelC${x*2+1}Ready;
           vec4 xC${x};`;d+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let x=0;x<c;x++)d+=`
           xTexelC${x*2} = vec4(0.0);
           xTexelC${x*2}Ready = 0;
           xTexelC${x*2+1} = vec4(0.0);
           xTexelC${x*2+1}Ready = 0;
           xC${x} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let x=0;x<(h+1)/2;x++){const v=x*2;if(d+=`
           xC = xCCorner + ${v*u};
           `,a===1){if(v<c&&(i%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }
               `,u===1&&v>0?d+=`
                 xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${v} = vec4(previous.zw, xTexelC${v}.xy);
                   } else {
                     xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xC${v} = xTexelC${v};
                 `,v+1<c)){const w=i%2===0?sT(u):u;u%2===0&&i%2===1||u%2!==0&&i%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${w};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                     xTexelC${v+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${v+1}.zw = vec2(0.0);
                     }
                     xTexelC${v+1}Ready = 1;
                   }
                   `,u>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);
                     } else {
                      xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);
                     }
                     `:d+=`
                     xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);
                     `):w===1?d+=`
                     xC${v+1} = xTexelC${v};
                     `:d+=`
                     xCOffset = xC + ${w};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                       xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${v+1}.zw = vec2(0.0);
                       }
                       xTexelC${v+1}Ready = 1;
                     }

                     xC${v+1} = xTexelC${v+1};
                     `}}else v<c&&(i%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {
                   xTexelC${v+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${v+1}.zw = vec2(0.0);
                   }
                   xTexelC${v+1}Ready = 1;
                 }

                 xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
               `,v+1<c&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                   xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v+1}.zw = vec2(0.);
                   }
                   xTexelC${v+1}Ready = 1;
                 }

                 xC${v} = vec4(
                   xTexelC${v}.xy, xTexelC${v+1}.xy);
               `,v+1<c&&(d+=`
                   xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
                 `)));v<c&&(d+=`
             wTexel = getW(r, ${v}, d1, d2);
             dotProd += xC${v}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${v}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,v+1<c&&(d+=`
               wTexel = getW(r, ${v+1}, d1, d2);
               dotProd += xC${v+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${v+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let f="",m="";s&&(r?f=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:o?f=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:f=`vec4 activation(vec4 x) {
           ${s}
         }`,m="result = activation(result);");const y=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${f}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${y}
         ${m}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sDe{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=er(this.outputShape.length);const{dataFormat:s}=n,r=xr(),o=s==="channelsLast",i=o?1:2,a=o?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let c=0;c<=1;c++)for(let h=0;h<=1;h++)l+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${c};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${o}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cw(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function s6({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const u=t.shape,l=s.texData.get(t.dataId),c=n.inChannels,h=u[0]*u[1]*u[2],d=n.outChannels,f=n.dataFormat==="channelsLast",m=!1,y=!1;let x;const v=[];if(o!=null){const k=cw(o.shape,f);k!=null&&(o=Le({inputs:{x:o},backend:s,attrs:{shape:k}}),v.push(o))}if(r!=null){const k=cw(r.shape,f);k!=null&&(r=Le({inputs:{x:r},backend:s,attrs:{shape:k}}),v.push(r))}if(!((h===1||d===1)&&c>qH)&&l.isPacked&&f&&l.texture!=null&&u[2]%2!==0&&kt(l.shape.slice(-3),u.slice(-3))){const k=u[0]*u[1]*(u[2]+1),I={dataId:t.dataId,shape:[1,k,n.inChannels],dtype:t.dtype},T=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,O(uw(l.shape,I.shape),()=>`packed reshape ${l.shape} to ${I.shape} isn't free`);const R=Le({inputs:{x:e},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}});v.push(R);const _=lw({a:I,b:R,backend:s,transposeA:m,transposeB:y,bias:r,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),D=s.texData.get(_.dataId);O(D.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=T,D.shape=n.outShape,x=co({inputs:{x:_},backend:s}),x.shape=n.outShape,v.push(_)}else{const k=n.outHeight*n.outWidth,I=Le({inputs:{x:t},backend:s,attrs:{shape:f?[n.batchSize,k,n.inChannels]:[n.batchSize,n.inChannels,k]}}),T=Le({inputs:{x:e},backend:s,attrs:{shape:[1,n.inChannels,n.outChannels]}}),R=lw({a:f?I:T,b:f?T:I,transposeA:!f,transposeB:y,backend:s,bias:r,activation:a,preluActivationWeights:o,leakyreluAlpha:i});x=Le({inputs:{x:R},backend:s,attrs:{shape:n.outShape}}),v.push(I),v.push(T),v.push(R)}for(const k of v)s.disposeIntermediateTensorInfo(k);return x}function r6({x:t,filter:e,convInfo:n,backend:s,bias:r=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:u,filterHeight:l,inChannels:c,outWidth:h,outHeight:d,dataFormat:f}=n,m=f==="channelsLast",y=u*l*c,x=d*h,v=[n.batchSize,y,x],w=!0,S=!1,k=[];if(o!=null){const K=cw(o.shape,m);K!=null&&(o=Le({inputs:{x:o},backend:s,attrs:{shape:K}}),k.push(o))}if(r!=null){const K=cw(r.shape,m);K!=null&&(r=Le({inputs:{x:r},backend:s,attrs:{shape:K}}),k.push(r))}const I=Le({inputs:{x:e},backend:s,attrs:{shape:[1,y,ie(e.shape)/y]}});k.push(I);const T=new sDe(v,n),R=[t.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],_=s.runWebGLProgram(T,[t],"float32",R),D=Le({inputs:{x:_},backend:s,attrs:{shape:v}});k.push(_),k.push(D);const L=r!=null,V=o!=null,U=a==="leakyrelu",j=a?oy(a,!0):null,q=new XH(m?D.shape:I.shape,m?I.shape:D.shape,m?[n.batchSize,x,n.outChannels]:[n.batchSize,n.outChannels,x],w,S,L,j,V,U),J=m?[D,I]:[I,D];if(r&&J.push(r),V&&J.push(o),U){const K=s.makeTensorInfo([],"float32",Ol(i,"float32"));J.push(K),k.push(K)}const te=s.runWebGLProgram(q,J,"float32"),le=Le({inputs:{x:te},backend:s,attrs:{shape:n.outShape}});k.push(te);for(const K of k)s.disposeIntermediateTensorInfo(K);return le}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rDe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o}=e,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:c}=s,h=fo(u),d=bn(r.shape,o.shape,i,l,a,c,!1,h);let f;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))f=s6({x:r,filter:o,convInfo:d,backend:n});else if(d.strideWidth<=2&&h==="channelsLast"&&ce().getBool("WEBGL_EXP_CONV")){const y=new n6(d),x=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];f=n.runWebGLProgram(y,[r,o],"float32",x)}else if(ce().getBool("WEBGL_CONV_IM2COL"))f=r6({x:r,filter:o,convInfo:d,backend:n});else{const y=new t6(d);f=n.runWebGLProgram(y,[r,o],"float32")}const m=Le({inputs:{x:f},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(f),m}const oDe={kernelName:$y,backendName:"webgl",kernelFunc:rDe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iDe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,i=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class aDe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,i=e.dataFormat==="channelsLast",a=n-1-e.padInfo.top,u=s-1-e.padInfo.left,l=i?1:2,c=i?2:3,h=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class uDe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideDepth,s=e.strideHeight,r=e.strideWidth,o=e.padInfo.front,i=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${o};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${i};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class lDe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterDepth,s=e.filterHeight,r=e.filterWidth,o=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=n-1-e.padInfo.front,l=s-1-e.padInfo.top,c=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${l}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cDe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:o}=e,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:c}=s,h=fo(u),d=bn(r.shape,c,i,1,a,l,!1,h),f=new iDe(d);return n.runWebGLProgram(f,[r,o],"float32")}const hDe={kernelName:Yw,backendName:"webgl",kernelFunc:cDe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dDe{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=er(this.outputShape.length);const n=e.filterHeight,s=e.filterWidth,r=n-1-e.padInfo.top,o=s-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            int wCPerm = ${s} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pDe(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:o}=e,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:c}=s,h=fo(l),d=bn(i,o.shape,a,1,u,c,!1,h);if(ce().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&h==="channelsLast"){const f=[[d.strideHeight,d.strideWidth]],m=new dDe(d);return n.runWebGLProgram(m,[r,o],"float32",f)}else{const f=new aDe(d);return n.runWebGLProgram(f,[r,o],"float32")}}const fDe={kernelName:Ny,backendName:"webgl",kernelFunc:pDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mDe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o}=e,{strides:i,pad:a,dilations:u}=s,l=Qi(r.shape,o.shape,i,u,a),c=new nDe(l);return n.runWebGLProgram(c,[r,o],"float32")}const gDe={kernelName:Ty,backendName:"webgl",kernelFunc:mDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yDe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:o}=e,{strides:i,pad:a,filterShape:u}=s,l=Qi(r.shape,u,i,1,a),c=new uDe(l);return n.runWebGLProgram(c,[r,o],"float32")}const xDe={kernelName:Qw,backendName:"webgl",kernelFunc:yDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vDe(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:o}=e,{pad:i,strides:a,inputShape:u}=s,l=Qi(u,o.shape,a,1,i),c=new lDe(l);return n.runWebGLProgram(c,[r,o],"float32")}const wDe={kernelName:Zw,backendName:"webgl",kernelFunc:vDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bDe=Vf+`
  return cos(x);
`,SDe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${_h}
  return result;
`,CDe=jt({opSnippet:bDe,packedOpSnippet:SDe}),kDe={kernelName:Bp,backendName:"webgl",kernelFunc:CDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IDe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,$De=jt({opSnippet:IDe}),NDe={kernelName:Vp,backendName:"webgl",kernelFunc:$De};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TDe{constructor(e,n,s,r,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,u,l]=e,[c]=n,[h,d]=s;this.outputShape=[c,h,d,l];const f=r==="bilinear"?1:0,[m,y]=[`${a-1}.0`,`${u-1}.0`],[x,v,w]=h>1?[`${(a-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${m} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${m}`],[S,k,I]=d>1?[`${(u-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${y} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${y}`];this.userCode=`
      const float height_ratio = float(${x});
      const float width_ratio = float(${S});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${v};
        float width_scale = ${k};

        float in_y = ${w};
        if( in_y < 0.0 || in_y > ${m} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${I};
        if( in_x < 0.0 || in_x > ${y} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EDe=t=>{const{inputs:e,backend:n,attrs:s}=t,{image:r,boxes:o,boxInd:i}=e,{cropSize:a,method:u,extrapolationValue:l}=s,c=new TDe(r.shape,o.shape,a,u,l);return n.runWebGLProgram(c,[r,o,i],"float32")},RDe={kernelName:eb,backendName:"webgl",kernelFunc:EDe};var ay;(function(t){t.Prod="*",t.Sum="+"})(ay||(ay={}));class gF{constructor(e,n,s,r){this.op=e,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const o=this.outputShape.length,i=this.op===ay.Prod?"1.0":"0.0",a=s?i:`getX(${yF(o,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let l="",c="";s?(l=r?`end != ${u-1}`:"end != 0",c=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${u}`:"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${ln(o)} coords = getOutputCoords();
        int end = ${xF(o,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${c};
          ${xF(o,"coords",this.op)} = idx;
          val ${this.op}= getX(${yF(o,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function yF(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function xF(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o6(t,e,n,s,r,o){const i=e.shape.length,a=cn([s],i);let u=e;a!=null&&(u=gr({inputs:{x:e},backend:n,attrs:{perm:a}}));const l=Sn(1,i)[0];if(l!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const c=u.shape[l];let h=co({inputs:{x:u},backend:n});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){const f=new gF(t,u.shape,!1,o),m=[[d]],y=h;h=n.runWebGLProgram(f,[h],h.dtype,m),n.disposeIntermediateTensorInfo(y)}if(r){const d=new gF(t,u.shape,r,o),f=h;h=n.runWebGLProgram(d,[h],h.dtype),n.disposeIntermediateTensorInfo(f)}if(a!=null){const d=Ta(a),f=gr({inputs:{x:h},backend:n,attrs:{perm:d}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(u),f}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ADe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,exclusive:i,reverse:a}=s;return o6(ay.Prod,r,n,o,i,a)}const _De={kernelName:Jw,backendName:"webgl",kernelFunc:ADe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DDe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,exclusive:i,reverse:a}=s;return o6(ay.Sum,r,n,o,i,a)}const PDe={kernelName:Ey,backendName:"webgl",kernelFunc:DDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FDe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,weights:o}=e,{size:i,binaryOutput:a}=s;if(r.shape.length===1){const u=n.readSync(r.dataId),l=n.readSync(o.dataId),c=zH(u,l,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,c)}else if(r.shape.length===2){const u=n.bufferSync(r),l=n.bufferSync(o),c=zEe(u,l,i,a);return n.makeTensorInfo(c.shape,o.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const ODe={kernelName:tb,backendName:"webgl",kernelFunc:FDe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LDe{constructor(e,n,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=n,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MDe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockSize:o,dataFormat:i}=s,a=r.shape[0],u=i==="NHWC"?r.shape[1]:r.shape[2],l=i==="NHWC"?r.shape[2]:r.shape[3],c=i==="NHWC"?r.shape[3]:r.shape[1],h=u*o,d=l*o,f=c/(o*o),m=i==="NHWC"?[a,h,d,f]:[a,f,h,d],y=new LDe(m,o,i);return n.runWebGLProgram(y,[r],r.dtype)}const zDe={kernelName:nb,backendName:"webgl",kernelFunc:MDe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i6{constructor(e,n=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=er(this.outputShape.length);const i=e.filterHeight,a=e.filterWidth,u=e.outChannels/e.inChannels;let l="",c="";s&&(r?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:l=`
          float activation(float x) {
            ${s}
          }
        `,c="result = activation(result);");const h=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${c}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class a6{constructor(e,n=!1,s=null,r=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=er(this.outputShape.length);const i=e.outChannels/e.inChannels,a=e.padInfo.left,u=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,h=e.filterWidth,d=h;let f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<h;v++)f+=`
          vec4 xTexelC${v*2};
          int xTexelC${v*2}Ready;
          vec4 xTexelC${v*2+1};
          int xTexelC${v*2+1}Ready;
          vec4 xC${v};`;f+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let v=0;v<h;v++)f+=`
          xTexelC${v*2} = vec4(0.0);
          xTexelC${v*2}Ready = 0;
          xTexelC${v*2+1} = vec4(0.0);
          xTexelC${v*2+1}Ready = 0;
          xC${v} = vec4(0.0);`;f+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let v=0;v<(d+1)/2;v++){const w=v*2;if(f+=`
          xC = xCCorner + ${w*l};
          `,u===1){if(w<h&&(a%2===1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }
              `,l===1&&w>0?f+=`
                xC${w} = vec4(xTexelC${w-2}.zw, xTexelC${w}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${w} = vec4(previous.zw, xTexelC${w}.xy);
                  } else {
                    xC${w} = vec4(0.0, 0.0, xTexelC${w}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                xC${w} = xTexelC${w};
                `,w+1<h)){const S=a%2===0?sT(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${S};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                    xTexelC${w+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${w+1}.zw = vec2(0.0);
                    }
                    xTexelC${w+1}Ready = 1;
                  }
                  `,l>1?f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${w+1} = vec4(previous.zw, xTexelC${w+1}.xy);
                    } else {
                     xC${w+1} = vec4(0.0, 0.0, xTexelC${w+1}.xy);
                    }
                    `:f+=`
                    xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.xy);
                    `):S===1?f+=`
                    xC${w+1} = xTexelC${w};
                    `:f+=`
                    xCOffset = xC + ${S};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                      xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${w+1}.zw = vec2(0.0);
                      }
                      xTexelC${w+1}Ready = 1;
                    }

                    xC${w+1} = xTexelC${w+1};
                    `}}else w<h&&(a%2===1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${w+1}Ready == 0) {
                  xTexelC${w+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${w+1}.zw = vec2(0.0);
                  }
                  xTexelC${w+1}Ready = 1;
                }

                xC${w} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
              `,w+1<h&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${w+1} = vec4(xTexelC${w+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                  xTexelC${w} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${w}.zw = vec2(0.0);
                  }
                  xTexelC${w}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                  xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${w+1}.zw = vec2(0.);
                  }
                  xTexelC${w+1}Ready = 1;
                }

                xC${w} = vec4(
                  xTexelC${w}.xy, xTexelC${w+1}.xy);
              `,w+1<h&&(f+=`
                  xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
                `)));w<h&&(f+=`
            wTexel = getW(r, ${w}, d1, q);
            dotProd += xC${w} * vec4(wTexel.xz, wTexel.xz);
          `,w+1<h&&(f+=`
              wTexel = getW(r, ${w+1}, d1, q);
              dotProd += xC${w+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
    }
  `,f+=`
      }
    `;let m="",y="";s&&(r?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:o?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:m=`vec4 activation(vec4 x) {
          ${s}
        }`,y="result = activation(result);");const x=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${m}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${x}
        ${y}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BDe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o}=e,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=s;let c=u;c==null&&(c=[1,1]),O(Ss(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const h=bn(r.shape,o.shape,i,c,a,l,!0);let d;ce().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?d=new a6(h):d=new i6(h);const f=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[r,o],"float32",f)}const VDe={kernelName:Ry,backendName:"webgl",kernelFunc:BDe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WDe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,o=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${o};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class UDe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,s=e.filterWidth,r=e.strideHeight,o=e.strideWidth,i=n-1-e.padInfo.top,a=s-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GDe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,dy:o}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:c}=s,h=bn(r.shape,c,i,a,u,l,!0),d=new WDe(h);return n.runWebGLProgram(d,[r,o],"float32")}const HDe={kernelName:sb,backendName:"webgl",kernelFunc:GDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jDe(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,filter:o}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:c}=s,h=bn(c,o.shape,i,a,u,l,!0),d=new UDe(h);return n.runWebGLProgram(d,[r,o],"float32")}const KDe={kernelName:rb,backendName:"webgl",kernelFunc:jDe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XDe{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qDe(t){const{inputs:e,backend:n}=t,{x:s}=e,r=[...s.shape,...s.shape],o=ie(s.shape),i=Le({inputs:{x:s},backend:n,attrs:{shape:[o]}}),a=new XDe(o),u=n.runWebGLProgram(a,[i],i.dtype),l=Le({inputs:{x:u},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),l}const YDe={kernelName:ob,backendName:"webgl",kernelFunc:qDe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QDe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:n,inWidth:s,padInfo:r,strideHeight:o,strideWidth:i,filterHeight:a,filterWidth:u,dilationHeight:l,dilationWidth:c}=e,{top:h,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${i});
      const ivec2 pads = ivec2(${h}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZDe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o}=e,{strides:i,pad:a,dilations:u}=s,l=zl(r.shape,o.shape,i,a,"NHWC",u);let c;const h=new QDe(l);c=n.runWebGLProgram(h,[r,o],"float32");const d=Le({inputs:{x:c},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(c),d}const JDe={kernelName:Ay,backendName:"webgl",kernelFunc:ZDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e3e(t){const{inputs:e,backend:n,attrs:s}=t,{equation:r}=s,o=e,{allDims:i,summedDims:a,idDims:u}=$S(r,o.length);TS(i.length,u,o);const{path:l,steps:c}=ES(a,u),h=c.length;let d=null,f=i.length;const m=[];for(let y=0;y<h;++y){for(const x of c[y]){const{permutationIndices:v,expandDims:w}=NS(f,u[x]);let S;RS(v)?S=o[x]:(S=gr({inputs:{x:o[x]},backend:n,attrs:{perm:v}}),m.push(S));const k=S.shape.slice();for(let I=0;I<w.length;++I)k.splice(w[I],0,1);kt(S.shape,k)||(S=Le({inputs:{x:S},backend:n,attrs:{shape:k}}),m.push(S)),d===null?d=S:(d=uR({inputs:{a:S,b:d},backend:n}),m.push(d))}y<h-1&&(l[y]>=0&&(d=ZS({inputs:{x:d},backend:n,attrs:{axis:l[y]-(i.length-f),keepDims:!1}}),m.push(d)),f--)}for(const y of m)y!==d&&n.disposeIntermediateTensorInfo(y);return d}const t3e={kernelName:ib,backendName:"webgl",kernelFunc:e3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n3e="return (x >= 0.0) ? x : (exp(x) - 1.0);",s3e=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,r3e=jt({opSnippet:n3e,packedOpSnippet:s3e}),o3e={kernelName:Up,backendName:"webgl",kernelFunc:r3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i3e="return (b >= 0.0) ? a : a * (b + 1.0);",a3e=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,u3e=t=>{const{inputs:e,backend:n}=t,{dy:s,y:r}=e,o=ce().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Bf(a3e,s.shape,r.shape):new hh(i3e,s.shape,r.shape);return n.runWebGLProgram(o,[s,r],s.dtype)},l3e={kernelName:ab,backendName:"webgl",kernelFunc:u3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c3e=`
  return vec4(equal(a, b));
`,h3e="return float(a == b);",d3e=Us({opSnippet:h3e,packedOpSnippet:c3e,dtype:"bool",cpuKernelImpl:GEe}),p3e={kernelName:_y,backendName:"webgl",kernelFunc:d3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f3e=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${wS};
  float a1 = ${bS};
  float a2 = ${SS};
  float a3 = ${CS};
  float a4 = ${kS};
  float a5 = ${IS};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,m3e=jt({opSnippet:f3e}),g3e={kernelName:Gp,backendName:"webgl",kernelFunc:m3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y3e=Vf+`
  return exp(x);
`,x3e=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,u6=jt({opSnippet:y3e,packedOpSnippet:x3e,cpuKernelImpl:HEe,dtype:"float32"}),v3e={kernelName:Hp,backendName:"webgl",kernelFunc:u6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W$(t){const{inputs:e,attrs:n,backend:s}=t,{dim:r}=n,{input:o}=e,i=o.shape.length,a=o.shape.slice();let u=r;return r<0&&(O(-(i+1)<=r,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+r+1),a.splice(u,0,1),Le({inputs:{x:o},backend:s,attrs:{shape:a}})}const w3e={kernelName:Dy,backendName:"webgl",kernelFunc:W$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vF="return exp(x) - 1.0;",b3e=jt({opSnippet:vF,packedOpSnippet:vF,cpuKernelImpl:jEe}),S3e={kernelName:jp,backendName:"webgl",kernelFunc:b3e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wF{constructor(e,n,s){this.variableNames=["real","imag"];const r=n[1];this.outputShape=n;const o=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=s?`${r}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l6(t,e,n){const s=n.texData.get(t.dataId),r=ie(t.shape),o=t.shape[t.shape.length-1],i=r/o,a=Le({inputs:{x:t},backend:n,attrs:{shape:[i,o]}}),u=a.shape,l=new wF("real",u,e),c=new wF("imag",u,e),h=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:u},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:u}],d=n.runWebGLProgram(l,h,"float32"),f=n.runWebGLProgram(c,h,"float32"),m=Hl({inputs:{real:d,imag:f},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f);const y=Le({inputs:{x:m},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(m),y}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C3e(t){const{inputs:e,backend:n}=t,{input:s}=e;return l6(s,!1,n)}const k3e={kernelName:ub,backendName:"webgl",kernelFunc:C3e};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I3e{constructor(e,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V0(t){const{backend:e,attrs:n}=t,{shape:s,value:r}=n;let{dtype:o}=n;if(o=o||mh(r),o==="string"){const i=Hn(o,ie(s));return i.fill(r),e.makeTensorInfo(s,o,i)}else{const i=new I3e(s,r),a=[[r]];return e.runWebGLProgram(i,[],o,a)}}const $3e={kernelName:lb,backendName:"webgl",kernelFunc:V0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class N3e{constructor(e){this.variableNames=["Image"],this.outputShape=[];const n=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T3e={kernelName:cb,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,s=e,r=new N3e(n.shape);return s.runWebGLProgram(r,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bF="return floor(x);",E3e=jt({opSnippet:bF,packedOpSnippet:bF,cpuKernelImpl:KEe}),R3e={kernelName:Kp,backendName:"webgl",kernelFunc:E3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A3e=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,_3e=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,D3e=Us({opSnippet:A3e,packedOpSnippet:_3e,dtype:"int32"}),P3e={kernelName:Xp,backendName:"webgl",kernelFunc:D3e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F3e{constructor(e){this.variableNames=["A"];const n=xr(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class O3e{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=xr(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L3e={kernelName:Pv,backendName:"webgl",kernelFunc:M3e};let gd,Nk=ce().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function M3e(t){const{inputs:e,backend:n,attrs:s}=t;let{pixels:r}=e;const{numChannels:o}=s,i=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[u,l]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[l,u],h=[l,u,o];if(a||i){const y=ce().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(gd==null||y!==Nk)&&(Nk=y,gd=document.createElement("canvas").getContext("2d",{willReadFrequently:Nk})),gd.canvas.width=u,gd.canvas.height=l,gd.drawImage(r,0,0,u,l),r=gd.canvas}const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=No.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),r);const f=ce().getBool("WEBGL_PACK")?new O3e(h):new F3e(h),m=n.runWebGLProgram(f,[d],"int32");return n.disposeData(d.dataId),m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z3e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dataFormat:c,dilations:h,dimRoundingMode:d,activation:f,leakyreluAlpha:m}=s,y=fo(c),x=bn(r.shape,o.shape,u,h,l,d,!1,y);let v;const w=[],S=i!=null,k=a!=null,I=f==="leakyrelu",T=()=>{const _=[r,o],D=(L,V)=>{if(V==="NCHW"&&L.shape.length===1&&L.shape[0]!==1){const U=Le({inputs:{x:L},backend:n,attrs:{shape:[L.shape[0],1,1]}});return w.push(U),U}return L};if(S&&_.push(D(i,c)),k&&_.push(D(a,c)),I){const L=n.makeTensorInfo([],"float32",Ol(m,"float32"));_.push(L),w.push(L)}return _};if(x.filterHeight===1&&x.filterWidth===1&&x.dilationHeight===1&&x.dilationWidth===1&&x.strideHeight===1&&x.strideWidth===1&&(x.padInfo.type==="SAME"||x.padInfo.type==="VALID"))v=s6({x:r,filter:o,convInfo:x,backend:n,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:m});else if(x.strideWidth<=2&&y==="channelsLast"&&ce().getBool("WEBGL_EXP_CONV")){const _=f?oy(f,!0):null,D=new n6(x,S,_,k,I),L=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],V=T();v=n.runWebGLProgram(D,V,"float32",L)}else if(ce().getBool("WEBGL_CONV_IM2COL"))v=r6({x:r,filter:o,convInfo:x,backend:n,bias:i,activation:f,preluActivationWeights:a,leakyreluAlpha:m});else{const _=f?oy(f,!1):null,D=new t6(x,S,_,k,I),L=T();v=n.runWebGLProgram(D,L,"float32")}const R=Le({inputs:{x:v},backend:n,attrs:{shape:x.outShape}});return w.push(v),w.forEach(_=>n.disposeIntermediateTensorInfo(_)),R}const B3e={kernelName:Vg,backendName:"webgl",kernelFunc:z3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V3e(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,filter:o,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:f}=s,m=[];let y=c;y==null&&(y=[1,1]),O(Ss(u,y),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${y}'`);const x=bn(r.shape,o.shape,u,y,l,h,!0),v=ce().getBool("WEBGL_PACK_DEPTHWISECONV")&&x.strideWidth<=2&&x.outChannels/x.inChannels===1,w=d?oy(d,v):null,S=[r,o],k=i!=null,I=a!=null,T=d==="leakyrelu";if(k&&S.push(i),I&&S.push(a),T){const L=n.makeTensorInfo([],"float32",Ol(f,"float32"));S.push(L),m.push(L)}let R;v?R=new a6(x,k,w,I,T):R=new i6(x,k,w,I,T);const _=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],D=n.runWebGLProgram(R,S,"float32",_);return m.forEach(L=>n.disposeIntermediateTensorInfo(L)),D}const W3e={kernelName:Wg,backendName:"webgl",kernelFunc:V3e};class U3e{constructor(e,n,s,r){this.sliceDim=e,this.strides=n,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const o=ln(s.length);let i=`
    int index;`;for(let a=0;a<this.sliceDim;a++)i+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G3e(t){const{inputs:e,backend:n}=t,{params:s,indices:r}=e,o=r.shape,i=o[o.length-1],a=ie(s.shape),[u,l,c,h]=hS(s,r),d=Le({inputs:{x:r},backend:n,attrs:{shape:[l,i]}}),f=Le({inputs:{x:s},backend:n,attrs:{shape:[ie(s.shape)/c,c]}});if(n.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const v=n.readSync(r.dataId),w=n.bufferSync(s),S=XEe(v,w,s.dtype,l,i,c,h,s.shape,a);return n.makeTensorInfo(u,s.dtype,S.values)}const m=new U3e(i,h,[l,c],s.shape),y=n.runWebGLProgram(m,[f,d],f.dtype),x=Le({inputs:{x:y},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),x}const H3e={kernelName:hb,backendName:"webgl",kernelFunc:G3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class j3e{constructor(e,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const s=ln(this.rank),r=K3e(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}}function K3e(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<t.length;r++)r===2?s.push("index"):s.push(`${n[r]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c6(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,indices:o}=e,{axis:i,batchDims:a}=s,u=vt(i,r.shape)[0];if(ce().get("DEBUG")){const w=n.readSync(o.dataId),S=r.shape[u];for(let k=0;k<w.length;++k){const I=w[k];O(I<=S-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${S-1}]`)}}const l=_S(r,o,u,a),c=ie(o.shape),h=[],d=Le({inputs:{x:r},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),f=Le({inputs:{x:o},backend:n,attrs:{shape:[l.batchSize,c/l.batchSize]}});h.push(d),h.push(f);const m=[l.batchSize,l.outerSize,c/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([r,o])||r.dtype==="string"){const w=n.bufferSync(f),S=n.bufferSync(d),k=qEe(S,w,m);return h.forEach(I=>n.disposeIntermediateTensorInfo(I)),n.makeTensorInfo(l.outputShape,k.dtype,k.values)}const y=new j3e(d.shape,m),x=n.runWebGLProgram(y,[d,f],d.dtype);h.push(x);const v=Le({inputs:{x},backend:n,attrs:{shape:l.outputShape}});return h.forEach(w=>n.disposeIntermediateTensorInfo(w)),v}const X3e={kernelName:Fy,backendName:"webgl",kernelFunc:c6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q3e="return float(a > b);",Y3e=`
  return vec4(greaterThan(a, b));
`,Q3e=Us({opSnippet:q3e,packedOpSnippet:Y3e,cpuKernelImpl:YEe,dtype:"bool"}),Z3e={kernelName:Oy,backendName:"webgl",kernelFunc:Q3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J3e="return float(a >= b);",ePe=`
  return vec4(greaterThanEqual(a, b));
`,tPe=Us({opSnippet:J3e,packedOpSnippet:ePe,dtype:"bool",cpuKernelImpl:QEe}),nPe={kernelName:qp,backendName:"webgl",kernelFunc:tPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sPe(t){const{inputs:e,backend:n}=t,{input:s}=e;return l6(s,!0,n)}const rPe={kernelName:db,backendName:"webgl",kernelFunc:sPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oPe="return float(!isnan(x) && !isinf(x));",iPe=jt({opSnippet:oPe,dtype:"bool"}),aPe={kernelName:Qp,backendName:"webgl",kernelFunc:iPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uPe="return float(isinf(x));",lPe=jt({opSnippet:uPe,dtype:"bool"}),cPe={kernelName:Zp,backendName:"webgl",kernelFunc:lPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hPe="return float(isnan(x));",dPe=jt({opSnippet:hPe,dtype:"bool"}),pPe={kernelName:Jp,backendName:"webgl",kernelFunc:dPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fPe="return float(a < b);",mPe=`
  return vec4(lessThan(a, b));
`,gPe=Us({opSnippet:fPe,packedOpSnippet:mPe,cpuKernelImpl:ZEe,dtype:"bool"}),yPe={kernelName:My,backendName:"webgl",kernelFunc:gPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xPe="return float(a <= b);",vPe=`
  return vec4(lessThanEqual(a, b));
`,wPe=Us({opSnippet:xPe,packedOpSnippet:vPe,cpuKernelImpl:JEe,dtype:"bool"}),bPe={kernelName:zy,backendName:"webgl",kernelFunc:wPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SPe(t){const{backend:e,attrs:n}=t,{start:s,stop:r,num:o}=n,i=eRe(s,r,o);return e.makeTensorInfo([i.length],"float32",i)}const CPe={kernelName:fb,backendName:"webgl",kernelFunc:SPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kPe=Vf+`
  return x < 0.0 ? 0./0. : log(x);
`,IPe=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,$Pe=jt({opSnippet:kPe,packedOpSnippet:IPe,cpuKernelImpl:tRe}),NPe={kernelName:ef,backendName:"webgl",kernelFunc:$Pe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TPe=Vf+`
  return log(1.0 + x);
`,EPe=jt({opSnippet:TPe}),RPe={kernelName:tf,backendName:"webgl",kernelFunc:EPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const APe="return float(a >= 1.0 && b >= 1.0);",_Pe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,DPe=Us({opSnippet:APe,packedOpSnippet:_Pe,dtype:"bool"}),PPe={kernelName:By,backendName:"webgl",kernelFunc:DPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FPe="return float(!(x >= 1.0));",OPe=jt({opSnippet:FPe}),LPe={kernelName:Vy,backendName:"webgl",kernelFunc:OPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MPe="return float(a >= 1.0 || b >= 1.0);",zPe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,BPe=Us({opSnippet:MPe,packedOpSnippet:zPe,dtype:"bool"}),VPe={kernelName:Wy,backendName:"webgl",kernelFunc:BPe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WPe{constructor(e,n,s,r,o){this.variableNames=["x"],this.outputShape=[];const i=n,a=e[3]-1;this.outputShape=e;let u;const l=`float(${s}) + float(${r}) * sum`;o===.5?u=`inversesqrt(${l})`:o===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UPe{constructor(e,n,s,r,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=n,a=e[3]-1;this.outputShape=e;let u;const l=`float(${s}) + float(${r}) * sum`;o===.5?u=`inversesqrt(${l})`:o===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GPe=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{depthRadius:o,bias:i,alpha:a,beta:u}=s,l=ce().getBool("WEBGL_PACK_NORMALIZATION")?new UPe(r.shape,o,i,a,u):new WPe(r.shape,o,i,a,u);return n.runWebGLProgram(l,[r],r.dtype)},HPe={kernelName:Uy,backendName:"webgl",kernelFunc:GPe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jPe{constructor(e,n,s,r,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=n,this.bias=s,this.alpha=r,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${o})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KPe=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r,y:o,dy:i}=e,{depthRadius:a,bias:u,alpha:l,beta:c}=s,h=new jPe(r.shape,a,u,l,c);return n.runWebGLProgram(h,[r,o,i],r.dtype)},XPe={kernelName:mb,backendName:"webgl",kernelFunc:KPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qPe(t,e,n,s){const r=ie(e),i=ie(t.shape)/r,a=Le({inputs:{x:t},attrs:{shape:[i,r]},backend:s}),u=Dh(a,t.dtype,"max",s),l=Le({inputs:{x:u},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(u),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h6(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reductionIndices:o,keepDims:i}=s,a=r.shape.length,u=vt(o,r.shape);let l=u;const c=cn(l,a),h=c!=null,d=n.shouldExecuteOnCPU([r]);let f=r;if(h){if(d){const S=n.texData.get(f.dataId).values,k=new Array(a);for(let R=0;R<k.length;R++)k[R]=r.shape[c[R]];const I=iR(S,r.shape,r.dtype,c,k);f=n.makeTensorInfo(k,r.dtype);const T=n.texData.get(f.dataId);T.values=I}else f=QS(r,c,n);l=Sn(l.length,a)}cs("max",l,a);const[m,y]=ts(f.shape,l);let x=m;i&&(x=qn(m,u));let v;if(d){const S=n.texData.get(f.dataId).values,k=nRe(S,ie(y),x,r.dtype);v=n.makeTensorInfo(x,r.dtype);const I=n.texData.get(v.dataId);I.values=k}else v=qPe(f,y,x,n);return h&&n.disposeIntermediateTensorInfo(f),v}const YPe={kernelName:Gy,backendName:"webgl",kernelFunc:h6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QPe=aR+`
  return max(a, b);
`,ZPe=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+_h+`
  return result;
`,JPe=Us({opSnippet:QPe,packedOpSnippet:ZPe,cpuKernelImpl:sRe}),eFe={kernelName:nf,backendName:"webgl",kernelFunc:JPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tFe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;M0(r,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=s,l=1;O(Ss(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);const c=Js(r.shape,o,i,l,a,u);if(c.filterWidth===1&&c.filterHeight===1&&kt(c.inShape,c.outShape))return co({inputs:{x:r},backend:n});const h=new iy(c,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}const nFe={kernelName:Hy,backendName:"webgl",kernelFunc:tFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sFe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{filterSize:o,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=s,c=[1,1,1],h=Lo(r.shape,o,i,c,a,l,u),d=new lR(h,"max",!1);return n.runWebGLProgram(d,[r],r.dtype)}const rFe={kernelName:jy,backendName:"webgl",kernelFunc:sFe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oFe{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,o=e.effectiveFilterHeight,i=e.effectiveFilterWidth,a=o-1-e.padInfo.top,u=i-1-e.padInfo.left,l=o*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class iFe{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideDepth,s=e.strideHeight,r=e.strideWidth,o=e.dilationDepth,i=e.dilationHeight,a=e.dilationWidth,u=e.effectiveFilterDepth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,h=u-1-e.padInfo.front,d=l-1-e.padInfo.top,f=c-1-e.padInfo.left,m=u*l*c-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${d}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${m} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aFe(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o}=e,i=o,{filterSize:a,strides:u,pad:l,dimRoundingMode:c}=s,h=[1,1,1],d=Lo(i.shape,a,u,h,l,c),f=new lR(d,"max",!0),m=n.runWebGLProgram(f,[i],i.dtype),y=new iFe(d),x=n.runWebGLProgram(y,[r,m],i.dtype);return n.disposeIntermediateTensorInfo(m),x}const uFe={kernelName:yb,backendName:"webgl",kernelFunc:aFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lFe(t){const{inputs:e,backend:n,attrs:s}=t,{dy:r,input:o,output:i}=e,a=o;M0([o,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:c,dimRoundingMode:h}=s,d=Js(a.shape,u,l,1,c,h),f=!0,m=new iy(d,"max",f),y=n.runWebGLProgram(m,[a],a.dtype),x=new oFe(d),v=n.runWebGLProgram(x,[r,y],a.dtype);return n.disposeIntermediateTensorInfo(y),v}const cFe={kernelName:gb,backendName:"webgl",kernelFunc:lFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hFe(t,e,n,s){let r=new iy(n,"max",!1);const o=s.runWebGLProgram(r,[t],"float32");r=new iy(n,"max",!0,!0,e);const i=s.runWebGLProgram(r,[t],"float32");return[o,i]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dFe={kernelName:xb,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{filterSize:r,strides:o,pad:i,includeBatchInIndex:a}=e,u=n;O(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const l=[1,1];O(Ss(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const c=Js(s.shape,r,o,l,i),[h,d]=hFe(s,a,c,u);return[h,d]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pFe(t,e,n,s){const r=ie(e),i=ie(t.shape)/r,a=Le({inputs:{x:t},attrs:{shape:[i,r]},backend:s}),u=Dh(a,"float32","mean",s),l=Le({inputs:{x:u},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(u),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fFe={kernelName:Ky,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:s}=t,{keepDims:r,axis:o}=e,i=n,a=s.shape.length,u=vt(o,s.shape);let l=u;const c=cn(l,a),h=c!=null,d=i.shouldExecuteOnCPU([s]),f=[];let m=s;if(h){if(d){const k=i.texData.get(m.dataId).values,I=new Array(a);for(let _=0;_<I.length;_++)I[_]=s.shape[c[_]];const T=iR(k,s.shape,s.dtype,c,I);m=i.makeTensorInfo(I,s.dtype);const R=i.texData.get(m.dataId);R.values=T}else m=QS(s,c,i);f.push(m),l=Sn(l.length,a)}cs("sum",l,a);const[y,x]=ts(m.shape,l);let v=y;r&&(v=qn(y,u));const w=pFe(m,x,v,i);for(const S of f)i.disposeIntermediateTensorInfo(S);return w}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mFe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:i}=s,a=r.shape.length,u=vt(o,r.shape);let l=u;const c=cn(l,a);let h=r;c!=null&&(h=gr({inputs:{x:r},backend:n,attrs:{perm:c}}),l=Sn(l.length,r.shape.length)),cs("min",l,a);const[d,f]=ts(h.shape,l),m=ie(f),y=Le({inputs:{x:h},backend:n,attrs:{shape:[-1,m]}}),x=Dh(y,y.dtype,"min",n);let v;if(i){const w=qn(d,u);v=Le({inputs:{x},backend:n,attrs:{shape:w}})}else v=Le({inputs:{x},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x),c!=null&&n.disposeIntermediateTensorInfo(h),v}const gFe={kernelName:Xy,backendName:"webgl",kernelFunc:mFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yFe=aR+`
  return min(a, b);
`,xFe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+_h+`
  return result;
`,vFe=Us({opSnippet:yFe,packedOpSnippet:xFe,cpuKernelImpl:rRe}),wFe={kernelName:sf,backendName:"webgl",kernelFunc:vFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bFe{constructor(e,n,s){this.variableNames=["x"],this.outputShape=n.map((c,h)=>c[0]+e[h]+c[1]);const r=e.length,o=ln(r),i=n.map(c=>c[0]).join(","),a=n.map((c,h)=>c[0]+e[h]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SFe{constructor(e,n,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((m,y)=>m[0]+e[y]+m[1]);const r=e.length,o=ln(r),i=n.map(m=>m[0]).join(","),a=n.map((m,y)=>m[0]+e[y]).join(","),u=pr("rc",r),l=pr("source",r),c=`${u[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${l.slice(-2).join()})`,d=s==="reflect"?0:1;let f="";if(r===1){const m=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;f=`
        ${o} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${l.join()}), ${h});
        ${u[r-1]} += 1;
        if(${c}) {
          ${m}
          result[1] = getChannel(getX(${l.join()}), ${h});
        }
      `}else{const m=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;f=`
        ${o} rc = outputLoc;
        ${m}
        result[0] = getChannel(getX(${l.join()}), ${h});
        ${u[r-1]} += 1;
        if(${c}) {
          ${m}
          result[1] = getChannel(getX(${l.join()}), ${h});
        }
        rc = outputLoc;
        ${u[r-2]} += 1;
        if(${u[r-2]} < ${this.outputShape[r-2]}) {
          ${m}
          result[2] = getChannel(getX(${l.join()}), ${h});
          ${u[r-1]} += 1;
          if(${c}) {
            ${m}
            result[3] = getChannel(getX(${l.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CFe=({inputs:t,backend:e,attrs:n})=>{const{x:s}=t,{paddings:r,mode:o}=n,i=ce().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new SFe(s.shape,r,o):new bFe(s.shape,r,o);return e.runWebGLProgram(i,[s],s.dtype)},kFe={kernelName:qy,backendName:"webgl",kernelFunc:CFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IFe=`if (b == 0.0) return NAN;
  return mod(a, b);`,$Fe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+_h+`
  return result;
`,NFe=Us({opSnippet:IFe,packedOpSnippet:$Fe}),TFe={kernelName:rf,backendName:"webgl",kernelFunc:NFe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EFe{constructor(e,n,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RFe=`
if (a == b) {
  return 1.0;
};
return a / b;`,AFe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,d6=Us({opSnippet:RFe,packedOpSnippet:AFe,checkOutOfBounds:!0}),_Fe={kernelName:Wp,backendName:"webgl",kernelFunc:d6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SF="return a - b;",p6=Us({opSnippet:SF,packedOpSnippet:SF,supportsComplex:!0,cpuKernelImpl:IRe}),DFe={kernelName:bf,backendName:"webgl",kernelFunc:p6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f6(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{dim:o}=s,i=vt([o],r.shape),a=h6({inputs:{x:r},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),u=qn(a.shape,i),l=Le({inputs:{x:a},backend:n,attrs:{shape:u}}),c=p6({inputs:{a:r,b:l},backend:n}),h=u6({inputs:{x:c},backend:n}),d=ZS({inputs:{x:h},backend:n,attrs:{axis:i,keepDims:!1}}),f=Le({inputs:{x:d},backend:n,attrs:{shape:u}}),m=d6({inputs:{a:h,b:f},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),m}const PFe={kernelName:p0,backendName:"webgl",kernelFunc:f6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FFe(t){const{inputs:e,backend:n,attrs:s}=t,{logits:r}=e,{numSamples:o,seed:i,normalized:a}=s,u=a?r:f6({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),l=u.shape[0],c=u.shape[1],h=new EFe(l,c,o),d=[[i]],f=n.runWebGLProgram(h,[u],"int32",d);return a||n.disposeIntermediateTensorInfo(u),f}const OFe={kernelName:vb,backendName:"webgl",kernelFunc:FFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LFe=Si+`
  return -x;
`,MFe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function zFe(t){const{inputs:e,backend:n}=t,{x:s}=e;if(n.shouldExecuteOnCPU([s])){const o=n.texData.get(s.dataId),[i,a]=iRe(o.values,s.shape,s.dtype);return n.makeTensorInfo(a,s.dtype,i)}let r;return ce().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new tl(s.shape,MFe):r=new ma(s.shape,LFe),n.runWebGLProgram(r,[s],s.dtype)}const BFe={kernelName:Yy,backendName:"webgl",kernelFunc:zFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VFe=lS;function WFe(t){Io("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=s,l=n.readSync(r.dataId),c=n.readSync(o.dataId),{selectedIndices:h}=VFe(l,c,i,a,u);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}const UFe={kernelName:wb,backendName:"webgl",kernelFunc:WFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GFe=uE;function HFe(t){Io("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=s,c=n.readSync(r.dataId),h=n.readSync(o.dataId),{selectedIndices:d,validOutputs:f}=GFe(c,h,i,a,u,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([f]))]}const jFe={kernelName:lT,backendName:"webgl",kernelFunc:HFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KFe=cS;function XFe(t){Io("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:s}=t,{boxes:r,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=s,c=n.readSync(r.dataId),h=n.readSync(o.dataId),d=i,f=a,m=u,y=l,{selectedIndices:x,selectedScores:v}=KFe(c,h,d,f,m,y);return[n.makeTensorInfo([x.length],"int32",new Int32Array(x)),n.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const qFe={kernelName:bb,backendName:"webgl",kernelFunc:XFe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YFe{constructor(e,n,s,r){this.variableNames=["indices"],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QFe=t=>{const{inputs:e,backend:n,attrs:s}=t,{indices:r}=e,{dtype:o,depth:i,onValue:a,offValue:u}=s,l=ie(r.shape),c=new YFe(l,i,a,u),h=Le({inputs:{x:r},backend:n,attrs:{shape:[l]}}),d=n.runWebGLProgram(c,[h],o);n.disposeIntermediateTensorInfo(h);const f=[...r.shape,i],m=Le({inputs:{x:d},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(d),m},ZFe={kernelName:Jy,backendName:"webgl",kernelFunc:QFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hw(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="complex64"){const r=B0({inputs:{input:s},backend:n}),o=hw({inputs:{x:r},backend:n}),i=JS({inputs:{input:s},backend:n}),a=hw({inputs:{x:i},backend:n}),u=Hl({inputs:{real:o,imag:a},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),u}else return V0({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:n})}const JFe={kernelName:g0,backendName:"webgl",kernelFunc:hw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m6(t){const{inputs:e,backend:n}=t,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=B0({inputs:{input:s},backend:n}),o=m6({inputs:{x:r},backend:n}),i=JS({inputs:{input:s},backend:n}),a=hw({inputs:{x:i},backend:n}),u=Hl({inputs:{real:o,imag:a},backend:n});return n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),u}else return V0({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:n})}const eOe={kernelName:Zy,backendName:"webgl",kernelFunc:m6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tOe(t){const{inputs:e,backend:n,attrs:s}=t,{axis:r}=s;if(e.length===1)return W$({inputs:{input:e[0]},backend:n,attrs:{dim:r}});const o=e[0].shape,i=e[0].dtype;e.forEach(c=>{Br(o,c.shape,"All tensors passed to stack must have matching shapes"),O(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=e.map(c=>{const h=W$({inputs:{input:c},backend:n,attrs:{dim:r}});return a.push(h),h}),l=e6({inputs:u,backend:n,attrs:{axis:r}});return a.forEach(c=>n.disposeIntermediateTensorInfo(c)),l}const nOe={kernelName:e0,backendName:"webgl",kernelFunc:tOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sOe{constructor(e,n,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((l,c)=>l[0]+e[c]+l[1]);const r=e.length,o=ln(r),i=n.map(l=>l[0]).join(","),a=n.map((l,c)=>l[0]+e[c]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${i});
      ${o} end = ${o}(${a});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rOe{constructor(e,n,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((y,x)=>y[0]+e[x]+y[1]);const r=e.length,o=ln(r),i=n.map(y=>y[0]).join(","),a=n.map((y,x)=>y[0]+e[x]).join(","),u=pr("rc",r),l=pr("source",r),c=`${u[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${l.slice(-2).join()})`,d=[`${o} rc = outputLoc;`,`${u[r-1]} += 1;
       if(${c}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${u[r-2]} += 1;
       if(${u[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${u[r-1]} += 1;
         if(${c}) {`],f=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let m="";for(let y=0,x=r===1?2:4;y<x;y++)m+=`
        ${d[y]}
        if (${f}) {
          result[${y}] = float(value);
        } else {
          ${o} source = rc - start;
          result[${y}] = getChannel(getX(${l.join()}), ${h});
        }
      `;m+=r===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${i});
      const ${o} end = ${o}(${a});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g6=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{paddings:o,constantValue:i}=s;if(ie(r.shape)===0){const l=o.map((c,h)=>c[0]+r.shape[h]+c[1]);return V0({backend:n,attrs:{shape:l,value:i,dtype:r.dtype}})}const a=ce().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rOe(r.shape,o,i):new sOe(r.shape,o,i),u=[[i]];return n.runWebGLProgram(a,[r],r.dtype,u)},oOe={kernelName:t0,backendName:"webgl",kernelFunc:g6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iOe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,aOe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+_h+`
  return result;
`,uOe=Us({opSnippet:iOe,packedOpSnippet:aOe}),lOe={kernelName:af,backendName:"webgl",kernelFunc:uOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cOe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{axis:o,keepDims:i}=s,a=r.shape.length,u=[],l=vt(o,r.shape);let c=l;const h=cn(c,a);let d=r;h!=null&&(d=gr({inputs:{x:r},backend:n,attrs:{perm:h}}),c=Sn(c.length,a),u.push(d)),cs("prod",c,a);let f;if(n.shouldExecuteOnCPU([d])){const m=n.texData.get(d.dataId).values,{outVals:y,outShape:x,outDtype:v}=uRe(d.shape,d.dtype,m,c);f=n.makeTensorInfo(x,v,y)}else{const[m,y]=ts(d.shape,c),x=ie(y),v=Le({inputs:{x:d},backend:n,attrs:{shape:[-1,x]}}),w=Bb(r.dtype),S=Dh(v,w,"prod",n);f=Le({inputs:{x:S},backend:n,attrs:{shape:m}}),u.push(v),u.push(S)}if(i){u.push(f);const m=qn(f.shape,l);f=Le({inputs:{x:f},backend:n,attrs:{shape:m}})}return u.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}const hOe={kernelName:s0,backendName:"webgl",kernelFunc:cOe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dOe(t){const{inputs:e,backend:n,attrs:s}=t,{paramsNestedSplits:r,paramsDenseValues:o,indices:i}=e,{outputRaggedRank:a}=s,u=r.map(v=>n.readSync(v.dataId)),l=r.map(v=>v.shape),c=n.readSync(o.dataId),h=n.readSync(i.dataId),[d,f,m]=lRe(u,l,c,o.shape,o.dtype,h,i.shape,a),y=d.map(v=>n.makeTensorInfo([v.length],"int32",v)),x=n.makeTensorInfo(m,o.dtype,f);return y.concat([x])}const pOe={kernelName:cT,backendName:"webgl",kernelFunc:dOe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fOe(t){const{inputs:e,backend:n}=t,{starts:s,limits:r,deltas:o}=e,i=n.readSync(s.dataId),a=n.readSync(r.dataId),u=n.readSync(o.dataId),[l,c]=cRe(i,s.shape,s.dtype,a,r.shape,u,o.shape),h=n.makeTensorInfo([l.length],"int32",l),d=n.makeTensorInfo([c.length],s.dtype,c);return[h,d]}const mOe={kernelName:hT,backendName:"webgl",kernelFunc:fOe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gOe(t){const{inputs:e,backend:n,attrs:s}=t,{shape:r,values:o,defaultValue:i,rowPartitionTensors:a}=e,{rowPartitionTypes:u}=s,l=n.readSync(r.dataId),c=n.readSync(o.dataId),h=n.readSync(i.dataId),d=a.map(x=>n.readSync(x.dataId)),f=a.map(x=>x.shape),[m,y]=hRe(l,r.shape,c,o.shape,o.dtype,h,i.shape,d,f,u);return n.makeTensorInfo(m,o.dtype,y)}const yOe={kernelName:dT,backendName:"webgl",kernelFunc:gOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y6=t=>{const{backend:e,attrs:n}=t,{start:s,stop:r,step:o,dtype:i}=n,a=dRe(s,r,o,i);return e.makeTensorInfo([a.length],i,a)},xOe={kernelName:Sb,backendName:"webgl",kernelFunc:y6};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vOe="return 1.0 / x;",wOe=jt({opSnippet:vOe}),bOe={kernelName:uf,backendName:"webgl",kernelFunc:wOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SOe=Si+`
  return (x < 0.0) ? 0.0 : x;
`,COe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,kOe=jt({opSnippet:SOe,packedOpSnippet:COe}),IOe={kernelName:lf,backendName:"webgl",kernelFunc:kOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Oe=Si+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,NOe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,TOe=jt({opSnippet:$Oe,packedOpSnippet:NOe}),EOe={kernelName:cf,backendName:"webgl",kernelFunc:TOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ROe{constructor(e,n,s,r,o){this.variableNames=["A"],this.outputShape=[];const[i,a,u,l]=e;this.outputShape=[i,n,s,l];const c=[r&&n>1?a-1:a,r&&s>1?u-1:u],h=[r&&n>1?n-1:n,r&&s>1?s-1:s];let d;o?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AOe{constructor(e,n,s,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,u,l]=e;this.outputShape=[i,n,s,l];const c=[r&&n>1?a-1:a,r&&s>1?u-1:u],h=[r&&n>1?n-1:n,r&&s>1?s-1:s];let d;o?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Oe(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:o,halfPixelCenters:i,size:a}=s,[u,l]=a,c=ce().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new AOe(r.shape,u,l,o,i):new ROe(r.shape,u,l,o,i);return n.runWebGLProgram(c,[r],"float32")}const DOe={kernelName:i0,backendName:"webgl",kernelFunc:_Oe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class POe{constructor(e,n,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,r,o]=n,[,i,a]=e,u=[s&&i>1?r-1:r,s&&a>1?o-1:o],l=[s&&i>1?i-1:i,s&&a>1?a-1:a],c=u[0]/l[0],h=u[1]/l[1],d=1/c,f=1/h,m=Math.ceil(d)*2+2,y=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${m});
        const int winWidth = int(${y});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FOe(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:o}=e,{alignCorners:i}=s,a=new POe(o.shape,r.shape,i);return n.runWebGLProgram(a,[o],o.dtype)}const OOe={kernelName:Ib,backendName:"webgl",kernelFunc:FOe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LOe{constructor(e,n,s,r,o){this.variableNames=["A"],this.outputShape=[];const[i,a,u,l]=e;this.outputShape=[i,n,s,l];const c=[r&&n>1?a-1:a,r&&s>1?u-1:u],h=[r&&n>1?n-1:n,r&&s>1?s-1:s],d=r?"0.5":"0.0";let f;o?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/h[0]},
          ${c[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MOe{constructor(e,n,s,r,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,u,l]=e;this.outputShape=[i,n,s,l];const c=[r&&n>1?a-1:a,r&&s>1?u-1:u],h=[r&&n>1?n-1:n,r&&s>1?s-1:s],d=r?"0.5":"0.0";let f;o?f="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/h[0]},
          ${c[1]/h[1]},
          ${c[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zOe(t){const{inputs:e,backend:n,attrs:s}=t,{images:r}=e,{alignCorners:o,halfPixelCenters:i,size:a}=s,[u,l]=a,c=ce().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new MOe(r.shape,u,l,o,i):new LOe(r.shape,u,l,o,i);return n.runWebGLProgram(c,[r],r.dtype)}const BOe={kernelName:o0,backendName:"webgl",kernelFunc:zOe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VOe{constructor(e,n,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,r,o]=n,[,i,a]=e,u=[s&&i>1?r-1:r,s&&a>1?o-1:o],l=[s&&i>1?i-1:i,s&&a>1?a-1:a],c=u[0]/l[0],h=u[1]/l[1],d=1/c,f=1/h,m=Math.ceil(d)*2+2,y=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${f});

        const int winHeight = int(${m});
        const int winWidth = int(${y});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WOe(t){const{inputs:e,backend:n,attrs:s}=t,{images:r,dy:o}=e,{alignCorners:i}=s,a=new VOe(o.shape,r.shape,i);return n.runWebGLProgram(a,[o],o.dtype)}const UOe={kernelName:kb,backendName:"webgl",kernelFunc:WOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GOe{constructor(e,n){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=a=>n.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,o=e.map((a,u)=>r(u)).join(","),i=ln(s);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HOe{constructor(e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=pr("rc",s),o=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,i=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,a=ln(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(r.slice())};
          if(${o}){
            result.g = ${l(r.slice())};
          }
          if(${i}) {
            result.b = ${c(r.slice())};
            if(${o}) {
              result.a = ${h(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(m){return d(m)}function l(m){return m[s-1]="("+m[s-1]+" + 1)",d(m)}function c(m){return m[s-2]="("+m[s-2]+" + 1)",d(m)}function h(m){return m[s-1]="("+m[s-1]+" + 1)",m[s-2]="("+m[s-2]+" + 1)",d(m)}function d(m){const y=e.map((w,S)=>f(S,m)),x=y.join(","),v=y.slice(-2).join(",");return`getChannel(getX(${x}), vec2(${v}))`}function f(m,y){return n.indexOf(m)!==-1&&e[m]!==1?`${e[m]} - ${y[m]} - 1`:`${y[m]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jOe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{dims:o}=s,i=r.shape.length,a=vt(o,r.shape);if(i===0)return co({inputs:{x:r},backend:n});const u=ce().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new HOe(r.shape,a):new GOe(r.shape,a);return n.runWebGLProgram(u,[r],r.dtype)}const KOe={kernelName:a0,backendName:"webgl",kernelFunc:jOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XOe{constructor(e,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let o="";typeof n=="number"?o=`float outputValue = ${n.toFixed(2)};`:o=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${o}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qOe={kernelName:Mb,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:s}=t,{radians:r,fillValue:o,center:i}=e,a=n,u=new XOe(s.shape,o),[l,c]=yS(i,s.shape[1],s.shape[2]),h=[[l,c,Math.sin(r),Math.cos(r)]];return a.runWebGLProgram(u,[s],s.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YOe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,QOe=jt({opSnippet:YOe}),ZOe={kernelName:hf,backendName:"webgl",kernelFunc:QOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JOe="return inversesqrt(x);",eLe=jt({opSnippet:JOe,cpuKernelImpl:pRe}),tLe={kernelName:df,backendName:"webgl",kernelFunc:eLe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cR{constructor(e,n,s,r,o,i,a=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const l=ln(o.length),c=ln(i.length);let h="";s===1?h="i":s===2&&(h="i, j");const d=`getIndices(${h})`;let f="";r===1?f="i":r===2&&(f="i, coords[1]");const m=`getUpdates(${f})`;let y="";u&&(y="coords[0], coords[1]");const x=`getDefaultValue(${y})`,v=n>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${o});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${v};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${m};
              found = true;
            }
          }
          setOutput(mix(${x}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nLe{constructor(e,n,s,r,o,i,a=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const l=ln(o.length),c=ln(i.length);let h="";s===1?h="i":s===2&&(h="i, j");const d=`getIndices(${h})`;let f="";r===1?f="i":r===2&&(f="i, coords[1]");const m=`getUpdates(${f})`;let y="";u&&(y="coords[0], coords[1]");const x=`getDefaultValue(${y})`,v=n>1?"strides[j]":"strides",w=n>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${o});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${n}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${v};
              if (j + 1 < ${n}) {
                flattenedIndex += index.yw * ${w};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${m};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${x}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sLe(t){const{inputs:e,backend:n,attrs:s}=t,{indices:r,updates:o}=e,{shape:i}=s,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=Ra(o,r,i),d=[h/l,l];if(h===0)return n.makeTensorInfo(i,r.dtype);const f=Le({inputs:{x:r},backend:n,attrs:{shape:[u,a]}}),m=Le({inputs:{x:o},backend:n,attrs:{shape:[u,l]}}),y=n.makeTensorInfo([],"float32",new Float32Array([0]));let x;ce().getBool("WEBGL_PACK")?x=new nLe(u,a,f.shape.length,m.shape.length,c,d):x=new cR(u,a,f.shape.length,m.shape.length,c,d);const v=n.runWebGLProgram(x,[m,f,y],m.dtype),w=Le({inputs:{x:v},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(y),w}const rLe={kernelName:$b,backendName:"webgl",kernelFunc:sLe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oLe{constructor(e,n,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const o="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,a=ce().getNumber("WEBGL_VERSION")===2?o:i,u=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iLe(t){const{inputs:e,backend:n,attrs:s}=t,{sortedSequence:r,values:o}=e,{side:i}=s,a=new oLe(r.shape[0],r.shape[1],o.shape[1],i),u=[[r.shape[1]]];return n.runWebGLProgram(a,[r,o],"int32",u)}const aLe={kernelName:Tb,backendName:"webgl",kernelFunc:iLe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uLe{constructor(e,n,s){this.variableNames=["c","a","b"],this.outputShape=n;let r,o;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)o="resRC",r="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],l=[];for(let c=0;c<n.length;c++)l.push(`${a[c]}`),c<e&&u.push(`${a[c]}`);r=u.join(),o=l.join()}const i=ln(s);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lLe(t){const{inputs:e,backend:n}=t,{condition:s,t:r,e:o}=e,i=new uLe(s.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(i,[s,r,o],_s(r.dtype,o.dtype))}const cLe={kernelName:u0,backendName:"webgl",kernelFunc:lLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hLe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${I0};
  float scale = ${$0};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,dLe=jt({opSnippet:hLe}),pLe={kernelName:pf,backendName:"webgl",kernelFunc:dLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fLe=Vf+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,mLe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,gLe=jt({opSnippet:fLe,packedOpSnippet:mLe,cpuKernelImpl:mRe}),yLe={kernelName:yf,backendName:"webgl",kernelFunc:gLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xLe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,vLe=jt({opSnippet:xLe}),wLe={kernelName:gf,backendName:"webgl",kernelFunc:vLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bLe=Vf+`
  return sin(x);
`,SLe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${_h}
  return result;
`,CLe=jt({opSnippet:bLe,packedOpSnippet:SLe}),kLe={kernelName:ff,backendName:"webgl",kernelFunc:CLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ILe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,$Le=jt({opSnippet:ILe}),NLe={kernelName:mf,backendName:"webgl",kernelFunc:$Le};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TLe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,ELe=jt({opSnippet:TLe}),RLe={kernelName:xf,backendName:"webgl",kernelFunc:ELe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ALe=t=>{const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{blockShape:o,paddings:i}=s;O(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=o.reduce((v,w)=>v*w),u=[[0,0]];u.push(...i);for(let v=1+o.length;v<r.shape.length;++v)u.push([0,0]);const l=[],c=g6({inputs:{x:r},backend:n,attrs:{paddings:u,constantValue:0}}),h=Sh(c.shape,o,a,!1),d=Ch(h.length,o.length,!1),f=kh(c.shape,o,a,!1),m=Le({inputs:{x:c},backend:n,attrs:{shape:h}}),y=gr({inputs:{x:m},backend:n,attrs:{perm:d}}),x=Le({inputs:{x:y},backend:n,attrs:{shape:f}});return l.push(c),l.push(m),l.push(y),l.forEach(v=>n.disposeIntermediateTensorInfo(v)),x},_Le={kernelName:h0,backendName:"webgl",kernelFunc:ALe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DLe(t){const{inputs:e,backend:n}=t,{indices:s,values:r,denseShape:o,defaultValue:i}=e;if(o.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${o.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const a=n.readSync(s.dataId),u=n.readSync(r.dataId),l=n.readSync(o.dataId),c=n.readSync(i.dataId)[0],[h,d,f,m,y]=yRe(a,s.shape,s.dtype,u,r.dtype,l,c);return[n.makeTensorInfo(d,s.dtype,h),n.makeTensorInfo([d[0]],r.dtype,f),n.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(x=>Number(x)))),n.makeTensorInfo([y.length],s.dtype,new Int32Array(y))]}const PLe={kernelName:pT,backendName:"webgl",kernelFunc:DLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FLe(t){const{inputs:e,backend:n}=t,{inputIndices:s,inputShape:r,newShape:o}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(o.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${o.shape}`);const i=Array.from(n.readSync(r.dataId)),a=n.readSync(s.dataId),u=Array.from(n.readSync(o.dataId)),[l,c,h]=xRe(a,s.shape,s.dtype,i,u);return[n.makeTensorInfo(c,s.dtype,l),n.makeTensorInfo([h.length],o.dtype,new Int32Array(h))]}const OLe={kernelName:fT,backendName:"webgl",kernelFunc:FLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LLe(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${o.shape}`);const i=n.readSync(s.dataId),a=n.readSync(r.dataId),u=n.readSync(o.dataId),[l,c]=VH(i,s.shape,s.dtype,a,u,!0);return n.makeTensorInfo(c,s.dtype,l)}const MLe={kernelName:Eb,backendName:"webgl",kernelFunc:LLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zLe(t){const{inputs:e,backend:n}=t,{data:s,indices:r,segmentIds:o}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(o.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${o.shape}`);const i=n.readSync(s.dataId),a=n.readSync(r.dataId),u=n.readSync(o.dataId),[l,c]=VH(i,s.shape,s.dtype,a,u);return n.makeTensorInfo(c,s.dtype,l)}const BLe={kernelName:Rb,backendName:"webgl",kernelFunc:zLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VLe(t){const{inputs:e,backend:n,attrs:s}=t,{sparseIndices:r,sparseValues:o,defaultValue:i}=e,{outputShape:a}=s,{sliceRank:u,numUpdates:l,sliceSize:c,strides:h,outputSize:d}=Ra(o,r,a),f=!1;if(o.dtype==="string"){const v=n.bufferSync(r),w=n.bufferSync(o),S=Vi(n.readSync(i.dataId)[0]),k=fRe(v,w,a,d,c,l,u,h,S,f);return n.makeTensorInfo(a,k.dtype,k.values)}const m=new cR(l,u,r.shape.length,o.shape.length,h,[d,1],f),y=n.runWebGLProgram(m,[o,r,i],o.dtype),x=Le({inputs:{x:y},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(y),x}const WLe={kernelName:Ab,backendName:"webgl",kernelFunc:VLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ULe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{numOrSizeSplits:o,axis:i}=s,a=vt(i,r.shape)[0],u=AS(r,o,a),l=r.shape.length,c=new Array(l).fill(0),h=r.shape.slice();return u.map(d=>{const f=[...h];f[a]=d;const m=Wf({inputs:{x:r},backend:n,attrs:{begin:c,size:f}});return c[a]+=d,m})}const GLe={kernelName:d0,backendName:"webgl",kernelFunc:ULe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CF="return sqrt(x);",HLe=jt({opSnippet:CF,packedOpSnippet:CF,cpuKernelImpl:vRe}),jLe={kernelName:vf,backendName:"webgl",kernelFunc:HLe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KLe="return x * x;",XLe=jt({opSnippet:KLe}),qLe={kernelName:_b,backendName:"webgl",kernelFunc:XLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kF="return (a - b) * (a - b);",YLe=Us({opSnippet:kF,packedOpSnippet:kF}),QLe={kernelName:wf,backendName:"webgl",kernelFunc:YLe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZLe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");const o=n.readSync(r.dataId),i=Hi(o),a=wRe(i,"string",s);return n.makeTensorInfo(r.shape,"string",a)}const JLe={kernelName:Db,backendName:"webgl",kernelFunc:ZLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eMe({inputs:t,attrs:e,backend:n}){const{x:s}=t,r=Si+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,o=new ma(s.shape,r);return n.runWebGLProgram(o,[s],s.dtype)}const tMe={kernelName:If,backendName:"webgl",kernelFunc:eMe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nMe{constructor(e,n,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,o=ln(s.length),i=ln(s.length);let a="";if(r===1)a="coords * strides + begin";else{let u=0;a=s.map((l,c)=>(u++,s.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${u-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${e});
      ${o} strides = ${o}(${n});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sMe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{begin:o,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s,{finalShapeSparse:f,finalShape:m,isIdentity:y,sliceDim0:x,isSimpleSlice:v,begin:w,end:S,strides:k}=fS(r.shape,o,i,a,u,l,c,h,d);let I;if(y)I=Le({inputs:{x:r},backend:n,attrs:{shape:m}});else if(x||v){O(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const R=pS(w,S,k),_=Wf({inputs:{x:r},backend:n,attrs:{begin:w,size:R}});I=Le({inputs:{x:_},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(_)}else if(n.shouldExecuteOnCPU([r])){const _=n.readSync(r.dataId),D=xt(r.shape,r.dtype,_),L=bRe(f,D,k,w);I=n.makeTensorInfo(m,r.dtype,L.values)}else{const _=new nMe(w,k,f);I=n.runWebGLProgram(_,[r],r.dtype)}const T=Le({inputs:{x:I},backend:n,attrs:{shape:m}});return n.disposeIntermediateTensorInfo(I),T}const rMe={kernelName:Pb,backendName:"webgl",kernelFunc:sMe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oMe(t){const{inputs:e,backend:n,attrs:s}=t,{separator:r,nGramWidths:o,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=s,{data:c,dataSplits:h}=e,d=n.readSync(c.dataId),f=n.readSync(h.dataId),[m,y]=SRe(d,f,r,o,i,a,u,l);return[n.makeTensorInfo([m.length],"string",m),n.makeTensorInfo(h.shape,"int32",y)]}const iMe={kernelName:Fb,backendName:"webgl",kernelFunc:oMe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aMe(t){const{inputs:e,backend:n,attrs:s}=t,{skipEmpty:r}=s,{input:o,delimiter:i}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(o.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${o.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const a=n.readSync(o.dataId),u=n.readSync(i.dataId)[0],[l,c,h]=CRe(a,u,r),d=c.length;return[n.makeTensorInfo([d,2],"int32",l),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}const uMe={kernelName:mT,backendName:"webgl",kernelFunc:aMe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lMe(t){const{inputs:e,backend:n,attrs:s}=t,{numBuckets:r}=s,{input:o}=e;if(o.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(o.dataId),a=kRe(i,r);return n.makeTensorInfo(o.shape,"int32",a)}const cMe={kernelName:gT,backendName:"webgl",kernelFunc:lMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hMe="return tan(x);",dMe=jt({opSnippet:hMe}),pMe={kernelName:Sf,backendName:"webgl",kernelFunc:dMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fMe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,mMe=jt({opSnippet:fMe}),gMe={kernelName:Cf,backendName:"webgl",kernelFunc:mMe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yMe(t){const{inputs:e,backend:n,attrs:s}=t,{tensor:r,indices:o,updates:i}=e,{sliceRank:a,numUpdates:u,sliceSize:l,strides:c,outputSize:h}=Ra(i,o,r.shape),d=[h/l,l];if(h===0)return n.makeTensorInfo(r.shape,o.dtype);const f=Le({inputs:{x:o},backend:n,attrs:{shape:[u,a]}}),m=Le({inputs:{x:i},backend:n,attrs:{shape:[u,l]}}),y=Le({inputs:{x:r},backend:n,attrs:{shape:d}}),x=new cR(u,a,f.shape.length,m.shape.length,c,d,!1,!0),v=n.runWebGLProgram(x,[m,f,y],y.dtype),w=Le({inputs:{x:v},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(v),w}const xMe={kernelName:Nb,backendName:"webgl",kernelFunc:yMe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vMe{constructor(e,n){this.variableNames=["A"];const s=new Array(e.length);for(let i=0;i<s.length;i++)s[i]=e[i]*n[i];this.outputShape=s,this.rank=s.length;const r=ln(this.rank),o=wMe(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}}function wMe(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<t.length;r++)s.push(`imod(${n[r]}, ${t[r]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x6(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{reps:o}=s;if(r.dtype==="string"||r.shape.length>5){const u=n.readSync(r.dataId),l=r.dtype==="string"?u.map(d=>Vi(d)):u,c=xt(r.shape,r.dtype,l),h=$Re(c,o);return n.makeTensorInfo(h.shape,h.dtype,h.values)}const i=new vMe(r.shape,o);return n.runWebGLProgram(i,[r],r.dtype)}const bMe={kernelName:kf,backendName:"webgl",kernelFunc:x6};class SMe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class CMe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gc(t,e){e!==null&&t.disposeIntermediateTensorInfo(e)}function IF(t){let e=1;for(;e<t;)e*=2;return e}function kMe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r}=e,{k:o,sorted:i}=s,a=ce().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=ce().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=r.shape,c=l[l.length-1];if(n.shouldExecuteOnCPU([r])||c<a||o>u){const L=n.readSync(r.dataId),[V,U]=NRe(L,l,r.dtype,o,i);return[n.makeTensorInfo(V.shape,V.dtype,V.values),n.makeTensorInfo(U.shape,U.dtype,U.values)]}if(o===0)return l[l.length-1]=0,[n.makeTensorInfo(l,r.dtype,[]),n.makeTensorInfo(l,"int32",[])];if(c===1)return[r,V0({attrs:{shape:l,dtype:"int32",value:0},backend:n})];const h=n.texData.get(r.dataId),d=h!==null&&h.isPacked,f=d?n.unpackTensor(r):r,y=ie(l)/c,x=Le({inputs:{x:f},attrs:{shape:[y,c]},backend:n});d&&gc(n,f);const v=IF(o),w=IF(c);let S=null;const k=()=>S===null?[x,x]:[x,S],I=(L,V,U)=>{const j=k(),q=new SMe(U),te=[[c],[S===null?1:0],[Number.NEGATIVE_INFINITY],[L],[V]],le=S;S=n.runWebGLProgram(q,j,"int32",te),gc(n,le)};for(let L=1;L<v;L*=2){const V=L*2;for(let U=L;U>=1;U/=2)I(V,U,[y,w])}for(let L=w;L>v;L/=2){const V=k(),U=new CMe([y,L/2]),q=[[c],[S===null?1:0],[v]],J=S;S=n.runWebGLProgram(U,V,"int32",q),gc(n,J);const te=v/2,le=te*2;for(let K=te;K>=1;K/=2)I(le,K,S.shape)}let T=S;S=Wf({inputs:{x:S},backend:n,attrs:{begin:0,size:[y,o]}}),gc(n,T);let R=c6({inputs:{x,indices:S},backend:n,attrs:{axis:1,batchDims:1}});gc(n,x);const _=l.slice(0,-1);_.push(o),T=S,S=Le({inputs:{x:S},attrs:{shape:_},backend:n}),gc(n,T);const D=R;return R=Le({inputs:{x:R},attrs:{shape:_},backend:n}),gc(n,D),[R,S]}const IMe={kernelName:Ob,backendName:"webgl",kernelFunc:kMe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $Me{constructor(e,n,s,r,o,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a=s==="nearest"?1:2;let u;switch(r){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${o});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${o});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NMe(t){const{inputs:e,backend:n,attrs:s}=t,{image:r,transforms:o}=e,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=s,[c,h,d,f]=r.shape,[m,y]=l??[h,d],x=[c,m,y,f],v=new $Me(h,d,i,a,u,x);return n.runWebGLProgram(v,[r,o],"float32")}const TMe={kernelName:Lb,backendName:"webgl",kernelFunc:NMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EMe(t){const{inputs:e,attrs:n,backend:s}=t,{axis:r}=n,{x:o}=e;M0(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=s.readSync(o.dataId),{outputValues:a,outputShape:u,indices:l}=TRe(i,r,o.shape,o.dtype);return[s.makeTensorInfo(u,o.dtype,a),s.makeTensorInfo([l.length],"int32",l)]}const RMe={kernelName:yT,backendName:"webgl",kernelFunc:EMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AMe(t){const{inputs:e,backend:n,attrs:s}=t,{value:r}=e;let{axis:o}=s;o<0&&(o+=r.shape.length);const i=r,a=i.shape.length,u=r.shape[o],l=new Array(a-1);let c=0;for(let y=0;y<a;y++)y!==o&&(l[c++]=i.shape[y]);const h=[],d=new Array(a).fill(0),f=i.shape.slice();f[o]=1;const m=new Array(u);for(let y=0;y<m.length;y++){d[o]=y;const x=Wf({inputs:{x:i},backend:n,attrs:{begin:d,size:f}}),v=Le({inputs:{x},backend:n,attrs:{shape:l}});m[y]=v,h.push(x)}return h.forEach(y=>n.disposeIntermediateTensorInfo(y)),m}const _Me={kernelName:f0,backendName:"webgl",kernelFunc:AMe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DMe{constructor(e,n){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,o=e.inSize,i=e.numSegments,a=i*Math.ceil(o/s);this.outputShape=[r,a];const u="0.0",l="sumValue",c=Math.floor(s/4)*4,h=s%4,d=`
        sumValue += dot(values, segFilter);
    `;let f="";o%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let m="";o%s>0&&(m=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${m}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${c};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${l});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PMe(t){const{inputs:e,backend:n,attrs:s}=t,{x:r,segmentIds:o}=e,{numSegments:i}=s,a=r.shape.length,u=[];let l=0;const c=cn([l],a);let h=r;c!=null&&(h=gr({inputs:{x:r},backend:n,attrs:{perm:c}}),u.push(h),l=Sn(1,a)[0]);const d=xE(h.shape,l,i),f=ie([h.shape[l]]),m=Le({inputs:{x:h},backend:n,attrs:{shape:[-1,f]}});u.push(m);const y=Bb(r.dtype),x=(k,I,T,R,_)=>{const D=k.shape[0],L=k.shape[1],V=r4(L,_),U={windowSize:V,inSize:L,batchSize:D,numSegments:_},j=new DMe(U,I),q=n.compileAndRun(j,[k,T],R);if(u.push(q),q.shape[1]===_)return q;const J=y6({backend:n,attrs:{start:0,stop:_,step:1,dtype:"float32"}}),te=x6({inputs:{x:J},backend:n,attrs:{reps:[L/V]}});return u.push(J),u.push(te),x(q,I,te,R,_)},v=x(m,"unsortedSegmentSum",o,y,i),w=Le({inputs:{x:v},backend:n,attrs:{shape:d}});let S=w;if(c!=null){u.push(w);const k=Ta(c);S=gr({inputs:{x:S},backend:n,attrs:{perm:k}})}return u.forEach(k=>n.disposeIntermediateTensorInfo(k)),S}const FMe={kernelName:m0,backendName:"webgl",kernelFunc:PMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OMe=[vAe,bAe,kAe,NAe,EAe,_Ae,PAe,OAe,BAe,WAe,HAe,XAe,QAe,t_e,r_e,i_e,u_e,d_e,f_e,g_e,w_e,N_e,E_e,D_e,F_e,V_e,U_e,K_e,nAe,Y_e,tDe,oDe,hDe,fDe,gDe,xDe,wDe,kDe,NDe,RDe,_De,PDe,ODe,zDe,VDe,HDe,KDe,YDe,JDe,t3e,o3e,l3e,p3e,g3e,v3e,w3e,S3e,k3e,$3e,T3e,R3e,P3e,L3e,B3e,W3e,H3e,X3e,Z3e,nPe,tAe,rPe,J_e,aPe,cPe,pPe,rAe,yPe,bPe,CPe,NPe,RPe,PPe,LPe,VPe,HPe,XPe,YPe,eFe,nFe,rFe,uFe,cFe,dFe,fFe,gFe,wFe,kFe,TFe,OFe,aAe,BFe,UFe,jFe,qFe,L_e,ZFe,eOe,nOe,oOe,lOe,iAe,hOe,pOe,mOe,yOe,xOe,M_e,_Fe,bOe,IOe,EOe,lAe,DOe,OOe,BOe,UOe,KOe,qOe,ZOe,tLe,rLe,aLe,cLe,pLe,yLe,wLe,kLe,NLe,I_e,PFe,RLe,_Le,PLe,OLe,MLe,BLe,WLe,GLe,jLe,qLe,QLe,JLe,tMe,rMe,iMe,uMe,cMe,DFe,gAe,pMe,gMe,xMe,bMe,IMe,TMe,yAe,RMe,_Me,FMe,JFe];for(const t of OMe)xT(t);const v6=fe.createContext({transformPagePoint:t=>t,isStatic:!1,reducedMotion:"never"}),eC=fe.createContext({}),hR=fe.createContext(null),tC=typeof document<"u",LMe=tC?fe.useLayoutEffect:fe.useEffect,w6=fe.createContext({strict:!1}),dR=t=>t.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),MMe="framerAppearId",b6="data-"+dR(MMe);function zMe(t,e,n,s){const{visualElement:r}=fe.useContext(eC),o=fe.useContext(w6),i=fe.useContext(hR),a=fe.useContext(v6).reducedMotion,u=fe.useRef();s=s||o.renderer,!u.current&&s&&(u.current=s(t,{visualState:e,parent:r,props:n,presenceContext:i,blockInitialAnimation:i?i.initial===!1:!1,reducedMotionConfig:a}));const l=u.current;fe.useInsertionEffect(()=>{l&&l.update(n,i)});const c=fe.useRef(!!(n[b6]&&!window.HandoffComplete));return LMe(()=>{l&&(l.render(),c.current&&l.animationState&&l.animationState.animateChanges())}),fe.useEffect(()=>{l&&(l.updateFeatures(),!c.current&&l.animationState&&l.animationState.animateChanges(),c.current&&(c.current=!1,window.HandoffComplete=!0))}),l}function Pd(t){return t&&typeof t=="object"&&Object.prototype.hasOwnProperty.call(t,"current")}function BMe(t,e,n){return fe.useCallback(s=>{s&&t.mount&&t.mount(s),e&&(s?e.mount(s):e.unmount()),n&&(typeof n=="function"?n(s):Pd(n)&&(n.current=s))},[e])}function uy(t){return typeof t=="string"||Array.isArray(t)}function nC(t){return t!==null&&typeof t=="object"&&typeof t.start=="function"}const pR=["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],fR=["initial",...pR];function sC(t){return nC(t.animate)||fR.some(e=>uy(t[e]))}function S6(t){return!!(sC(t)||t.variants)}function VMe(t,e){if(sC(t)){const{initial:n,animate:s}=t;return{initial:n===!1||uy(n)?n:void 0,animate:uy(s)?s:void 0}}return t.inherit!==!1?e:{}}function WMe(t){const{initial:e,animate:n}=VMe(t,fe.useContext(eC));return fe.useMemo(()=>({initial:e,animate:n}),[$F(e),$F(n)])}function $F(t){return Array.isArray(t)?t.join(" "):t}const NF={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},ly={};for(const t in NF)ly[t]={isEnabled:e=>NF[t].some(n=>!!e[n])};function UMe(t){for(const e in t)ly[e]={...ly[e],...t[e]}}const C6=fe.createContext({}),k6=fe.createContext({}),GMe=Symbol.for("motionComponentSymbol");function HMe({preloadedFeatures:t,createVisualElement:e,useRender:n,useVisualState:s,Component:r}){t&&UMe(t);function o(a,u){let l;const c={...fe.useContext(v6),...a,layoutId:jMe(a)},{isStatic:h}=c,d=WMe(a),f=s(a,h);if(!h&&tC){d.visualElement=zMe(r,f,c,e);const m=fe.useContext(k6),y=fe.useContext(w6).strict;d.visualElement&&(l=d.visualElement.loadFeatures(c,y,t,m))}return fe.createElement(eC.Provider,{value:d},l&&d.visualElement?fe.createElement(l,{visualElement:d.visualElement,...c}):null,n(r,a,BMe(f,d.visualElement,u),f,h,d.visualElement))}const i=fe.forwardRef(o);return i[GMe]=r,i}function jMe({layoutId:t}){const e=fe.useContext(C6).id;return e&&t!==void 0?e+"-"+t:t}function KMe(t){function e(s,r={}){return HMe(t(s,r))}if(typeof Proxy>"u")return e;const n=new Map;return new Proxy(e,{get:(s,r)=>(n.has(r)||n.set(r,e(r)),n.get(r))})}const XMe=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];function mR(t){return typeof t!="string"||t.includes("-")?!1:!!(XMe.indexOf(t)>-1||/[A-Z]/.test(t))}const dw={};function qMe(t){Object.assign(dw,t)}const W0=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],Ph=new Set(W0);function I6(t,{layout:e,layoutId:n}){return Ph.has(t)||t.startsWith("origin")||(e||n!==void 0)&&(!!dw[t]||t==="opacity")}const ho=t=>!!(t&&t.getVelocity),YMe={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},QMe=W0.length;function ZMe(t,{enableHardwareAcceleration:e=!0,allowTransformNone:n=!0},s,r){let o="";for(let i=0;i<QMe;i++){const a=W0[i];if(t[a]!==void 0){const u=YMe[a]||a;o+=`${u}(${t[a]}) `}}return e&&!t.z&&(o+="translateZ(0)"),o=o.trim(),r?o=r(t,s?"":o):n&&s&&(o="none"),o}const $6=t=>e=>typeof e=="string"&&e.startsWith(t),N6=$6("--"),U$=$6("var(--"),JMe=/var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g,eze=(t,e)=>e&&typeof t=="number"?e.transform(t):t,Rl=(t,e,n)=>Math.min(Math.max(n,t),e),Fh={test:t=>typeof t=="number",parse:parseFloat,transform:t=>t},xg={...Fh,transform:t=>Rl(0,1,t)},P1={...Fh,default:1},vg=t=>Math.round(t*1e5)/1e5,rC=/(-)?([\d]*\.?[\d])+/g,T6=/(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,tze=/^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;function U0(t){return typeof t=="string"}const G0=t=>({test:e=>U0(e)&&e.endsWith(t)&&e.split(" ").length===1,parse:parseFloat,transform:e=>`${e}${t}`}),Uu=G0("deg"),Sa=G0("%"),yt=G0("px"),nze=G0("vh"),sze=G0("vw"),TF={...Sa,parse:t=>Sa.parse(t)/100,transform:t=>Sa.transform(t*100)},EF={...Fh,transform:Math.round},E6={borderWidth:yt,borderTopWidth:yt,borderRightWidth:yt,borderBottomWidth:yt,borderLeftWidth:yt,borderRadius:yt,radius:yt,borderTopLeftRadius:yt,borderTopRightRadius:yt,borderBottomRightRadius:yt,borderBottomLeftRadius:yt,width:yt,maxWidth:yt,height:yt,maxHeight:yt,size:yt,top:yt,right:yt,bottom:yt,left:yt,padding:yt,paddingTop:yt,paddingRight:yt,paddingBottom:yt,paddingLeft:yt,margin:yt,marginTop:yt,marginRight:yt,marginBottom:yt,marginLeft:yt,rotate:Uu,rotateX:Uu,rotateY:Uu,rotateZ:Uu,scale:P1,scaleX:P1,scaleY:P1,scaleZ:P1,skew:Uu,skewX:Uu,skewY:Uu,distance:yt,translateX:yt,translateY:yt,translateZ:yt,x:yt,y:yt,z:yt,perspective:yt,transformPerspective:yt,opacity:xg,originX:TF,originY:TF,originZ:yt,zIndex:EF,fillOpacity:xg,strokeOpacity:xg,numOctaves:EF};function gR(t,e,n,s){const{style:r,vars:o,transform:i,transformOrigin:a}=t;let u=!1,l=!1,c=!0;for(const h in e){const d=e[h];if(N6(h)){o[h]=d;continue}const f=E6[h],m=eze(d,f);if(Ph.has(h)){if(u=!0,i[h]=m,!c)continue;d!==(f.default||0)&&(c=!1)}else h.startsWith("origin")?(l=!0,a[h]=m):r[h]=m}if(e.transform||(u||s?r.transform=ZMe(t.transform,n,c,s):r.transform&&(r.transform="none")),l){const{originX:h="50%",originY:d="50%",originZ:f=0}=a;r.transformOrigin=`${h} ${d} ${f}`}}const yR=()=>({style:{},transform:{},transformOrigin:{},vars:{}});function R6(t,e,n){for(const s in e)!ho(e[s])&&!I6(s,n)&&(t[s]=e[s])}function rze({transformTemplate:t},e,n){return fe.useMemo(()=>{const s=yR();return gR(s,e,{enableHardwareAcceleration:!n},t),Object.assign({},s.vars,s.style)},[e])}function oze(t,e,n){const s=t.style||{},r={};return R6(r,s,t),Object.assign(r,rze(t,e,n)),t.transformValues?t.transformValues(r):r}function ize(t,e,n){const s={},r=oze(t,e,n);return t.drag&&t.dragListener!==!1&&(s.draggable=!1,r.userSelect=r.WebkitUserSelect=r.WebkitTouchCallout="none",r.touchAction=t.drag===!0?"none":`pan-${t.drag==="x"?"y":"x"}`),t.tabIndex===void 0&&(t.onTap||t.onTapStart||t.whileTap)&&(s.tabIndex=0),s.style=r,s}const aze=new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","transformValues","custom","inherit","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","globalTapTarget","ignoreStrict","viewport"]);function pw(t){return t.startsWith("while")||t.startsWith("drag")&&t!=="draggable"||t.startsWith("layout")||t.startsWith("onTap")||t.startsWith("onPan")||t.startsWith("onLayout")||aze.has(t)}let A6=t=>!pw(t);function uze(t){t&&(A6=e=>e.startsWith("on")?!pw(e):t(e))}try{uze(require("@emotion/is-prop-valid").default)}catch{}function lze(t,e,n){const s={};for(const r in t)r==="values"&&typeof t.values=="object"||(A6(r)||n===!0&&pw(r)||!e&&!pw(r)||t.draggable&&r.startsWith("onDrag"))&&(s[r]=t[r]);return s}function RF(t,e,n){return typeof t=="string"?t:yt.transform(e+n*t)}function cze(t,e,n){const s=RF(e,t.x,t.width),r=RF(n,t.y,t.height);return`${s} ${r}`}const hze={offset:"stroke-dashoffset",array:"stroke-dasharray"},dze={offset:"strokeDashoffset",array:"strokeDasharray"};function pze(t,e,n=1,s=0,r=!0){t.pathLength=1;const o=r?hze:dze;t[o.offset]=yt.transform(-s);const i=yt.transform(e),a=yt.transform(n);t[o.array]=`${i} ${a}`}function xR(t,{attrX:e,attrY:n,attrScale:s,originX:r,originY:o,pathLength:i,pathSpacing:a=1,pathOffset:u=0,...l},c,h,d){if(gR(t,l,c,d),h){t.style.viewBox&&(t.attrs.viewBox=t.style.viewBox);return}t.attrs=t.style,t.style={};const{attrs:f,style:m,dimensions:y}=t;f.transform&&(y&&(m.transform=f.transform),delete f.transform),y&&(r!==void 0||o!==void 0||m.transform)&&(m.transformOrigin=cze(y,r!==void 0?r:.5,o!==void 0?o:.5)),e!==void 0&&(f.x=e),n!==void 0&&(f.y=n),s!==void 0&&(f.scale=s),i!==void 0&&pze(f,i,a,u,!1)}const _6=()=>({...yR(),attrs:{}}),vR=t=>typeof t=="string"&&t.toLowerCase()==="svg";function fze(t,e,n,s){const r=fe.useMemo(()=>{const o=_6();return xR(o,e,{enableHardwareAcceleration:!1},vR(s),t.transformTemplate),{...o.attrs,style:{...o.style}}},[e]);if(t.style){const o={};R6(o,t.style,t),r.style={...o,...r.style}}return r}function mze(t=!1){return(n,s,r,{latestValues:o},i)=>{const u=(mR(n)?fze:ize)(s,o,i,n),c={...lze(s,typeof n=="string",t),...u,ref:r},{children:h}=s,d=fe.useMemo(()=>ho(h)?h.get():h,[h]);return fe.createElement(n,{...c,children:d})}}function D6(t,{style:e,vars:n},s,r){Object.assign(t.style,e,r&&r.getProjectionStyles(s));for(const o in n)t.style.setProperty(o,n[o])}const P6=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function F6(t,e,n,s){D6(t,e,void 0,s);for(const r in e.attrs)t.setAttribute(P6.has(r)?r:dR(r),e.attrs[r])}function wR(t,e){const{style:n}=t,s={};for(const r in n)(ho(n[r])||e.style&&ho(e.style[r])||I6(r,t))&&(s[r]=n[r]);return s}function O6(t,e){const n=wR(t,e);for(const s in t)if(ho(t[s])||ho(e[s])){const r=W0.indexOf(s)!==-1?"attr"+s.charAt(0).toUpperCase()+s.substring(1):s;n[r]=t[s]}return n}function bR(t,e,n,s={},r={}){return typeof e=="function"&&(e=e(n!==void 0?n:t.custom,s,r)),typeof e=="string"&&(e=t.variants&&t.variants[e]),typeof e=="function"&&(e=e(n!==void 0?n:t.custom,s,r)),e}function gze(t){const e=fe.useRef(null);return e.current===null&&(e.current=t()),e.current}const fw=t=>Array.isArray(t),yze=t=>!!(t&&typeof t=="object"&&t.mix&&t.toValue),xze=t=>fw(t)?t[t.length-1]||0:t;function sv(t){const e=ho(t)?t.get():t;return yze(e)?e.toValue():e}function vze({scrapeMotionValuesFromProps:t,createRenderState:e,onMount:n},s,r,o){const i={latestValues:wze(s,r,o,t),renderState:e()};return n&&(i.mount=a=>n(s,a,i)),i}const L6=t=>(e,n)=>{const s=fe.useContext(eC),r=fe.useContext(hR),o=()=>vze(t,e,s,r);return n?o():gze(o)};function wze(t,e,n,s){const r={},o=s(t,{});for(const d in o)r[d]=sv(o[d]);let{initial:i,animate:a}=t;const u=sC(t),l=S6(t);e&&l&&!u&&t.inherit!==!1&&(i===void 0&&(i=e.initial),a===void 0&&(a=e.animate));let c=n?n.initial===!1:!1;c=c||i===!1;const h=c?a:i;return h&&typeof h!="boolean"&&!nC(h)&&(Array.isArray(h)?h:[h]).forEach(f=>{const m=bR(t,f);if(!m)return;const{transitionEnd:y,transition:x,...v}=m;for(const w in v){let S=v[w];if(Array.isArray(S)){const k=c?S.length-1:0;S=S[k]}S!==null&&(r[w]=S)}for(const w in y)r[w]=y[w]}),r}const Jn=t=>t;class AF{constructor(){this.order=[],this.scheduled=new Set}add(e){if(!this.scheduled.has(e))return this.scheduled.add(e),this.order.push(e),!0}remove(e){const n=this.order.indexOf(e);n!==-1&&(this.order.splice(n,1),this.scheduled.delete(e))}clear(){this.order.length=0,this.scheduled.clear()}}function bze(t){let e=new AF,n=new AF,s=0,r=!1,o=!1;const i=new WeakSet,a={schedule:(u,l=!1,c=!1)=>{const h=c&&r,d=h?e:n;return l&&i.add(u),d.add(u)&&h&&r&&(s=e.order.length),u},cancel:u=>{n.remove(u),i.delete(u)},process:u=>{if(r){o=!0;return}if(r=!0,[e,n]=[n,e],n.clear(),s=e.order.length,s)for(let l=0;l<s;l++){const c=e.order[l];c(u),i.has(c)&&(a.schedule(c),t())}r=!1,o&&(o=!1,a.process(u))}};return a}const F1=["prepare","read","update","preRender","render","postRender"],Sze=40;function Cze(t,e){let n=!1,s=!0;const r={delta:0,timestamp:0,isProcessing:!1},o=F1.reduce((h,d)=>(h[d]=bze(()=>n=!0),h),{}),i=h=>o[h].process(r),a=()=>{const h=performance.now();n=!1,r.delta=s?1e3/60:Math.max(Math.min(h-r.timestamp,Sze),1),r.timestamp=h,r.isProcessing=!0,F1.forEach(i),r.isProcessing=!1,n&&e&&(s=!1,t(a))},u=()=>{n=!0,s=!0,r.isProcessing||t(a)};return{schedule:F1.reduce((h,d)=>{const f=o[d];return h[d]=(m,y=!1,x=!1)=>(n||u(),f.schedule(m,y,x)),h},{}),cancel:h=>F1.forEach(d=>o[d].cancel(h)),state:r,steps:o}}const{schedule:An,cancel:wu,state:ur,steps:Tk}=Cze(typeof requestAnimationFrame<"u"?requestAnimationFrame:Jn,!0),kze={useVisualState:L6({scrapeMotionValuesFromProps:O6,createRenderState:_6,onMount:(t,e,{renderState:n,latestValues:s})=>{An.read(()=>{try{n.dimensions=typeof e.getBBox=="function"?e.getBBox():e.getBoundingClientRect()}catch{n.dimensions={x:0,y:0,width:0,height:0}}}),An.render(()=>{xR(n,s,{enableHardwareAcceleration:!1},vR(e.tagName),t.transformTemplate),F6(e,n)})}})},Ize={useVisualState:L6({scrapeMotionValuesFromProps:wR,createRenderState:yR})};function $ze(t,{forwardMotionProps:e=!1},n,s){return{...mR(t)?kze:Ize,preloadedFeatures:n,useRender:mze(e),createVisualElement:s,Component:t}}function su(t,e,n,s={passive:!0}){return t.addEventListener(e,n,s),()=>t.removeEventListener(e,n)}const M6=t=>t.pointerType==="mouse"?typeof t.button!="number"||t.button<=0:t.isPrimary!==!1;function oC(t,e="page"){return{point:{x:t[e+"X"],y:t[e+"Y"]}}}const Nze=t=>e=>M6(e)&&t(e,oC(e));function cu(t,e,n,s){return su(t,e,Nze(n),s)}const Tze=(t,e)=>n=>e(t(n)),fl=(...t)=>t.reduce(Tze);function z6(t){let e=null;return()=>{const n=()=>{e=null};return e===null?(e=t,n):!1}}const _F=z6("dragHorizontal"),DF=z6("dragVertical");function B6(t){let e=!1;if(t==="y")e=DF();else if(t==="x")e=_F();else{const n=_F(),s=DF();n&&s?e=()=>{n(),s()}:(n&&n(),s&&s())}return e}function V6(){const t=B6(!0);return t?(t(),!1):!0}class jl{constructor(e){this.isMounted=!1,this.node=e}update(){}}function PF(t,e){const n="pointer"+(e?"enter":"leave"),s="onHover"+(e?"Start":"End"),r=(o,i)=>{if(o.pointerType==="touch"||V6())return;const a=t.getProps();t.animationState&&a.whileHover&&t.animationState.setActive("whileHover",e),a[s]&&An.update(()=>a[s](o,i))};return cu(t.current,n,r,{passive:!t.getProps()[s]})}class Eze extends jl{mount(){this.unmount=fl(PF(this.node,!0),PF(this.node,!1))}unmount(){}}class Rze extends jl{constructor(){super(...arguments),this.isActive=!1}onFocus(){let e=!1;try{e=this.node.current.matches(":focus-visible")}catch{e=!0}!e||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){!this.isActive||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=fl(su(this.node.current,"focus",()=>this.onFocus()),su(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}const W6=(t,e)=>e?t===e?!0:W6(t,e.parentElement):!1;function Ek(t,e){if(!e)return;const n=new PointerEvent("pointer"+t);e(n,oC(n))}class Aze extends jl{constructor(){super(...arguments),this.removeStartListeners=Jn,this.removeEndListeners=Jn,this.removeAccessibleListeners=Jn,this.startPointerPress=(e,n)=>{if(this.isPressing)return;this.removeEndListeners();const s=this.node.getProps(),o=cu(window,"pointerup",(a,u)=>{if(!this.checkPressEnd())return;const{onTap:l,onTapCancel:c,globalTapTarget:h}=this.node.getProps();An.update(()=>{!h&&!W6(this.node.current,a.target)?c&&c(a,u):l&&l(a,u)})},{passive:!(s.onTap||s.onPointerUp)}),i=cu(window,"pointercancel",(a,u)=>this.cancelPress(a,u),{passive:!(s.onTapCancel||s.onPointerCancel)});this.removeEndListeners=fl(o,i),this.startPress(e,n)},this.startAccessiblePress=()=>{const e=o=>{if(o.key!=="Enter"||this.isPressing)return;const i=a=>{a.key!=="Enter"||!this.checkPressEnd()||Ek("up",(u,l)=>{const{onTap:c}=this.node.getProps();c&&An.update(()=>c(u,l))})};this.removeEndListeners(),this.removeEndListeners=su(this.node.current,"keyup",i),Ek("down",(a,u)=>{this.startPress(a,u)})},n=su(this.node.current,"keydown",e),s=()=>{this.isPressing&&Ek("cancel",(o,i)=>this.cancelPress(o,i))},r=su(this.node.current,"blur",s);this.removeAccessibleListeners=fl(n,r)}}startPress(e,n){this.isPressing=!0;const{onTapStart:s,whileTap:r}=this.node.getProps();r&&this.node.animationState&&this.node.animationState.setActive("whileTap",!0),s&&An.update(()=>s(e,n))}checkPressEnd(){return this.removeEndListeners(),this.isPressing=!1,this.node.getProps().whileTap&&this.node.animationState&&this.node.animationState.setActive("whileTap",!1),!V6()}cancelPress(e,n){if(!this.checkPressEnd())return;const{onTapCancel:s}=this.node.getProps();s&&An.update(()=>s(e,n))}mount(){const e=this.node.getProps(),n=cu(e.globalTapTarget?window:this.node.current,"pointerdown",this.startPointerPress,{passive:!(e.onTapStart||e.onPointerStart)}),s=su(this.node.current,"focus",this.startAccessiblePress);this.removeStartListeners=fl(n,s)}unmount(){this.removeStartListeners(),this.removeEndListeners(),this.removeAccessibleListeners()}}const G$=new WeakMap,Rk=new WeakMap,_ze=t=>{const e=G$.get(t.target);e&&e(t)},Dze=t=>{t.forEach(_ze)};function Pze({root:t,...e}){const n=t||document;Rk.has(n)||Rk.set(n,{});const s=Rk.get(n),r=JSON.stringify(e);return s[r]||(s[r]=new IntersectionObserver(Dze,{root:t,...e})),s[r]}function Fze(t,e,n){const s=Pze(e);return G$.set(t,n),s.observe(t),()=>{G$.delete(t),s.unobserve(t)}}const Oze={some:0,all:1};class Lze extends jl{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport:e={}}=this.node.getProps(),{root:n,margin:s,amount:r="some",once:o}=e,i={root:n?n.current:void 0,rootMargin:s,threshold:typeof r=="number"?r:Oze[r]},a=u=>{const{isIntersecting:l}=u;if(this.isInView===l||(this.isInView=l,o&&!l&&this.hasEnteredView))return;l&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",l);const{onViewportEnter:c,onViewportLeave:h}=this.node.getProps(),d=l?c:h;d&&d(u)};return Fze(this.node.current,i,a)}mount(){this.startObserver()}update(){if(typeof IntersectionObserver>"u")return;const{props:e,prevProps:n}=this.node;["amount","margin","root"].some(Mze(e,n))&&this.startObserver()}unmount(){}}function Mze({viewport:t={}},{viewport:e={}}={}){return n=>t[n]!==e[n]}const zze={inView:{Feature:Lze},tap:{Feature:Aze},focus:{Feature:Rze},hover:{Feature:Eze}};function U6(t,e){if(!Array.isArray(e))return!1;const n=e.length;if(n!==t.length)return!1;for(let s=0;s<n;s++)if(e[s]!==t[s])return!1;return!0}function Bze(t){const e={};return t.values.forEach((n,s)=>e[s]=n.get()),e}function Vze(t){const e={};return t.values.forEach((n,s)=>e[s]=n.getVelocity()),e}function iC(t,e,n){const s=t.getProps();return bR(s,e,n!==void 0?n:s.custom,Bze(t),Vze(t))}let Wze=Jn,SR=Jn;const ml=t=>t*1e3,hu=t=>t/1e3,Uze={current:!1},G6=t=>Array.isArray(t)&&typeof t[0]=="number";function H6(t){return!!(!t||typeof t=="string"&&j6[t]||G6(t)||Array.isArray(t)&&t.every(H6))}const og=([t,e,n,s])=>`cubic-bezier(${t}, ${e}, ${n}, ${s})`,j6={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:og([0,.65,.55,1]),circOut:og([.55,0,1,.45]),backIn:og([.31,.01,.66,-.59]),backOut:og([.33,1.53,.69,.99])};function K6(t){if(t)return G6(t)?og(t):Array.isArray(t)?t.map(K6):j6[t]}function Gze(t,e,n,{delay:s=0,duration:r,repeat:o=0,repeatType:i="loop",ease:a,times:u}={}){const l={[e]:n};u&&(l.offset=u);const c=K6(a);return Array.isArray(c)&&(l.easing=c),t.animate(l,{delay:s,duration:r,easing:Array.isArray(c)?"linear":c,fill:"both",iterations:o+1,direction:i==="reverse"?"alternate":"normal"})}function Hze(t,{repeat:e,repeatType:n="loop"}){const s=e&&n!=="loop"&&e%2===1?0:t.length-1;return t[s]}const X6=(t,e,n)=>(((1-3*n+3*e)*t+(3*n-6*e))*t+3*e)*t,jze=1e-7,Kze=12;function Xze(t,e,n,s,r){let o,i,a=0;do i=e+(n-e)/2,o=X6(i,s,r)-t,o>0?n=i:e=i;while(Math.abs(o)>jze&&++a<Kze);return i}function H0(t,e,n,s){if(t===e&&n===s)return Jn;const r=o=>Xze(o,0,1,t,n);return o=>o===0||o===1?o:X6(r(o),e,s)}const qze=H0(.42,0,1,1),Yze=H0(0,0,.58,1),q6=H0(.42,0,.58,1),Qze=t=>Array.isArray(t)&&typeof t[0]!="number",Y6=t=>e=>e<=.5?t(2*e)/2:(2-t(2*(1-e)))/2,Q6=t=>e=>1-t(1-e),CR=t=>1-Math.sin(Math.acos(t)),Z6=Q6(CR),Zze=Y6(CR),J6=H0(.33,1.53,.69,.99),kR=Q6(J6),Jze=Y6(kR),eBe=t=>(t*=2)<1?.5*kR(t):.5*(2-Math.pow(2,-10*(t-1))),tBe={linear:Jn,easeIn:qze,easeInOut:q6,easeOut:Yze,circIn:CR,circInOut:Zze,circOut:Z6,backIn:kR,backInOut:Jze,backOut:J6,anticipate:eBe},FF=t=>{if(Array.isArray(t)){SR(t.length===4);const[e,n,s,r]=t;return H0(e,n,s,r)}else if(typeof t=="string")return tBe[t];return t},IR=(t,e)=>n=>!!(U0(n)&&tze.test(n)&&n.startsWith(t)||e&&Object.prototype.hasOwnProperty.call(n,e)),ej=(t,e,n)=>s=>{if(!U0(s))return s;const[r,o,i,a]=s.match(rC);return{[t]:parseFloat(r),[e]:parseFloat(o),[n]:parseFloat(i),alpha:a!==void 0?parseFloat(a):1}},nBe=t=>Rl(0,255,t),Ak={...Fh,transform:t=>Math.round(nBe(t))},Mc={test:IR("rgb","red"),parse:ej("red","green","blue"),transform:({red:t,green:e,blue:n,alpha:s=1})=>"rgba("+Ak.transform(t)+", "+Ak.transform(e)+", "+Ak.transform(n)+", "+vg(xg.transform(s))+")"};function sBe(t){let e="",n="",s="",r="";return t.length>5?(e=t.substring(1,3),n=t.substring(3,5),s=t.substring(5,7),r=t.substring(7,9)):(e=t.substring(1,2),n=t.substring(2,3),s=t.substring(3,4),r=t.substring(4,5),e+=e,n+=n,s+=s,r+=r),{red:parseInt(e,16),green:parseInt(n,16),blue:parseInt(s,16),alpha:r?parseInt(r,16)/255:1}}const H$={test:IR("#"),parse:sBe,transform:Mc.transform},Fd={test:IR("hsl","hue"),parse:ej("hue","saturation","lightness"),transform:({hue:t,saturation:e,lightness:n,alpha:s=1})=>"hsla("+Math.round(t)+", "+Sa.transform(vg(e))+", "+Sa.transform(vg(n))+", "+vg(xg.transform(s))+")"},$r={test:t=>Mc.test(t)||H$.test(t)||Fd.test(t),parse:t=>Mc.test(t)?Mc.parse(t):Fd.test(t)?Fd.parse(t):H$.parse(t),transform:t=>U0(t)?t:t.hasOwnProperty("red")?Mc.transform(t):Fd.transform(t)},Gn=(t,e,n)=>-n*t+n*e+t;function _k(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+(e-t)*6*n:n<1/2?e:n<2/3?t+(e-t)*(2/3-n)*6:t}function rBe({hue:t,saturation:e,lightness:n,alpha:s}){t/=360,e/=100,n/=100;let r=0,o=0,i=0;if(!e)r=o=i=n;else{const a=n<.5?n*(1+e):n+e-n*e,u=2*n-a;r=_k(u,a,t+1/3),o=_k(u,a,t),i=_k(u,a,t-1/3)}return{red:Math.round(r*255),green:Math.round(o*255),blue:Math.round(i*255),alpha:s}}const Dk=(t,e,n)=>{const s=t*t;return Math.sqrt(Math.max(0,n*(e*e-s)+s))},oBe=[H$,Mc,Fd],iBe=t=>oBe.find(e=>e.test(t));function OF(t){const e=iBe(t);let n=e.parse(t);return e===Fd&&(n=rBe(n)),n}const tj=(t,e)=>{const n=OF(t),s=OF(e),r={...n};return o=>(r.red=Dk(n.red,s.red,o),r.green=Dk(n.green,s.green,o),r.blue=Dk(n.blue,s.blue,o),r.alpha=Gn(n.alpha,s.alpha,o),Mc.transform(r))};function aBe(t){var e,n;return isNaN(t)&&U0(t)&&(((e=t.match(rC))===null||e===void 0?void 0:e.length)||0)+(((n=t.match(T6))===null||n===void 0?void 0:n.length)||0)>0}const nj={regex:JMe,countKey:"Vars",token:"${v}",parse:Jn},sj={regex:T6,countKey:"Colors",token:"${c}",parse:$r.parse},rj={regex:rC,countKey:"Numbers",token:"${n}",parse:Fh.parse};function Pk(t,{regex:e,countKey:n,token:s,parse:r}){const o=t.tokenised.match(e);o&&(t["num"+n]=o.length,t.tokenised=t.tokenised.replace(e,s),t.values.push(...o.map(r)))}function mw(t){const e=t.toString(),n={value:e,tokenised:e,values:[],numVars:0,numColors:0,numNumbers:0};return n.value.includes("var(--")&&Pk(n,nj),Pk(n,sj),Pk(n,rj),n}function oj(t){return mw(t).values}function ij(t){const{values:e,numColors:n,numVars:s,tokenised:r}=mw(t),o=e.length;return i=>{let a=r;for(let u=0;u<o;u++)u<s?a=a.replace(nj.token,i[u]):u<s+n?a=a.replace(sj.token,$r.transform(i[u])):a=a.replace(rj.token,vg(i[u]));return a}}const uBe=t=>typeof t=="number"?0:t;function lBe(t){const e=oj(t);return ij(t)(e.map(uBe))}const Al={test:aBe,parse:oj,createTransformer:ij,getAnimatableNone:lBe},aj=(t,e)=>n=>`${n>0?e:t}`;function uj(t,e){return typeof t=="number"?n=>Gn(t,e,n):$r.test(t)?tj(t,e):t.startsWith("var(")?aj(t,e):cj(t,e)}const lj=(t,e)=>{const n=[...t],s=n.length,r=t.map((o,i)=>uj(o,e[i]));return o=>{for(let i=0;i<s;i++)n[i]=r[i](o);return n}},cBe=(t,e)=>{const n={...t,...e},s={};for(const r in n)t[r]!==void 0&&e[r]!==void 0&&(s[r]=uj(t[r],e[r]));return r=>{for(const o in s)n[o]=s[o](r);return n}},cj=(t,e)=>{const n=Al.createTransformer(e),s=mw(t),r=mw(e);return s.numVars===r.numVars&&s.numColors===r.numColors&&s.numNumbers>=r.numNumbers?fl(lj(s.values,r.values),n):aj(t,e)},cy=(t,e,n)=>{const s=e-t;return s===0?1:(n-t)/s},LF=(t,e)=>n=>Gn(t,e,n);function hBe(t){return typeof t=="number"?LF:typeof t=="string"?$r.test(t)?tj:cj:Array.isArray(t)?lj:typeof t=="object"?cBe:LF}function dBe(t,e,n){const s=[],r=n||hBe(t[0]),o=t.length-1;for(let i=0;i<o;i++){let a=r(t[i],t[i+1]);if(e){const u=Array.isArray(e)?e[i]||Jn:e;a=fl(u,a)}s.push(a)}return s}function hj(t,e,{clamp:n=!0,ease:s,mixer:r}={}){const o=t.length;if(SR(o===e.length),o===1)return()=>e[0];t[0]>t[o-1]&&(t=[...t].reverse(),e=[...e].reverse());const i=dBe(e,s,r),a=i.length,u=l=>{let c=0;if(a>1)for(;c<t.length-2&&!(l<t[c+1]);c++);const h=cy(t[c],t[c+1],l);return i[c](h)};return n?l=>u(Rl(t[0],t[o-1],l)):u}function pBe(t,e){const n=t[t.length-1];for(let s=1;s<=e;s++){const r=cy(0,e,s);t.push(Gn(n,1,r))}}function fBe(t){const e=[0];return pBe(e,t.length-1),e}function mBe(t,e){return t.map(n=>n*e)}function gBe(t,e){return t.map(()=>e||q6).splice(0,t.length-1)}function gw({duration:t=300,keyframes:e,times:n,ease:s="easeInOut"}){const r=Qze(s)?s.map(FF):FF(s),o={done:!1,value:e[0]},i=mBe(n&&n.length===e.length?n:fBe(e),t),a=hj(i,e,{ease:Array.isArray(r)?r:gBe(e,r)});return{calculatedDuration:t,next:u=>(o.value=a(u),o.done=u>=t,o)}}function dj(t,e){return e?t*(1e3/e):0}const yBe=5;function pj(t,e,n){const s=Math.max(e-yBe,0);return dj(n-t(s),e-s)}const Fk=.001,xBe=.01,MF=10,vBe=.05,wBe=1;function bBe({duration:t=800,bounce:e=.25,velocity:n=0,mass:s=1}){let r,o;Wze(t<=ml(MF));let i=1-e;i=Rl(vBe,wBe,i),t=Rl(xBe,MF,hu(t)),i<1?(r=l=>{const c=l*i,h=c*t,d=c-n,f=j$(l,i),m=Math.exp(-h);return Fk-d/f*m},o=l=>{const h=l*i*t,d=h*n+n,f=Math.pow(i,2)*Math.pow(l,2)*t,m=Math.exp(-h),y=j$(Math.pow(l,2),i);return(-r(l)+Fk>0?-1:1)*((d-f)*m)/y}):(r=l=>{const c=Math.exp(-l*t),h=(l-n)*t+1;return-Fk+c*h},o=l=>{const c=Math.exp(-l*t),h=(n-l)*(t*t);return c*h});const a=5/t,u=CBe(r,o,a);if(t=ml(t),isNaN(u))return{stiffness:100,damping:10,duration:t};{const l=Math.pow(u,2)*s;return{stiffness:l,damping:i*2*Math.sqrt(s*l),duration:t}}}const SBe=12;function CBe(t,e,n){let s=n;for(let r=1;r<SBe;r++)s=s-t(s)/e(s);return s}function j$(t,e){return t*Math.sqrt(1-e*e)}const kBe=["duration","bounce"],IBe=["stiffness","damping","mass"];function zF(t,e){return e.some(n=>t[n]!==void 0)}function $Be(t){let e={velocity:0,stiffness:100,damping:10,mass:1,isResolvedFromDuration:!1,...t};if(!zF(t,IBe)&&zF(t,kBe)){const n=bBe(t);e={...e,...n,mass:1},e.isResolvedFromDuration=!0}return e}function fj({keyframes:t,restDelta:e,restSpeed:n,...s}){const r=t[0],o=t[t.length-1],i={done:!1,value:r},{stiffness:a,damping:u,mass:l,duration:c,velocity:h,isResolvedFromDuration:d}=$Be({...s,velocity:-hu(s.velocity||0)}),f=h||0,m=u/(2*Math.sqrt(a*l)),y=o-r,x=hu(Math.sqrt(a/l)),v=Math.abs(y)<5;n||(n=v?.01:2),e||(e=v?.005:.5);let w;if(m<1){const S=j$(x,m);w=k=>{const I=Math.exp(-m*x*k);return o-I*((f+m*x*y)/S*Math.sin(S*k)+y*Math.cos(S*k))}}else if(m===1)w=S=>o-Math.exp(-x*S)*(y+(f+x*y)*S);else{const S=x*Math.sqrt(m*m-1);w=k=>{const I=Math.exp(-m*x*k),T=Math.min(S*k,300);return o-I*((f+m*x*y)*Math.sinh(T)+S*y*Math.cosh(T))/S}}return{calculatedDuration:d&&c||null,next:S=>{const k=w(S);if(d)i.done=S>=c;else{let I=f;S!==0&&(m<1?I=pj(w,S,k):I=0);const T=Math.abs(I)<=n,R=Math.abs(o-k)<=e;i.done=T&&R}return i.value=i.done?o:k,i}}}function BF({keyframes:t,velocity:e=0,power:n=.8,timeConstant:s=325,bounceDamping:r=10,bounceStiffness:o=500,modifyTarget:i,min:a,max:u,restDelta:l=.5,restSpeed:c}){const h=t[0],d={done:!1,value:h},f=_=>a!==void 0&&_<a||u!==void 0&&_>u,m=_=>a===void 0?u:u===void 0||Math.abs(a-_)<Math.abs(u-_)?a:u;let y=n*e;const x=h+y,v=i===void 0?x:i(x);v!==x&&(y=v-h);const w=_=>-y*Math.exp(-_/s),S=_=>v+w(_),k=_=>{const D=w(_),L=S(_);d.done=Math.abs(D)<=l,d.value=d.done?v:L};let I,T;const R=_=>{f(d.value)&&(I=_,T=fj({keyframes:[d.value,m(d.value)],velocity:pj(S,_,d.value),damping:r,stiffness:o,restDelta:l,restSpeed:c}))};return R(0),{calculatedDuration:null,next:_=>{let D=!1;return!T&&I===void 0&&(D=!0,k(_),R(_)),I!==void 0&&_>I?T.next(_-I):(!D&&k(_),d)}}}const NBe=t=>{const e=({timestamp:n})=>t(n);return{start:()=>An.update(e,!0),stop:()=>wu(e),now:()=>ur.isProcessing?ur.timestamp:performance.now()}},VF=2e4;function WF(t){let e=0;const n=50;let s=t.next(e);for(;!s.done&&e<VF;)e+=n,s=t.next(e);return e>=VF?1/0:e}const TBe={decay:BF,inertia:BF,tween:gw,keyframes:gw,spring:fj};function yw({autoplay:t=!0,delay:e=0,driver:n=NBe,keyframes:s,type:r="keyframes",repeat:o=0,repeatDelay:i=0,repeatType:a="loop",onPlay:u,onStop:l,onComplete:c,onUpdate:h,...d}){let f=1,m=!1,y,x;const v=()=>{x=new Promise(he=>{y=he})};v();let w;const S=TBe[r]||gw;let k;S!==gw&&typeof s[0]!="number"&&(k=hj([0,100],s,{clamp:!1}),s=[0,100]);const I=S({...d,keyframes:s});let T;a==="mirror"&&(T=S({...d,keyframes:[...s].reverse(),velocity:-(d.velocity||0)}));let R="idle",_=null,D=null,L=null;I.calculatedDuration===null&&o&&(I.calculatedDuration=WF(I));const{calculatedDuration:V}=I;let U=1/0,j=1/0;V!==null&&(U=V+i,j=U*(o+1)-i);let q=0;const J=he=>{if(D===null)return;f>0&&(D=Math.min(D,he)),f<0&&(D=Math.min(he-j/f,D)),_!==null?q=_:q=Math.round(he-D)*f;const xe=q-e*(f>=0?1:-1),Ce=f>=0?xe<0:xe>j;q=Math.max(xe,0),R==="finished"&&_===null&&(q=j);let Ee=q,Ie=I;if(o){const je=Math.min(q,j)/U;let rt=Math.floor(je),tt=je%1;!tt&&je>=1&&(tt=1),tt===1&&rt--,rt=Math.min(rt,o+1),!!(rt%2)&&(a==="reverse"?(tt=1-tt,i&&(tt-=i/U)):a==="mirror"&&(Ie=T)),Ee=Rl(0,1,tt)*U}const ke=Ce?{done:!1,value:s[0]}:Ie.next(Ee);k&&(ke.value=k(ke.value));let{done:Ae}=ke;!Ce&&V!==null&&(Ae=f>=0?q>=j:q<=0);const Ke=_===null&&(R==="finished"||R==="running"&&Ae);return h&&h(ke.value),Ke&&K(),ke},te=()=>{w&&w.stop(),w=void 0},le=()=>{R="idle",te(),y(),v(),D=L=null},K=()=>{R="finished",c&&c(),te(),y()},re=()=>{if(m)return;w||(w=n(J));const he=w.now();u&&u(),_!==null?D=he-_:(!D||R==="finished")&&(D=he),R==="finished"&&v(),L=D,_=null,R="running",w.start()};t&&re();const pe={then(he,xe){return x.then(he,xe)},get time(){return hu(q)},set time(he){he=ml(he),q=he,_!==null||!w||f===0?_=he:D=w.now()-he/f},get duration(){const he=I.calculatedDuration===null?WF(I):I.calculatedDuration;return hu(he)},get speed(){return f},set speed(he){he===f||!w||(f=he,pe.time=hu(q))},get state(){return R},play:re,pause:()=>{R="paused",_=q},stop:()=>{m=!0,R!=="idle"&&(R="idle",l&&l(),le())},cancel:()=>{L!==null&&J(L),le()},complete:()=>{R="finished"},sample:he=>(D=0,J(he))};return pe}function EBe(t){let e;return()=>(e===void 0&&(e=t()),e)}const RBe=EBe(()=>Object.hasOwnProperty.call(Element.prototype,"animate")),ABe=new Set(["opacity","clipPath","filter","transform","backgroundColor"]),O1=10,_Be=2e4,DBe=(t,e)=>e.type==="spring"||t==="backgroundColor"||!H6(e.ease);function PBe(t,e,{onUpdate:n,onComplete:s,...r}){if(!(RBe()&&ABe.has(e)&&!r.repeatDelay&&r.repeatType!=="mirror"&&r.damping!==0&&r.type!=="inertia"))return!1;let i=!1,a,u,l=!1;const c=()=>{u=new Promise(S=>{a=S})};c();let{keyframes:h,duration:d=300,ease:f,times:m}=r;if(DBe(e,r)){const S=yw({...r,repeat:0,delay:0});let k={done:!1,value:h[0]};const I=[];let T=0;for(;!k.done&&T<_Be;)k=S.sample(T),I.push(k.value),T+=O1;m=void 0,h=I,d=T-O1,f="linear"}const y=Gze(t.owner.current,e,h,{...r,duration:d,ease:f,times:m}),x=()=>{l=!1,y.cancel()},v=()=>{l=!0,An.update(x),a(),c()};return y.onfinish=()=>{l||(t.set(Hze(h,r)),s&&s(),v())},{then(S,k){return u.then(S,k)},attachTimeline(S){return y.timeline=S,y.onfinish=null,Jn},get time(){return hu(y.currentTime||0)},set time(S){y.currentTime=ml(S)},get speed(){return y.playbackRate},set speed(S){y.playbackRate=S},get duration(){return hu(d)},play:()=>{i||(y.play(),wu(x))},pause:()=>y.pause(),stop:()=>{if(i=!0,y.playState==="idle")return;const{currentTime:S}=y;if(S){const k=yw({...r,autoplay:!1});t.setWithVelocity(k.sample(S-O1).value,k.sample(S).value,O1)}v()},complete:()=>{l||y.finish()},cancel:v}}function FBe({keyframes:t,delay:e,onUpdate:n,onComplete:s}){const r=()=>(n&&n(t[t.length-1]),s&&s(),{time:0,speed:1,duration:0,play:Jn,pause:Jn,stop:Jn,then:o=>(o(),Promise.resolve()),cancel:Jn,complete:Jn});return e?yw({keyframes:[0,1],duration:0,delay:e,onComplete:r}):r()}const OBe={type:"spring",stiffness:500,damping:25,restSpeed:10},LBe=t=>({type:"spring",stiffness:550,damping:t===0?2*Math.sqrt(550):30,restSpeed:10}),MBe={type:"keyframes",duration:.8},zBe={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},BBe=(t,{keyframes:e})=>e.length>2?MBe:Ph.has(t)?t.startsWith("scale")?LBe(e[1]):OBe:zBe,K$=(t,e)=>t==="zIndex"?!1:!!(typeof e=="number"||Array.isArray(e)||typeof e=="string"&&(Al.test(e)||e==="0")&&!e.startsWith("url(")),VBe=new Set(["brightness","contrast","saturate","opacity"]);function WBe(t){const[e,n]=t.slice(0,-1).split("(");if(e==="drop-shadow")return t;const[s]=n.match(rC)||[];if(!s)return t;const r=n.replace(s,"");let o=VBe.has(e)?1:0;return s!==n&&(o*=100),e+"("+o+r+")"}const UBe=/([a-z-]*)\(.*?\)/g,X$={...Al,getAnimatableNone:t=>{const e=t.match(UBe);return e?e.map(WBe).join(" "):t}},GBe={...E6,color:$r,backgroundColor:$r,outlineColor:$r,fill:$r,stroke:$r,borderColor:$r,borderTopColor:$r,borderRightColor:$r,borderBottomColor:$r,borderLeftColor:$r,filter:X$,WebkitFilter:X$},$R=t=>GBe[t];function mj(t,e){let n=$R(t);return n!==X$&&(n=Al),n.getAnimatableNone?n.getAnimatableNone(e):void 0}const gj=t=>/^0[^.\s]+$/.test(t);function HBe(t){if(typeof t=="number")return t===0;if(t!==null)return t==="none"||t==="0"||gj(t)}function jBe(t,e,n,s){const r=K$(e,n);let o;Array.isArray(n)?o=[...n]:o=[null,n];const i=s.from!==void 0?s.from:t.get();let a;const u=[];for(let l=0;l<o.length;l++)o[l]===null&&(o[l]=l===0?i:o[l-1]),HBe(o[l])&&u.push(l),typeof o[l]=="string"&&o[l]!=="none"&&o[l]!=="0"&&(a=o[l]);if(r&&u.length&&a)for(let l=0;l<u.length;l++){const c=u[l];o[c]=mj(e,a)}return o}function KBe({when:t,delay:e,delayChildren:n,staggerChildren:s,staggerDirection:r,repeat:o,repeatType:i,repeatDelay:a,from:u,elapsed:l,...c}){return!!Object.keys(c).length}function NR(t,e){return t[e]||t.default||t}const XBe={skipAnimations:!1},TR=(t,e,n,s={})=>r=>{const o=NR(s,t)||{},i=o.delay||s.delay||0;let{elapsed:a=0}=s;a=a-ml(i);const u=jBe(e,t,n,o),l=u[0],c=u[u.length-1],h=K$(t,l),d=K$(t,c);let f={keyframes:u,velocity:e.getVelocity(),ease:"easeOut",...o,delay:-a,onUpdate:m=>{e.set(m),o.onUpdate&&o.onUpdate(m)},onComplete:()=>{r(),o.onComplete&&o.onComplete()}};if(KBe(o)||(f={...f,...BBe(t,f)}),f.duration&&(f.duration=ml(f.duration)),f.repeatDelay&&(f.repeatDelay=ml(f.repeatDelay)),!h||!d||Uze.current||o.type===!1||XBe.skipAnimations)return FBe(f);if(!s.isHandoff&&e.owner&&e.owner.current instanceof HTMLElement&&!e.owner.getProps().onUpdate){const m=PBe(e,t,f);if(m)return m}return yw(f)};function xw(t){return!!(ho(t)&&t.add)}const yj=t=>/^\-?\d*\.?\d+$/.test(t);function ER(t,e){t.indexOf(e)===-1&&t.push(e)}function RR(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}class AR{constructor(){this.subscriptions=[]}add(e){return ER(this.subscriptions,e),()=>RR(this.subscriptions,e)}notify(e,n,s){const r=this.subscriptions.length;if(r)if(r===1)this.subscriptions[0](e,n,s);else for(let o=0;o<r;o++){const i=this.subscriptions[o];i&&i(e,n,s)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}const qBe=t=>!isNaN(parseFloat(t));class YBe{constructor(e,n={}){this.version="10.18.0",this.timeDelta=0,this.lastUpdated=0,this.canTrackVelocity=!1,this.events={},this.updateAndNotify=(s,r=!0)=>{this.prev=this.current,this.current=s;const{delta:o,timestamp:i}=ur;this.lastUpdated!==i&&(this.timeDelta=o,this.lastUpdated=i,An.postRender(this.scheduleVelocityCheck)),this.prev!==this.current&&this.events.change&&this.events.change.notify(this.current),this.events.velocityChange&&this.events.velocityChange.notify(this.getVelocity()),r&&this.events.renderRequest&&this.events.renderRequest.notify(this.current)},this.scheduleVelocityCheck=()=>An.postRender(this.velocityCheck),this.velocityCheck=({timestamp:s})=>{s!==this.lastUpdated&&(this.prev=this.current,this.events.velocityChange&&this.events.velocityChange.notify(this.getVelocity()))},this.hasAnimated=!1,this.prev=this.current=e,this.canTrackVelocity=qBe(this.current),this.owner=n.owner}onChange(e){return this.on("change",e)}on(e,n){this.events[e]||(this.events[e]=new AR);const s=this.events[e].add(n);return e==="change"?()=>{s(),An.read(()=>{this.events.change.getSize()||this.stop()})}:s}clearListeners(){for(const e in this.events)this.events[e].clear()}attach(e,n){this.passiveEffect=e,this.stopPassiveEffect=n}set(e,n=!0){!n||!this.passiveEffect?this.updateAndNotify(e,n):this.passiveEffect(e,this.updateAndNotify)}setWithVelocity(e,n,s){this.set(n),this.prev=e,this.timeDelta=s}jump(e){this.updateAndNotify(e),this.prev=e,this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}get(){return this.current}getPrevious(){return this.prev}getVelocity(){return this.canTrackVelocity?dj(parseFloat(this.current)-parseFloat(this.prev),this.timeDelta):0}start(e){return this.stop(),new Promise(n=>{this.hasAnimated=!0,this.animation=e(n),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function bp(t,e){return new YBe(t,e)}const xj=t=>e=>e.test(t),QBe={test:t=>t==="auto",parse:t=>t},vj=[Fh,yt,Sa,Uu,sze,nze,QBe],jm=t=>vj.find(xj(t)),ZBe=[...vj,$r,Al],JBe=t=>ZBe.find(xj(t));function eVe(t,e,n){t.hasValue(e)?t.getValue(e).set(n):t.addValue(e,bp(n))}function tVe(t,e){const n=iC(t,e);let{transitionEnd:s={},transition:r={},...o}=n?t.makeTargetAnimatable(n,!1):{};o={...o,...s};for(const i in o){const a=xze(o[i]);eVe(t,i,a)}}function nVe(t,e,n){var s,r;const o=Object.keys(e).filter(a=>!t.hasValue(a)),i=o.length;if(i)for(let a=0;a<i;a++){const u=o[a],l=e[u];let c=null;Array.isArray(l)&&(c=l[0]),c===null&&(c=(r=(s=n[u])!==null&&s!==void 0?s:t.readValue(u))!==null&&r!==void 0?r:e[u]),c!=null&&(typeof c=="string"&&(yj(c)||gj(c))?c=parseFloat(c):!JBe(c)&&Al.test(l)&&(c=mj(u,l)),t.addValue(u,bp(c,{owner:t})),n[u]===void 0&&(n[u]=c),c!==null&&t.setBaseTarget(u,c))}}function sVe(t,e){return e?(e[t]||e.default||e).from:void 0}function rVe(t,e,n){const s={};for(const r in t){const o=sVe(r,e);if(o!==void 0)s[r]=o;else{const i=n.getValue(r);i&&(s[r]=i.get())}}return s}function oVe({protectedKeys:t,needsAnimating:e},n){const s=t.hasOwnProperty(n)&&e[n]!==!0;return e[n]=!1,s}function iVe(t,e){const n=t.get();if(Array.isArray(e)){for(let s=0;s<e.length;s++)if(e[s]!==n)return!0}else return n!==e}function wj(t,e,{delay:n=0,transitionOverride:s,type:r}={}){let{transition:o=t.getDefaultTransition(),transitionEnd:i,...a}=t.makeTargetAnimatable(e);const u=t.getValue("willChange");s&&(o=s);const l=[],c=r&&t.animationState&&t.animationState.getState()[r];for(const h in a){const d=t.getValue(h),f=a[h];if(!d||f===void 0||c&&oVe(c,h))continue;const m={delay:n,elapsed:0,...NR(o||{},h)};if(window.HandoffAppearAnimations){const v=t.getProps()[b6];if(v){const w=window.HandoffAppearAnimations(v,h,d,An);w!==null&&(m.elapsed=w,m.isHandoff=!0)}}let y=!m.isHandoff&&!iVe(d,f);if(m.type==="spring"&&(d.getVelocity()||m.velocity)&&(y=!1),d.animation&&(y=!1),y)continue;d.start(TR(h,d,f,t.shouldReduceMotion&&Ph.has(h)?{type:!1}:m));const x=d.animation;xw(u)&&(u.add(h),x.then(()=>u.remove(h))),l.push(x)}return i&&Promise.all(l).then(()=>{i&&tVe(t,i)}),l}function q$(t,e,n={}){const s=iC(t,e,n.custom);let{transition:r=t.getDefaultTransition()||{}}=s||{};n.transitionOverride&&(r=n.transitionOverride);const o=s?()=>Promise.all(wj(t,s,n)):()=>Promise.resolve(),i=t.variantChildren&&t.variantChildren.size?(u=0)=>{const{delayChildren:l=0,staggerChildren:c,staggerDirection:h}=r;return aVe(t,e,l+u,c,h,n)}:()=>Promise.resolve(),{when:a}=r;if(a){const[u,l]=a==="beforeChildren"?[o,i]:[i,o];return u().then(()=>l())}else return Promise.all([o(),i(n.delay)])}function aVe(t,e,n=0,s=0,r=1,o){const i=[],a=(t.variantChildren.size-1)*s,u=r===1?(l=0)=>l*s:(l=0)=>a-l*s;return Array.from(t.variantChildren).sort(uVe).forEach((l,c)=>{l.notify("AnimationStart",e),i.push(q$(l,e,{...o,delay:n+u(c)}).then(()=>l.notify("AnimationComplete",e)))}),Promise.all(i)}function uVe(t,e){return t.sortNodePosition(e)}function lVe(t,e,n={}){t.notify("AnimationStart",e);let s;if(Array.isArray(e)){const r=e.map(o=>q$(t,o,n));s=Promise.all(r)}else if(typeof e=="string")s=q$(t,e,n);else{const r=typeof e=="function"?iC(t,e,n.custom):e;s=Promise.all(wj(t,r,n))}return s.then(()=>t.notify("AnimationComplete",e))}const cVe=[...pR].reverse(),hVe=pR.length;function dVe(t){return e=>Promise.all(e.map(({animation:n,options:s})=>lVe(t,n,s)))}function pVe(t){let e=dVe(t);const n=mVe();let s=!0;const r=(u,l)=>{const c=iC(t,l);if(c){const{transition:h,transitionEnd:d,...f}=c;u={...u,...f,...d}}return u};function o(u){e=u(t)}function i(u,l){const c=t.getProps(),h=t.getVariantContext(!0)||{},d=[],f=new Set;let m={},y=1/0;for(let v=0;v<hVe;v++){const w=cVe[v],S=n[w],k=c[w]!==void 0?c[w]:h[w],I=uy(k),T=w===l?S.isActive:null;T===!1&&(y=v);let R=k===h[w]&&k!==c[w]&&I;if(R&&s&&t.manuallyAnimateOnMount&&(R=!1),S.protectedKeys={...m},!S.isActive&&T===null||!k&&!S.prevProp||nC(k)||typeof k=="boolean")continue;let D=fVe(S.prevProp,k)||w===l&&S.isActive&&!R&&I||v>y&&I,L=!1;const V=Array.isArray(k)?k:[k];let U=V.reduce(r,{});T===!1&&(U={});const{prevResolvedValues:j={}}=S,q={...j,...U},J=te=>{D=!0,f.has(te)&&(L=!0,f.delete(te)),S.needsAnimating[te]=!0};for(const te in q){const le=U[te],K=j[te];if(m.hasOwnProperty(te))continue;let re=!1;fw(le)&&fw(K)?re=!U6(le,K):re=le!==K,re?le!==void 0?J(te):f.add(te):le!==void 0&&f.has(te)?J(te):S.protectedKeys[te]=!0}S.prevProp=k,S.prevResolvedValues=U,S.isActive&&(m={...m,...U}),s&&t.blockInitialAnimation&&(D=!1),D&&(!R||L)&&d.push(...V.map(te=>({animation:te,options:{type:w,...u}})))}if(f.size){const v={};f.forEach(w=>{const S=t.getBaseTarget(w);S!==void 0&&(v[w]=S)}),d.push({animation:v})}let x=!!d.length;return s&&(c.initial===!1||c.initial===c.animate)&&!t.manuallyAnimateOnMount&&(x=!1),s=!1,x?e(d):Promise.resolve()}function a(u,l,c){var h;if(n[u].isActive===l)return Promise.resolve();(h=t.variantChildren)===null||h===void 0||h.forEach(f=>{var m;return(m=f.animationState)===null||m===void 0?void 0:m.setActive(u,l)}),n[u].isActive=l;const d=i(c,u);for(const f in n)n[f].protectedKeys={};return d}return{animateChanges:i,setActive:a,setAnimateFunction:o,getState:()=>n}}function fVe(t,e){return typeof e=="string"?e!==t:Array.isArray(e)?!U6(e,t):!1}function yc(t=!1){return{isActive:t,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function mVe(){return{animate:yc(!0),whileInView:yc(),whileHover:yc(),whileTap:yc(),whileDrag:yc(),whileFocus:yc(),exit:yc()}}class gVe extends jl{constructor(e){super(e),e.animationState||(e.animationState=pVe(e))}updateAnimationControlsSubscription(){const{animate:e}=this.node.getProps();this.unmount(),nC(e)&&(this.unmount=e.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate:e}=this.node.getProps(),{animate:n}=this.node.prevProps||{};e!==n&&this.updateAnimationControlsSubscription()}unmount(){}}let yVe=0;class xVe extends jl{constructor(){super(...arguments),this.id=yVe++}update(){if(!this.node.presenceContext)return;const{isPresent:e,onExitComplete:n,custom:s}=this.node.presenceContext,{isPresent:r}=this.node.prevPresenceContext||{};if(!this.node.animationState||e===r)return;const o=this.node.animationState.setActive("exit",!e,{custom:s??this.node.getProps().custom});n&&!e&&o.then(()=>n(this.id))}mount(){const{register:e}=this.node.presenceContext||{};e&&(this.unmount=e(this.id))}unmount(){}}const vVe={animation:{Feature:gVe},exit:{Feature:xVe}},UF=(t,e)=>Math.abs(t-e);function wVe(t,e){const n=UF(t.x,e.x),s=UF(t.y,e.y);return Math.sqrt(n**2+s**2)}class bj{constructor(e,n,{transformPagePoint:s,contextWindow:r,dragSnapToOrigin:o=!1}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.contextWindow=window,this.updatePoint=()=>{if(!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const h=Lk(this.lastMoveEventInfo,this.history),d=this.startEvent!==null,f=wVe(h.offset,{x:0,y:0})>=3;if(!d&&!f)return;const{point:m}=h,{timestamp:y}=ur;this.history.push({...m,timestamp:y});const{onStart:x,onMove:v}=this.handlers;d||(x&&x(this.lastMoveEvent,h),this.startEvent=this.lastMoveEvent),v&&v(this.lastMoveEvent,h)},this.handlePointerMove=(h,d)=>{this.lastMoveEvent=h,this.lastMoveEventInfo=Ok(d,this.transformPagePoint),An.update(this.updatePoint,!0)},this.handlePointerUp=(h,d)=>{this.end();const{onEnd:f,onSessionEnd:m,resumeAnimation:y}=this.handlers;if(this.dragSnapToOrigin&&y&&y(),!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const x=Lk(h.type==="pointercancel"?this.lastMoveEventInfo:Ok(d,this.transformPagePoint),this.history);this.startEvent&&f&&f(h,x),m&&m(h,x)},!M6(e))return;this.dragSnapToOrigin=o,this.handlers=n,this.transformPagePoint=s,this.contextWindow=r||window;const i=oC(e),a=Ok(i,this.transformPagePoint),{point:u}=a,{timestamp:l}=ur;this.history=[{...u,timestamp:l}];const{onSessionStart:c}=n;c&&c(e,Lk(a,this.history)),this.removeListeners=fl(cu(this.contextWindow,"pointermove",this.handlePointerMove),cu(this.contextWindow,"pointerup",this.handlePointerUp),cu(this.contextWindow,"pointercancel",this.handlePointerUp))}updateHandlers(e){this.handlers=e}end(){this.removeListeners&&this.removeListeners(),wu(this.updatePoint)}}function Ok(t,e){return e?{point:e(t.point)}:t}function GF(t,e){return{x:t.x-e.x,y:t.y-e.y}}function Lk({point:t},e){return{point:t,delta:GF(t,Sj(e)),offset:GF(t,bVe(e)),velocity:SVe(e,.1)}}function bVe(t){return t[0]}function Sj(t){return t[t.length-1]}function SVe(t,e){if(t.length<2)return{x:0,y:0};let n=t.length-1,s=null;const r=Sj(t);for(;n>=0&&(s=t[n],!(r.timestamp-s.timestamp>ml(e)));)n--;if(!s)return{x:0,y:0};const o=hu(r.timestamp-s.timestamp);if(o===0)return{x:0,y:0};const i={x:(r.x-s.x)/o,y:(r.y-s.y)/o};return i.x===1/0&&(i.x=0),i.y===1/0&&(i.y=0),i}function Do(t){return t.max-t.min}function Y$(t,e=0,n=.01){return Math.abs(t-e)<=n}function HF(t,e,n,s=.5){t.origin=s,t.originPoint=Gn(e.min,e.max,t.origin),t.scale=Do(n)/Do(e),(Y$(t.scale,1,1e-4)||isNaN(t.scale))&&(t.scale=1),t.translate=Gn(n.min,n.max,t.origin)-t.originPoint,(Y$(t.translate)||isNaN(t.translate))&&(t.translate=0)}function wg(t,e,n,s){HF(t.x,e.x,n.x,s?s.originX:void 0),HF(t.y,e.y,n.y,s?s.originY:void 0)}function jF(t,e,n){t.min=n.min+e.min,t.max=t.min+Do(e)}function CVe(t,e,n){jF(t.x,e.x,n.x),jF(t.y,e.y,n.y)}function KF(t,e,n){t.min=e.min-n.min,t.max=t.min+Do(e)}function bg(t,e,n){KF(t.x,e.x,n.x),KF(t.y,e.y,n.y)}function kVe(t,{min:e,max:n},s){return e!==void 0&&t<e?t=s?Gn(e,t,s.min):Math.max(t,e):n!==void 0&&t>n&&(t=s?Gn(n,t,s.max):Math.min(t,n)),t}function XF(t,e,n){return{min:e!==void 0?t.min+e:void 0,max:n!==void 0?t.max+n-(t.max-t.min):void 0}}function IVe(t,{top:e,left:n,bottom:s,right:r}){return{x:XF(t.x,n,r),y:XF(t.y,e,s)}}function qF(t,e){let n=e.min-t.min,s=e.max-t.max;return e.max-e.min<t.max-t.min&&([n,s]=[s,n]),{min:n,max:s}}function $Ve(t,e){return{x:qF(t.x,e.x),y:qF(t.y,e.y)}}function NVe(t,e){let n=.5;const s=Do(t),r=Do(e);return r>s?n=cy(e.min,e.max-s,t.min):s>r&&(n=cy(t.min,t.max-r,e.min)),Rl(0,1,n)}function TVe(t,e){const n={};return e.min!==void 0&&(n.min=e.min-t.min),e.max!==void 0&&(n.max=e.max-t.min),n}const Q$=.35;function EVe(t=Q$){return t===!1?t=0:t===!0&&(t=Q$),{x:YF(t,"left","right"),y:YF(t,"top","bottom")}}function YF(t,e,n){return{min:QF(t,e),max:QF(t,n)}}function QF(t,e){return typeof t=="number"?t:t[e]||0}const ZF=()=>({translate:0,scale:1,origin:0,originPoint:0}),Od=()=>({x:ZF(),y:ZF()}),JF=()=>({min:0,max:0}),ds=()=>({x:JF(),y:JF()});function Jo(t){return[t("x"),t("y")]}function Cj({top:t,left:e,right:n,bottom:s}){return{x:{min:e,max:n},y:{min:t,max:s}}}function RVe({x:t,y:e}){return{top:e.min,right:t.max,bottom:e.max,left:t.min}}function AVe(t,e){if(!e)return t;const n=e({x:t.left,y:t.top}),s=e({x:t.right,y:t.bottom});return{top:n.y,left:n.x,bottom:s.y,right:s.x}}function Mk(t){return t===void 0||t===1}function Z$({scale:t,scaleX:e,scaleY:n}){return!Mk(t)||!Mk(e)||!Mk(n)}function Sc(t){return Z$(t)||kj(t)||t.z||t.rotate||t.rotateX||t.rotateY}function kj(t){return eO(t.x)||eO(t.y)}function eO(t){return t&&t!=="0%"}function vw(t,e,n){const s=t-n,r=e*s;return n+r}function tO(t,e,n,s,r){return r!==void 0&&(t=vw(t,r,s)),vw(t,n,s)+e}function J$(t,e=0,n=1,s,r){t.min=tO(t.min,e,n,s,r),t.max=tO(t.max,e,n,s,r)}function Ij(t,{x:e,y:n}){J$(t.x,e.translate,e.scale,e.originPoint),J$(t.y,n.translate,n.scale,n.originPoint)}function _Ve(t,e,n,s=!1){const r=n.length;if(!r)return;e.x=e.y=1;let o,i;for(let a=0;a<r;a++){o=n[a],i=o.projectionDelta;const u=o.instance;u&&u.style&&u.style.display==="contents"||(s&&o.options.layoutScroll&&o.scroll&&o!==o.root&&Ld(t,{x:-o.scroll.offset.x,y:-o.scroll.offset.y}),i&&(e.x*=i.x.scale,e.y*=i.y.scale,Ij(t,i)),s&&Sc(o.latestValues)&&Ld(t,o.latestValues))}e.x=nO(e.x),e.y=nO(e.y)}function nO(t){return Number.isInteger(t)||t>1.0000000000001||t<.999999999999?t:1}function Ku(t,e){t.min=t.min+e,t.max=t.max+e}function sO(t,e,[n,s,r]){const o=e[r]!==void 0?e[r]:.5,i=Gn(t.min,t.max,o);J$(t,e[n],e[s],i,e.scale)}const DVe=["x","scaleX","originX"],PVe=["y","scaleY","originY"];function Ld(t,e){sO(t.x,e,DVe),sO(t.y,e,PVe)}function $j(t,e){return Cj(AVe(t.getBoundingClientRect(),e))}function FVe(t,e,n){const s=$j(t,n),{scroll:r}=e;return r&&(Ku(s.x,r.offset.x),Ku(s.y,r.offset.y)),s}const Nj=({current:t})=>t?t.ownerDocument.defaultView:null,OVe=new WeakMap;class LVe{constructor(e){this.openGlobalLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=ds(),this.visualElement=e}start(e,{snapToCursor:n=!1}={}){const{presenceContext:s}=this.visualElement;if(s&&s.isPresent===!1)return;const r=c=>{const{dragSnapToOrigin:h}=this.getProps();h?this.pauseAnimation():this.stopAnimation(),n&&this.snapToCursor(oC(c,"page").point)},o=(c,h)=>{const{drag:d,dragPropagation:f,onDragStart:m}=this.getProps();if(d&&!f&&(this.openGlobalLock&&this.openGlobalLock(),this.openGlobalLock=B6(d),!this.openGlobalLock))return;this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),Jo(x=>{let v=this.getAxisMotionValue(x).get()||0;if(Sa.test(v)){const{projection:w}=this.visualElement;if(w&&w.layout){const S=w.layout.layoutBox[x];S&&(v=Do(S)*(parseFloat(v)/100))}}this.originPoint[x]=v}),m&&An.update(()=>m(c,h),!1,!0);const{animationState:y}=this.visualElement;y&&y.setActive("whileDrag",!0)},i=(c,h)=>{const{dragPropagation:d,dragDirectionLock:f,onDirectionLock:m,onDrag:y}=this.getProps();if(!d&&!this.openGlobalLock)return;const{offset:x}=h;if(f&&this.currentDirection===null){this.currentDirection=MVe(x),this.currentDirection!==null&&m&&m(this.currentDirection);return}this.updateAxis("x",h.point,x),this.updateAxis("y",h.point,x),this.visualElement.render(),y&&y(c,h)},a=(c,h)=>this.stop(c,h),u=()=>Jo(c=>{var h;return this.getAnimationState(c)==="paused"&&((h=this.getAxisMotionValue(c).animation)===null||h===void 0?void 0:h.play())}),{dragSnapToOrigin:l}=this.getProps();this.panSession=new bj(e,{onSessionStart:r,onStart:o,onMove:i,onSessionEnd:a,resumeAnimation:u},{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:l,contextWindow:Nj(this.visualElement)})}stop(e,n){const s=this.isDragging;if(this.cancel(),!s)return;const{velocity:r}=n;this.startAnimation(r);const{onDragEnd:o}=this.getProps();o&&An.update(()=>o(e,n))}cancel(){this.isDragging=!1;const{projection:e,animationState:n}=this.visualElement;e&&(e.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation:s}=this.getProps();!s&&this.openGlobalLock&&(this.openGlobalLock(),this.openGlobalLock=null),n&&n.setActive("whileDrag",!1)}updateAxis(e,n,s){const{drag:r}=this.getProps();if(!s||!L1(e,r,this.currentDirection))return;const o=this.getAxisMotionValue(e);let i=this.originPoint[e]+s[e];this.constraints&&this.constraints[e]&&(i=kVe(i,this.constraints[e],this.elastic[e])),o.set(i)}resolveConstraints(){var e;const{dragConstraints:n,dragElastic:s}=this.getProps(),r=this.visualElement.projection&&!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):(e=this.visualElement.projection)===null||e===void 0?void 0:e.layout,o=this.constraints;n&&Pd(n)?this.constraints||(this.constraints=this.resolveRefConstraints()):n&&r?this.constraints=IVe(r.layoutBox,n):this.constraints=!1,this.elastic=EVe(s),o!==this.constraints&&r&&this.constraints&&!this.hasMutatedConstraints&&Jo(i=>{this.getAxisMotionValue(i)&&(this.constraints[i]=TVe(r.layoutBox[i],this.constraints[i]))})}resolveRefConstraints(){const{dragConstraints:e,onMeasureDragConstraints:n}=this.getProps();if(!e||!Pd(e))return!1;const s=e.current,{projection:r}=this.visualElement;if(!r||!r.layout)return!1;const o=FVe(s,r.root,this.visualElement.getTransformPagePoint());let i=$Ve(r.layout.layoutBox,o);if(n){const a=n(RVe(i));this.hasMutatedConstraints=!!a,a&&(i=Cj(a))}return i}startAnimation(e){const{drag:n,dragMomentum:s,dragElastic:r,dragTransition:o,dragSnapToOrigin:i,onDragTransitionEnd:a}=this.getProps(),u=this.constraints||{},l=Jo(c=>{if(!L1(c,n,this.currentDirection))return;let h=u&&u[c]||{};i&&(h={min:0,max:0});const d=r?200:1e6,f=r?40:1e7,m={type:"inertia",velocity:s?e[c]:0,bounceStiffness:d,bounceDamping:f,timeConstant:750,restDelta:1,restSpeed:10,...o,...h};return this.startAxisValueAnimation(c,m)});return Promise.all(l).then(a)}startAxisValueAnimation(e,n){const s=this.getAxisMotionValue(e);return s.start(TR(e,s,0,n))}stopAnimation(){Jo(e=>this.getAxisMotionValue(e).stop())}pauseAnimation(){Jo(e=>{var n;return(n=this.getAxisMotionValue(e).animation)===null||n===void 0?void 0:n.pause()})}getAnimationState(e){var n;return(n=this.getAxisMotionValue(e).animation)===null||n===void 0?void 0:n.state}getAxisMotionValue(e){const n="_drag"+e.toUpperCase(),s=this.visualElement.getProps(),r=s[n];return r||this.visualElement.getValue(e,(s.initial?s.initial[e]:void 0)||0)}snapToCursor(e){Jo(n=>{const{drag:s}=this.getProps();if(!L1(n,s,this.currentDirection))return;const{projection:r}=this.visualElement,o=this.getAxisMotionValue(n);if(r&&r.layout){const{min:i,max:a}=r.layout.layoutBox[n];o.set(e[n]-Gn(i,a,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:e,dragConstraints:n}=this.getProps(),{projection:s}=this.visualElement;if(!Pd(n)||!s||!this.constraints)return;this.stopAnimation();const r={x:0,y:0};Jo(i=>{const a=this.getAxisMotionValue(i);if(a){const u=a.get();r[i]=NVe({min:u,max:u},this.constraints[i])}});const{transformTemplate:o}=this.visualElement.getProps();this.visualElement.current.style.transform=o?o({},""):"none",s.root&&s.root.updateScroll(),s.updateLayout(),this.resolveConstraints(),Jo(i=>{if(!L1(i,e,null))return;const a=this.getAxisMotionValue(i),{min:u,max:l}=this.constraints[i];a.set(Gn(u,l,r[i]))})}addListeners(){if(!this.visualElement.current)return;OVe.set(this.visualElement,this);const e=this.visualElement.current,n=cu(e,"pointerdown",u=>{const{drag:l,dragListener:c=!0}=this.getProps();l&&c&&this.start(u)}),s=()=>{const{dragConstraints:u}=this.getProps();Pd(u)&&(this.constraints=this.resolveRefConstraints())},{projection:r}=this.visualElement,o=r.addEventListener("measure",s);r&&!r.layout&&(r.root&&r.root.updateScroll(),r.updateLayout()),s();const i=su(window,"resize",()=>this.scalePositionWithinConstraints()),a=r.addEventListener("didUpdate",({delta:u,hasLayoutChanged:l})=>{this.isDragging&&l&&(Jo(c=>{const h=this.getAxisMotionValue(c);h&&(this.originPoint[c]+=u[c].translate,h.set(h.get()+u[c].translate))}),this.visualElement.render())});return()=>{i(),n(),o(),a&&a()}}getProps(){const e=this.visualElement.getProps(),{drag:n=!1,dragDirectionLock:s=!1,dragPropagation:r=!1,dragConstraints:o=!1,dragElastic:i=Q$,dragMomentum:a=!0}=e;return{...e,drag:n,dragDirectionLock:s,dragPropagation:r,dragConstraints:o,dragElastic:i,dragMomentum:a}}}function L1(t,e,n){return(e===!0||e===t)&&(n===null||n===t)}function MVe(t,e=10){let n=null;return Math.abs(t.y)>e?n="y":Math.abs(t.x)>e&&(n="x"),n}class zVe extends jl{constructor(e){super(e),this.removeGroupControls=Jn,this.removeListeners=Jn,this.controls=new LVe(e)}mount(){const{dragControls:e}=this.node.getProps();e&&(this.removeGroupControls=e.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||Jn}unmount(){this.removeGroupControls(),this.removeListeners()}}const rO=t=>(e,n)=>{t&&An.update(()=>t(e,n))};class BVe extends jl{constructor(){super(...arguments),this.removePointerDownListener=Jn}onPointerDown(e){this.session=new bj(e,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint(),contextWindow:Nj(this.node)})}createPanHandlers(){const{onPanSessionStart:e,onPanStart:n,onPan:s,onPanEnd:r}=this.node.getProps();return{onSessionStart:rO(e),onStart:rO(n),onMove:s,onEnd:(o,i)=>{delete this.session,r&&An.update(()=>r(o,i))}}}mount(){this.removePointerDownListener=cu(this.node.current,"pointerdown",e=>this.onPointerDown(e))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener(),this.session&&this.session.end()}}function VVe(){const t=fe.useContext(hR);if(t===null)return[!0,null];const{isPresent:e,onExitComplete:n,register:s}=t,r=fe.useId();return fe.useEffect(()=>s(r),[]),!e&&n?[!1,()=>n&&n(r)]:[!0]}const rv={hasAnimatedSinceResize:!0,hasEverUpdated:!1};function oO(t,e){return e.max===e.min?0:t/(e.max-e.min)*100}const Km={correct:(t,e)=>{if(!e.target)return t;if(typeof t=="string")if(yt.test(t))t=parseFloat(t);else return t;const n=oO(t,e.target.x),s=oO(t,e.target.y);return`${n}% ${s}%`}},WVe={correct:(t,{treeScale:e,projectionDelta:n})=>{const s=t,r=Al.parse(t);if(r.length>5)return s;const o=Al.createTransformer(t),i=typeof r[0]!="number"?1:0,a=n.x.scale*e.x,u=n.y.scale*e.y;r[0+i]/=a,r[1+i]/=u;const l=Gn(a,u,.5);return typeof r[2+i]=="number"&&(r[2+i]/=l),typeof r[3+i]=="number"&&(r[3+i]/=l),o(r)}};class UVe extends iN.Component{componentDidMount(){const{visualElement:e,layoutGroup:n,switchLayoutGroup:s,layoutId:r}=this.props,{projection:o}=e;qMe(GVe),o&&(n.group&&n.group.add(o),s&&s.register&&r&&s.register(o),o.root.didUpdate(),o.addEventListener("animationComplete",()=>{this.safeToRemove()}),o.setOptions({...o.options,onExitComplete:()=>this.safeToRemove()})),rv.hasEverUpdated=!0}getSnapshotBeforeUpdate(e){const{layoutDependency:n,visualElement:s,drag:r,isPresent:o}=this.props,i=s.projection;return i&&(i.isPresent=o,r||e.layoutDependency!==n||n===void 0?i.willUpdate():this.safeToRemove(),e.isPresent!==o&&(o?i.promote():i.relegate()||An.postRender(()=>{const a=i.getStack();(!a||!a.members.length)&&this.safeToRemove()}))),null}componentDidUpdate(){const{projection:e}=this.props.visualElement;e&&(e.root.didUpdate(),queueMicrotask(()=>{!e.currentAnimation&&e.isLead()&&this.safeToRemove()}))}componentWillUnmount(){const{visualElement:e,layoutGroup:n,switchLayoutGroup:s}=this.props,{projection:r}=e;r&&(r.scheduleCheckAfterUnmount(),n&&n.group&&n.group.remove(r),s&&s.deregister&&s.deregister(r))}safeToRemove(){const{safeToRemove:e}=this.props;e&&e()}render(){return null}}function Tj(t){const[e,n]=VVe(),s=fe.useContext(C6);return iN.createElement(UVe,{...t,layoutGroup:s,switchLayoutGroup:fe.useContext(k6),isPresent:e,safeToRemove:n})}const GVe={borderRadius:{...Km,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:Km,borderTopRightRadius:Km,borderBottomLeftRadius:Km,borderBottomRightRadius:Km,boxShadow:WVe},Ej=["TopLeft","TopRight","BottomLeft","BottomRight"],HVe=Ej.length,iO=t=>typeof t=="string"?parseFloat(t):t,aO=t=>typeof t=="number"||yt.test(t);function jVe(t,e,n,s,r,o){r?(t.opacity=Gn(0,n.opacity!==void 0?n.opacity:1,KVe(s)),t.opacityExit=Gn(e.opacity!==void 0?e.opacity:1,0,XVe(s))):o&&(t.opacity=Gn(e.opacity!==void 0?e.opacity:1,n.opacity!==void 0?n.opacity:1,s));for(let i=0;i<HVe;i++){const a=`border${Ej[i]}Radius`;let u=uO(e,a),l=uO(n,a);if(u===void 0&&l===void 0)continue;u||(u=0),l||(l=0),u===0||l===0||aO(u)===aO(l)?(t[a]=Math.max(Gn(iO(u),iO(l),s),0),(Sa.test(l)||Sa.test(u))&&(t[a]+="%")):t[a]=l}(e.rotate||n.rotate)&&(t.rotate=Gn(e.rotate||0,n.rotate||0,s))}function uO(t,e){return t[e]!==void 0?t[e]:t.borderRadius}const KVe=Rj(0,.5,Z6),XVe=Rj(.5,.95,Jn);function Rj(t,e,n){return s=>s<t?0:s>e?1:n(cy(t,e,s))}function lO(t,e){t.min=e.min,t.max=e.max}function Qo(t,e){lO(t.x,e.x),lO(t.y,e.y)}function cO(t,e,n,s,r){return t-=e,t=vw(t,1/n,s),r!==void 0&&(t=vw(t,1/r,s)),t}function qVe(t,e=0,n=1,s=.5,r,o=t,i=t){if(Sa.test(e)&&(e=parseFloat(e),e=Gn(i.min,i.max,e/100)-i.min),typeof e!="number")return;let a=Gn(o.min,o.max,s);t===o&&(a-=e),t.min=cO(t.min,e,n,a,r),t.max=cO(t.max,e,n,a,r)}function hO(t,e,[n,s,r],o,i){qVe(t,e[n],e[s],e[r],e.scale,o,i)}const YVe=["x","scaleX","originX"],QVe=["y","scaleY","originY"];function dO(t,e,n,s){hO(t.x,e,YVe,n?n.x:void 0,s?s.x:void 0),hO(t.y,e,QVe,n?n.y:void 0,s?s.y:void 0)}function pO(t){return t.translate===0&&t.scale===1}function Aj(t){return pO(t.x)&&pO(t.y)}function ZVe(t,e){return t.x.min===e.x.min&&t.x.max===e.x.max&&t.y.min===e.y.min&&t.y.max===e.y.max}function _j(t,e){return Math.round(t.x.min)===Math.round(e.x.min)&&Math.round(t.x.max)===Math.round(e.x.max)&&Math.round(t.y.min)===Math.round(e.y.min)&&Math.round(t.y.max)===Math.round(e.y.max)}function fO(t){return Do(t.x)/Do(t.y)}class JVe{constructor(){this.members=[]}add(e){ER(this.members,e),e.scheduleRender()}remove(e){if(RR(this.members,e),e===this.prevLead&&(this.prevLead=void 0),e===this.lead){const n=this.members[this.members.length-1];n&&this.promote(n)}}relegate(e){const n=this.members.findIndex(r=>e===r);if(n===0)return!1;let s;for(let r=n;r>=0;r--){const o=this.members[r];if(o.isPresent!==!1){s=o;break}}return s?(this.promote(s),!0):!1}promote(e,n){const s=this.lead;if(e!==s&&(this.prevLead=s,this.lead=e,e.show(),s)){s.instance&&s.scheduleRender(),e.scheduleRender(),e.resumeFrom=s,n&&(e.resumeFrom.preserveOpacity=!0),s.snapshot&&(e.snapshot=s.snapshot,e.snapshot.latestValues=s.animationValues||s.latestValues),e.root&&e.root.isUpdating&&(e.isLayoutDirty=!0);const{crossfade:r}=e.options;r===!1&&s.hide()}}exitAnimationComplete(){this.members.forEach(e=>{const{options:n,resumingFrom:s}=e;n.onExitComplete&&n.onExitComplete(),s&&s.options.onExitComplete&&s.options.onExitComplete()})}scheduleRender(){this.members.forEach(e=>{e.instance&&e.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}function mO(t,e,n){let s="";const r=t.x.translate/e.x,o=t.y.translate/e.y;if((r||o)&&(s=`translate3d(${r}px, ${o}px, 0) `),(e.x!==1||e.y!==1)&&(s+=`scale(${1/e.x}, ${1/e.y}) `),n){const{rotate:u,rotateX:l,rotateY:c}=n;u&&(s+=`rotate(${u}deg) `),l&&(s+=`rotateX(${l}deg) `),c&&(s+=`rotateY(${c}deg) `)}const i=t.x.scale*e.x,a=t.y.scale*e.y;return(i!==1||a!==1)&&(s+=`scale(${i}, ${a})`),s||"none"}const e4e=(t,e)=>t.depth-e.depth;class t4e{constructor(){this.children=[],this.isDirty=!1}add(e){ER(this.children,e),this.isDirty=!0}remove(e){RR(this.children,e),this.isDirty=!0}forEach(e){this.isDirty&&this.children.sort(e4e),this.isDirty=!1,this.children.forEach(e)}}function n4e(t,e){const n=performance.now(),s=({timestamp:r})=>{const o=r-n;o>=e&&(wu(s),t(o-e))};return An.read(s,!0),()=>wu(s)}function s4e(t){window.MotionDebug&&window.MotionDebug.record(t)}function r4e(t){return t instanceof SVGElement&&t.tagName!=="svg"}function o4e(t,e,n){const s=ho(t)?t:bp(t);return s.start(TR("",s,e,n)),s.animation}const gO=["","X","Y","Z"],i4e={visibility:"hidden"},yO=1e3;let a4e=0;const Cc={type:"projectionFrame",totalNodes:0,resolvedTargetDeltas:0,recalculatedProjection:0};function Dj({attachResizeListener:t,defaultParent:e,measureScroll:n,checkIsScrollRoot:s,resetTransform:r}){return class{constructor(i={},a=e==null?void 0:e()){this.id=a4e++,this.animationId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.updateScheduled=!1,this.projectionUpdateScheduled=!1,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{this.projectionUpdateScheduled=!1,Cc.totalNodes=Cc.resolvedTargetDeltas=Cc.recalculatedProjection=0,this.nodes.forEach(c4e),this.nodes.forEach(m4e),this.nodes.forEach(g4e),this.nodes.forEach(h4e),s4e(Cc)},this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=i,this.root=a?a.root||a:this,this.path=a?[...a.path,a]:[],this.parent=a,this.depth=a?a.depth+1:0;for(let u=0;u<this.path.length;u++)this.path[u].shouldResetTransform=!0;this.root===this&&(this.nodes=new t4e)}addEventListener(i,a){return this.eventHandlers.has(i)||this.eventHandlers.set(i,new AR),this.eventHandlers.get(i).add(a)}notifyListeners(i,...a){const u=this.eventHandlers.get(i);u&&u.notify(...a)}hasListeners(i){return this.eventHandlers.has(i)}mount(i,a=this.root.hasTreeAnimated){if(this.instance)return;this.isSVG=r4e(i),this.instance=i;const{layoutId:u,layout:l,visualElement:c}=this.options;if(c&&!c.current&&c.mount(i),this.root.nodes.add(this),this.parent&&this.parent.children.add(this),a&&(l||u)&&(this.isLayoutDirty=!0),t){let h;const d=()=>this.root.updateBlockedByResize=!1;t(i,()=>{this.root.updateBlockedByResize=!0,h&&h(),h=n4e(d,250),rv.hasAnimatedSinceResize&&(rv.hasAnimatedSinceResize=!1,this.nodes.forEach(vO))})}u&&this.root.registerSharedNode(u,this),this.options.animate!==!1&&c&&(u||l)&&this.addEventListener("didUpdate",({delta:h,hasLayoutChanged:d,hasRelativeTargetChanged:f,layout:m})=>{if(this.isTreeAnimationBlocked()){this.target=void 0,this.relativeTarget=void 0;return}const y=this.options.transition||c.getDefaultTransition()||b4e,{onLayoutAnimationStart:x,onLayoutAnimationComplete:v}=c.getProps(),w=!this.targetLayout||!_j(this.targetLayout,m)||f,S=!d&&f;if(this.options.layoutRoot||this.resumeFrom&&this.resumeFrom.instance||S||d&&(w||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0),this.setAnimationOrigin(h,S);const k={...NR(y,"layout"),onPlay:x,onComplete:v};(c.shouldReduceMotion||this.options.layoutRoot)&&(k.delay=0,k.type=!1),this.startAnimation(k)}else d||vO(this),this.isLead()&&this.options.onExitComplete&&this.options.onExitComplete();this.targetLayout=m})}unmount(){this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this);const i=this.getStack();i&&i.remove(this),this.parent&&this.parent.children.delete(this),this.instance=void 0,wu(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach(y4e),this.animationId++)}getTransformTemplate(){const{visualElement:i}=this.options;return i&&i.getProps().transformTemplate}willUpdate(i=!0){if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked()){this.options.onExitComplete&&this.options.onExitComplete();return}if(!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let c=0;c<this.path.length;c++){const h=this.path[c];h.shouldResetTransform=!0,h.updateScroll("snapshot"),h.options.layoutRoot&&h.willUpdate(!1)}const{layoutId:a,layout:u}=this.options;if(a===void 0&&!u)return;const l=this.getTransformTemplate();this.prevTransformTemplateValue=l?l(this.latestValues,""):void 0,this.updateSnapshot(),i&&this.notifyListeners("willUpdate")}update(){if(this.updateScheduled=!1,this.isUpdateBlocked()){this.unblockUpdate(),this.clearAllSnapshots(),this.nodes.forEach(xO);return}this.isUpdating||this.nodes.forEach(p4e),this.isUpdating=!1,this.nodes.forEach(f4e),this.nodes.forEach(u4e),this.nodes.forEach(l4e),this.clearAllSnapshots();const a=performance.now();ur.delta=Rl(0,1e3/60,a-ur.timestamp),ur.timestamp=a,ur.isProcessing=!0,Tk.update.process(ur),Tk.preRender.process(ur),Tk.render.process(ur),ur.isProcessing=!1}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,queueMicrotask(()=>this.update()))}clearAllSnapshots(){this.nodes.forEach(d4e),this.sharedNodes.forEach(x4e)}scheduleUpdateProjection(){this.projectionUpdateScheduled||(this.projectionUpdateScheduled=!0,An.preRender(this.updateProjection,!1,!0))}scheduleCheckAfterUnmount(){An.postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){this.snapshot||!this.instance||(this.snapshot=this.measure())}updateLayout(){if(!this.instance||(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead())&&!this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let u=0;u<this.path.length;u++)this.path[u].updateScroll();const i=this.layout;this.layout=this.measure(!1),this.layoutCorrected=ds(),this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);const{visualElement:a}=this.options;a&&a.notify("LayoutMeasure",this.layout.layoutBox,i?i.layoutBox:void 0)}updateScroll(i="measure"){let a=!!(this.options.layoutScroll&&this.instance);this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===i&&(a=!1),a&&(this.scroll={animationId:this.root.animationId,phase:i,isRoot:s(this.instance),offset:n(this.instance)})}resetTransform(){if(!r)return;const i=this.isLayoutDirty||this.shouldResetTransform,a=this.projectionDelta&&!Aj(this.projectionDelta),u=this.getTransformTemplate(),l=u?u(this.latestValues,""):void 0,c=l!==this.prevTransformTemplateValue;i&&(a||Sc(this.latestValues)||c)&&(r(this.instance,l),this.shouldResetTransform=!1,this.scheduleRender())}measure(i=!0){const a=this.measurePageBox();let u=this.removeElementScroll(a);return i&&(u=this.removeTransform(u)),S4e(u),{animationId:this.root.animationId,measuredBox:a,layoutBox:u,latestValues:{},source:this.id}}measurePageBox(){const{visualElement:i}=this.options;if(!i)return ds();const a=i.measureViewportBox(),{scroll:u}=this.root;return u&&(Ku(a.x,u.offset.x),Ku(a.y,u.offset.y)),a}removeElementScroll(i){const a=ds();Qo(a,i);for(let u=0;u<this.path.length;u++){const l=this.path[u],{scroll:c,options:h}=l;if(l!==this.root&&c&&h.layoutScroll){if(c.isRoot){Qo(a,i);const{scroll:d}=this.root;d&&(Ku(a.x,-d.offset.x),Ku(a.y,-d.offset.y))}Ku(a.x,c.offset.x),Ku(a.y,c.offset.y)}}return a}applyTransform(i,a=!1){const u=ds();Qo(u,i);for(let l=0;l<this.path.length;l++){const c=this.path[l];!a&&c.options.layoutScroll&&c.scroll&&c!==c.root&&Ld(u,{x:-c.scroll.offset.x,y:-c.scroll.offset.y}),Sc(c.latestValues)&&Ld(u,c.latestValues)}return Sc(this.latestValues)&&Ld(u,this.latestValues),u}removeTransform(i){const a=ds();Qo(a,i);for(let u=0;u<this.path.length;u++){const l=this.path[u];if(!l.instance||!Sc(l.latestValues))continue;Z$(l.latestValues)&&l.updateSnapshot();const c=ds(),h=l.measurePageBox();Qo(c,h),dO(a,l.latestValues,l.snapshot?l.snapshot.layoutBox:void 0,c)}return Sc(this.latestValues)&&dO(a,this.latestValues),a}setTargetDelta(i){this.targetDelta=i,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}setOptions(i){this.options={...this.options,...i,crossfade:i.crossfade!==void 0?i.crossfade:!0}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&this.relativeParent.resolvedRelativeTargetAt!==ur.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(i=!1){var a;const u=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=u.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=u.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=u.isSharedProjectionDirty);const l=!!this.resumingFrom||this!==u;if(!(i||l&&this.isSharedProjectionDirty||this.isProjectionDirty||!((a=this.parent)===null||a===void 0)&&a.isProjectionDirty||this.attemptToResolveRelativeTarget))return;const{layout:h,layoutId:d}=this.options;if(!(!this.layout||!(h||d))){if(this.resolvedRelativeTargetAt=ur.timestamp,!this.targetDelta&&!this.relativeTarget){const f=this.getClosestProjectingParent();f&&f.layout&&this.animationProgress!==1?(this.relativeParent=f,this.forceRelativeParentToResolveTarget(),this.relativeTarget=ds(),this.relativeTargetOrigin=ds(),bg(this.relativeTargetOrigin,this.layout.layoutBox,f.layout.layoutBox),Qo(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}if(!(!this.relativeTarget&&!this.targetDelta)){if(this.target||(this.target=ds(),this.targetWithTransforms=ds()),this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),CVe(this.target,this.relativeTarget,this.relativeParent.target)):this.targetDelta?(this.resumingFrom?this.target=this.applyTransform(this.layout.layoutBox):Qo(this.target,this.layout.layoutBox),Ij(this.target,this.targetDelta)):Qo(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget){this.attemptToResolveRelativeTarget=!1;const f=this.getClosestProjectingParent();f&&!!f.resumingFrom==!!this.resumingFrom&&!f.options.layoutScroll&&f.target&&this.animationProgress!==1?(this.relativeParent=f,this.forceRelativeParentToResolveTarget(),this.relativeTarget=ds(),this.relativeTargetOrigin=ds(),bg(this.relativeTargetOrigin,this.target,f.target),Qo(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}Cc.resolvedTargetDeltas++}}}getClosestProjectingParent(){if(!(!this.parent||Z$(this.parent.latestValues)||kj(this.parent.latestValues)))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return!!((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&&this.layout)}calcProjection(){var i;const a=this.getLead(),u=!!this.resumingFrom||this!==a;let l=!0;if((this.isProjectionDirty||!((i=this.parent)===null||i===void 0)&&i.isProjectionDirty)&&(l=!1),u&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(l=!1),this.resolvedRelativeTargetAt===ur.timestamp&&(l=!1),l)return;const{layout:c,layoutId:h}=this.options;if(this.isTreeAnimating=!!(this.parent&&this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!(c||h))return;Qo(this.layoutCorrected,this.layout.layoutBox);const d=this.treeScale.x,f=this.treeScale.y;_Ve(this.layoutCorrected,this.treeScale,this.path,u),a.layout&&!a.target&&(this.treeScale.x!==1||this.treeScale.y!==1)&&(a.target=a.layout.layoutBox);const{target:m}=a;if(!m){this.projectionTransform&&(this.projectionDelta=Od(),this.projectionTransform="none",this.scheduleRender());return}this.projectionDelta||(this.projectionDelta=Od(),this.projectionDeltaWithTransform=Od());const y=this.projectionTransform;wg(this.projectionDelta,this.layoutCorrected,m,this.latestValues),this.projectionTransform=mO(this.projectionDelta,this.treeScale),(this.projectionTransform!==y||this.treeScale.x!==d||this.treeScale.y!==f)&&(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",m)),Cc.recalculatedProjection++}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(i=!0){if(this.options.scheduleRender&&this.options.scheduleRender(),i){const a=this.getStack();a&&a.scheduleRender()}this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}setAnimationOrigin(i,a=!1){const u=this.snapshot,l=u?u.latestValues:{},c={...this.latestValues},h=Od();(!this.relativeParent||!this.relativeParent.options.layoutRoot)&&(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!a;const d=ds(),f=u?u.source:void 0,m=this.layout?this.layout.source:void 0,y=f!==m,x=this.getStack(),v=!x||x.members.length<=1,w=!!(y&&!v&&this.options.crossfade===!0&&!this.path.some(w4e));this.animationProgress=0;let S;this.mixTargetDelta=k=>{const I=k/1e3;wO(h.x,i.x,I),wO(h.y,i.y,I),this.setTargetDelta(h),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout&&(bg(d,this.layout.layoutBox,this.relativeParent.layout.layoutBox),v4e(this.relativeTarget,this.relativeTargetOrigin,d,I),S&&ZVe(this.relativeTarget,S)&&(this.isProjectionDirty=!1),S||(S=ds()),Qo(S,this.relativeTarget)),y&&(this.animationValues=c,jVe(c,l,this.latestValues,I,w,v)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=I},this.mixTargetDelta(this.options.layoutRoot?1e3:0)}startAnimation(i){this.notifyListeners("animationStart"),this.currentAnimation&&this.currentAnimation.stop(),this.resumingFrom&&this.resumingFrom.currentAnimation&&this.resumingFrom.currentAnimation.stop(),this.pendingAnimation&&(wu(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=An.update(()=>{rv.hasAnimatedSinceResize=!0,this.currentAnimation=o4e(0,yO,{...i,onUpdate:a=>{this.mixTargetDelta(a),i.onUpdate&&i.onUpdate(a)},onComplete:()=>{i.onComplete&&i.onComplete(),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0})}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const i=this.getStack();i&&i.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(yO),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const i=this.getLead();let{targetWithTransforms:a,target:u,layout:l,latestValues:c}=i;if(!(!a||!u||!l)){if(this!==i&&this.layout&&l&&Pj(this.options.animationType,this.layout.layoutBox,l.layoutBox)){u=this.target||ds();const h=Do(this.layout.layoutBox.x);u.x.min=i.target.x.min,u.x.max=u.x.min+h;const d=Do(this.layout.layoutBox.y);u.y.min=i.target.y.min,u.y.max=u.y.min+d}Qo(a,u),Ld(a,c),wg(this.projectionDeltaWithTransform,this.layoutCorrected,a,c)}}registerSharedNode(i,a){this.sharedNodes.has(i)||this.sharedNodes.set(i,new JVe),this.sharedNodes.get(i).add(a);const l=a.options.initialPromotionConfig;a.promote({transition:l?l.transition:void 0,preserveFollowOpacity:l&&l.shouldPreserveFollowOpacity?l.shouldPreserveFollowOpacity(a):void 0})}isLead(){const i=this.getStack();return i?i.lead===this:!0}getLead(){var i;const{layoutId:a}=this.options;return a?((i=this.getStack())===null||i===void 0?void 0:i.lead)||this:this}getPrevLead(){var i;const{layoutId:a}=this.options;return a?(i=this.getStack())===null||i===void 0?void 0:i.prevLead:void 0}getStack(){const{layoutId:i}=this.options;if(i)return this.root.sharedNodes.get(i)}promote({needsReset:i,transition:a,preserveFollowOpacity:u}={}){const l=this.getStack();l&&l.promote(this,u),i&&(this.projectionDelta=void 0,this.needsReset=!0),a&&this.setOptions({transition:a})}relegate(){const i=this.getStack();return i?i.relegate(this):!1}resetRotation(){const{visualElement:i}=this.options;if(!i)return;let a=!1;const{latestValues:u}=i;if((u.rotate||u.rotateX||u.rotateY||u.rotateZ)&&(a=!0),!a)return;const l={};for(let c=0;c<gO.length;c++){const h="rotate"+gO[c];u[h]&&(l[h]=u[h],i.setStaticValue(h,0))}i.render();for(const c in l)i.setStaticValue(c,l[c]);i.scheduleRender()}getProjectionStyles(i){var a,u;if(!this.instance||this.isSVG)return;if(!this.isVisible)return i4e;const l={visibility:""},c=this.getTransformTemplate();if(this.needsReset)return this.needsReset=!1,l.opacity="",l.pointerEvents=sv(i==null?void 0:i.pointerEvents)||"",l.transform=c?c(this.latestValues,""):"none",l;const h=this.getLead();if(!this.projectionDelta||!this.layout||!h.target){const y={};return this.options.layoutId&&(y.opacity=this.latestValues.opacity!==void 0?this.latestValues.opacity:1,y.pointerEvents=sv(i==null?void 0:i.pointerEvents)||""),this.hasProjected&&!Sc(this.latestValues)&&(y.transform=c?c({},""):"none",this.hasProjected=!1),y}const d=h.animationValues||h.latestValues;this.applyTransformsToTarget(),l.transform=mO(this.projectionDeltaWithTransform,this.treeScale,d),c&&(l.transform=c(d,l.transform));const{x:f,y:m}=this.projectionDelta;l.transformOrigin=`${f.origin*100}% ${m.origin*100}% 0`,h.animationValues?l.opacity=h===this?(u=(a=d.opacity)!==null&&a!==void 0?a:this.latestValues.opacity)!==null&&u!==void 0?u:1:this.preserveOpacity?this.latestValues.opacity:d.opacityExit:l.opacity=h===this?d.opacity!==void 0?d.opacity:"":d.opacityExit!==void 0?d.opacityExit:0;for(const y in dw){if(d[y]===void 0)continue;const{correct:x,applyTo:v}=dw[y],w=l.transform==="none"?d[y]:x(d[y],h);if(v){const S=v.length;for(let k=0;k<S;k++)l[v[k]]=w}else l[y]=w}return this.options.layoutId&&(l.pointerEvents=h===this?sv(i==null?void 0:i.pointerEvents)||"":"none"),l}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(i=>{var a;return(a=i.currentAnimation)===null||a===void 0?void 0:a.stop()}),this.root.nodes.forEach(xO),this.root.sharedNodes.clear()}}}function u4e(t){t.updateLayout()}function l4e(t){var e;const n=((e=t.resumeFrom)===null||e===void 0?void 0:e.snapshot)||t.snapshot;if(t.isLead()&&t.layout&&n&&t.hasListeners("didUpdate")){const{layoutBox:s,measuredBox:r}=t.layout,{animationType:o}=t.options,i=n.source!==t.layout.source;o==="size"?Jo(h=>{const d=i?n.measuredBox[h]:n.layoutBox[h],f=Do(d);d.min=s[h].min,d.max=d.min+f}):Pj(o,n.layoutBox,s)&&Jo(h=>{const d=i?n.measuredBox[h]:n.layoutBox[h],f=Do(s[h]);d.max=d.min+f,t.relativeTarget&&!t.currentAnimation&&(t.isProjectionDirty=!0,t.relativeTarget[h].max=t.relativeTarget[h].min+f)});const a=Od();wg(a,s,n.layoutBox);const u=Od();i?wg(u,t.applyTransform(r,!0),n.measuredBox):wg(u,s,n.layoutBox);const l=!Aj(a);let c=!1;if(!t.resumeFrom){const h=t.getClosestProjectingParent();if(h&&!h.resumeFrom){const{snapshot:d,layout:f}=h;if(d&&f){const m=ds();bg(m,n.layoutBox,d.layoutBox);const y=ds();bg(y,s,f.layoutBox),_j(m,y)||(c=!0),h.options.layoutRoot&&(t.relativeTarget=y,t.relativeTargetOrigin=m,t.relativeParent=h)}}}t.notifyListeners("didUpdate",{layout:s,snapshot:n,delta:u,layoutDelta:a,hasLayoutChanged:l,hasRelativeTargetChanged:c})}else if(t.isLead()){const{onExitComplete:s}=t.options;s&&s()}t.options.transition=void 0}function c4e(t){Cc.totalNodes++,t.parent&&(t.isProjecting()||(t.isProjectionDirty=t.parent.isProjectionDirty),t.isSharedProjectionDirty||(t.isSharedProjectionDirty=!!(t.isProjectionDirty||t.parent.isProjectionDirty||t.parent.isSharedProjectionDirty)),t.isTransformDirty||(t.isTransformDirty=t.parent.isTransformDirty))}function h4e(t){t.isProjectionDirty=t.isSharedProjectionDirty=t.isTransformDirty=!1}function d4e(t){t.clearSnapshot()}function xO(t){t.clearMeasurements()}function p4e(t){t.isLayoutDirty=!1}function f4e(t){const{visualElement:e}=t.options;e&&e.getProps().onBeforeLayoutMeasure&&e.notify("BeforeLayoutMeasure"),t.resetTransform()}function vO(t){t.finishAnimation(),t.targetDelta=t.relativeTarget=t.target=void 0,t.isProjectionDirty=!0}function m4e(t){t.resolveTargetDelta()}function g4e(t){t.calcProjection()}function y4e(t){t.resetRotation()}function x4e(t){t.removeLeadSnapshot()}function wO(t,e,n){t.translate=Gn(e.translate,0,n),t.scale=Gn(e.scale,1,n),t.origin=e.origin,t.originPoint=e.originPoint}function bO(t,e,n,s){t.min=Gn(e.min,n.min,s),t.max=Gn(e.max,n.max,s)}function v4e(t,e,n,s){bO(t.x,e.x,n.x,s),bO(t.y,e.y,n.y,s)}function w4e(t){return t.animationValues&&t.animationValues.opacityExit!==void 0}const b4e={duration:.45,ease:[.4,0,.1,1]},SO=t=>typeof navigator<"u"&&navigator.userAgent.toLowerCase().includes(t),CO=SO("applewebkit/")&&!SO("chrome/")?Math.round:Jn;function kO(t){t.min=CO(t.min),t.max=CO(t.max)}function S4e(t){kO(t.x),kO(t.y)}function Pj(t,e,n){return t==="position"||t==="preserve-aspect"&&!Y$(fO(e),fO(n),.2)}const C4e=Dj({attachResizeListener:(t,e)=>su(t,"resize",e),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),zk={current:void 0},Fj=Dj({measureScroll:t=>({x:t.scrollLeft,y:t.scrollTop}),defaultParent:()=>{if(!zk.current){const t=new C4e({});t.mount(window),t.setOptions({layoutScroll:!0}),zk.current=t}return zk.current},resetTransform:(t,e)=>{t.style.transform=e!==void 0?e:"none"},checkIsScrollRoot:t=>window.getComputedStyle(t).position==="fixed"}),k4e={pan:{Feature:BVe},drag:{Feature:zVe,ProjectionNode:Fj,MeasureLayout:Tj}},I4e=/var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;function $4e(t){const e=I4e.exec(t);if(!e)return[,];const[,n,s]=e;return[n,s]}function eN(t,e,n=1){const[s,r]=$4e(t);if(!s)return;const o=window.getComputedStyle(e).getPropertyValue(s);if(o){const i=o.trim();return yj(i)?parseFloat(i):i}else return U$(r)?eN(r,e,n+1):r}function N4e(t,{...e},n){const s=t.current;if(!(s instanceof Element))return{target:e,transitionEnd:n};n&&(n={...n}),t.values.forEach(r=>{const o=r.get();if(!U$(o))return;const i=eN(o,s);i&&r.set(i)});for(const r in e){const o=e[r];if(!U$(o))continue;const i=eN(o,s);i&&(e[r]=i,n||(n={}),n[r]===void 0&&(n[r]=o))}return{target:e,transitionEnd:n}}const T4e=new Set(["width","height","top","left","right","bottom","x","y","translateX","translateY"]),Oj=t=>T4e.has(t),E4e=t=>Object.keys(t).some(Oj),IO=t=>t===Fh||t===yt,$O=(t,e)=>parseFloat(t.split(", ")[e]),NO=(t,e)=>(n,{transform:s})=>{if(s==="none"||!s)return 0;const r=s.match(/^matrix3d\((.+)\)$/);if(r)return $O(r[1],e);{const o=s.match(/^matrix\((.+)\)$/);return o?$O(o[1],t):0}},R4e=new Set(["x","y","z"]),A4e=W0.filter(t=>!R4e.has(t));function _4e(t){const e=[];return A4e.forEach(n=>{const s=t.getValue(n);s!==void 0&&(e.push([n,s.get()]),s.set(n.startsWith("scale")?1:0))}),e.length&&t.render(),e}const Sp={width:({x:t},{paddingLeft:e="0",paddingRight:n="0"})=>t.max-t.min-parseFloat(e)-parseFloat(n),height:({y:t},{paddingTop:e="0",paddingBottom:n="0"})=>t.max-t.min-parseFloat(e)-parseFloat(n),top:(t,{top:e})=>parseFloat(e),left:(t,{left:e})=>parseFloat(e),bottom:({y:t},{top:e})=>parseFloat(e)+(t.max-t.min),right:({x:t},{left:e})=>parseFloat(e)+(t.max-t.min),x:NO(4,13),y:NO(5,14)};Sp.translateX=Sp.x;Sp.translateY=Sp.y;const D4e=(t,e,n)=>{const s=e.measureViewportBox(),r=e.current,o=getComputedStyle(r),{display:i}=o,a={};i==="none"&&e.setStaticValue("display",t.display||"block"),n.forEach(l=>{a[l]=Sp[l](s,o)}),e.render();const u=e.measureViewportBox();return n.forEach(l=>{const c=e.getValue(l);c&&c.jump(a[l]),t[l]=Sp[l](u,o)}),t},P4e=(t,e,n={},s={})=>{e={...e},s={...s};const r=Object.keys(e).filter(Oj);let o=[],i=!1;const a=[];if(r.forEach(u=>{const l=t.getValue(u);if(!t.hasValue(u))return;let c=n[u],h=jm(c);const d=e[u];let f;if(fw(d)){const m=d.length,y=d[0]===null?1:0;c=d[y],h=jm(c);for(let x=y;x<m&&d[x]!==null;x++)f?SR(jm(d[x])===f):f=jm(d[x])}else f=jm(d);if(h!==f)if(IO(h)&&IO(f)){const m=l.get();typeof m=="string"&&l.set(parseFloat(m)),typeof d=="string"?e[u]=parseFloat(d):Array.isArray(d)&&f===yt&&(e[u]=d.map(parseFloat))}else h!=null&&h.transform&&(f!=null&&f.transform)&&(c===0||d===0)?c===0?l.set(f.transform(c)):e[u]=h.transform(d):(i||(o=_4e(t),i=!0),a.push(u),s[u]=s[u]!==void 0?s[u]:e[u],l.jump(d))}),a.length){const u=a.indexOf("height")>=0?window.pageYOffset:null,l=D4e(e,t,a);return o.length&&o.forEach(([c,h])=>{t.getValue(c).set(h)}),t.render(),tC&&u!==null&&window.scrollTo({top:u}),{target:l,transitionEnd:s}}else return{target:e,transitionEnd:s}};function F4e(t,e,n,s){return E4e(e)?P4e(t,e,n,s):{target:e,transitionEnd:s}}const O4e=(t,e,n,s)=>{const r=N4e(t,e,s);return e=r.target,s=r.transitionEnd,F4e(t,e,n,s)},tN={current:null},Lj={current:!1};function L4e(){if(Lj.current=!0,!!tC)if(window.matchMedia){const t=window.matchMedia("(prefers-reduced-motion)"),e=()=>tN.current=t.matches;t.addListener(e),e()}else tN.current=!1}function M4e(t,e,n){const{willChange:s}=e;for(const r in e){const o=e[r],i=n[r];if(ho(o))t.addValue(r,o),xw(s)&&s.add(r);else if(ho(i))t.addValue(r,bp(o,{owner:t})),xw(s)&&s.remove(r);else if(i!==o)if(t.hasValue(r)){const a=t.getValue(r);!a.hasAnimated&&a.set(o)}else{const a=t.getStaticValue(r);t.addValue(r,bp(a!==void 0?a:o,{owner:t}))}}for(const r in n)e[r]===void 0&&t.removeValue(r);return e}const TO=new WeakMap,Mj=Object.keys(ly),z4e=Mj.length,EO=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"],B4e=fR.length;class V4e{constructor({parent:e,props:n,presenceContext:s,reducedMotionConfig:r,visualState:o},i={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.scheduleRender=()=>An.render(this.render,!1,!0);const{latestValues:a,renderState:u}=o;this.latestValues=a,this.baseTarget={...a},this.initialValues=n.initial?{...a}:{},this.renderState=u,this.parent=e,this.props=n,this.presenceContext=s,this.depth=e?e.depth+1:0,this.reducedMotionConfig=r,this.options=i,this.isControllingVariants=sC(n),this.isVariantNode=S6(n),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=!!(e&&e.current);const{willChange:l,...c}=this.scrapeMotionValuesFromProps(n,{});for(const h in c){const d=c[h];a[h]!==void 0&&ho(d)&&(d.set(a[h],!1),xw(l)&&l.add(h))}}scrapeMotionValuesFromProps(e,n){return{}}mount(e){this.current=e,TO.set(e,this),this.projection&&!this.projection.instance&&this.projection.mount(e),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((n,s)=>this.bindToMotionValue(s,n)),Lj.current||L4e(),this.shouldReduceMotion=this.reducedMotionConfig==="never"?!1:this.reducedMotionConfig==="always"?!0:tN.current,this.parent&&this.parent.children.add(this),this.update(this.props,this.presenceContext)}unmount(){TO.delete(this.current),this.projection&&this.projection.unmount(),wu(this.notifyUpdate),wu(this.render),this.valueSubscriptions.forEach(e=>e()),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent&&this.parent.children.delete(this);for(const e in this.events)this.events[e].clear();for(const e in this.features)this.features[e].unmount();this.current=null}bindToMotionValue(e,n){const s=Ph.has(e),r=n.on("change",i=>{this.latestValues[e]=i,this.props.onUpdate&&An.update(this.notifyUpdate,!1,!0),s&&this.projection&&(this.projection.isTransformDirty=!0)}),o=n.on("renderRequest",this.scheduleRender);this.valueSubscriptions.set(e,()=>{r(),o()})}sortNodePosition(e){return!this.current||!this.sortInstanceNodePosition||this.type!==e.type?0:this.sortInstanceNodePosition(this.current,e.current)}loadFeatures({children:e,...n},s,r,o){let i,a;for(let u=0;u<z4e;u++){const l=Mj[u],{isEnabled:c,Feature:h,ProjectionNode:d,MeasureLayout:f}=ly[l];d&&(i=d),c(n)&&(!this.features[l]&&h&&(this.features[l]=new h(this)),f&&(a=f))}if((this.type==="html"||this.type==="svg")&&!this.projection&&i){this.projection=new i(this.latestValues,this.parent&&this.parent.projection);const{layoutId:u,layout:l,drag:c,dragConstraints:h,layoutScroll:d,layoutRoot:f}=n;this.projection.setOptions({layoutId:u,layout:l,alwaysMeasureLayout:!!c||h&&Pd(h),visualElement:this,scheduleRender:()=>this.scheduleRender(),animationType:typeof l=="string"?l:"both",initialPromotionConfig:o,layoutScroll:d,layoutRoot:f})}return a}updateFeatures(){for(const e in this.features){const n=this.features[e];n.isMounted?n.update():(n.mount(),n.isMounted=!0)}}triggerBuild(){this.build(this.renderState,this.latestValues,this.options,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):ds()}getStaticValue(e){return this.latestValues[e]}setStaticValue(e,n){this.latestValues[e]=n}makeTargetAnimatable(e,n=!0){return this.makeTargetAnimatableFromInstance(e,this.props,n)}update(e,n){(e.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=e,this.prevPresenceContext=this.presenceContext,this.presenceContext=n;for(let s=0;s<EO.length;s++){const r=EO[s];this.propEventSubscriptions[r]&&(this.propEventSubscriptions[r](),delete this.propEventSubscriptions[r]);const o=e["on"+r];o&&(this.propEventSubscriptions[r]=this.on(r,o))}this.prevMotionValues=M4e(this,this.scrapeMotionValuesFromProps(e,this.prevProps),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(e){return this.props.variants?this.props.variants[e]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}getVariantContext(e=!1){if(e)return this.parent?this.parent.getVariantContext():void 0;if(!this.isControllingVariants){const s=this.parent?this.parent.getVariantContext()||{}:{};return this.props.initial!==void 0&&(s.initial=this.props.initial),s}const n={};for(let s=0;s<B4e;s++){const r=fR[s],o=this.props[r];(uy(o)||o===!1)&&(n[r]=o)}return n}addVariantChild(e){const n=this.getClosestVariantNode();if(n)return n.variantChildren&&n.variantChildren.add(e),()=>n.variantChildren.delete(e)}addValue(e,n){n!==this.values.get(e)&&(this.removeValue(e),this.bindToMotionValue(e,n)),this.values.set(e,n),this.latestValues[e]=n.get()}removeValue(e){this.values.delete(e);const n=this.valueSubscriptions.get(e);n&&(n(),this.valueSubscriptions.delete(e)),delete this.latestValues[e],this.removeValueFromRenderState(e,this.renderState)}hasValue(e){return this.values.has(e)}getValue(e,n){if(this.props.values&&this.props.values[e])return this.props.values[e];let s=this.values.get(e);return s===void 0&&n!==void 0&&(s=bp(n,{owner:this}),this.addValue(e,s)),s}readValue(e){var n;return this.latestValues[e]!==void 0||!this.current?this.latestValues[e]:(n=this.getBaseTargetFromProps(this.props,e))!==null&&n!==void 0?n:this.readValueFromInstance(this.current,e,this.options)}setBaseTarget(e,n){this.baseTarget[e]=n}getBaseTarget(e){var n;const{initial:s}=this.props,r=typeof s=="string"||typeof s=="object"?(n=bR(this.props,s))===null||n===void 0?void 0:n[e]:void 0;if(s&&r!==void 0)return r;const o=this.getBaseTargetFromProps(this.props,e);return o!==void 0&&!ho(o)?o:this.initialValues[e]!==void 0&&r===void 0?void 0:this.baseTarget[e]}on(e,n){return this.events[e]||(this.events[e]=new AR),this.events[e].add(n)}notify(e,...n){this.events[e]&&this.events[e].notify(...n)}}class zj extends V4e{sortInstanceNodePosition(e,n){return e.compareDocumentPosition(n)&2?1:-1}getBaseTargetFromProps(e,n){return e.style?e.style[n]:void 0}removeValueFromRenderState(e,{vars:n,style:s}){delete n[e],delete s[e]}makeTargetAnimatableFromInstance({transition:e,transitionEnd:n,...s},{transformValues:r},o){let i=rVe(s,e||{},this);if(r&&(n&&(n=r(n)),s&&(s=r(s)),i&&(i=r(i))),o){nVe(this,s,i);const a=O4e(this,s,i,n);n=a.transitionEnd,s=a.target}return{transition:e,transitionEnd:n,...s}}}function W4e(t){return window.getComputedStyle(t)}class U4e extends zj{constructor(){super(...arguments),this.type="html"}readValueFromInstance(e,n){if(Ph.has(n)){const s=$R(n);return s&&s.default||0}else{const s=W4e(e),r=(N6(n)?s.getPropertyValue(n):s[n])||0;return typeof r=="string"?r.trim():r}}measureInstanceViewportBox(e,{transformPagePoint:n}){return $j(e,n)}build(e,n,s,r){gR(e,n,s,r.transformTemplate)}scrapeMotionValuesFromProps(e,n){return wR(e,n)}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children:e}=this.props;ho(e)&&(this.childSubscription=e.on("change",n=>{this.current&&(this.current.textContent=`${n}`)}))}renderInstance(e,n,s,r){D6(e,n,s,r)}}class G4e extends zj{constructor(){super(...arguments),this.type="svg",this.isSVGTag=!1}getBaseTargetFromProps(e,n){return e[n]}readValueFromInstance(e,n){if(Ph.has(n)){const s=$R(n);return s&&s.default||0}return n=P6.has(n)?n:dR(n),e.getAttribute(n)}measureInstanceViewportBox(){return ds()}scrapeMotionValuesFromProps(e,n){return O6(e,n)}build(e,n,s,r){xR(e,n,s,this.isSVGTag,r.transformTemplate)}renderInstance(e,n,s,r){F6(e,n,s,r)}mount(e){this.isSVGTag=vR(e.tagName),super.mount(e)}}const H4e=(t,e)=>mR(t)?new G4e(e,{enableHardwareAcceleration:!1}):new U4e(e,{enableHardwareAcceleration:!0}),j4e={layout:{ProjectionNode:Fj,MeasureLayout:Tj}},K4e={...vVe,...zze,...k4e,...j4e},X4e=KMe((t,e)=>$ze(t,e,K4e,H4e));var ww={exports:{}};/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ww.exports;(function(t,e){(function(){var n,s="4.17.21",r=200,o="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",i="Expected a function",a="Invalid `variable` option passed into `_.template`",u="__lodash_hash_undefined__",l=500,c="__lodash_placeholder__",h=1,d=2,f=4,m=1,y=2,x=1,v=2,w=4,S=8,k=16,I=32,T=64,R=128,_=256,D=512,L=30,V="...",U=800,j=16,q=1,J=2,te=3,le=1/0,K=9007199254740991,re=17976931348623157e292,pe=NaN,he=4294967295,xe=he-1,Ce=he>>>1,Ee=[["ary",R],["bind",x],["bindKey",v],["curry",S],["curryRight",k],["flip",D],["partial",I],["partialRight",T],["rearg",_]],Ie="[object Arguments]",ke="[object Array]",Ae="[object AsyncFunction]",Ke="[object Boolean]",je="[object Date]",rt="[object DOMException]",tt="[object Error]",Et="[object Function]",lt="[object GeneratorFunction]",at="[object Map]",Lt="[object Number]",qt="[object Null]",Ft="[object Object]",Zt="[object Promise]",Wr="[object Proxy]",yn="[object RegExp]",Mn="[object Set]",zn="[object String]",vr="[object Symbol]",rs="[object Undefined]",Ps="[object WeakMap]",wr="[object WeakSet]",Fs="[object ArrayBuffer]",Gs="[object DataView]",Bo="[object Float32Array]",_a="[object Float64Array]",Ji="[object Int8Array]",$u="[object Int16Array]",Ur="[object Int32Array]",Da="[object Uint8Array]",Nu="[object Uint8ClampedArray]",Uf="[object Uint16Array]",Oh="[object Uint32Array]",Gf=/\b__p \+= '';/g,Pa=/\b(__p \+=) '' \+/g,Kl=/(__e\(.*?\)|\b__t\)) \+\n'';/g,Hf=/&(?:amp|lt|gt|quot|#39);/g,jf=/[&<>"']/g,Kf=RegExp(Hf.source),j0=RegExp(jf.source),Fa=/<%-([\s\S]+?)%>/g,Xf=/<%([\s\S]+?)%>/g,qf=/<%=([\s\S]+?)%>/g,Lh=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,Mh=/^\w*$/,aC=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,ea=/[\\^$.*+?()[\]{}|]/g,uC=RegExp(ea.source),go=/^\s+/,Oa=/\s/,K0=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,Bn=/\{\n\/\* \[wrapped with (.+)\] \*/,Vo=/,? & /,Yf=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,lC=/[()=,{}\[\]\/\s]/,zh=/\\(\\)?/g,Qf=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,Xl=/\w*$/,ql=/^[-+]0x[0-9a-f]+$/i,X0=/^0b[01]+$/i,Zf=/^\[object .+?Constructor\]$/,Jf=/^0o[0-7]+$/i,q0=/^(?:0|[1-9]\d*)$/,yo=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,br=/($^)/,Yl=/['\n\r\u2028\u2029\\]/g,Tu="\\ud800-\\udfff",em="\\u0300-\\u036f",Y0="\\ufe20-\\ufe2f",tm="\\u20d0-\\u20ff",xo=em+Y0+tm,nm="\\u2700-\\u27bf",Ql="a-z\\xdf-\\xf6\\xf8-\\xff",Wo="\\xac\\xb1\\xd7\\xf7",Bh="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",cC="\\u2000-\\u206f",Q0=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",Vh="A-Z\\xc0-\\xd6\\xd8-\\xde",Z0="\\ufe0e\\ufe0f",J0=Wo+Bh+cC+Q0,Wh="[']",ex="["+Tu+"]",sm="["+J0+"]",Zl="["+xo+"]",Hs="\\d+",tx="["+nm+"]",rm="["+Ql+"]",Jl="[^"+Tu+J0+Hs+nm+Ql+Vh+"]",Uh="\\ud83c[\\udffb-\\udfff]",nx="(?:"+Zl+"|"+Uh+")",sx="[^"+Tu+"]",om="(?:\\ud83c[\\udde6-\\uddff]){2}",Gh="[\\ud800-\\udbff][\\udc00-\\udfff]",La="["+Vh+"]",ec="\\u200d",im="(?:"+rm+"|"+Jl+")",rx="(?:"+La+"|"+Jl+")",Eu="(?:"+Wh+"(?:d|ll|m|re|s|t|ve))?",ox="(?:"+Wh+"(?:D|LL|M|RE|S|T|VE))?",ix=nx+"?",ax="["+Z0+"]?",hC="(?:"+ec+"(?:"+[sx,om,Gh].join("|")+")"+ax+ix+")*",am="\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",tc="\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",ux=ax+ix+hC,dC="(?:"+[tx,om,Gh].join("|")+")"+ux,pC="(?:"+[sx+Zl+"?",Zl,om,Gh,ex].join("|")+")",fC=RegExp(Wh,"g"),um=RegExp(Zl,"g"),Hh=RegExp(Uh+"(?="+Uh+")|"+pC+ux,"g"),lx=RegExp([La+"?"+rm+"+"+Eu+"(?="+[sm,La,"$"].join("|")+")",rx+"+"+ox+"(?="+[sm,La+im,"$"].join("|")+")",La+"?"+im+"+"+Eu,La+"+"+ox,tc,am,Hs,dC].join("|"),"g"),nc=RegExp("["+ec+Tu+xo+Z0+"]"),vo=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,mC=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],gC=-1,hn={};hn[Bo]=hn[_a]=hn[Ji]=hn[$u]=hn[Ur]=hn[Da]=hn[Nu]=hn[Uf]=hn[Oh]=!0,hn[Ie]=hn[ke]=hn[Fs]=hn[Ke]=hn[Gs]=hn[je]=hn[tt]=hn[Et]=hn[at]=hn[Lt]=hn[Ft]=hn[yn]=hn[Mn]=hn[zn]=hn[Ps]=!1;var rn={};rn[Ie]=rn[ke]=rn[Fs]=rn[Gs]=rn[Ke]=rn[je]=rn[Bo]=rn[_a]=rn[Ji]=rn[$u]=rn[Ur]=rn[at]=rn[Lt]=rn[Ft]=rn[yn]=rn[Mn]=rn[zn]=rn[vr]=rn[Da]=rn[Nu]=rn[Uf]=rn[Oh]=!0,rn[tt]=rn[Et]=rn[Ps]=!1;var lm={:"A",:"A",:"A",:"A",:"A",:"A",:"a",:"a",:"a",:"a",:"a",:"a",:"C",:"c",:"D",:"d",:"E",:"E",:"E",:"E",:"e",:"e",:"e",:"e",:"I",:"I",:"I",:"I",:"i",:"i",:"i",:"i",:"N",:"n",:"O",:"O",:"O",:"O",:"O",:"O",:"o",:"o",:"o",:"o",:"o",:"o",:"U",:"U",:"U",:"U",:"u",:"u",:"u",:"u",:"Y",:"y",:"y",:"Ae",:"ae",:"Th",:"th",:"ss",:"A",:"A",:"A",:"a",:"a",:"a",:"C",:"C",:"C",:"C",:"c",:"c",:"c",:"c",:"D",:"D",:"d",:"d",:"E",:"E",:"E",:"E",:"E",:"e",:"e",:"e",:"e",:"e",:"G",:"G",:"G",:"G",:"g",:"g",:"g",:"g",:"H",:"H",:"h",:"h",:"I",:"I",:"I",:"I",:"I",:"i",:"i",:"i",:"i",:"i",:"J",:"j",:"K",:"k",:"k",:"L",:"L",:"L",:"L",:"L",:"l",:"l",:"l",:"l",:"l",:"N",:"N",:"N",:"N",:"n",:"n",:"n",:"n",:"O",:"O",:"O",:"o",:"o",:"o",:"R",:"R",:"R",:"r",:"r",:"r",:"S",:"S",:"S",:"S",:"s",:"s",:"s",:"s",:"T",:"T",:"T",:"t",:"t",:"t",:"U",:"U",:"U",:"U",:"U",:"U",:"u",:"u",:"u",:"u",:"u",:"u",:"W",:"w",:"Y",:"y",:"Y",:"Z",:"Z",:"Z",:"z",:"z",:"z",:"IJ",:"ij",:"Oe",:"oe",:"'n",:"s"},cm={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},Ru={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"},cx={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},hm=parseFloat,yC=parseInt,hx=typeof Rr=="object"&&Rr&&Rr.Object===Object&&Rr,sc=typeof self=="object"&&self&&self.Object===Object&&self,hs=hx||sc||Function("return this")(),jh=e&&!e.nodeType&&e,Ma=jh&&!0&&t&&!t.nodeType&&t,dx=Ma&&Ma.exports===jh,Au=dx&&hx.process,Sr=function(){try{var ue=Ma&&Ma.require&&Ma.require("util").types;return ue||Au&&Au.binding&&Au.binding("util")}catch{}}(),px=Sr&&Sr.isArrayBuffer,dm=Sr&&Sr.isDate,fx=Sr&&Sr.isMap,mx=Sr&&Sr.isRegExp,Kh=Sr&&Sr.isSet,Xh=Sr&&Sr.isTypedArray;function tr(ue,ve,ge){switch(ge.length){case 0:return ue.call(ve);case 1:return ue.call(ve,ge[0]);case 2:return ue.call(ve,ge[0],ge[1]);case 3:return ue.call(ve,ge[0],ge[1],ge[2])}return ue.apply(ve,ge)}function xC(ue,ve,ge,Xe){for(var wt=-1,Jt=ue==null?0:ue.length;++wt<Jt;){var Is=ue[wt];ve(Xe,Is,ge(Is),ue)}return Xe}function Gr(ue,ve){for(var ge=-1,Xe=ue==null?0:ue.length;++ge<Xe&&ve(ue[ge],ge,ue)!==!1;);return ue}function vC(ue,ve){for(var ge=ue==null?0:ue.length;ge--&&ve(ue[ge],ge,ue)!==!1;);return ue}function gx(ue,ve){for(var ge=-1,Xe=ue==null?0:ue.length;++ge<Xe;)if(!ve(ue[ge],ge,ue))return!1;return!0}function Ci(ue,ve){for(var ge=-1,Xe=ue==null?0:ue.length,wt=0,Jt=[];++ge<Xe;){var Is=ue[ge];ve(Is,ge,ue)&&(Jt[wt++]=Is)}return Jt}function qh(ue,ve){var ge=ue==null?0:ue.length;return!!ge&&b(ue,ve,0)>-1}function pm(ue,ve,ge){for(var Xe=-1,wt=ue==null?0:ue.length;++Xe<wt;)if(ge(ve,ue[Xe]))return!0;return!1}function dn(ue,ve){for(var ge=-1,Xe=ue==null?0:ue.length,wt=Array(Xe);++ge<Xe;)wt[ge]=ve(ue[ge],ge,ue);return wt}function ta(ue,ve){for(var ge=-1,Xe=ve.length,wt=ue.length;++ge<Xe;)ue[wt+ge]=ve[ge];return ue}function fm(ue,ve,ge,Xe){var wt=-1,Jt=ue==null?0:ue.length;for(Xe&&Jt&&(ge=ue[++wt]);++wt<Jt;)ge=ve(ge,ue[wt],wt,ue);return ge}function wC(ue,ve,ge,Xe){var wt=ue==null?0:ue.length;for(Xe&&wt&&(ge=ue[--wt]);wt--;)ge=ve(ge,ue[wt],wt,ue);return ge}function _u(ue,ve){for(var ge=-1,Xe=ue==null?0:ue.length;++ge<Xe;)if(ve(ue[ge],ge,ue))return!0;return!1}var bC=W("length");function SC(ue){return ue.split("")}function CC(ue){return ue.match(Yf)||[]}function mm(ue,ve,ge){var Xe;return ge(ue,function(wt,Jt,Is){if(ve(wt,Jt,Is))return Xe=Jt,!1}),Xe}function rc(ue,ve,ge,Xe){for(var wt=ue.length,Jt=ge+(Xe?1:-1);Xe?Jt--:++Jt<wt;)if(ve(ue[Jt],Jt,ue))return Jt;return-1}function b(ue,ve,ge){return ve===ve?Bj(ue,ve,ge):rc(ue,A,ge)}function $(ue,ve,ge,Xe){for(var wt=ge-1,Jt=ue.length;++wt<Jt;)if(Xe(ue[wt],ve))return wt;return-1}function A(ue){return ue!==ue}function F(ue,ve){var ge=ue==null?0:ue.length;return ge?me(ue,ve)/ge:pe}function W(ue){return function(ve){return ve==null?n:ve[ue]}}function H(ue){return function(ve){return ue==null?n:ue[ve]}}function G(ue,ve,ge,Xe,wt){return wt(ue,function(Jt,Is,xn){ge=Xe?(Xe=!1,Jt):ve(ge,Jt,Is,xn)}),ge}function oe(ue,ve){var ge=ue.length;for(ue.sort(ve);ge--;)ue[ge]=ue[ge].value;return ue}function me(ue,ve){for(var ge,Xe=-1,wt=ue.length;++Xe<wt;){var Jt=ve(ue[Xe]);Jt!==n&&(ge=ge===n?Jt:ge+Jt)}return ge}function Te(ue,ve){for(var ge=-1,Xe=Array(ue);++ge<ue;)Xe[ge]=ve(ge);return Xe}function Oe(ue,ve){return dn(ve,function(ge){return[ge,ue[ge]]})}function ct(ue){return ue&&ue.slice(0,DR(ue)+1).replace(go,"")}function He(ue){return function(ve){return ue(ve)}}function ze(ue,ve){return dn(ve,function(ge){return ue[ge]})}function it(ue,ve){return ue.has(ve)}function It(ue,ve){for(var ge=-1,Xe=ue.length;++ge<Xe&&b(ve,ue[ge],0)>-1;);return ge}function pn(ue,ve){for(var ge=ue.length;ge--&&b(ve,ue[ge],0)>-1;);return ge}function fn(ue,ve){for(var ge=ue.length,Xe=0;ge--;)ue[ge]===ve&&++Xe;return Xe}var ks=H(lm),Hr=H(cm);function nr(ue){return"\\"+cx[ue]}function Kt(ue,ve){return ue==null?n:ue[ve]}function Dn(ue){return nc.test(ue)}function na(ue){return vo.test(ue)}function kC(ue){for(var ve,ge=[];!(ve=ue.next()).done;)ge.push(ve.value);return ge}function gm(ue){var ve=-1,ge=Array(ue.size);return ue.forEach(function(Xe,wt){ge[++ve]=[wt,Xe]}),ge}function yx(ue,ve){return function(ge){return ue(ve(ge))}}function sa(ue,ve){for(var ge=-1,Xe=ue.length,wt=0,Jt=[];++ge<Xe;){var Is=ue[ge];(Is===ve||Is===c)&&(ue[ge]=c,Jt[wt++]=ge)}return Jt}function Yh(ue){var ve=-1,ge=Array(ue.size);return ue.forEach(function(Xe){ge[++ve]=Xe}),ge}function Qh(ue){var ve=-1,ge=Array(ue.size);return ue.forEach(function(Xe){ge[++ve]=[Xe,Xe]}),ge}function Bj(ue,ve,ge){for(var Xe=ge-1,wt=ue.length;++Xe<wt;)if(ue[Xe]===ve)return Xe;return-1}function Vj(ue,ve,ge){for(var Xe=ge+1;Xe--;)if(ue[Xe]===ve)return Xe;return Xe}function Zh(ue){return Dn(ue)?Uj(ue):bC(ue)}function ki(ue){return Dn(ue)?Gj(ue):SC(ue)}function DR(ue){for(var ve=ue.length;ve--&&Oa.test(ue.charAt(ve)););return ve}var Wj=H(Ru);function Uj(ue){for(var ve=Hh.lastIndex=0;Hh.test(ue);)++ve;return ve}function Gj(ue){return ue.match(Hh)||[]}function Hj(ue){return ue.match(lx)||[]}var jj=function ue(ve){ve=ve==null?hs:Jh.defaults(hs.Object(),ve,Jh.pick(hs,mC));var ge=ve.Array,Xe=ve.Date,wt=ve.Error,Jt=ve.Function,Is=ve.Math,xn=ve.Object,IC=ve.RegExp,Kj=ve.String,Uo=ve.TypeError,xx=ge.prototype,Xj=Jt.prototype,ed=xn.prototype,vx=ve["__core-js_shared__"],wx=Xj.toString,on=ed.hasOwnProperty,qj=0,PR=function(){var p=/[^.]+$/.exec(vx&&vx.keys&&vx.keys.IE_PROTO||"");return p?"Symbol(src)_1."+p:""}(),bx=ed.toString,Yj=wx.call(xn),Qj=hs._,Zj=IC("^"+wx.call(on).replace(ea,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Sx=dx?ve.Buffer:n,Du=ve.Symbol,Cx=ve.Uint8Array,FR=Sx?Sx.allocUnsafe:n,kx=yx(xn.getPrototypeOf,xn),OR=xn.create,LR=ed.propertyIsEnumerable,Ix=xx.splice,MR=Du?Du.isConcatSpreadable:n,ym=Du?Du.iterator:n,oc=Du?Du.toStringTag:n,$x=function(){try{var p=cc(xn,"defineProperty");return p({},"",{}),p}catch{}}(),Jj=ve.clearTimeout!==hs.clearTimeout&&ve.clearTimeout,e5=Xe&&Xe.now!==hs.Date.now&&Xe.now,t5=ve.setTimeout!==hs.setTimeout&&ve.setTimeout,Nx=Is.ceil,Tx=Is.floor,$C=xn.getOwnPropertySymbols,n5=Sx?Sx.isBuffer:n,zR=ve.isFinite,s5=xx.join,r5=yx(xn.keys,xn),$s=Is.max,sr=Is.min,o5=Xe.now,i5=ve.parseInt,BR=Is.random,a5=xx.reverse,NC=cc(ve,"DataView"),xm=cc(ve,"Map"),TC=cc(ve,"Promise"),td=cc(ve,"Set"),vm=cc(ve,"WeakMap"),wm=cc(xn,"create"),Ex=vm&&new vm,nd={},u5=hc(NC),l5=hc(xm),c5=hc(TC),h5=hc(td),d5=hc(vm),Rx=Du?Du.prototype:n,bm=Rx?Rx.valueOf:n,VR=Rx?Rx.toString:n;function z(p){if(Yn(p)&&!St(p)&&!(p instanceof Mt)){if(p instanceof Go)return p;if(on.call(p,"__wrapped__"))return WA(p)}return new Go(p)}var sd=function(){function p(){}return function(g){if(!Vn(g))return{};if(OR)return OR(g);p.prototype=g;var C=new p;return p.prototype=n,C}}();function Ax(){}function Go(p,g){this.__wrapped__=p,this.__actions__=[],this.__chain__=!!g,this.__index__=0,this.__values__=n}z.templateSettings={escape:Fa,evaluate:Xf,interpolate:qf,variable:"",imports:{_:z}},z.prototype=Ax.prototype,z.prototype.constructor=z,Go.prototype=sd(Ax.prototype),Go.prototype.constructor=Go;function Mt(p){this.__wrapped__=p,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=he,this.__views__=[]}function p5(){var p=new Mt(this.__wrapped__);return p.__actions__=jr(this.__actions__),p.__dir__=this.__dir__,p.__filtered__=this.__filtered__,p.__iteratees__=jr(this.__iteratees__),p.__takeCount__=this.__takeCount__,p.__views__=jr(this.__views__),p}function f5(){if(this.__filtered__){var p=new Mt(this);p.__dir__=-1,p.__filtered__=!0}else p=this.clone(),p.__dir__*=-1;return p}function m5(){var p=this.__wrapped__.value(),g=this.__dir__,C=St(p),N=g<0,P=C?p.length:0,B=NK(0,P,this.__views__),X=B.start,ne=B.end,de=ne-X,be=N?ne:X-1,Se=this.__iteratees__,Ne=Se.length,We=0,st=sr(de,this.__takeCount__);if(!C||!N&&P==de&&st==de)return hA(p,this.__actions__);var dt=[];e:for(;de--&&We<st;){be+=g;for(var Rt=-1,pt=p[be];++Rt<Ne;){var Ot=Se[Rt],Gt=Ot.iteratee,So=Ot.type,Ir=Gt(pt);if(So==J)pt=Ir;else if(!Ir){if(So==q)continue e;break e}}dt[We++]=pt}return dt}Mt.prototype=sd(Ax.prototype),Mt.prototype.constructor=Mt;function ic(p){var g=-1,C=p==null?0:p.length;for(this.clear();++g<C;){var N=p[g];this.set(N[0],N[1])}}function g5(){this.__data__=wm?wm(null):{},this.size=0}function y5(p){var g=this.has(p)&&delete this.__data__[p];return this.size-=g?1:0,g}function x5(p){var g=this.__data__;if(wm){var C=g[p];return C===u?n:C}return on.call(g,p)?g[p]:n}function v5(p){var g=this.__data__;return wm?g[p]!==n:on.call(g,p)}function w5(p,g){var C=this.__data__;return this.size+=this.has(p)?0:1,C[p]=wm&&g===n?u:g,this}ic.prototype.clear=g5,ic.prototype.delete=y5,ic.prototype.get=x5,ic.prototype.has=v5,ic.prototype.set=w5;function za(p){var g=-1,C=p==null?0:p.length;for(this.clear();++g<C;){var N=p[g];this.set(N[0],N[1])}}function b5(){this.__data__=[],this.size=0}function S5(p){var g=this.__data__,C=_x(g,p);if(C<0)return!1;var N=g.length-1;return C==N?g.pop():Ix.call(g,C,1),--this.size,!0}function C5(p){var g=this.__data__,C=_x(g,p);return C<0?n:g[C][1]}function k5(p){return _x(this.__data__,p)>-1}function I5(p,g){var C=this.__data__,N=_x(C,p);return N<0?(++this.size,C.push([p,g])):C[N][1]=g,this}za.prototype.clear=b5,za.prototype.delete=S5,za.prototype.get=C5,za.prototype.has=k5,za.prototype.set=I5;function Ba(p){var g=-1,C=p==null?0:p.length;for(this.clear();++g<C;){var N=p[g];this.set(N[0],N[1])}}function $5(){this.size=0,this.__data__={hash:new ic,map:new(xm||za),string:new ic}}function N5(p){var g=Gx(this,p).delete(p);return this.size-=g?1:0,g}function T5(p){return Gx(this,p).get(p)}function E5(p){return Gx(this,p).has(p)}function R5(p,g){var C=Gx(this,p),N=C.size;return C.set(p,g),this.size+=C.size==N?0:1,this}Ba.prototype.clear=$5,Ba.prototype.delete=N5,Ba.prototype.get=T5,Ba.prototype.has=E5,Ba.prototype.set=R5;function ac(p){var g=-1,C=p==null?0:p.length;for(this.__data__=new Ba;++g<C;)this.add(p[g])}function A5(p){return this.__data__.set(p,u),this}function _5(p){return this.__data__.has(p)}ac.prototype.add=ac.prototype.push=A5,ac.prototype.has=_5;function Ii(p){var g=this.__data__=new za(p);this.size=g.size}function D5(){this.__data__=new za,this.size=0}function P5(p){var g=this.__data__,C=g.delete(p);return this.size=g.size,C}function F5(p){return this.__data__.get(p)}function O5(p){return this.__data__.has(p)}function L5(p,g){var C=this.__data__;if(C instanceof za){var N=C.__data__;if(!xm||N.length<r-1)return N.push([p,g]),this.size=++C.size,this;C=this.__data__=new Ba(N)}return C.set(p,g),this.size=C.size,this}Ii.prototype.clear=D5,Ii.prototype.delete=P5,Ii.prototype.get=F5,Ii.prototype.has=O5,Ii.prototype.set=L5;function WR(p,g){var C=St(p),N=!C&&dc(p),P=!C&&!N&&Mu(p),B=!C&&!N&&!P&&ad(p),X=C||N||P||B,ne=X?Te(p.length,Kj):[],de=ne.length;for(var be in p)(g||on.call(p,be))&&!(X&&(be=="length"||P&&(be=="offset"||be=="parent")||B&&(be=="buffer"||be=="byteLength"||be=="byteOffset")||Ga(be,de)))&&ne.push(be);return ne}function UR(p){var g=p.length;return g?p[zC(0,g-1)]:n}function M5(p,g){return Hx(jr(p),uc(g,0,p.length))}function z5(p){return Hx(jr(p))}function EC(p,g,C){(C!==n&&!$i(p[g],C)||C===n&&!(g in p))&&Va(p,g,C)}function Sm(p,g,C){var N=p[g];(!(on.call(p,g)&&$i(N,C))||C===n&&!(g in p))&&Va(p,g,C)}function _x(p,g){for(var C=p.length;C--;)if($i(p[C][0],g))return C;return-1}function B5(p,g,C,N){return Pu(p,function(P,B,X){g(N,P,C(P),X)}),N}function GR(p,g){return p&&oa(g,Os(g),p)}function V5(p,g){return p&&oa(g,Xr(g),p)}function Va(p,g,C){g=="__proto__"&&$x?$x(p,g,{configurable:!0,enumerable:!0,value:C,writable:!0}):p[g]=C}function RC(p,g){for(var C=-1,N=g.length,P=ge(N),B=p==null;++C<N;)P[C]=B?n:c2(p,g[C]);return P}function uc(p,g,C){return p===p&&(C!==n&&(p=p<=C?p:C),g!==n&&(p=p>=g?p:g)),p}function Ho(p,g,C,N,P,B){var X,ne=g&h,de=g&d,be=g&f;if(C&&(X=P?C(p,N,P,B):C(p)),X!==n)return X;if(!Vn(p))return p;var Se=St(p);if(Se){if(X=EK(p),!ne)return jr(p,X)}else{var Ne=rr(p),We=Ne==Et||Ne==lt;if(Mu(p))return fA(p,ne);if(Ne==Ft||Ne==Ie||We&&!P){if(X=de||We?{}:DA(p),!ne)return de?xK(p,V5(X,p)):yK(p,GR(X,p))}else{if(!rn[Ne])return P?p:{};X=RK(p,Ne,ne)}}B||(B=new Ii);var st=B.get(p);if(st)return st;B.set(p,X),u_(p)?p.forEach(function(pt){X.add(Ho(pt,g,C,pt,p,B))}):i_(p)&&p.forEach(function(pt,Ot){X.set(Ot,Ho(pt,g,C,Ot,p,B))});var dt=be?de?YC:qC:de?Xr:Os,Rt=Se?n:dt(p);return Gr(Rt||p,function(pt,Ot){Rt&&(Ot=pt,pt=p[Ot]),Sm(X,Ot,Ho(pt,g,C,Ot,p,B))}),X}function W5(p){var g=Os(p);return function(C){return HR(C,p,g)}}function HR(p,g,C){var N=C.length;if(p==null)return!N;for(p=xn(p);N--;){var P=C[N],B=g[P],X=p[P];if(X===n&&!(P in p)||!B(X))return!1}return!0}function jR(p,g,C){if(typeof p!="function")throw new Uo(i);return Em(function(){p.apply(n,C)},g)}function Cm(p,g,C,N){var P=-1,B=qh,X=!0,ne=p.length,de=[],be=g.length;if(!ne)return de;C&&(g=dn(g,He(C))),N?(B=pm,X=!1):g.length>=r&&(B=it,X=!1,g=new ac(g));e:for(;++P<ne;){var Se=p[P],Ne=C==null?Se:C(Se);if(Se=N||Se!==0?Se:0,X&&Ne===Ne){for(var We=be;We--;)if(g[We]===Ne)continue e;de.push(Se)}else B(g,Ne,N)||de.push(Se)}return de}var Pu=vA(ra),KR=vA(_C,!0);function U5(p,g){var C=!0;return Pu(p,function(N,P,B){return C=!!g(N,P,B),C}),C}function Dx(p,g,C){for(var N=-1,P=p.length;++N<P;){var B=p[N],X=g(B);if(X!=null&&(ne===n?X===X&&!bo(X):C(X,ne)))var ne=X,de=B}return de}function G5(p,g,C,N){var P=p.length;for(C=Nt(C),C<0&&(C=-C>P?0:P+C),N=N===n||N>P?P:Nt(N),N<0&&(N+=P),N=C>N?0:c_(N);C<N;)p[C++]=g;return p}function XR(p,g){var C=[];return Pu(p,function(N,P,B){g(N,P,B)&&C.push(N)}),C}function js(p,g,C,N,P){var B=-1,X=p.length;for(C||(C=_K),P||(P=[]);++B<X;){var ne=p[B];g>0&&C(ne)?g>1?js(ne,g-1,C,N,P):ta(P,ne):N||(P[P.length]=ne)}return P}var AC=wA(),qR=wA(!0);function ra(p,g){return p&&AC(p,g,Os)}function _C(p,g){return p&&qR(p,g,Os)}function Px(p,g){return Ci(g,function(C){return Ha(p[C])})}function lc(p,g){g=Ou(g,p);for(var C=0,N=g.length;p!=null&&C<N;)p=p[ia(g[C++])];return C&&C==N?p:n}function YR(p,g,C){var N=g(p);return St(p)?N:ta(N,C(p))}function Cr(p){return p==null?p===n?rs:qt:oc&&oc in xn(p)?$K(p):zK(p)}function DC(p,g){return p>g}function H5(p,g){return p!=null&&on.call(p,g)}function j5(p,g){return p!=null&&g in xn(p)}function K5(p,g,C){return p>=sr(g,C)&&p<$s(g,C)}function PC(p,g,C){for(var N=C?pm:qh,P=p[0].length,B=p.length,X=B,ne=ge(B),de=1/0,be=[];X--;){var Se=p[X];X&&g&&(Se=dn(Se,He(g))),de=sr(Se.length,de),ne[X]=!C&&(g||P>=120&&Se.length>=120)?new ac(X&&Se):n}Se=p[0];var Ne=-1,We=ne[0];e:for(;++Ne<P&&be.length<de;){var st=Se[Ne],dt=g?g(st):st;if(st=C||st!==0?st:0,!(We?it(We,dt):N(be,dt,C))){for(X=B;--X;){var Rt=ne[X];if(!(Rt?it(Rt,dt):N(p[X],dt,C)))continue e}We&&We.push(dt),be.push(st)}}return be}function X5(p,g,C,N){return ra(p,function(P,B,X){g(N,C(P),B,X)}),N}function km(p,g,C){g=Ou(g,p),p=LA(p,g);var N=p==null?p:p[ia(Ko(g))];return N==null?n:tr(N,p,C)}function QR(p){return Yn(p)&&Cr(p)==Ie}function q5(p){return Yn(p)&&Cr(p)==Fs}function Y5(p){return Yn(p)&&Cr(p)==je}function Im(p,g,C,N,P){return p===g?!0:p==null||g==null||!Yn(p)&&!Yn(g)?p!==p&&g!==g:Q5(p,g,C,N,Im,P)}function Q5(p,g,C,N,P,B){var X=St(p),ne=St(g),de=X?ke:rr(p),be=ne?ke:rr(g);de=de==Ie?Ft:de,be=be==Ie?Ft:be;var Se=de==Ft,Ne=be==Ft,We=de==be;if(We&&Mu(p)){if(!Mu(g))return!1;X=!0,Se=!1}if(We&&!Se)return B||(B=new Ii),X||ad(p)?RA(p,g,C,N,P,B):kK(p,g,de,C,N,P,B);if(!(C&m)){var st=Se&&on.call(p,"__wrapped__"),dt=Ne&&on.call(g,"__wrapped__");if(st||dt){var Rt=st?p.value():p,pt=dt?g.value():g;return B||(B=new Ii),P(Rt,pt,C,N,B)}}return We?(B||(B=new Ii),IK(p,g,C,N,P,B)):!1}function Z5(p){return Yn(p)&&rr(p)==at}function FC(p,g,C,N){var P=C.length,B=P,X=!N;if(p==null)return!B;for(p=xn(p);P--;){var ne=C[P];if(X&&ne[2]?ne[1]!==p[ne[0]]:!(ne[0]in p))return!1}for(;++P<B;){ne=C[P];var de=ne[0],be=p[de],Se=ne[1];if(X&&ne[2]){if(be===n&&!(de in p))return!1}else{var Ne=new Ii;if(N)var We=N(be,Se,de,p,g,Ne);if(!(We===n?Im(Se,be,m|y,N,Ne):We))return!1}}return!0}function ZR(p){if(!Vn(p)||PK(p))return!1;var g=Ha(p)?Zj:Zf;return g.test(hc(p))}function J5(p){return Yn(p)&&Cr(p)==yn}function eK(p){return Yn(p)&&rr(p)==Mn}function tK(p){return Yn(p)&&Qx(p.length)&&!!hn[Cr(p)]}function JR(p){return typeof p=="function"?p:p==null?qr:typeof p=="object"?St(p)?nA(p[0],p[1]):tA(p):b_(p)}function OC(p){if(!Tm(p))return r5(p);var g=[];for(var C in xn(p))on.call(p,C)&&C!="constructor"&&g.push(C);return g}function nK(p){if(!Vn(p))return MK(p);var g=Tm(p),C=[];for(var N in p)N=="constructor"&&(g||!on.call(p,N))||C.push(N);return C}function LC(p,g){return p<g}function eA(p,g){var C=-1,N=Kr(p)?ge(p.length):[];return Pu(p,function(P,B,X){N[++C]=g(P,B,X)}),N}function tA(p){var g=ZC(p);return g.length==1&&g[0][2]?FA(g[0][0],g[0][1]):function(C){return C===p||FC(C,p,g)}}function nA(p,g){return e2(p)&&PA(g)?FA(ia(p),g):function(C){var N=c2(C,p);return N===n&&N===g?h2(C,p):Im(g,N,m|y)}}function Fx(p,g,C,N,P){p!==g&&AC(g,function(B,X){if(P||(P=new Ii),Vn(B))sK(p,g,X,C,Fx,N,P);else{var ne=N?N(n2(p,X),B,X+"",p,g,P):n;ne===n&&(ne=B),EC(p,X,ne)}},Xr)}function sK(p,g,C,N,P,B,X){var ne=n2(p,C),de=n2(g,C),be=X.get(de);if(be){EC(p,C,be);return}var Se=B?B(ne,de,C+"",p,g,X):n,Ne=Se===n;if(Ne){var We=St(de),st=!We&&Mu(de),dt=!We&&!st&&ad(de);Se=de,We||st||dt?St(ne)?Se=ne:os(ne)?Se=jr(ne):st?(Ne=!1,Se=fA(de,!0)):dt?(Ne=!1,Se=mA(de,!0)):Se=[]:Rm(de)||dc(de)?(Se=ne,dc(ne)?Se=h_(ne):(!Vn(ne)||Ha(ne))&&(Se=DA(de))):Ne=!1}Ne&&(X.set(de,Se),P(Se,de,N,B,X),X.delete(de)),EC(p,C,Se)}function sA(p,g){var C=p.length;if(C)return g+=g<0?C:0,Ga(g,C)?p[g]:n}function rA(p,g,C){g.length?g=dn(g,function(B){return St(B)?function(X){return lc(X,B.length===1?B[0]:B)}:B}):g=[qr];var N=-1;g=dn(g,He(ht()));var P=eA(p,function(B,X,ne){var de=dn(g,function(be){return be(B)});return{criteria:de,index:++N,value:B}});return oe(P,function(B,X){return gK(B,X,C)})}function rK(p,g){return oA(p,g,function(C,N){return h2(p,N)})}function oA(p,g,C){for(var N=-1,P=g.length,B={};++N<P;){var X=g[N],ne=lc(p,X);C(ne,X)&&$m(B,Ou(X,p),ne)}return B}function oK(p){return function(g){return lc(g,p)}}function MC(p,g,C,N){var P=N?$:b,B=-1,X=g.length,ne=p;for(p===g&&(g=jr(g)),C&&(ne=dn(p,He(C)));++B<X;)for(var de=0,be=g[B],Se=C?C(be):be;(de=P(ne,Se,de,N))>-1;)ne!==p&&Ix.call(ne,de,1),Ix.call(p,de,1);return p}function iA(p,g){for(var C=p?g.length:0,N=C-1;C--;){var P=g[C];if(C==N||P!==B){var B=P;Ga(P)?Ix.call(p,P,1):WC(p,P)}}return p}function zC(p,g){return p+Tx(BR()*(g-p+1))}function iK(p,g,C,N){for(var P=-1,B=$s(Nx((g-p)/(C||1)),0),X=ge(B);B--;)X[N?B:++P]=p,p+=C;return X}function BC(p,g){var C="";if(!p||g<1||g>K)return C;do g%2&&(C+=p),g=Tx(g/2),g&&(p+=p);while(g);return C}function _t(p,g){return s2(OA(p,g,qr),p+"")}function aK(p){return UR(ud(p))}function uK(p,g){var C=ud(p);return Hx(C,uc(g,0,C.length))}function $m(p,g,C,N){if(!Vn(p))return p;g=Ou(g,p);for(var P=-1,B=g.length,X=B-1,ne=p;ne!=null&&++P<B;){var de=ia(g[P]),be=C;if(de==="__proto__"||de==="constructor"||de==="prototype")return p;if(P!=X){var Se=ne[de];be=N?N(Se,de,ne):n,be===n&&(be=Vn(Se)?Se:Ga(g[P+1])?[]:{})}Sm(ne,de,be),ne=ne[de]}return p}var aA=Ex?function(p,g){return Ex.set(p,g),p}:qr,lK=$x?function(p,g){return $x(p,"toString",{configurable:!0,enumerable:!1,value:p2(g),writable:!0})}:qr;function cK(p){return Hx(ud(p))}function jo(p,g,C){var N=-1,P=p.length;g<0&&(g=-g>P?0:P+g),C=C>P?P:C,C<0&&(C+=P),P=g>C?0:C-g>>>0,g>>>=0;for(var B=ge(P);++N<P;)B[N]=p[N+g];return B}function hK(p,g){var C;return Pu(p,function(N,P,B){return C=g(N,P,B),!C}),!!C}function Ox(p,g,C){var N=0,P=p==null?N:p.length;if(typeof g=="number"&&g===g&&P<=Ce){for(;N<P;){var B=N+P>>>1,X=p[B];X!==null&&!bo(X)&&(C?X<=g:X<g)?N=B+1:P=B}return P}return VC(p,g,qr,C)}function VC(p,g,C,N){var P=0,B=p==null?0:p.length;if(B===0)return 0;g=C(g);for(var X=g!==g,ne=g===null,de=bo(g),be=g===n;P<B;){var Se=Tx((P+B)/2),Ne=C(p[Se]),We=Ne!==n,st=Ne===null,dt=Ne===Ne,Rt=bo(Ne);if(X)var pt=N||dt;else be?pt=dt&&(N||We):ne?pt=dt&&We&&(N||!st):de?pt=dt&&We&&!st&&(N||!Rt):st||Rt?pt=!1:pt=N?Ne<=g:Ne<g;pt?P=Se+1:B=Se}return sr(B,xe)}function uA(p,g){for(var C=-1,N=p.length,P=0,B=[];++C<N;){var X=p[C],ne=g?g(X):X;if(!C||!$i(ne,de)){var de=ne;B[P++]=X===0?0:X}}return B}function lA(p){return typeof p=="number"?p:bo(p)?pe:+p}function wo(p){if(typeof p=="string")return p;if(St(p))return dn(p,wo)+"";if(bo(p))return VR?VR.call(p):"";var g=p+"";return g=="0"&&1/p==-le?"-0":g}function Fu(p,g,C){var N=-1,P=qh,B=p.length,X=!0,ne=[],de=ne;if(C)X=!1,P=pm;else if(B>=r){var be=g?null:SK(p);if(be)return Yh(be);X=!1,P=it,de=new ac}else de=g?[]:ne;e:for(;++N<B;){var Se=p[N],Ne=g?g(Se):Se;if(Se=C||Se!==0?Se:0,X&&Ne===Ne){for(var We=de.length;We--;)if(de[We]===Ne)continue e;g&&de.push(Ne),ne.push(Se)}else P(de,Ne,C)||(de!==ne&&de.push(Ne),ne.push(Se))}return ne}function WC(p,g){return g=Ou(g,p),p=LA(p,g),p==null||delete p[ia(Ko(g))]}function cA(p,g,C,N){return $m(p,g,C(lc(p,g)),N)}function Lx(p,g,C,N){for(var P=p.length,B=N?P:-1;(N?B--:++B<P)&&g(p[B],B,p););return C?jo(p,N?0:B,N?B+1:P):jo(p,N?B+1:0,N?P:B)}function hA(p,g){var C=p;return C instanceof Mt&&(C=C.value()),fm(g,function(N,P){return P.func.apply(P.thisArg,ta([N],P.args))},C)}function UC(p,g,C){var N=p.length;if(N<2)return N?Fu(p[0]):[];for(var P=-1,B=ge(N);++P<N;)for(var X=p[P],ne=-1;++ne<N;)ne!=P&&(B[P]=Cm(B[P]||X,p[ne],g,C));return Fu(js(B,1),g,C)}function dA(p,g,C){for(var N=-1,P=p.length,B=g.length,X={};++N<P;){var ne=N<B?g[N]:n;C(X,p[N],ne)}return X}function GC(p){return os(p)?p:[]}function HC(p){return typeof p=="function"?p:qr}function Ou(p,g){return St(p)?p:e2(p,g)?[p]:VA(tn(p))}var dK=_t;function Lu(p,g,C){var N=p.length;return C=C===n?N:C,!g&&C>=N?p:jo(p,g,C)}var pA=Jj||function(p){return hs.clearTimeout(p)};function fA(p,g){if(g)return p.slice();var C=p.length,N=FR?FR(C):new p.constructor(C);return p.copy(N),N}function jC(p){var g=new p.constructor(p.byteLength);return new Cx(g).set(new Cx(p)),g}function pK(p,g){var C=g?jC(p.buffer):p.buffer;return new p.constructor(C,p.byteOffset,p.byteLength)}function fK(p){var g=new p.constructor(p.source,Xl.exec(p));return g.lastIndex=p.lastIndex,g}function mK(p){return bm?xn(bm.call(p)):{}}function mA(p,g){var C=g?jC(p.buffer):p.buffer;return new p.constructor(C,p.byteOffset,p.length)}function gA(p,g){if(p!==g){var C=p!==n,N=p===null,P=p===p,B=bo(p),X=g!==n,ne=g===null,de=g===g,be=bo(g);if(!ne&&!be&&!B&&p>g||B&&X&&de&&!ne&&!be||N&&X&&de||!C&&de||!P)return 1;if(!N&&!B&&!be&&p<g||be&&C&&P&&!N&&!B||ne&&C&&P||!X&&P||!de)return-1}return 0}function gK(p,g,C){for(var N=-1,P=p.criteria,B=g.criteria,X=P.length,ne=C.length;++N<X;){var de=gA(P[N],B[N]);if(de){if(N>=ne)return de;var be=C[N];return de*(be=="desc"?-1:1)}}return p.index-g.index}function yA(p,g,C,N){for(var P=-1,B=p.length,X=C.length,ne=-1,de=g.length,be=$s(B-X,0),Se=ge(de+be),Ne=!N;++ne<de;)Se[ne]=g[ne];for(;++P<X;)(Ne||P<B)&&(Se[C[P]]=p[P]);for(;be--;)Se[ne++]=p[P++];return Se}function xA(p,g,C,N){for(var P=-1,B=p.length,X=-1,ne=C.length,de=-1,be=g.length,Se=$s(B-ne,0),Ne=ge(Se+be),We=!N;++P<Se;)Ne[P]=p[P];for(var st=P;++de<be;)Ne[st+de]=g[de];for(;++X<ne;)(We||P<B)&&(Ne[st+C[X]]=p[P++]);return Ne}function jr(p,g){var C=-1,N=p.length;for(g||(g=ge(N));++C<N;)g[C]=p[C];return g}function oa(p,g,C,N){var P=!C;C||(C={});for(var B=-1,X=g.length;++B<X;){var ne=g[B],de=N?N(C[ne],p[ne],ne,C,p):n;de===n&&(de=p[ne]),P?Va(C,ne,de):Sm(C,ne,de)}return C}function yK(p,g){return oa(p,JC(p),g)}function xK(p,g){return oa(p,AA(p),g)}function Mx(p,g){return function(C,N){var P=St(C)?xC:B5,B=g?g():{};return P(C,p,ht(N,2),B)}}function rd(p){return _t(function(g,C){var N=-1,P=C.length,B=P>1?C[P-1]:n,X=P>2?C[2]:n;for(B=p.length>3&&typeof B=="function"?(P--,B):n,X&&kr(C[0],C[1],X)&&(B=P<3?n:B,P=1),g=xn(g);++N<P;){var ne=C[N];ne&&p(g,ne,N,B)}return g})}function vA(p,g){return function(C,N){if(C==null)return C;if(!Kr(C))return p(C,N);for(var P=C.length,B=g?P:-1,X=xn(C);(g?B--:++B<P)&&N(X[B],B,X)!==!1;);return C}}function wA(p){return function(g,C,N){for(var P=-1,B=xn(g),X=N(g),ne=X.length;ne--;){var de=X[p?ne:++P];if(C(B[de],de,B)===!1)break}return g}}function vK(p,g,C){var N=g&x,P=Nm(p);function B(){var X=this&&this!==hs&&this instanceof B?P:p;return X.apply(N?C:this,arguments)}return B}function bA(p){return function(g){g=tn(g);var C=Dn(g)?ki(g):n,N=C?C[0]:g.charAt(0),P=C?Lu(C,1).join(""):g.slice(1);return N[p]()+P}}function od(p){return function(g){return fm(v_(x_(g).replace(fC,"")),p,"")}}function Nm(p){return function(){var g=arguments;switch(g.length){case 0:return new p;case 1:return new p(g[0]);case 2:return new p(g[0],g[1]);case 3:return new p(g[0],g[1],g[2]);case 4:return new p(g[0],g[1],g[2],g[3]);case 5:return new p(g[0],g[1],g[2],g[3],g[4]);case 6:return new p(g[0],g[1],g[2],g[3],g[4],g[5]);case 7:return new p(g[0],g[1],g[2],g[3],g[4],g[5],g[6])}var C=sd(p.prototype),N=p.apply(C,g);return Vn(N)?N:C}}function wK(p,g,C){var N=Nm(p);function P(){for(var B=arguments.length,X=ge(B),ne=B,de=id(P);ne--;)X[ne]=arguments[ne];var be=B<3&&X[0]!==de&&X[B-1]!==de?[]:sa(X,de);if(B-=be.length,B<C)return $A(p,g,zx,P.placeholder,n,X,be,n,n,C-B);var Se=this&&this!==hs&&this instanceof P?N:p;return tr(Se,this,X)}return P}function SA(p){return function(g,C,N){var P=xn(g);if(!Kr(g)){var B=ht(C,3);g=Os(g),C=function(ne){return B(P[ne],ne,P)}}var X=p(g,C,N);return X>-1?P[B?g[X]:X]:n}}function CA(p){return Ua(function(g){var C=g.length,N=C,P=Go.prototype.thru;for(p&&g.reverse();N--;){var B=g[N];if(typeof B!="function")throw new Uo(i);if(P&&!X&&Ux(B)=="wrapper")var X=new Go([],!0)}for(N=X?N:C;++N<C;){B=g[N];var ne=Ux(B),de=ne=="wrapper"?QC(B):n;de&&t2(de[0])&&de[1]==(R|S|I|_)&&!de[4].length&&de[9]==1?X=X[Ux(de[0])].apply(X,de[3]):X=B.length==1&&t2(B)?X[ne]():X.thru(B)}return function(){var be=arguments,Se=be[0];if(X&&be.length==1&&St(Se))return X.plant(Se).value();for(var Ne=0,We=C?g[Ne].apply(this,be):Se;++Ne<C;)We=g[Ne].call(this,We);return We}})}function zx(p,g,C,N,P,B,X,ne,de,be){var Se=g&R,Ne=g&x,We=g&v,st=g&(S|k),dt=g&D,Rt=We?n:Nm(p);function pt(){for(var Ot=arguments.length,Gt=ge(Ot),So=Ot;So--;)Gt[So]=arguments[So];if(st)var Ir=id(pt),Co=fn(Gt,Ir);if(N&&(Gt=yA(Gt,N,P,st)),B&&(Gt=xA(Gt,B,X,st)),Ot-=Co,st&&Ot<be){var is=sa(Gt,Ir);return $A(p,g,zx,pt.placeholder,C,Gt,is,ne,de,be-Ot)}var Ni=Ne?C:this,Ka=We?Ni[p]:p;return Ot=Gt.length,ne?Gt=BK(Gt,ne):dt&&Ot>1&&Gt.reverse(),Se&&de<Ot&&(Gt.length=de),this&&this!==hs&&this instanceof pt&&(Ka=Rt||Nm(Ka)),Ka.apply(Ni,Gt)}return pt}function kA(p,g){return function(C,N){return X5(C,p,g(N),{})}}function Bx(p,g){return function(C,N){var P;if(C===n&&N===n)return g;if(C!==n&&(P=C),N!==n){if(P===n)return N;typeof C=="string"||typeof N=="string"?(C=wo(C),N=wo(N)):(C=lA(C),N=lA(N)),P=p(C,N)}return P}}function KC(p){return Ua(function(g){return g=dn(g,He(ht())),_t(function(C){var N=this;return p(g,function(P){return tr(P,N,C)})})})}function Vx(p,g){g=g===n?" ":wo(g);var C=g.length;if(C<2)return C?BC(g,p):g;var N=BC(g,Nx(p/Zh(g)));return Dn(g)?Lu(ki(N),0,p).join(""):N.slice(0,p)}function bK(p,g,C,N){var P=g&x,B=Nm(p);function X(){for(var ne=-1,de=arguments.length,be=-1,Se=N.length,Ne=ge(Se+de),We=this&&this!==hs&&this instanceof X?B:p;++be<Se;)Ne[be]=N[be];for(;de--;)Ne[be++]=arguments[++ne];return tr(We,P?C:this,Ne)}return X}function IA(p){return function(g,C,N){return N&&typeof N!="number"&&kr(g,C,N)&&(C=N=n),g=ja(g),C===n?(C=g,g=0):C=ja(C),N=N===n?g<C?1:-1:ja(N),iK(g,C,N,p)}}function Wx(p){return function(g,C){return typeof g=="string"&&typeof C=="string"||(g=Xo(g),C=Xo(C)),p(g,C)}}function $A(p,g,C,N,P,B,X,ne,de,be){var Se=g&S,Ne=Se?X:n,We=Se?n:X,st=Se?B:n,dt=Se?n:B;g|=Se?I:T,g&=~(Se?T:I),g&w||(g&=~(x|v));var Rt=[p,g,P,st,Ne,dt,We,ne,de,be],pt=C.apply(n,Rt);return t2(p)&&MA(pt,Rt),pt.placeholder=N,zA(pt,p,g)}function XC(p){var g=Is[p];return function(C,N){if(C=Xo(C),N=N==null?0:sr(Nt(N),292),N&&zR(C)){var P=(tn(C)+"e").split("e"),B=g(P[0]+"e"+(+P[1]+N));return P=(tn(B)+"e").split("e"),+(P[0]+"e"+(+P[1]-N))}return g(C)}}var SK=td&&1/Yh(new td([,-0]))[1]==le?function(p){return new td(p)}:g2;function NA(p){return function(g){var C=rr(g);return C==at?gm(g):C==Mn?Qh(g):Oe(g,p(g))}}function Wa(p,g,C,N,P,B,X,ne){var de=g&v;if(!de&&typeof p!="function")throw new Uo(i);var be=N?N.length:0;if(be||(g&=~(I|T),N=P=n),X=X===n?X:$s(Nt(X),0),ne=ne===n?ne:Nt(ne),be-=P?P.length:0,g&T){var Se=N,Ne=P;N=P=n}var We=de?n:QC(p),st=[p,g,C,N,P,Se,Ne,B,X,ne];if(We&&LK(st,We),p=st[0],g=st[1],C=st[2],N=st[3],P=st[4],ne=st[9]=st[9]===n?de?0:p.length:$s(st[9]-be,0),!ne&&g&(S|k)&&(g&=~(S|k)),!g||g==x)var dt=vK(p,g,C);else g==S||g==k?dt=wK(p,g,ne):(g==I||g==(x|I))&&!P.length?dt=bK(p,g,C,N):dt=zx.apply(n,st);var Rt=We?aA:MA;return zA(Rt(dt,st),p,g)}function TA(p,g,C,N){return p===n||$i(p,ed[C])&&!on.call(N,C)?g:p}function EA(p,g,C,N,P,B){return Vn(p)&&Vn(g)&&(B.set(g,p),Fx(p,g,n,EA,B),B.delete(g)),p}function CK(p){return Rm(p)?n:p}function RA(p,g,C,N,P,B){var X=C&m,ne=p.length,de=g.length;if(ne!=de&&!(X&&de>ne))return!1;var be=B.get(p),Se=B.get(g);if(be&&Se)return be==g&&Se==p;var Ne=-1,We=!0,st=C&y?new ac:n;for(B.set(p,g),B.set(g,p);++Ne<ne;){var dt=p[Ne],Rt=g[Ne];if(N)var pt=X?N(Rt,dt,Ne,g,p,B):N(dt,Rt,Ne,p,g,B);if(pt!==n){if(pt)continue;We=!1;break}if(st){if(!_u(g,function(Ot,Gt){if(!it(st,Gt)&&(dt===Ot||P(dt,Ot,C,N,B)))return st.push(Gt)})){We=!1;break}}else if(!(dt===Rt||P(dt,Rt,C,N,B))){We=!1;break}}return B.delete(p),B.delete(g),We}function kK(p,g,C,N,P,B,X){switch(C){case Gs:if(p.byteLength!=g.byteLength||p.byteOffset!=g.byteOffset)return!1;p=p.buffer,g=g.buffer;case Fs:return!(p.byteLength!=g.byteLength||!B(new Cx(p),new Cx(g)));case Ke:case je:case Lt:return $i(+p,+g);case tt:return p.name==g.name&&p.message==g.message;case yn:case zn:return p==g+"";case at:var ne=gm;case Mn:var de=N&m;if(ne||(ne=Yh),p.size!=g.size&&!de)return!1;var be=X.get(p);if(be)return be==g;N|=y,X.set(p,g);var Se=RA(ne(p),ne(g),N,P,B,X);return X.delete(p),Se;case vr:if(bm)return bm.call(p)==bm.call(g)}return!1}function IK(p,g,C,N,P,B){var X=C&m,ne=qC(p),de=ne.length,be=qC(g),Se=be.length;if(de!=Se&&!X)return!1;for(var Ne=de;Ne--;){var We=ne[Ne];if(!(X?We in g:on.call(g,We)))return!1}var st=B.get(p),dt=B.get(g);if(st&&dt)return st==g&&dt==p;var Rt=!0;B.set(p,g),B.set(g,p);for(var pt=X;++Ne<de;){We=ne[Ne];var Ot=p[We],Gt=g[We];if(N)var So=X?N(Gt,Ot,We,g,p,B):N(Ot,Gt,We,p,g,B);if(!(So===n?Ot===Gt||P(Ot,Gt,C,N,B):So)){Rt=!1;break}pt||(pt=We=="constructor")}if(Rt&&!pt){var Ir=p.constructor,Co=g.constructor;Ir!=Co&&"constructor"in p&&"constructor"in g&&!(typeof Ir=="function"&&Ir instanceof Ir&&typeof Co=="function"&&Co instanceof Co)&&(Rt=!1)}return B.delete(p),B.delete(g),Rt}function Ua(p){return s2(OA(p,n,HA),p+"")}function qC(p){return YR(p,Os,JC)}function YC(p){return YR(p,Xr,AA)}var QC=Ex?function(p){return Ex.get(p)}:g2;function Ux(p){for(var g=p.name+"",C=nd[g],N=on.call(nd,g)?C.length:0;N--;){var P=C[N],B=P.func;if(B==null||B==p)return P.name}return g}function id(p){var g=on.call(z,"placeholder")?z:p;return g.placeholder}function ht(){var p=z.iteratee||f2;return p=p===f2?JR:p,arguments.length?p(arguments[0],arguments[1]):p}function Gx(p,g){var C=p.__data__;return DK(g)?C[typeof g=="string"?"string":"hash"]:C.map}function ZC(p){for(var g=Os(p),C=g.length;C--;){var N=g[C],P=p[N];g[C]=[N,P,PA(P)]}return g}function cc(p,g){var C=Kt(p,g);return ZR(C)?C:n}function $K(p){var g=on.call(p,oc),C=p[oc];try{p[oc]=n;var N=!0}catch{}var P=bx.call(p);return N&&(g?p[oc]=C:delete p[oc]),P}var JC=$C?function(p){return p==null?[]:(p=xn(p),Ci($C(p),function(g){return LR.call(p,g)}))}:y2,AA=$C?function(p){for(var g=[];p;)ta(g,JC(p)),p=kx(p);return g}:y2,rr=Cr;(NC&&rr(new NC(new ArrayBuffer(1)))!=Gs||xm&&rr(new xm)!=at||TC&&rr(TC.resolve())!=Zt||td&&rr(new td)!=Mn||vm&&rr(new vm)!=Ps)&&(rr=function(p){var g=Cr(p),C=g==Ft?p.constructor:n,N=C?hc(C):"";if(N)switch(N){case u5:return Gs;case l5:return at;case c5:return Zt;case h5:return Mn;case d5:return Ps}return g});function NK(p,g,C){for(var N=-1,P=C.length;++N<P;){var B=C[N],X=B.size;switch(B.type){case"drop":p+=X;break;case"dropRight":g-=X;break;case"take":g=sr(g,p+X);break;case"takeRight":p=$s(p,g-X);break}}return{start:p,end:g}}function TK(p){var g=p.match(Bn);return g?g[1].split(Vo):[]}function _A(p,g,C){g=Ou(g,p);for(var N=-1,P=g.length,B=!1;++N<P;){var X=ia(g[N]);if(!(B=p!=null&&C(p,X)))break;p=p[X]}return B||++N!=P?B:(P=p==null?0:p.length,!!P&&Qx(P)&&Ga(X,P)&&(St(p)||dc(p)))}function EK(p){var g=p.length,C=new p.constructor(g);return g&&typeof p[0]=="string"&&on.call(p,"index")&&(C.index=p.index,C.input=p.input),C}function DA(p){return typeof p.constructor=="function"&&!Tm(p)?sd(kx(p)):{}}function RK(p,g,C){var N=p.constructor;switch(g){case Fs:return jC(p);case Ke:case je:return new N(+p);case Gs:return pK(p,C);case Bo:case _a:case Ji:case $u:case Ur:case Da:case Nu:case Uf:case Oh:return mA(p,C);case at:return new N;case Lt:case zn:return new N(p);case yn:return fK(p);case Mn:return new N;case vr:return mK(p)}}function AK(p,g){var C=g.length;if(!C)return p;var N=C-1;return g[N]=(C>1?"& ":"")+g[N],g=g.join(C>2?", ":" "),p.replace(K0,`{
/* [wrapped with `+g+`] */
`)}function _K(p){return St(p)||dc(p)||!!(MR&&p&&p[MR])}function Ga(p,g){var C=typeof p;return g=g??K,!!g&&(C=="number"||C!="symbol"&&q0.test(p))&&p>-1&&p%1==0&&p<g}function kr(p,g,C){if(!Vn(C))return!1;var N=typeof g;return(N=="number"?Kr(C)&&Ga(g,C.length):N=="string"&&g in C)?$i(C[g],p):!1}function e2(p,g){if(St(p))return!1;var C=typeof p;return C=="number"||C=="symbol"||C=="boolean"||p==null||bo(p)?!0:Mh.test(p)||!Lh.test(p)||g!=null&&p in xn(g)}function DK(p){var g=typeof p;return g=="string"||g=="number"||g=="symbol"||g=="boolean"?p!=="__proto__":p===null}function t2(p){var g=Ux(p),C=z[g];if(typeof C!="function"||!(g in Mt.prototype))return!1;if(p===C)return!0;var N=QC(C);return!!N&&p===N[0]}function PK(p){return!!PR&&PR in p}var FK=vx?Ha:x2;function Tm(p){var g=p&&p.constructor,C=typeof g=="function"&&g.prototype||ed;return p===C}function PA(p){return p===p&&!Vn(p)}function FA(p,g){return function(C){return C==null?!1:C[p]===g&&(g!==n||p in xn(C))}}function OK(p){var g=qx(p,function(N){return C.size===l&&C.clear(),N}),C=g.cache;return g}function LK(p,g){var C=p[1],N=g[1],P=C|N,B=P<(x|v|R),X=N==R&&C==S||N==R&&C==_&&p[7].length<=g[8]||N==(R|_)&&g[7].length<=g[8]&&C==S;if(!(B||X))return p;N&x&&(p[2]=g[2],P|=C&x?0:w);var ne=g[3];if(ne){var de=p[3];p[3]=de?yA(de,ne,g[4]):ne,p[4]=de?sa(p[3],c):g[4]}return ne=g[5],ne&&(de=p[5],p[5]=de?xA(de,ne,g[6]):ne,p[6]=de?sa(p[5],c):g[6]),ne=g[7],ne&&(p[7]=ne),N&R&&(p[8]=p[8]==null?g[8]:sr(p[8],g[8])),p[9]==null&&(p[9]=g[9]),p[0]=g[0],p[1]=P,p}function MK(p){var g=[];if(p!=null)for(var C in xn(p))g.push(C);return g}function zK(p){return bx.call(p)}function OA(p,g,C){return g=$s(g===n?p.length-1:g,0),function(){for(var N=arguments,P=-1,B=$s(N.length-g,0),X=ge(B);++P<B;)X[P]=N[g+P];P=-1;for(var ne=ge(g+1);++P<g;)ne[P]=N[P];return ne[g]=C(X),tr(p,this,ne)}}function LA(p,g){return g.length<2?p:lc(p,jo(g,0,-1))}function BK(p,g){for(var C=p.length,N=sr(g.length,C),P=jr(p);N--;){var B=g[N];p[N]=Ga(B,C)?P[B]:n}return p}function n2(p,g){if(!(g==="constructor"&&typeof p[g]=="function")&&g!="__proto__")return p[g]}var MA=BA(aA),Em=t5||function(p,g){return hs.setTimeout(p,g)},s2=BA(lK);function zA(p,g,C){var N=g+"";return s2(p,AK(N,VK(TK(N),C)))}function BA(p){var g=0,C=0;return function(){var N=o5(),P=j-(N-C);if(C=N,P>0){if(++g>=U)return arguments[0]}else g=0;return p.apply(n,arguments)}}function Hx(p,g){var C=-1,N=p.length,P=N-1;for(g=g===n?N:g;++C<g;){var B=zC(C,P),X=p[B];p[B]=p[C],p[C]=X}return p.length=g,p}var VA=OK(function(p){var g=[];return p.charCodeAt(0)===46&&g.push(""),p.replace(aC,function(C,N,P,B){g.push(P?B.replace(zh,"$1"):N||C)}),g});function ia(p){if(typeof p=="string"||bo(p))return p;var g=p+"";return g=="0"&&1/p==-le?"-0":g}function hc(p){if(p!=null){try{return wx.call(p)}catch{}try{return p+""}catch{}}return""}function VK(p,g){return Gr(Ee,function(C){var N="_."+C[0];g&C[1]&&!qh(p,N)&&p.push(N)}),p.sort()}function WA(p){if(p instanceof Mt)return p.clone();var g=new Go(p.__wrapped__,p.__chain__);return g.__actions__=jr(p.__actions__),g.__index__=p.__index__,g.__values__=p.__values__,g}function WK(p,g,C){(C?kr(p,g,C):g===n)?g=1:g=$s(Nt(g),0);var N=p==null?0:p.length;if(!N||g<1)return[];for(var P=0,B=0,X=ge(Nx(N/g));P<N;)X[B++]=jo(p,P,P+=g);return X}function UK(p){for(var g=-1,C=p==null?0:p.length,N=0,P=[];++g<C;){var B=p[g];B&&(P[N++]=B)}return P}function GK(){var p=arguments.length;if(!p)return[];for(var g=ge(p-1),C=arguments[0],N=p;N--;)g[N-1]=arguments[N];return ta(St(C)?jr(C):[C],js(g,1))}var HK=_t(function(p,g){return os(p)?Cm(p,js(g,1,os,!0)):[]}),jK=_t(function(p,g){var C=Ko(g);return os(C)&&(C=n),os(p)?Cm(p,js(g,1,os,!0),ht(C,2)):[]}),KK=_t(function(p,g){var C=Ko(g);return os(C)&&(C=n),os(p)?Cm(p,js(g,1,os,!0),n,C):[]});function XK(p,g,C){var N=p==null?0:p.length;return N?(g=C||g===n?1:Nt(g),jo(p,g<0?0:g,N)):[]}function qK(p,g,C){var N=p==null?0:p.length;return N?(g=C||g===n?1:Nt(g),g=N-g,jo(p,0,g<0?0:g)):[]}function YK(p,g){return p&&p.length?Lx(p,ht(g,3),!0,!0):[]}function QK(p,g){return p&&p.length?Lx(p,ht(g,3),!0):[]}function ZK(p,g,C,N){var P=p==null?0:p.length;return P?(C&&typeof C!="number"&&kr(p,g,C)&&(C=0,N=P),G5(p,g,C,N)):[]}function UA(p,g,C){var N=p==null?0:p.length;if(!N)return-1;var P=C==null?0:Nt(C);return P<0&&(P=$s(N+P,0)),rc(p,ht(g,3),P)}function GA(p,g,C){var N=p==null?0:p.length;if(!N)return-1;var P=N-1;return C!==n&&(P=Nt(C),P=C<0?$s(N+P,0):sr(P,N-1)),rc(p,ht(g,3),P,!0)}function HA(p){var g=p==null?0:p.length;return g?js(p,1):[]}function JK(p){var g=p==null?0:p.length;return g?js(p,le):[]}function e8(p,g){var C=p==null?0:p.length;return C?(g=g===n?1:Nt(g),js(p,g)):[]}function t8(p){for(var g=-1,C=p==null?0:p.length,N={};++g<C;){var P=p[g];N[P[0]]=P[1]}return N}function jA(p){return p&&p.length?p[0]:n}function n8(p,g,C){var N=p==null?0:p.length;if(!N)return-1;var P=C==null?0:Nt(C);return P<0&&(P=$s(N+P,0)),b(p,g,P)}function s8(p){var g=p==null?0:p.length;return g?jo(p,0,-1):[]}var r8=_t(function(p){var g=dn(p,GC);return g.length&&g[0]===p[0]?PC(g):[]}),o8=_t(function(p){var g=Ko(p),C=dn(p,GC);return g===Ko(C)?g=n:C.pop(),C.length&&C[0]===p[0]?PC(C,ht(g,2)):[]}),i8=_t(function(p){var g=Ko(p),C=dn(p,GC);return g=typeof g=="function"?g:n,g&&C.pop(),C.length&&C[0]===p[0]?PC(C,n,g):[]});function a8(p,g){return p==null?"":s5.call(p,g)}function Ko(p){var g=p==null?0:p.length;return g?p[g-1]:n}function u8(p,g,C){var N=p==null?0:p.length;if(!N)return-1;var P=N;return C!==n&&(P=Nt(C),P=P<0?$s(N+P,0):sr(P,N-1)),g===g?Vj(p,g,P):rc(p,A,P,!0)}function l8(p,g){return p&&p.length?sA(p,Nt(g)):n}var c8=_t(KA);function KA(p,g){return p&&p.length&&g&&g.length?MC(p,g):p}function h8(p,g,C){return p&&p.length&&g&&g.length?MC(p,g,ht(C,2)):p}function d8(p,g,C){return p&&p.length&&g&&g.length?MC(p,g,n,C):p}var p8=Ua(function(p,g){var C=p==null?0:p.length,N=RC(p,g);return iA(p,dn(g,function(P){return Ga(P,C)?+P:P}).sort(gA)),N});function f8(p,g){var C=[];if(!(p&&p.length))return C;var N=-1,P=[],B=p.length;for(g=ht(g,3);++N<B;){var X=p[N];g(X,N,p)&&(C.push(X),P.push(N))}return iA(p,P),C}function r2(p){return p==null?p:a5.call(p)}function m8(p,g,C){var N=p==null?0:p.length;return N?(C&&typeof C!="number"&&kr(p,g,C)?(g=0,C=N):(g=g==null?0:Nt(g),C=C===n?N:Nt(C)),jo(p,g,C)):[]}function g8(p,g){return Ox(p,g)}function y8(p,g,C){return VC(p,g,ht(C,2))}function x8(p,g){var C=p==null?0:p.length;if(C){var N=Ox(p,g);if(N<C&&$i(p[N],g))return N}return-1}function v8(p,g){return Ox(p,g,!0)}function w8(p,g,C){return VC(p,g,ht(C,2),!0)}function b8(p,g){var C=p==null?0:p.length;if(C){var N=Ox(p,g,!0)-1;if($i(p[N],g))return N}return-1}function S8(p){return p&&p.length?uA(p):[]}function C8(p,g){return p&&p.length?uA(p,ht(g,2)):[]}function k8(p){var g=p==null?0:p.length;return g?jo(p,1,g):[]}function I8(p,g,C){return p&&p.length?(g=C||g===n?1:Nt(g),jo(p,0,g<0?0:g)):[]}function $8(p,g,C){var N=p==null?0:p.length;return N?(g=C||g===n?1:Nt(g),g=N-g,jo(p,g<0?0:g,N)):[]}function N8(p,g){return p&&p.length?Lx(p,ht(g,3),!1,!0):[]}function T8(p,g){return p&&p.length?Lx(p,ht(g,3)):[]}var E8=_t(function(p){return Fu(js(p,1,os,!0))}),R8=_t(function(p){var g=Ko(p);return os(g)&&(g=n),Fu(js(p,1,os,!0),ht(g,2))}),A8=_t(function(p){var g=Ko(p);return g=typeof g=="function"?g:n,Fu(js(p,1,os,!0),n,g)});function _8(p){return p&&p.length?Fu(p):[]}function D8(p,g){return p&&p.length?Fu(p,ht(g,2)):[]}function P8(p,g){return g=typeof g=="function"?g:n,p&&p.length?Fu(p,n,g):[]}function o2(p){if(!(p&&p.length))return[];var g=0;return p=Ci(p,function(C){if(os(C))return g=$s(C.length,g),!0}),Te(g,function(C){return dn(p,W(C))})}function XA(p,g){if(!(p&&p.length))return[];var C=o2(p);return g==null?C:dn(C,function(N){return tr(g,n,N)})}var F8=_t(function(p,g){return os(p)?Cm(p,g):[]}),O8=_t(function(p){return UC(Ci(p,os))}),L8=_t(function(p){var g=Ko(p);return os(g)&&(g=n),UC(Ci(p,os),ht(g,2))}),M8=_t(function(p){var g=Ko(p);return g=typeof g=="function"?g:n,UC(Ci(p,os),n,g)}),z8=_t(o2);function B8(p,g){return dA(p||[],g||[],Sm)}function V8(p,g){return dA(p||[],g||[],$m)}var W8=_t(function(p){var g=p.length,C=g>1?p[g-1]:n;return C=typeof C=="function"?(p.pop(),C):n,XA(p,C)});function qA(p){var g=z(p);return g.__chain__=!0,g}function U8(p,g){return g(p),p}function jx(p,g){return g(p)}var G8=Ua(function(p){var g=p.length,C=g?p[0]:0,N=this.__wrapped__,P=function(B){return RC(B,p)};return g>1||this.__actions__.length||!(N instanceof Mt)||!Ga(C)?this.thru(P):(N=N.slice(C,+C+(g?1:0)),N.__actions__.push({func:jx,args:[P],thisArg:n}),new Go(N,this.__chain__).thru(function(B){return g&&!B.length&&B.push(n),B}))});function H8(){return qA(this)}function j8(){return new Go(this.value(),this.__chain__)}function K8(){this.__values__===n&&(this.__values__=l_(this.value()));var p=this.__index__>=this.__values__.length,g=p?n:this.__values__[this.__index__++];return{done:p,value:g}}function X8(){return this}function q8(p){for(var g,C=this;C instanceof Ax;){var N=WA(C);N.__index__=0,N.__values__=n,g?P.__wrapped__=N:g=N;var P=N;C=C.__wrapped__}return P.__wrapped__=p,g}function Y8(){var p=this.__wrapped__;if(p instanceof Mt){var g=p;return this.__actions__.length&&(g=new Mt(this)),g=g.reverse(),g.__actions__.push({func:jx,args:[r2],thisArg:n}),new Go(g,this.__chain__)}return this.thru(r2)}function Q8(){return hA(this.__wrapped__,this.__actions__)}var Z8=Mx(function(p,g,C){on.call(p,C)?++p[C]:Va(p,C,1)});function J8(p,g,C){var N=St(p)?gx:U5;return C&&kr(p,g,C)&&(g=n),N(p,ht(g,3))}function eX(p,g){var C=St(p)?Ci:XR;return C(p,ht(g,3))}var tX=SA(UA),nX=SA(GA);function sX(p,g){return js(Kx(p,g),1)}function rX(p,g){return js(Kx(p,g),le)}function oX(p,g,C){return C=C===n?1:Nt(C),js(Kx(p,g),C)}function YA(p,g){var C=St(p)?Gr:Pu;return C(p,ht(g,3))}function QA(p,g){var C=St(p)?vC:KR;return C(p,ht(g,3))}var iX=Mx(function(p,g,C){on.call(p,C)?p[C].push(g):Va(p,C,[g])});function aX(p,g,C,N){p=Kr(p)?p:ud(p),C=C&&!N?Nt(C):0;var P=p.length;return C<0&&(C=$s(P+C,0)),Zx(p)?C<=P&&p.indexOf(g,C)>-1:!!P&&b(p,g,C)>-1}var uX=_t(function(p,g,C){var N=-1,P=typeof g=="function",B=Kr(p)?ge(p.length):[];return Pu(p,function(X){B[++N]=P?tr(g,X,C):km(X,g,C)}),B}),lX=Mx(function(p,g,C){Va(p,C,g)});function Kx(p,g){var C=St(p)?dn:eA;return C(p,ht(g,3))}function cX(p,g,C,N){return p==null?[]:(St(g)||(g=g==null?[]:[g]),C=N?n:C,St(C)||(C=C==null?[]:[C]),rA(p,g,C))}var hX=Mx(function(p,g,C){p[C?0:1].push(g)},function(){return[[],[]]});function dX(p,g,C){var N=St(p)?fm:G,P=arguments.length<3;return N(p,ht(g,4),C,P,Pu)}function pX(p,g,C){var N=St(p)?wC:G,P=arguments.length<3;return N(p,ht(g,4),C,P,KR)}function fX(p,g){var C=St(p)?Ci:XR;return C(p,Yx(ht(g,3)))}function mX(p){var g=St(p)?UR:aK;return g(p)}function gX(p,g,C){(C?kr(p,g,C):g===n)?g=1:g=Nt(g);var N=St(p)?M5:uK;return N(p,g)}function yX(p){var g=St(p)?z5:cK;return g(p)}function xX(p){if(p==null)return 0;if(Kr(p))return Zx(p)?Zh(p):p.length;var g=rr(p);return g==at||g==Mn?p.size:OC(p).length}function vX(p,g,C){var N=St(p)?_u:hK;return C&&kr(p,g,C)&&(g=n),N(p,ht(g,3))}var wX=_t(function(p,g){if(p==null)return[];var C=g.length;return C>1&&kr(p,g[0],g[1])?g=[]:C>2&&kr(g[0],g[1],g[2])&&(g=[g[0]]),rA(p,js(g,1),[])}),Xx=e5||function(){return hs.Date.now()};function bX(p,g){if(typeof g!="function")throw new Uo(i);return p=Nt(p),function(){if(--p<1)return g.apply(this,arguments)}}function ZA(p,g,C){return g=C?n:g,g=p&&g==null?p.length:g,Wa(p,R,n,n,n,n,g)}function JA(p,g){var C;if(typeof g!="function")throw new Uo(i);return p=Nt(p),function(){return--p>0&&(C=g.apply(this,arguments)),p<=1&&(g=n),C}}var i2=_t(function(p,g,C){var N=x;if(C.length){var P=sa(C,id(i2));N|=I}return Wa(p,N,g,C,P)}),e_=_t(function(p,g,C){var N=x|v;if(C.length){var P=sa(C,id(e_));N|=I}return Wa(g,N,p,C,P)});function t_(p,g,C){g=C?n:g;var N=Wa(p,S,n,n,n,n,n,g);return N.placeholder=t_.placeholder,N}function n_(p,g,C){g=C?n:g;var N=Wa(p,k,n,n,n,n,n,g);return N.placeholder=n_.placeholder,N}function s_(p,g,C){var N,P,B,X,ne,de,be=0,Se=!1,Ne=!1,We=!0;if(typeof p!="function")throw new Uo(i);g=Xo(g)||0,Vn(C)&&(Se=!!C.leading,Ne="maxWait"in C,B=Ne?$s(Xo(C.maxWait)||0,g):B,We="trailing"in C?!!C.trailing:We);function st(is){var Ni=N,Ka=P;return N=P=n,be=is,X=p.apply(Ka,Ni),X}function dt(is){return be=is,ne=Em(Ot,g),Se?st(is):X}function Rt(is){var Ni=is-de,Ka=is-be,S_=g-Ni;return Ne?sr(S_,B-Ka):S_}function pt(is){var Ni=is-de,Ka=is-be;return de===n||Ni>=g||Ni<0||Ne&&Ka>=B}function Ot(){var is=Xx();if(pt(is))return Gt(is);ne=Em(Ot,Rt(is))}function Gt(is){return ne=n,We&&N?st(is):(N=P=n,X)}function So(){ne!==n&&pA(ne),be=0,N=de=P=ne=n}function Ir(){return ne===n?X:Gt(Xx())}function Co(){var is=Xx(),Ni=pt(is);if(N=arguments,P=this,de=is,Ni){if(ne===n)return dt(de);if(Ne)return pA(ne),ne=Em(Ot,g),st(de)}return ne===n&&(ne=Em(Ot,g)),X}return Co.cancel=So,Co.flush=Ir,Co}var SX=_t(function(p,g){return jR(p,1,g)}),CX=_t(function(p,g,C){return jR(p,Xo(g)||0,C)});function kX(p){return Wa(p,D)}function qx(p,g){if(typeof p!="function"||g!=null&&typeof g!="function")throw new Uo(i);var C=function(){var N=arguments,P=g?g.apply(this,N):N[0],B=C.cache;if(B.has(P))return B.get(P);var X=p.apply(this,N);return C.cache=B.set(P,X)||B,X};return C.cache=new(qx.Cache||Ba),C}qx.Cache=Ba;function Yx(p){if(typeof p!="function")throw new Uo(i);return function(){var g=arguments;switch(g.length){case 0:return!p.call(this);case 1:return!p.call(this,g[0]);case 2:return!p.call(this,g[0],g[1]);case 3:return!p.call(this,g[0],g[1],g[2])}return!p.apply(this,g)}}function IX(p){return JA(2,p)}var $X=dK(function(p,g){g=g.length==1&&St(g[0])?dn(g[0],He(ht())):dn(js(g,1),He(ht()));var C=g.length;return _t(function(N){for(var P=-1,B=sr(N.length,C);++P<B;)N[P]=g[P].call(this,N[P]);return tr(p,this,N)})}),a2=_t(function(p,g){var C=sa(g,id(a2));return Wa(p,I,n,g,C)}),r_=_t(function(p,g){var C=sa(g,id(r_));return Wa(p,T,n,g,C)}),NX=Ua(function(p,g){return Wa(p,_,n,n,n,g)});function TX(p,g){if(typeof p!="function")throw new Uo(i);return g=g===n?g:Nt(g),_t(p,g)}function EX(p,g){if(typeof p!="function")throw new Uo(i);return g=g==null?0:$s(Nt(g),0),_t(function(C){var N=C[g],P=Lu(C,0,g);return N&&ta(P,N),tr(p,this,P)})}function RX(p,g,C){var N=!0,P=!0;if(typeof p!="function")throw new Uo(i);return Vn(C)&&(N="leading"in C?!!C.leading:N,P="trailing"in C?!!C.trailing:P),s_(p,g,{leading:N,maxWait:g,trailing:P})}function AX(p){return ZA(p,1)}function _X(p,g){return a2(HC(g),p)}function DX(){if(!arguments.length)return[];var p=arguments[0];return St(p)?p:[p]}function PX(p){return Ho(p,f)}function FX(p,g){return g=typeof g=="function"?g:n,Ho(p,f,g)}function OX(p){return Ho(p,h|f)}function LX(p,g){return g=typeof g=="function"?g:n,Ho(p,h|f,g)}function MX(p,g){return g==null||HR(p,g,Os(g))}function $i(p,g){return p===g||p!==p&&g!==g}var zX=Wx(DC),BX=Wx(function(p,g){return p>=g}),dc=QR(function(){return arguments}())?QR:function(p){return Yn(p)&&on.call(p,"callee")&&!LR.call(p,"callee")},St=ge.isArray,VX=px?He(px):q5;function Kr(p){return p!=null&&Qx(p.length)&&!Ha(p)}function os(p){return Yn(p)&&Kr(p)}function WX(p){return p===!0||p===!1||Yn(p)&&Cr(p)==Ke}var Mu=n5||x2,UX=dm?He(dm):Y5;function GX(p){return Yn(p)&&p.nodeType===1&&!Rm(p)}function HX(p){if(p==null)return!0;if(Kr(p)&&(St(p)||typeof p=="string"||typeof p.splice=="function"||Mu(p)||ad(p)||dc(p)))return!p.length;var g=rr(p);if(g==at||g==Mn)return!p.size;if(Tm(p))return!OC(p).length;for(var C in p)if(on.call(p,C))return!1;return!0}function jX(p,g){return Im(p,g)}function KX(p,g,C){C=typeof C=="function"?C:n;var N=C?C(p,g):n;return N===n?Im(p,g,n,C):!!N}function u2(p){if(!Yn(p))return!1;var g=Cr(p);return g==tt||g==rt||typeof p.message=="string"&&typeof p.name=="string"&&!Rm(p)}function XX(p){return typeof p=="number"&&zR(p)}function Ha(p){if(!Vn(p))return!1;var g=Cr(p);return g==Et||g==lt||g==Ae||g==Wr}function o_(p){return typeof p=="number"&&p==Nt(p)}function Qx(p){return typeof p=="number"&&p>-1&&p%1==0&&p<=K}function Vn(p){var g=typeof p;return p!=null&&(g=="object"||g=="function")}function Yn(p){return p!=null&&typeof p=="object"}var i_=fx?He(fx):Z5;function qX(p,g){return p===g||FC(p,g,ZC(g))}function YX(p,g,C){return C=typeof C=="function"?C:n,FC(p,g,ZC(g),C)}function QX(p){return a_(p)&&p!=+p}function ZX(p){if(FK(p))throw new wt(o);return ZR(p)}function JX(p){return p===null}function eq(p){return p==null}function a_(p){return typeof p=="number"||Yn(p)&&Cr(p)==Lt}function Rm(p){if(!Yn(p)||Cr(p)!=Ft)return!1;var g=kx(p);if(g===null)return!0;var C=on.call(g,"constructor")&&g.constructor;return typeof C=="function"&&C instanceof C&&wx.call(C)==Yj}var l2=mx?He(mx):J5;function tq(p){return o_(p)&&p>=-K&&p<=K}var u_=Kh?He(Kh):eK;function Zx(p){return typeof p=="string"||!St(p)&&Yn(p)&&Cr(p)==zn}function bo(p){return typeof p=="symbol"||Yn(p)&&Cr(p)==vr}var ad=Xh?He(Xh):tK;function nq(p){return p===n}function sq(p){return Yn(p)&&rr(p)==Ps}function rq(p){return Yn(p)&&Cr(p)==wr}var oq=Wx(LC),iq=Wx(function(p,g){return p<=g});function l_(p){if(!p)return[];if(Kr(p))return Zx(p)?ki(p):jr(p);if(ym&&p[ym])return kC(p[ym]());var g=rr(p),C=g==at?gm:g==Mn?Yh:ud;return C(p)}function ja(p){if(!p)return p===0?p:0;if(p=Xo(p),p===le||p===-le){var g=p<0?-1:1;return g*re}return p===p?p:0}function Nt(p){var g=ja(p),C=g%1;return g===g?C?g-C:g:0}function c_(p){return p?uc(Nt(p),0,he):0}function Xo(p){if(typeof p=="number")return p;if(bo(p))return pe;if(Vn(p)){var g=typeof p.valueOf=="function"?p.valueOf():p;p=Vn(g)?g+"":g}if(typeof p!="string")return p===0?p:+p;p=ct(p);var C=X0.test(p);return C||Jf.test(p)?yC(p.slice(2),C?2:8):ql.test(p)?pe:+p}function h_(p){return oa(p,Xr(p))}function aq(p){return p?uc(Nt(p),-K,K):p===0?p:0}function tn(p){return p==null?"":wo(p)}var uq=rd(function(p,g){if(Tm(g)||Kr(g)){oa(g,Os(g),p);return}for(var C in g)on.call(g,C)&&Sm(p,C,g[C])}),d_=rd(function(p,g){oa(g,Xr(g),p)}),Jx=rd(function(p,g,C,N){oa(g,Xr(g),p,N)}),lq=rd(function(p,g,C,N){oa(g,Os(g),p,N)}),cq=Ua(RC);function hq(p,g){var C=sd(p);return g==null?C:GR(C,g)}var dq=_t(function(p,g){p=xn(p);var C=-1,N=g.length,P=N>2?g[2]:n;for(P&&kr(g[0],g[1],P)&&(N=1);++C<N;)for(var B=g[C],X=Xr(B),ne=-1,de=X.length;++ne<de;){var be=X[ne],Se=p[be];(Se===n||$i(Se,ed[be])&&!on.call(p,be))&&(p[be]=B[be])}return p}),pq=_t(function(p){return p.push(n,EA),tr(p_,n,p)});function fq(p,g){return mm(p,ht(g,3),ra)}function mq(p,g){return mm(p,ht(g,3),_C)}function gq(p,g){return p==null?p:AC(p,ht(g,3),Xr)}function yq(p,g){return p==null?p:qR(p,ht(g,3),Xr)}function xq(p,g){return p&&ra(p,ht(g,3))}function vq(p,g){return p&&_C(p,ht(g,3))}function wq(p){return p==null?[]:Px(p,Os(p))}function bq(p){return p==null?[]:Px(p,Xr(p))}function c2(p,g,C){var N=p==null?n:lc(p,g);return N===n?C:N}function Sq(p,g){return p!=null&&_A(p,g,H5)}function h2(p,g){return p!=null&&_A(p,g,j5)}var Cq=kA(function(p,g,C){g!=null&&typeof g.toString!="function"&&(g=bx.call(g)),p[g]=C},p2(qr)),kq=kA(function(p,g,C){g!=null&&typeof g.toString!="function"&&(g=bx.call(g)),on.call(p,g)?p[g].push(C):p[g]=[C]},ht),Iq=_t(km);function Os(p){return Kr(p)?WR(p):OC(p)}function Xr(p){return Kr(p)?WR(p,!0):nK(p)}function $q(p,g){var C={};return g=ht(g,3),ra(p,function(N,P,B){Va(C,g(N,P,B),N)}),C}function Nq(p,g){var C={};return g=ht(g,3),ra(p,function(N,P,B){Va(C,P,g(N,P,B))}),C}var Tq=rd(function(p,g,C){Fx(p,g,C)}),p_=rd(function(p,g,C,N){Fx(p,g,C,N)}),Eq=Ua(function(p,g){var C={};if(p==null)return C;var N=!1;g=dn(g,function(B){return B=Ou(B,p),N||(N=B.length>1),B}),oa(p,YC(p),C),N&&(C=Ho(C,h|d|f,CK));for(var P=g.length;P--;)WC(C,g[P]);return C});function Rq(p,g){return f_(p,Yx(ht(g)))}var Aq=Ua(function(p,g){return p==null?{}:rK(p,g)});function f_(p,g){if(p==null)return{};var C=dn(YC(p),function(N){return[N]});return g=ht(g),oA(p,C,function(N,P){return g(N,P[0])})}function _q(p,g,C){g=Ou(g,p);var N=-1,P=g.length;for(P||(P=1,p=n);++N<P;){var B=p==null?n:p[ia(g[N])];B===n&&(N=P,B=C),p=Ha(B)?B.call(p):B}return p}function Dq(p,g,C){return p==null?p:$m(p,g,C)}function Pq(p,g,C,N){return N=typeof N=="function"?N:n,p==null?p:$m(p,g,C,N)}var m_=NA(Os),g_=NA(Xr);function Fq(p,g,C){var N=St(p),P=N||Mu(p)||ad(p);if(g=ht(g,4),C==null){var B=p&&p.constructor;P?C=N?new B:[]:Vn(p)?C=Ha(B)?sd(kx(p)):{}:C={}}return(P?Gr:ra)(p,function(X,ne,de){return g(C,X,ne,de)}),C}function Oq(p,g){return p==null?!0:WC(p,g)}function Lq(p,g,C){return p==null?p:cA(p,g,HC(C))}function Mq(p,g,C,N){return N=typeof N=="function"?N:n,p==null?p:cA(p,g,HC(C),N)}function ud(p){return p==null?[]:ze(p,Os(p))}function zq(p){return p==null?[]:ze(p,Xr(p))}function Bq(p,g,C){return C===n&&(C=g,g=n),C!==n&&(C=Xo(C),C=C===C?C:0),g!==n&&(g=Xo(g),g=g===g?g:0),uc(Xo(p),g,C)}function Vq(p,g,C){return g=ja(g),C===n?(C=g,g=0):C=ja(C),p=Xo(p),K5(p,g,C)}function Wq(p,g,C){if(C&&typeof C!="boolean"&&kr(p,g,C)&&(g=C=n),C===n&&(typeof g=="boolean"?(C=g,g=n):typeof p=="boolean"&&(C=p,p=n)),p===n&&g===n?(p=0,g=1):(p=ja(p),g===n?(g=p,p=0):g=ja(g)),p>g){var N=p;p=g,g=N}if(C||p%1||g%1){var P=BR();return sr(p+P*(g-p+hm("1e-"+((P+"").length-1))),g)}return zC(p,g)}var Uq=od(function(p,g,C){return g=g.toLowerCase(),p+(C?y_(g):g)});function y_(p){return d2(tn(p).toLowerCase())}function x_(p){return p=tn(p),p&&p.replace(yo,ks).replace(um,"")}function Gq(p,g,C){p=tn(p),g=wo(g);var N=p.length;C=C===n?N:uc(Nt(C),0,N);var P=C;return C-=g.length,C>=0&&p.slice(C,P)==g}function Hq(p){return p=tn(p),p&&j0.test(p)?p.replace(jf,Hr):p}function jq(p){return p=tn(p),p&&uC.test(p)?p.replace(ea,"\\$&"):p}var Kq=od(function(p,g,C){return p+(C?"-":"")+g.toLowerCase()}),Xq=od(function(p,g,C){return p+(C?" ":"")+g.toLowerCase()}),qq=bA("toLowerCase");function Yq(p,g,C){p=tn(p),g=Nt(g);var N=g?Zh(p):0;if(!g||N>=g)return p;var P=(g-N)/2;return Vx(Tx(P),C)+p+Vx(Nx(P),C)}function Qq(p,g,C){p=tn(p),g=Nt(g);var N=g?Zh(p):0;return g&&N<g?p+Vx(g-N,C):p}function Zq(p,g,C){p=tn(p),g=Nt(g);var N=g?Zh(p):0;return g&&N<g?Vx(g-N,C)+p:p}function Jq(p,g,C){return C||g==null?g=0:g&&(g=+g),i5(tn(p).replace(go,""),g||0)}function e7(p,g,C){return(C?kr(p,g,C):g===n)?g=1:g=Nt(g),BC(tn(p),g)}function t7(){var p=arguments,g=tn(p[0]);return p.length<3?g:g.replace(p[1],p[2])}var n7=od(function(p,g,C){return p+(C?"_":"")+g.toLowerCase()});function s7(p,g,C){return C&&typeof C!="number"&&kr(p,g,C)&&(g=C=n),C=C===n?he:C>>>0,C?(p=tn(p),p&&(typeof g=="string"||g!=null&&!l2(g))&&(g=wo(g),!g&&Dn(p))?Lu(ki(p),0,C):p.split(g,C)):[]}var r7=od(function(p,g,C){return p+(C?" ":"")+d2(g)});function o7(p,g,C){return p=tn(p),C=C==null?0:uc(Nt(C),0,p.length),g=wo(g),p.slice(C,C+g.length)==g}function i7(p,g,C){var N=z.templateSettings;C&&kr(p,g,C)&&(g=n),p=tn(p),g=Jx({},g,N,TA);var P=Jx({},g.imports,N.imports,TA),B=Os(P),X=ze(P,B),ne,de,be=0,Se=g.interpolate||br,Ne="__p += '",We=IC((g.escape||br).source+"|"+Se.source+"|"+(Se===qf?Qf:br).source+"|"+(g.evaluate||br).source+"|$","g"),st="//# sourceURL="+(on.call(g,"sourceURL")?(g.sourceURL+"").replace(/\s/g," "):"lodash.templateSources["+ ++gC+"]")+`
`;p.replace(We,function(pt,Ot,Gt,So,Ir,Co){return Gt||(Gt=So),Ne+=p.slice(be,Co).replace(Yl,nr),Ot&&(ne=!0,Ne+=`' +
__e(`+Ot+`) +
'`),Ir&&(de=!0,Ne+=`';
`+Ir+`;
__p += '`),Gt&&(Ne+=`' +
((__t = (`+Gt+`)) == null ? '' : __t) +
'`),be=Co+pt.length,pt}),Ne+=`';
`;var dt=on.call(g,"variable")&&g.variable;if(!dt)Ne=`with (obj) {
`+Ne+`
}
`;else if(lC.test(dt))throw new wt(a);Ne=(de?Ne.replace(Gf,""):Ne).replace(Pa,"$1").replace(Kl,"$1;"),Ne="function("+(dt||"obj")+`) {
`+(dt?"":`obj || (obj = {});
`)+"var __t, __p = ''"+(ne?", __e = _.escape":"")+(de?`, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
`:`;
`)+Ne+`return __p
}`;var Rt=w_(function(){return Jt(B,st+"return "+Ne).apply(n,X)});if(Rt.source=Ne,u2(Rt))throw Rt;return Rt}function a7(p){return tn(p).toLowerCase()}function u7(p){return tn(p).toUpperCase()}function l7(p,g,C){if(p=tn(p),p&&(C||g===n))return ct(p);if(!p||!(g=wo(g)))return p;var N=ki(p),P=ki(g),B=It(N,P),X=pn(N,P)+1;return Lu(N,B,X).join("")}function c7(p,g,C){if(p=tn(p),p&&(C||g===n))return p.slice(0,DR(p)+1);if(!p||!(g=wo(g)))return p;var N=ki(p),P=pn(N,ki(g))+1;return Lu(N,0,P).join("")}function h7(p,g,C){if(p=tn(p),p&&(C||g===n))return p.replace(go,"");if(!p||!(g=wo(g)))return p;var N=ki(p),P=It(N,ki(g));return Lu(N,P).join("")}function d7(p,g){var C=L,N=V;if(Vn(g)){var P="separator"in g?g.separator:P;C="length"in g?Nt(g.length):C,N="omission"in g?wo(g.omission):N}p=tn(p);var B=p.length;if(Dn(p)){var X=ki(p);B=X.length}if(C>=B)return p;var ne=C-Zh(N);if(ne<1)return N;var de=X?Lu(X,0,ne).join(""):p.slice(0,ne);if(P===n)return de+N;if(X&&(ne+=de.length-ne),l2(P)){if(p.slice(ne).search(P)){var be,Se=de;for(P.global||(P=IC(P.source,tn(Xl.exec(P))+"g")),P.lastIndex=0;be=P.exec(Se);)var Ne=be.index;de=de.slice(0,Ne===n?ne:Ne)}}else if(p.indexOf(wo(P),ne)!=ne){var We=de.lastIndexOf(P);We>-1&&(de=de.slice(0,We))}return de+N}function p7(p){return p=tn(p),p&&Kf.test(p)?p.replace(Hf,Wj):p}var f7=od(function(p,g,C){return p+(C?" ":"")+g.toUpperCase()}),d2=bA("toUpperCase");function v_(p,g,C){return p=tn(p),g=C?n:g,g===n?na(p)?Hj(p):CC(p):p.match(g)||[]}var w_=_t(function(p,g){try{return tr(p,n,g)}catch(C){return u2(C)?C:new wt(C)}}),m7=Ua(function(p,g){return Gr(g,function(C){C=ia(C),Va(p,C,i2(p[C],p))}),p});function g7(p){var g=p==null?0:p.length,C=ht();return p=g?dn(p,function(N){if(typeof N[1]!="function")throw new Uo(i);return[C(N[0]),N[1]]}):[],_t(function(N){for(var P=-1;++P<g;){var B=p[P];if(tr(B[0],this,N))return tr(B[1],this,N)}})}function y7(p){return W5(Ho(p,h))}function p2(p){return function(){return p}}function x7(p,g){return p==null||p!==p?g:p}var v7=CA(),w7=CA(!0);function qr(p){return p}function f2(p){return JR(typeof p=="function"?p:Ho(p,h))}function b7(p){return tA(Ho(p,h))}function S7(p,g){return nA(p,Ho(g,h))}var C7=_t(function(p,g){return function(C){return km(C,p,g)}}),k7=_t(function(p,g){return function(C){return km(p,C,g)}});function m2(p,g,C){var N=Os(g),P=Px(g,N);C==null&&!(Vn(g)&&(P.length||!N.length))&&(C=g,g=p,p=this,P=Px(g,Os(g)));var B=!(Vn(C)&&"chain"in C)||!!C.chain,X=Ha(p);return Gr(P,function(ne){var de=g[ne];p[ne]=de,X&&(p.prototype[ne]=function(){var be=this.__chain__;if(B||be){var Se=p(this.__wrapped__),Ne=Se.__actions__=jr(this.__actions__);return Ne.push({func:de,args:arguments,thisArg:p}),Se.__chain__=be,Se}return de.apply(p,ta([this.value()],arguments))})}),p}function I7(){return hs._===this&&(hs._=Qj),this}function g2(){}function $7(p){return p=Nt(p),_t(function(g){return sA(g,p)})}var N7=KC(dn),T7=KC(gx),E7=KC(_u);function b_(p){return e2(p)?W(ia(p)):oK(p)}function R7(p){return function(g){return p==null?n:lc(p,g)}}var A7=IA(),_7=IA(!0);function y2(){return[]}function x2(){return!1}function D7(){return{}}function P7(){return""}function F7(){return!0}function O7(p,g){if(p=Nt(p),p<1||p>K)return[];var C=he,N=sr(p,he);g=ht(g),p-=he;for(var P=Te(N,g);++C<p;)g(C);return P}function L7(p){return St(p)?dn(p,ia):bo(p)?[p]:jr(VA(tn(p)))}function M7(p){var g=++qj;return tn(p)+g}var z7=Bx(function(p,g){return p+g},0),B7=XC("ceil"),V7=Bx(function(p,g){return p/g},1),W7=XC("floor");function U7(p){return p&&p.length?Dx(p,qr,DC):n}function G7(p,g){return p&&p.length?Dx(p,ht(g,2),DC):n}function H7(p){return F(p,qr)}function j7(p,g){return F(p,ht(g,2))}function K7(p){return p&&p.length?Dx(p,qr,LC):n}function X7(p,g){return p&&p.length?Dx(p,ht(g,2),LC):n}var q7=Bx(function(p,g){return p*g},1),Y7=XC("round"),Q7=Bx(function(p,g){return p-g},0);function Z7(p){return p&&p.length?me(p,qr):0}function J7(p,g){return p&&p.length?me(p,ht(g,2)):0}return z.after=bX,z.ary=ZA,z.assign=uq,z.assignIn=d_,z.assignInWith=Jx,z.assignWith=lq,z.at=cq,z.before=JA,z.bind=i2,z.bindAll=m7,z.bindKey=e_,z.castArray=DX,z.chain=qA,z.chunk=WK,z.compact=UK,z.concat=GK,z.cond=g7,z.conforms=y7,z.constant=p2,z.countBy=Z8,z.create=hq,z.curry=t_,z.curryRight=n_,z.debounce=s_,z.defaults=dq,z.defaultsDeep=pq,z.defer=SX,z.delay=CX,z.difference=HK,z.differenceBy=jK,z.differenceWith=KK,z.drop=XK,z.dropRight=qK,z.dropRightWhile=YK,z.dropWhile=QK,z.fill=ZK,z.filter=eX,z.flatMap=sX,z.flatMapDeep=rX,z.flatMapDepth=oX,z.flatten=HA,z.flattenDeep=JK,z.flattenDepth=e8,z.flip=kX,z.flow=v7,z.flowRight=w7,z.fromPairs=t8,z.functions=wq,z.functionsIn=bq,z.groupBy=iX,z.initial=s8,z.intersection=r8,z.intersectionBy=o8,z.intersectionWith=i8,z.invert=Cq,z.invertBy=kq,z.invokeMap=uX,z.iteratee=f2,z.keyBy=lX,z.keys=Os,z.keysIn=Xr,z.map=Kx,z.mapKeys=$q,z.mapValues=Nq,z.matches=b7,z.matchesProperty=S7,z.memoize=qx,z.merge=Tq,z.mergeWith=p_,z.method=C7,z.methodOf=k7,z.mixin=m2,z.negate=Yx,z.nthArg=$7,z.omit=Eq,z.omitBy=Rq,z.once=IX,z.orderBy=cX,z.over=N7,z.overArgs=$X,z.overEvery=T7,z.overSome=E7,z.partial=a2,z.partialRight=r_,z.partition=hX,z.pick=Aq,z.pickBy=f_,z.property=b_,z.propertyOf=R7,z.pull=c8,z.pullAll=KA,z.pullAllBy=h8,z.pullAllWith=d8,z.pullAt=p8,z.range=A7,z.rangeRight=_7,z.rearg=NX,z.reject=fX,z.remove=f8,z.rest=TX,z.reverse=r2,z.sampleSize=gX,z.set=Dq,z.setWith=Pq,z.shuffle=yX,z.slice=m8,z.sortBy=wX,z.sortedUniq=S8,z.sortedUniqBy=C8,z.split=s7,z.spread=EX,z.tail=k8,z.take=I8,z.takeRight=$8,z.takeRightWhile=N8,z.takeWhile=T8,z.tap=U8,z.throttle=RX,z.thru=jx,z.toArray=l_,z.toPairs=m_,z.toPairsIn=g_,z.toPath=L7,z.toPlainObject=h_,z.transform=Fq,z.unary=AX,z.union=E8,z.unionBy=R8,z.unionWith=A8,z.uniq=_8,z.uniqBy=D8,z.uniqWith=P8,z.unset=Oq,z.unzip=o2,z.unzipWith=XA,z.update=Lq,z.updateWith=Mq,z.values=ud,z.valuesIn=zq,z.without=F8,z.words=v_,z.wrap=_X,z.xor=O8,z.xorBy=L8,z.xorWith=M8,z.zip=z8,z.zipObject=B8,z.zipObjectDeep=V8,z.zipWith=W8,z.entries=m_,z.entriesIn=g_,z.extend=d_,z.extendWith=Jx,m2(z,z),z.add=z7,z.attempt=w_,z.camelCase=Uq,z.capitalize=y_,z.ceil=B7,z.clamp=Bq,z.clone=PX,z.cloneDeep=OX,z.cloneDeepWith=LX,z.cloneWith=FX,z.conformsTo=MX,z.deburr=x_,z.defaultTo=x7,z.divide=V7,z.endsWith=Gq,z.eq=$i,z.escape=Hq,z.escapeRegExp=jq,z.every=J8,z.find=tX,z.findIndex=UA,z.findKey=fq,z.findLast=nX,z.findLastIndex=GA,z.findLastKey=mq,z.floor=W7,z.forEach=YA,z.forEachRight=QA,z.forIn=gq,z.forInRight=yq,z.forOwn=xq,z.forOwnRight=vq,z.get=c2,z.gt=zX,z.gte=BX,z.has=Sq,z.hasIn=h2,z.head=jA,z.identity=qr,z.includes=aX,z.indexOf=n8,z.inRange=Vq,z.invoke=Iq,z.isArguments=dc,z.isArray=St,z.isArrayBuffer=VX,z.isArrayLike=Kr,z.isArrayLikeObject=os,z.isBoolean=WX,z.isBuffer=Mu,z.isDate=UX,z.isElement=GX,z.isEmpty=HX,z.isEqual=jX,z.isEqualWith=KX,z.isError=u2,z.isFinite=XX,z.isFunction=Ha,z.isInteger=o_,z.isLength=Qx,z.isMap=i_,z.isMatch=qX,z.isMatchWith=YX,z.isNaN=QX,z.isNative=ZX,z.isNil=eq,z.isNull=JX,z.isNumber=a_,z.isObject=Vn,z.isObjectLike=Yn,z.isPlainObject=Rm,z.isRegExp=l2,z.isSafeInteger=tq,z.isSet=u_,z.isString=Zx,z.isSymbol=bo,z.isTypedArray=ad,z.isUndefined=nq,z.isWeakMap=sq,z.isWeakSet=rq,z.join=a8,z.kebabCase=Kq,z.last=Ko,z.lastIndexOf=u8,z.lowerCase=Xq,z.lowerFirst=qq,z.lt=oq,z.lte=iq,z.max=U7,z.maxBy=G7,z.mean=H7,z.meanBy=j7,z.min=K7,z.minBy=X7,z.stubArray=y2,z.stubFalse=x2,z.stubObject=D7,z.stubString=P7,z.stubTrue=F7,z.multiply=q7,z.nth=l8,z.noConflict=I7,z.noop=g2,z.now=Xx,z.pad=Yq,z.padEnd=Qq,z.padStart=Zq,z.parseInt=Jq,z.random=Wq,z.reduce=dX,z.reduceRight=pX,z.repeat=e7,z.replace=t7,z.result=_q,z.round=Y7,z.runInContext=ue,z.sample=mX,z.size=xX,z.snakeCase=n7,z.some=vX,z.sortedIndex=g8,z.sortedIndexBy=y8,z.sortedIndexOf=x8,z.sortedLastIndex=v8,z.sortedLastIndexBy=w8,z.sortedLastIndexOf=b8,z.startCase=r7,z.startsWith=o7,z.subtract=Q7,z.sum=Z7,z.sumBy=J7,z.template=i7,z.times=O7,z.toFinite=ja,z.toInteger=Nt,z.toLength=c_,z.toLower=a7,z.toNumber=Xo,z.toSafeInteger=aq,z.toString=tn,z.toUpper=u7,z.trim=l7,z.trimEnd=c7,z.trimStart=h7,z.truncate=d7,z.unescape=p7,z.uniqueId=M7,z.upperCase=f7,z.upperFirst=d2,z.each=YA,z.eachRight=QA,z.first=jA,m2(z,function(){var p={};return ra(z,function(g,C){on.call(z.prototype,C)||(p[C]=g)}),p}(),{chain:!1}),z.VERSION=s,Gr(["bind","bindKey","curry","curryRight","partial","partialRight"],function(p){z[p].placeholder=z}),Gr(["drop","take"],function(p,g){Mt.prototype[p]=function(C){C=C===n?1:$s(Nt(C),0);var N=this.__filtered__&&!g?new Mt(this):this.clone();return N.__filtered__?N.__takeCount__=sr(C,N.__takeCount__):N.__views__.push({size:sr(C,he),type:p+(N.__dir__<0?"Right":"")}),N},Mt.prototype[p+"Right"]=function(C){return this.reverse()[p](C).reverse()}}),Gr(["filter","map","takeWhile"],function(p,g){var C=g+1,N=C==q||C==te;Mt.prototype[p]=function(P){var B=this.clone();return B.__iteratees__.push({iteratee:ht(P,3),type:C}),B.__filtered__=B.__filtered__||N,B}}),Gr(["head","last"],function(p,g){var C="take"+(g?"Right":"");Mt.prototype[p]=function(){return this[C](1).value()[0]}}),Gr(["initial","tail"],function(p,g){var C="drop"+(g?"":"Right");Mt.prototype[p]=function(){return this.__filtered__?new Mt(this):this[C](1)}}),Mt.prototype.compact=function(){return this.filter(qr)},Mt.prototype.find=function(p){return this.filter(p).head()},Mt.prototype.findLast=function(p){return this.reverse().find(p)},Mt.prototype.invokeMap=_t(function(p,g){return typeof p=="function"?new Mt(this):this.map(function(C){return km(C,p,g)})}),Mt.prototype.reject=function(p){return this.filter(Yx(ht(p)))},Mt.prototype.slice=function(p,g){p=Nt(p);var C=this;return C.__filtered__&&(p>0||g<0)?new Mt(C):(p<0?C=C.takeRight(-p):p&&(C=C.drop(p)),g!==n&&(g=Nt(g),C=g<0?C.dropRight(-g):C.take(g-p)),C)},Mt.prototype.takeRightWhile=function(p){return this.reverse().takeWhile(p).reverse()},Mt.prototype.toArray=function(){return this.take(he)},ra(Mt.prototype,function(p,g){var C=/^(?:filter|find|map|reject)|While$/.test(g),N=/^(?:head|last)$/.test(g),P=z[N?"take"+(g=="last"?"Right":""):g],B=N||/^find/.test(g);P&&(z.prototype[g]=function(){var X=this.__wrapped__,ne=N?[1]:arguments,de=X instanceof Mt,be=ne[0],Se=de||St(X),Ne=function(Ot){var Gt=P.apply(z,ta([Ot],ne));return N&&We?Gt[0]:Gt};Se&&C&&typeof be=="function"&&be.length!=1&&(de=Se=!1);var We=this.__chain__,st=!!this.__actions__.length,dt=B&&!We,Rt=de&&!st;if(!B&&Se){X=Rt?X:new Mt(this);var pt=p.apply(X,ne);return pt.__actions__.push({func:jx,args:[Ne],thisArg:n}),new Go(pt,We)}return dt&&Rt?p.apply(this,ne):(pt=this.thru(Ne),dt?N?pt.value()[0]:pt.value():pt)})}),Gr(["pop","push","shift","sort","splice","unshift"],function(p){var g=xx[p],C=/^(?:push|sort|unshift)$/.test(p)?"tap":"thru",N=/^(?:pop|shift)$/.test(p);z.prototype[p]=function(){var P=arguments;if(N&&!this.__chain__){var B=this.value();return g.apply(St(B)?B:[],P)}return this[C](function(X){return g.apply(St(X)?X:[],P)})}}),ra(Mt.prototype,function(p,g){var C=z[g];if(C){var N=C.name+"";on.call(nd,N)||(nd[N]=[]),nd[N].push({name:g,func:C})}}),nd[zx(n,v).name]=[{name:"wrapper",func:n}],Mt.prototype.clone=p5,Mt.prototype.reverse=f5,Mt.prototype.value=m5,z.prototype.at=G8,z.prototype.chain=H8,z.prototype.commit=j8,z.prototype.next=K8,z.prototype.plant=q8,z.prototype.reverse=Y8,z.prototype.toJSON=z.prototype.valueOf=z.prototype.value=Q8,z.prototype.first=z.prototype.head,ym&&(z.prototype[ym]=X8),z},Jh=jj();Ma?((Ma.exports=Jh)._=Jh,jh._=Jh):hs._=Jh}).call(Rr)})(ww,ww.exports);var q4e=ww.exports;function Y4e(){let t=speechSynthesis.getVoices();if(!t.length){const e=new SpeechSynthesisUtterance("");speechSynthesis.speak(e),t=speechSynthesis.getVoices()}return t}function Q4e(){const t=fe.useRef(null),e=fe.useRef(!1),{sets:n}=fe.useContext(Bw),s=()=>{const o=n[Math.floor(Math.random()*n.length)],i=new SpeechSynthesisUtterance,a=Y4e();i.volume=1,i.rate=1,i.pitch=2,i.text=o,i.lang="en",i.voice=a[0],speechSynthesis.speak(i),setTimeout(()=>{e.current=!1},2e3)},r=q4e.debounce(s,1e3,{leading:!0,trailing:!1});return fe.useEffect(()=>{const o=async()=>{if(navigator.mediaDevices.getUserMedia&&t.current){const u=await navigator.mediaDevices.getUserMedia({video:!0});return t.current.srcObject=u,new Promise(l=>{t.current.onloadedmetadata=()=>{l(t.current)}})}},i=async(u,l)=>{if(t.current){const c=await u.estimatePoses(l),h=await _ve.keypointsToNormalizedKeypoints(c[0].keypoints,l);if(c&&c.length>0){const d=h[0],f=h[7];f.y<d.y+.05&&!e.current&&f.score&&f.score>.7&&(e.current=!0,r()),requestAnimationFrame(()=>{i(u,l)})}}},a=async()=>{const u={architecture:"MobileNetV1",outputStride:16,inputResolution:{width:640,height:480},multiplier:.75},l=await Ave(va.PoseNet,u);await o();const c=document.querySelector("#video");i(l,c)};Tee("webgl").then(()=>{a()}).catch(()=>{a()})},[r]),Pt.jsxs("div",{className:"flex justify-center items-center h-full w-full",children:[Pt.jsx("video",{id:"video",ref:t,autoPlay:!0,playsInline:!0,height:window.innerHeight,width:window.innerWidth,className:"object-cover",style:{display:"none"}}),Pt.jsxs("div",{className:"m-auto px-4",children:[Pt.jsx(X4e.div,{className:"bg-indigo-500 h-20 w-20 mx-auto",animate:{scale:[1,2,2,1,1],rotate:[0,0,180,180,0],borderRadius:["0%","0%","50%","50%","0%"]},transition:{duration:2,ease:"easeInOut",times:[0,.2,.5,.8,1],repeat:1/0,repeatDelay:1}}),Pt.jsx("p",{className:"mt-20 text-white text-center",children:"Start setting, work your neutral position!"}),Pt.jsx("p",{className:"text-center text-indigo-500 text-xs mt-2",children:"(i) We need your permission for the camera and the microphone"})]})]})}function Z4e(){const{sets:t}=fe.useContext(Bw);return Pt.jsxs(Pt.Fragment,{children:[t.length>1?Pt.jsx(Q4e,{}):Pt.jsx("div",{className:"h-full w-full flex p-4",children:Pt.jsxs("section",{className:"p-4 m-auto bg-white flex flex-col items-center rounded-lg",children:[Pt.jsxs("div",{className:"flex items-center rounded-lg",children:[Pt.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:"1.5",stroke:"currentColor",className:"w-6 h-6 mr-2 stroke-indigo-500",children:Pt.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"})}),Pt.jsx("p",{className:"text-lg text-indigo-500",children:"Please add at least 2 sets to start training."})]}),Pt.jsx(FI,{to:"/",className:"text-indigo-500 underline",children:"Back"})]})}),Pt.jsxs("section",{className:"absolute z-10 top-4 left-4 flex",children:[Pt.jsx(FI,{to:"/",className:"bg-transparent hover:bg-indigo-950 mr-4 px-4 py-2 flex justify-center items-center rounded-lg",children:Pt.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",strokeWidth:"1.5",stroke:"currentColor",className:"w-6 h-6 stroke-white	",children:Pt.jsx("path",{strokeLinecap:"round",strokeLinejoin:"round",d:"M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18"})})}),Pt.jsx("p",{className:"text-3xl font-bold text-white",children:"Training"})]})]})}const _R=new fZ,J4e=new JN({getParentRoute:()=>_R,path:"/",component:LJ}),eWe=new JN({getParentRoute:()=>_R,path:"/training",component:Z4e}),tWe=XM({initialEntries:["/"]}),nWe=_R.addChildren([J4e,eWe]),sWe=new CZ({routeTree:nWe,history:tWe});function rWe(){return Pt.jsx(TZ,{children:Pt.jsx("div",{className:"h-screen w-screen bg-indigo-950 flex flex-col",children:Pt.jsx(aZ,{router:sWe})})})}Bk.createRoot(document.getElementById("root")).render(Pt.jsx(iN.StrictMode,{children:Pt.jsx(rWe,{})}));
